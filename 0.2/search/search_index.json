{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Robot Framework Manual","text":""},{"location":"#what-is-robot-framework","title":"What is Robot Framework?","text":"<p>Robot Framework\u00ae is a generic open source automation framework for acceptance testing, behavior-driven development (BDD) and robotic process automation (RPA). It has simple plain text syntax, and it can be extended easily with generic and custom libraries.</p> <p>Robot Framework is operating system and application independent. It is implemented using Python which is also the primary language to extend it. The framework has a rich ecosystem around it consisting of various generic libraries and tools that are developed as separate projects. For more information about Robot Framework and the ecosystem, see https://robotframework.org.</p>"},{"location":"#what-is-in-this-manual","title":"What is in this manual?","text":"<p>Robot Framework Manual contains indepth information about all Robot Framework features such as data syntax, how to execute tests and how to extend the framework.</p> <p>The manual concentrates only to Robot Framework core and is rather technical. If you are looking for more practical information related to getting started with Robot Framework or using it in a certain domain such as web automation, see the excellent Robot Framework Guides project.</p>"},{"location":"glossary/","title":"Glossary","text":"Keyword Keywords are very important for us. 886d7696-137e-4a59-a39d-6f7d311d5bd1:_:Keyword Library keyword Ditto 886d7696-137e-4a59-a39d-6f7d311d5bd1:_:Library keyword"},{"location":"api/","title":"Robot Framework API","text":"<p>Robot Framework's primary public API is exposed via these modules:</p> <ul> <li>robot.api: The main stable API.</li> <li>robot.run: Entry points for executing tests or tasks.</li> <li>robot.rebot: Entry points for post-processing outputs (Rebot).</li> <li>robot.libdoc: Entry points for the Libdoc tool.</li> </ul> <p>You may sometimes need to import items also from other modules, for example to be able to use them in type hints, but that should be relatively rare.</p> <p>Warning</p> <p>API docs are not rendered properly, because they are written using reStructuredText that is not supported on this platform. They will be converted to Markdown after this Manual has been moved under the core Robot Framework repository.</p> <p>To see how API docs will look after conversion, see the robot.api.deco and robot.run modules that have already been converted.</p>"},{"location":"api/nav/","title":"Nav","text":"<ul> <li>API</li> <li> robot<ul> <li> api<ul> <li> deco</li> <li> exceptions</li> <li> interfaces</li> <li> logger</li> <li> parsing</li> </ul> </li> <li> conf<ul> <li> gatherfailed</li> <li> languages</li> <li> settings</li> </ul> </li> <li> errors</li> <li> htmldata<ul> <li> common</li> <li> htmlfilewriter</li> <li> jsonwriter</li> <li> libdoc</li> <li> rebot</li> <li> template</li> <li> testdoc</li> </ul> </li> <li> libdoc</li> <li> libdocpkg<ul> <li> builder</li> <li> consoleviewer</li> <li> datatypes</li> <li> htmlutils</li> <li> htmlwriter</li> <li> jsonbuilder</li> <li> jsonwriter</li> <li> model</li> <li> output</li> <li> robotbuilder</li> <li> standardtypes</li> <li> writer</li> <li> xmlbuilder</li> <li> xmlwriter</li> </ul> </li> <li> libraries<ul> <li> BuiltIn</li> <li> Collections</li> <li> DateTime</li> <li> Dialogs</li> <li> Easter</li> <li> OperatingSystem</li> <li> Process</li> <li> Remote</li> <li> Screenshot</li> <li> String</li> <li> Telnet</li> <li> XML</li> <li> dialogs_py</li> </ul> </li> <li> model<ul> <li> body</li> <li> configurer</li> <li> control</li> <li> filter</li> <li> fixture</li> <li> itemlist</li> <li> keyword</li> <li> message</li> <li> metadata</li> <li> modelobject</li> <li> modifier</li> <li> namepatterns</li> <li> statistics</li> <li> stats</li> <li> suitestatistics</li> <li> tags</li> <li> tagsetter</li> <li> tagstatistics</li> <li> testcase</li> <li> testsuite</li> <li> totalstatistics</li> <li> visitor</li> </ul> </li> <li> output<ul> <li> console<ul> <li> dotted</li> <li> highlighting</li> <li> quiet</li> <li> verbose</li> </ul> </li> <li> debugfile</li> <li> filelogger</li> <li> librarylogger</li> <li> listeners</li> <li> logger</li> <li> loggerapi</li> <li> loggerhelper</li> <li> output</li> <li> pyloggingconf</li> <li> stdoutlogsplitter</li> <li> xmllogger</li> </ul> </li> <li> parsing<ul> <li> lexer<ul> <li> blocklexers</li> <li> context</li> <li> lexer</li> <li> settings</li> <li> statementlexers</li> <li> tokenizer</li> <li> tokens</li> </ul> </li> <li> model<ul> <li> blocks</li> <li> statements</li> <li> visitor</li> </ul> </li> <li> parser<ul> <li> blockparsers</li> <li> fileparser</li> <li> parser</li> </ul> </li> <li> suitestructure</li> </ul> </li> <li> pythonpathsetter</li> <li> rebot</li> <li> reporting<ul> <li> expandkeywordmatcher</li> <li> jsbuildingcontext</li> <li> jsexecutionresult</li> <li> jsmodelbuilders</li> <li> jswriter</li> <li> logreportwriters</li> <li> outputwriter</li> <li> resultwriter</li> <li> stringcache</li> <li> xunitwriter</li> </ul> </li> <li> result<ul> <li> configurer</li> <li> executionerrors</li> <li> executionresult</li> <li> flattenkeywordmatcher</li> <li> keywordremover</li> <li> merger</li> <li> messagefilter</li> <li> model</li> <li> modeldeprecation</li> <li> resultbuilder</li> <li> suiteteardownfailed</li> <li> visitor</li> <li> xmlelementhandlers</li> </ul> </li> <li> run</li> <li> running<ul> <li> arguments<ul> <li> argumentconverter</li> <li> argumentmapper</li> <li> argumentparser</li> <li> argumentresolver</li> <li> argumentspec</li> <li> argumentvalidator</li> <li> customconverters</li> <li> embedded</li> <li> typeconverters</li> <li> typeinfo</li> <li> typeinfoparser</li> <li> typevalidator</li> </ul> </li> <li> bodyrunner</li> <li> builder<ul> <li> builders</li> <li> parsers</li> <li> settings</li> <li> transformers</li> </ul> </li> <li> context</li> <li> dynamicmethods</li> <li> importer</li> <li> invalidkeyword</li> <li> keywordfinder</li> <li> keywordimplementation</li> <li> librarykeyword</li> <li> librarykeywordrunner</li> <li> libraryscopes</li> <li> model</li> <li> namespace</li> <li> outputcapture</li> <li> randomizer</li> <li> resourcemodel</li> <li> runkwregister</li> <li> signalhandler</li> <li> status</li> <li> statusreporter</li> <li> suiterunner</li> <li> testlibraries</li> <li> timeouts<ul> <li> nosupport</li> <li> posix</li> <li> windows</li> </ul> </li> <li> userkeywordrunner</li> </ul> </li> <li> testdoc</li> <li> utils<ul> <li> application</li> <li> argumentparser</li> <li> asserts</li> <li> charwidth</li> <li> compress</li> <li> connectioncache</li> <li> dotdict</li> <li> encoding</li> <li> encodingsniffer</li> <li> error</li> <li> escaping</li> <li> etreewrapper</li> <li> filereader</li> <li> frange</li> <li> htmlformatters</li> <li> importer</li> <li> markuputils</li> <li> markupwriters</li> <li> match</li> <li> misc</li> <li> normalizing</li> <li> notset</li> <li> platform</li> <li> recommendations</li> <li> restreader</li> <li> robotenv</li> <li> robotinspect</li> <li> robotio</li> <li> robotpath</li> <li> robottime</li> <li> robottypes</li> <li> setter</li> <li> sortable</li> <li> text</li> <li> typehints</li> <li> unic</li> </ul> </li> <li> variables<ul> <li> assigner</li> <li> evaluation</li> <li> filesetter</li> <li> finders</li> <li> notfound</li> <li> replacer</li> <li> resolvable</li> <li> scopes</li> <li> search</li> <li> store</li> <li> tablesetter</li> <li> variables</li> </ul> </li> <li> version</li> </ul> </li> </ul>"},{"location":"api/robot/","title":"robot","text":""},{"location":"api/robot/#robot","title":"robot","text":"<p>The root of the Robot Framework package.</p> <p>The command line entry points provided by the framework are exposed for programmatic usage as follows:</p> <ul> <li>run: Function to run tests.</li> <li>run_cli: Function to run tests     with command line argument processing.</li> <li>rebot: Function to post-process outputs.</li> <li>rebot_cli: Function to post-process outputs     with command line argument processing.</li> <li>libdoc: Module for library documentation generation.</li> <li>testdoc: Module for test case documentation generation.</li> </ul> <p>All the functions above can be imported directly from the <code>robot</code> root module like <code>from robot import run</code>. Functions and classes provided by the modules need to be imported like <code>from robot.libdoc import libdoc_cli</code>.</p> <p>The functions and modules listed above are considered stable. Other modules in this package are for internal usage and may change without a prior notice.</p> <p>Tip</p> <p>The stable public API is otherwise exposed via the robot.api module.</p>"},{"location":"api/robot/#robot.rebot_cli","title":"rebot_cli","text":"<pre><code>rebot_cli(arguments=None, exit=True)\n</code></pre> <p>Command line execution entry point for post-processing outputs.</p> <p>:param arguments: Command line options and arguments as a list of strings.     Defaults to <code>sys.argv[1:]</code> if not given. :param exit: If <code>True</code>, call <code>sys.exit</code> with the return code denoting     execution status, otherwise just return the rc.</p> <p>Entry point used when post-processing outputs from the command line, but can also be used by custom scripts. Especially useful if the script itself needs to accept same arguments as accepted by Rebot, because the script can just pass them forward directly along with the possible default values it sets itself.</p> <p>Example::</p> <pre><code>from robot import rebot_cli\n\nrebot_cli(['--name', 'Example', '--log', 'NONE', 'o1.xml', 'o2.xml'])\n</code></pre> <p>See also the :func:<code>rebot</code> function that allows setting options as keyword arguments like <code>name=\"Example\"</code> and generally has a richer API for programmatic Rebot execution.</p> Source code in <code>src/robot/rebot.py</code> <pre><code>def rebot_cli(arguments=None, exit=True):\n    \"\"\"Command line execution entry point for post-processing outputs.\n\n    :param arguments: Command line options and arguments as a list of strings.\n        Defaults to ``sys.argv[1:]`` if not given.\n    :param exit: If ``True``, call ``sys.exit`` with the return code denoting\n        execution status, otherwise just return the rc.\n\n    Entry point used when post-processing outputs from the command line, but\n    can also be used by custom scripts. Especially useful if the script itself\n    needs to accept same arguments as accepted by Rebot, because the script can\n    just pass them forward directly along with the possible default values it\n    sets itself.\n\n    Example::\n\n        from robot import rebot_cli\n\n        rebot_cli(['--name', 'Example', '--log', 'NONE', 'o1.xml', 'o2.xml'])\n\n    See also the :func:`rebot` function that allows setting options as keyword\n    arguments like ``name=\"Example\"`` and generally has a richer API for\n    programmatic Rebot execution.\n    \"\"\"\n    if arguments is None:\n        arguments = sys.argv[1:]\n    return Rebot().execute_cli(arguments, exit=exit)\n</code></pre>"},{"location":"api/robot/#robot.run_cli","title":"run_cli","text":"<pre><code>run_cli(\n    arguments: list[str] | None = None, exit: bool = True\n)\n</code></pre> <p>Command line execution entry point for running tests.</p> <p>Parameters:</p> Name Type Description Default <code>arguments</code> <code>list[str] | None</code> <p>Command line options and arguments as a list of strings. Defaults to <code>sys.argv[1:]</code> if not given.</p> <code>None</code> <code>exit</code> <code>bool</code> <p>If <code>True</code>, call <code>sys.exit</code> with the return code denoting execution status, otherwise just return the rc.</p> <code>True</code> <p>Entry point used when running tests from the command line, but can also be used by custom scripts that execute tests. Especially useful if the script itself needs to accept same arguments as accepted by Robot Framework, because the script can just pass them forward directly along with the possible default values it sets itself.</p> <p>Example:</p> <pre><code>from robot import run_cli\n\n# Run tests and return the return code.\nrc = run_cli(['--name', 'Example', 'tests.robot'], exit=False)\n\n# Run tests and exit to the system automatically.\nrun_cli(['--name', 'Example', 'tests.robot'])\n</code></pre> <p>See also the robot.run function that allows setting options as keyword arguments like <code>name=\"Example\"</code> and generally has a richer API for programmatic test execution.</p> Source code in <code>src/robot/run.py</code> <pre><code>def run_cli(arguments: 'list[str]|None' = None, exit: bool = True):\n    \"\"\"Command line execution entry point for running tests.\n\n    Parameters:\n        arguments: Command line options and arguments as a list of strings.\n            Defaults to `sys.argv[1:]` if not given.\n        exit: If `True`, call `sys.exit` with the return code denoting\n            execution status, otherwise just return the rc.\n\n    Entry point used when running tests from the command line, but can also\n    be used by custom scripts that execute tests. Especially useful if the\n    script itself needs to accept same arguments as accepted by Robot Framework,\n    because the script can just pass them forward directly along with the\n    possible default values it sets itself.\n\n    Example:\n\n        from robot import run_cli\n\n        # Run tests and return the return code.\n        rc = run_cli(['--name', 'Example', 'tests.robot'], exit=False)\n\n        # Run tests and exit to the system automatically.\n        run_cli(['--name', 'Example', 'tests.robot'])\n\n    See also the [robot.run][robot.run.run] function that allows setting options as keyword\n    arguments like `name=\"Example\"` and generally has a richer API for\n    programmatic test execution.\n    \"\"\"\n    if arguments is None:\n        arguments = sys.argv[1:]\n    return RobotFramework().execute_cli(arguments, exit=exit)\n</code></pre>"},{"location":"api/robot/errors/","title":"robot.errors","text":""},{"location":"api/robot/errors/#robot.errors","title":"robot.errors","text":"<p>Exceptions and return codes used internally.</p> <p>External libraries should not used exceptions defined here.</p>"},{"location":"api/robot/errors/#robot.errors.RobotError","title":"RobotError","text":"<pre><code>RobotError(message='', details='')\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base class for Robot Framework errors.</p> <p>Do not raise this method but use more specific errors instead.</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message='', details=''):\n    super().__init__(message)\n    self.details = details\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.FrameworkError","title":"FrameworkError","text":"<pre><code>FrameworkError(message='', details='')\n</code></pre> <p>               Bases: <code>RobotError</code></p> <p>Can be used when the core framework goes to unexpected state.</p> <p>It is good to explicitly raise a FrameworkError if some framework component is used incorrectly. This is pretty much same as 'Internal Error' and should of course never happen.</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message='', details=''):\n    super().__init__(message)\n    self.details = details\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.DataError","title":"DataError","text":"<pre><code>DataError(message='', details='', syntax=False)\n</code></pre> <p>               Bases: <code>RobotError</code></p> <p>Used when the provided test data is invalid.</p> <p>DataErrors are not caught by keywords that run other keywords (e.g. <code>Run Keyword And Expect Error</code>).</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message='', details='', syntax=False):\n    super().__init__(message, details)\n    self.syntax = syntax\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.VariableError","title":"VariableError","text":"<pre><code>VariableError(message='', details='')\n</code></pre> <p>               Bases: <code>DataError</code></p> <p>Used when variable does not exist.</p> <p>VariableErrors are caught by keywords that run other keywords (e.g. <code>Run Keyword And Expect Error</code>).</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message='', details=''):\n    super().__init__(message, details)\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.KeywordError","title":"KeywordError","text":"<pre><code>KeywordError(message='', details='')\n</code></pre> <p>               Bases: <code>DataError</code></p> <p>Used when no keyword is found or there is more than one match.</p> <p>KeywordErrors are caught by keywords that run other keywords (e.g. <code>Run Keyword And Expect Error</code>).</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message='', details=''):\n    super().__init__(message, details)\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.TimeoutError","title":"TimeoutError","text":"<pre><code>TimeoutError(message='', test_timeout=True)\n</code></pre> <p>               Bases: <code>RobotError</code></p> <p>Used when a test or keyword timeout occurs.</p> <p>This exception is handled specially so that execution of the current test is always stopped immediately and it is not caught by keywords executing other keywords (e.g. <code>Run Keyword And Expect Error</code>).</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message='', test_timeout=True):\n    super().__init__(message)\n    self.test_timeout = test_timeout\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.Information","title":"Information","text":"<pre><code>Information(message='', details='')\n</code></pre> <p>               Bases: <code>RobotError</code></p> <p>Used by argument parser with --help or --version.</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message='', details=''):\n    super().__init__(message)\n    self.details = details\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.ExecutionStatus","title":"ExecutionStatus","text":"<pre><code>ExecutionStatus(\n    message,\n    test_timeout=False,\n    keyword_timeout=False,\n    syntax=False,\n    exit=False,\n    continue_on_failure=False,\n    skip=False,\n    return_value=None,\n)\n</code></pre> <p>               Bases: <code>RobotError</code></p> <p>Base class for exceptions communicating status in test execution.</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message, test_timeout=False, keyword_timeout=False,\n             syntax=False, exit=False, continue_on_failure=False,\n             skip=False, return_value=None):\n    if '\\r\\n' in message:\n        message = message.replace('\\r\\n', '\\n')\n    from robot.utils import cut_long_message\n    super().__init__(cut_long_message(message))\n    self.test_timeout = test_timeout\n    self.keyword_timeout = keyword_timeout\n    self.syntax = syntax\n    self.exit = exit\n    self._continue_on_failure = continue_on_failure\n    self.skip = skip\n    self.return_value = return_value\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.ExecutionFailed","title":"ExecutionFailed","text":"<pre><code>ExecutionFailed(\n    message,\n    test_timeout=False,\n    keyword_timeout=False,\n    syntax=False,\n    exit=False,\n    continue_on_failure=False,\n    skip=False,\n    return_value=None,\n)\n</code></pre> <p>               Bases: <code>ExecutionStatus</code></p> <p>Used for communicating failures in test execution.</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message, test_timeout=False, keyword_timeout=False,\n             syntax=False, exit=False, continue_on_failure=False,\n             skip=False, return_value=None):\n    if '\\r\\n' in message:\n        message = message.replace('\\r\\n', '\\n')\n    from robot.utils import cut_long_message\n    super().__init__(cut_long_message(message))\n    self.test_timeout = test_timeout\n    self.keyword_timeout = keyword_timeout\n    self.syntax = syntax\n    self.exit = exit\n    self._continue_on_failure = continue_on_failure\n    self.skip = skip\n    self.return_value = return_value\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.ExecutionPassed","title":"ExecutionPassed","text":"<pre><code>ExecutionPassed(message=None, **kwargs)\n</code></pre> <p>               Bases: <code>ExecutionStatus</code></p> <p>Base class for all exceptions communicating that execution passed.</p> <p>Should not be raised directly, but more detailed exceptions used instead.</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message=None, **kwargs):\n    super().__init__(message, **kwargs)\n    self._earlier_failures = []\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.PassExecution","title":"PassExecution","text":"<pre><code>PassExecution(message)\n</code></pre> <p>               Bases: <code>ExecutionPassed</code></p> <p>Used by 'Pass Execution' keyword.</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message):\n    super().__init__(message)\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.ContinueLoop","title":"ContinueLoop","text":"<pre><code>ContinueLoop()\n</code></pre> <p>               Bases: <code>ExecutionPassed</code></p> <p>Used by CONTINUE statement.</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self):\n    super().__init__(\"Invalid 'CONTINUE' usage.\")\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.BreakLoop","title":"BreakLoop","text":"<pre><code>BreakLoop()\n</code></pre> <p>               Bases: <code>ExecutionPassed</code></p> <p>Used by BREAK statement.</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self):\n    super().__init__(\"Invalid 'BREAK' usage.\")\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.ReturnFromKeyword","title":"ReturnFromKeyword","text":"<pre><code>ReturnFromKeyword(return_value=None, failures=None)\n</code></pre> <p>               Bases: <code>ExecutionPassed</code></p> <p>Used by 'RETURN' statement.</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, return_value=None, failures=None):\n    super().__init__(\"Invalid 'RETURN' usage.\", return_value=return_value)\n    if failures:\n        self.set_earlier_failures(failures)\n</code></pre>"},{"location":"api/robot/errors/#robot.errors.RemoteError","title":"RemoteError","text":"<pre><code>RemoteError(\n    message=\"\", details=\"\", fatal=False, continuable=False\n)\n</code></pre> <p>               Bases: <code>RobotError</code></p> <p>Used by Remote library to report remote errors.</p> Source code in <code>src/robot/errors.py</code> <pre><code>def __init__(self, message='', details='', fatal=False, continuable=False):\n    super().__init__(message, details)\n    self.ROBOT_EXIT_ON_FAILURE = fatal\n    self.ROBOT_CONTINUE_ON_FAILURE = continuable\n</code></pre>"},{"location":"api/robot/libdoc/","title":"robot.libdoc","text":""},{"location":"api/robot/libdoc/#robot.libdoc","title":"robot.libdoc","text":"<p>Module implementing the command line entry point for the Libdoc tool.</p> <p>This module can be executed from the command line using the following approaches::</p> <pre><code>python -m robot.libdoc\npython path/to/robot/libdoc.py\n</code></pre> <p>This module also exposes the following public API:</p> <ul> <li>:func:<code>libdoc_cli</code> function for simple command line tools.</li> <li>:func:<code>libdoc</code> function as a high level programmatic API.</li> <li>:func:<code>~robot.libdocpkg.builder.LibraryDocumentation</code> as the API to generate   :class:<code>~robot.libdocpkg.model.LibraryDoc</code> instances.</li> </ul> <p>Libdoc itself is implemented in the :mod:<code>~robot.libdocpkg</code> package.</p>"},{"location":"api/robot/libdoc/#robot.libdoc.libdoc_cli","title":"libdoc_cli","text":"<pre><code>libdoc_cli(arguments=None, exit=True)\n</code></pre> <p>Executes Libdoc similarly as from the command line.</p> <p>:param arguments: Command line options and arguments as a list of strings.     Starting from RF 4.0, defaults to <code>sys.argv[1:]</code> if not given. :param exit: If <code>True</code>, call <code>sys.exit</code> automatically. New in RF 4.0.</p> <p>The :func:<code>libdoc</code> function may work better in programmatic usage.</p> <p>Example::</p> <pre><code>from robot.libdoc import libdoc_cli\n\nlibdoc_cli(['--version', '1.0', 'MyLibrary.py', 'MyLibrary.html'])\n</code></pre> Source code in <code>src/robot/libdoc.py</code> <pre><code>def libdoc_cli(arguments=None, exit=True):\n    \"\"\"Executes Libdoc similarly as from the command line.\n\n    :param arguments: Command line options and arguments as a list of strings.\n        Starting from RF 4.0, defaults to ``sys.argv[1:]`` if not given.\n    :param exit: If ``True``, call ``sys.exit`` automatically. New in RF 4.0.\n\n    The :func:`libdoc` function may work better in programmatic usage.\n\n    Example::\n\n        from robot.libdoc import libdoc_cli\n\n        libdoc_cli(['--version', '1.0', 'MyLibrary.py', 'MyLibrary.html'])\n    \"\"\"\n    if arguments is None:\n        arguments = sys.argv[1:]\n    LibDoc().execute_cli(arguments, exit=exit)\n</code></pre>"},{"location":"api/robot/libdoc/#robot.libdoc.libdoc","title":"libdoc","text":"<pre><code>libdoc(\n    library_or_resource,\n    outfile,\n    name=\"\",\n    version=\"\",\n    format=None,\n    docformat=None,\n    specdocformat=None,\n    quiet=False,\n)\n</code></pre> <p>Executes Libdoc.</p> <p>:param library_or_resource: Name or path of the library or resource     file to be documented. :param outfile: Path to the file where to write outputs. :param name: Custom name to give to the documented library or resource. :param version: Version to give to the documented library or resource. :param format: Specifies whether to generate HTML, XML or JSON output.     If this options is not used, the format is got from the extension of     the output file. Possible values are <code>'HTML'</code>, <code>'XML'</code>, <code>'JSON'</code>     and <code>'LIBSPEC'</code>. :param docformat: Documentation source format. Possible values are     <code>'ROBOT'</code>, <code>'reST'</code>, <code>'HTML'</code> and <code>'TEXT'</code>. The default value     can be specified in library source code and the initial default     is <code>'ROBOT'</code>. :param specdocformat: Specifies whether the keyword documentation in spec     files is converted to HTML regardless of the original documentation     format. Possible values are <code>'HTML'</code> (convert to HTML) and <code>'RAW'</code>     (use original format). The default depends on the output format.     New in Robot Framework 4.0. :param quiet: When true, the path of the generated output file is not     printed the console. New in Robot Framework 4.0.</p> <p>Arguments have same semantics as Libdoc command line options with same names. Run <code>libdoc --help</code> or consult the Libdoc section in the Robot Framework User Guide for more details.</p> <p>Example::</p> <pre><code>from robot.libdoc import libdoc\n\nlibdoc('MyLibrary.py', 'MyLibrary.html', version='1.0')\n</code></pre> Source code in <code>src/robot/libdoc.py</code> <pre><code>def libdoc(library_or_resource, outfile, name='', version='', format=None,\n           docformat=None, specdocformat=None, quiet=False):\n    \"\"\"Executes Libdoc.\n\n    :param library_or_resource: Name or path of the library or resource\n        file to be documented.\n    :param outfile: Path to the file where to write outputs.\n    :param name: Custom name to give to the documented library or resource.\n    :param version: Version to give to the documented library or resource.\n    :param format: Specifies whether to generate HTML, XML or JSON output.\n        If this options is not used, the format is got from the extension of\n        the output file. Possible values are ``'HTML'``, ``'XML'``, ``'JSON'``\n        and ``'LIBSPEC'``.\n    :param docformat: Documentation source format. Possible values are\n        ``'ROBOT'``, ``'reST'``, ``'HTML'`` and ``'TEXT'``. The default value\n        can be specified in library source code and the initial default\n        is ``'ROBOT'``.\n    :param specdocformat: Specifies whether the keyword documentation in spec\n        files is converted to HTML regardless of the original documentation\n        format. Possible values are ``'HTML'`` (convert to HTML) and ``'RAW'``\n        (use original format). The default depends on the output format.\n        New in Robot Framework 4.0.\n    :param quiet: When true, the path of the generated output file is not\n        printed the console. New in Robot Framework 4.0.\n\n    Arguments have same semantics as Libdoc command line options with same names.\n    Run ``libdoc --help`` or consult the Libdoc section in the Robot Framework\n    User Guide for more details.\n\n    Example::\n\n        from robot.libdoc import libdoc\n\n        libdoc('MyLibrary.py', 'MyLibrary.html', version='1.0')\n    \"\"\"\n    return LibDoc().execute(\n        library_or_resource, outfile, name=name, version=version, format=format,\n        docformat=docformat, specdocformat=specdocformat, quiet=quiet\n    )\n</code></pre>"},{"location":"api/robot/pythonpathsetter/","title":"robot.pythonpathsetter","text":""},{"location":"api/robot/pythonpathsetter/#robot.pythonpathsetter","title":"robot.pythonpathsetter","text":"<p>Modifies <code>sys.path</code> if Robot Framework's entry points are run as scripts.</p> <p>When, for example, <code>robot/run.py</code> or <code>robot/libdoc.py</code> is executed as a script, the <code>robot</code> directory is in <code>sys.path</code> but its parent directory is not. Importing this module adds the parent directory to <code>sys.path</code> to make it possible to import the <code>robot</code> module. The <code>robot</code> directory itself is removed to prevent importing internal modules directly.</p> <p>Does nothing if the <code>robot</code> module is already imported.</p>"},{"location":"api/robot/rebot/","title":"robot.rebot","text":""},{"location":"api/robot/rebot/#robot.rebot","title":"robot.rebot","text":"<p>Module implementing the command line entry point for post-processing outputs.</p> <p>This module can be executed from the command line using the following approaches::</p> <pre><code>python -m robot.rebot\npython path/to/robot/rebot.py\n</code></pre> <p>Instead of <code>python</code> it is possible to use also other Python interpreters. This module is also used by the installed <code>rebot</code> start-up script.</p> <p>This module also provides :func:<code>rebot</code> and :func:<code>rebot_cli</code> functions that can be used programmatically. Other code is for internal usage.</p>"},{"location":"api/robot/rebot/#robot.rebot.rebot_cli","title":"rebot_cli","text":"<pre><code>rebot_cli(arguments=None, exit=True)\n</code></pre> <p>Command line execution entry point for post-processing outputs.</p> <p>:param arguments: Command line options and arguments as a list of strings.     Defaults to <code>sys.argv[1:]</code> if not given. :param exit: If <code>True</code>, call <code>sys.exit</code> with the return code denoting     execution status, otherwise just return the rc.</p> <p>Entry point used when post-processing outputs from the command line, but can also be used by custom scripts. Especially useful if the script itself needs to accept same arguments as accepted by Rebot, because the script can just pass them forward directly along with the possible default values it sets itself.</p> <p>Example::</p> <pre><code>from robot import rebot_cli\n\nrebot_cli(['--name', 'Example', '--log', 'NONE', 'o1.xml', 'o2.xml'])\n</code></pre> <p>See also the :func:<code>rebot</code> function that allows setting options as keyword arguments like <code>name=\"Example\"</code> and generally has a richer API for programmatic Rebot execution.</p> Source code in <code>src/robot/rebot.py</code> <pre><code>def rebot_cli(arguments=None, exit=True):\n    \"\"\"Command line execution entry point for post-processing outputs.\n\n    :param arguments: Command line options and arguments as a list of strings.\n        Defaults to ``sys.argv[1:]`` if not given.\n    :param exit: If ``True``, call ``sys.exit`` with the return code denoting\n        execution status, otherwise just return the rc.\n\n    Entry point used when post-processing outputs from the command line, but\n    can also be used by custom scripts. Especially useful if the script itself\n    needs to accept same arguments as accepted by Rebot, because the script can\n    just pass them forward directly along with the possible default values it\n    sets itself.\n\n    Example::\n\n        from robot import rebot_cli\n\n        rebot_cli(['--name', 'Example', '--log', 'NONE', 'o1.xml', 'o2.xml'])\n\n    See also the :func:`rebot` function that allows setting options as keyword\n    arguments like ``name=\"Example\"`` and generally has a richer API for\n    programmatic Rebot execution.\n    \"\"\"\n    if arguments is None:\n        arguments = sys.argv[1:]\n    return Rebot().execute_cli(arguments, exit=exit)\n</code></pre>"},{"location":"api/robot/rebot/#robot.rebot.rebot","title":"rebot","text":"<pre><code>rebot(*outputs, **options)\n</code></pre> <p>Programmatic entry point for post-processing outputs.</p> <p>:param outputs: Paths to Robot Framework output files similarly     as when running the <code>rebot</code> command on the command line. :param options: Options to configure processing outputs. Accepted     options are mostly same as normal command line options to the <code>rebot</code>     command. Option names match command line option long names without     hyphens so that, for example, <code>--name</code> becomes <code>name</code>.</p> <p>The semantics related to passing options are exactly the same as with the :func:<code>~robot.run.run</code> function. See its documentation for more details.</p> <p>Examples::</p> <pre><code>from robot import rebot\n\nrebot('path/to/output.xml')\nwith open('stdout.txt', 'w') as stdout:\n    rebot('o1.xml', 'o2.xml', name='Example', log=None, stdout=stdout)\n</code></pre> <p>Equivalent command line usage::</p> <pre><code>rebot path/to/output.xml\nrebot --name Example --log NONE o1.xml o2.xml &gt; stdout.txt\n</code></pre> Source code in <code>src/robot/rebot.py</code> <pre><code>def rebot(*outputs, **options):\n    \"\"\"Programmatic entry point for post-processing outputs.\n\n    :param outputs: Paths to Robot Framework output files similarly\n        as when running the ``rebot`` command on the command line.\n    :param options: Options to configure processing outputs. Accepted\n        options are mostly same as normal command line options to the ``rebot``\n        command. Option names match command line option long names without\n        hyphens so that, for example, ``--name`` becomes ``name``.\n\n    The semantics related to passing options are exactly the same as with the\n    :func:`~robot.run.run` function. See its documentation for more details.\n\n    Examples::\n\n        from robot import rebot\n\n        rebot('path/to/output.xml')\n        with open('stdout.txt', 'w') as stdout:\n            rebot('o1.xml', 'o2.xml', name='Example', log=None, stdout=stdout)\n\n    Equivalent command line usage::\n\n        rebot path/to/output.xml\n        rebot --name Example --log NONE o1.xml o2.xml &gt; stdout.txt\n    \"\"\"\n    return Rebot().execute(*outputs, **options)\n</code></pre>"},{"location":"api/robot/run/","title":"robot.run","text":""},{"location":"api/robot/run/#robot.run","title":"robot.run","text":"<p>Module implementing the command line entry point for executing tests.</p> <p>This module can be executed from the command line using the following approaches:</p> <pre><code>python -m robot.run\npython path/to/robot/run.py\n</code></pre> <p>Instead of <code>python</code> it is possible to use also other Python interpreters. This module is also used by the installed <code>robot</code> start-up script.</p> <p>This module also provides robot.run and robot.run_cli functions that can be used programmatically. Other code is for internal usage.</p>"},{"location":"api/robot/run/#robot.run.run_cli","title":"run_cli","text":"<pre><code>run_cli(\n    arguments: list[str] | None = None, exit: bool = True\n)\n</code></pre> <p>Command line execution entry point for running tests.</p> <p>Parameters:</p> Name Type Description Default <code>arguments</code> <code>list[str] | None</code> <p>Command line options and arguments as a list of strings. Defaults to <code>sys.argv[1:]</code> if not given.</p> <code>None</code> <code>exit</code> <code>bool</code> <p>If <code>True</code>, call <code>sys.exit</code> with the return code denoting execution status, otherwise just return the rc.</p> <code>True</code> <p>Entry point used when running tests from the command line, but can also be used by custom scripts that execute tests. Especially useful if the script itself needs to accept same arguments as accepted by Robot Framework, because the script can just pass them forward directly along with the possible default values it sets itself.</p> <p>Example:</p> <pre><code>from robot import run_cli\n\n# Run tests and return the return code.\nrc = run_cli(['--name', 'Example', 'tests.robot'], exit=False)\n\n# Run tests and exit to the system automatically.\nrun_cli(['--name', 'Example', 'tests.robot'])\n</code></pre> <p>See also the robot.run function that allows setting options as keyword arguments like <code>name=\"Example\"</code> and generally has a richer API for programmatic test execution.</p> Source code in <code>src/robot/run.py</code> <pre><code>def run_cli(arguments: 'list[str]|None' = None, exit: bool = True):\n    \"\"\"Command line execution entry point for running tests.\n\n    Parameters:\n        arguments: Command line options and arguments as a list of strings.\n            Defaults to `sys.argv[1:]` if not given.\n        exit: If `True`, call `sys.exit` with the return code denoting\n            execution status, otherwise just return the rc.\n\n    Entry point used when running tests from the command line, but can also\n    be used by custom scripts that execute tests. Especially useful if the\n    script itself needs to accept same arguments as accepted by Robot Framework,\n    because the script can just pass them forward directly along with the\n    possible default values it sets itself.\n\n    Example:\n\n        from robot import run_cli\n\n        # Run tests and return the return code.\n        rc = run_cli(['--name', 'Example', 'tests.robot'], exit=False)\n\n        # Run tests and exit to the system automatically.\n        run_cli(['--name', 'Example', 'tests.robot'])\n\n    See also the [robot.run][robot.run.run] function that allows setting options as keyword\n    arguments like `name=\"Example\"` and generally has a richer API for\n    programmatic test execution.\n    \"\"\"\n    if arguments is None:\n        arguments = sys.argv[1:]\n    return RobotFramework().execute_cli(arguments, exit=exit)\n</code></pre>"},{"location":"api/robot/run/#robot.run.run","title":"run","text":"<pre><code>run(*sources: list[str | Path], **options: dict[str, Any])\n</code></pre> <p>Programmatic entry point for running tests.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>list[str | Path]</code> <p>Paths to test case files/directories to be executed similarly as when running the <code>robot</code> command on the command line.</p> <code>()</code> <code>options</code> <code>dict[str, Any]</code> <p>Options to configure and control execution. Accepted options are mostly same as normal command line options to the <code>robot</code> command. Option names match command line option long names without hyphens so that, for example, <code>--name</code> becomes <code>name</code>.</p> <code>{}</code> <p>Most options that can be given from the command line work. An exception is that options <code>--pythonpath</code>, <code>--argumentfile</code>, <code>--help</code> and <code>--version</code> are not supported.</p> <p>Options that can be given on the command line multiple times can be passed as lists. For example, <code>include=['tag1', 'tag2']</code> is equivalent to <code>--include tag1 --include tag2</code>. If such options are used only once, they can be given also as a single string like <code>include='tag'</code>.</p> <p>Options that accept no value can be given as Booleans. For example, <code>dryrun=True</code> is same as using the <code>--dryrun</code> option.</p> <p>Options that accept string <code>NONE</code> as a special value can also be used with Python <code>None</code>. For example, using <code>log=None</code> is equivalent to <code>--log NONE</code>.</p> <p><code>listener</code>, <code>prerunmodifier</code> and <code>prerebotmodifier</code> options allow passing values as Python objects in addition to module names these command line options support. For example, <code>run('tests', listener=MyListener())</code>.</p> <p>To capture the standard output and error streams, pass an open file or file-like object as special keyword arguments <code>stdout</code> and <code>stderr</code>, respectively.</p> <p>A return code is returned similarly as when running on the command line. Zero means that tests were executed and no test failed, values up to 250 denote the number of failed tests, and values between 251-255 are for other statuses documented in the Robot Framework User Guide.</p> <p>Example:</p> <pre><code>from robot import run\n\nrun('path/to/tests.robot')\nrun('tests.robot', include=['tag1', 'tag2'], splitlog=True)\nwith open('stdout.txt', 'w') as stdout:\n    run('t1.robot', 't2.robot', name='Example', log=None, stdout=stdout)\n</code></pre> <p>Equivalent command line usage:</p> <pre><code>robot path/to/tests.robot\nrobot --include tag1 --include tag2 --splitlog tests.robot\nrobot --name Example --log NONE t1.robot t2.robot &gt; stdout.txt\n</code></pre> Source code in <code>src/robot/run.py</code> <pre><code>def run(*sources: 'list[str|Path]', **options: 'dict[str, Any]'):\n    \"\"\"Programmatic entry point for running tests.\n\n    Parameters:\n        sources: Paths to test case files/directories to be executed similarly\n            as when running the `robot` command on the command line.\n        options: Options to configure and control execution. Accepted\n            options are mostly same as normal command line options to the `robot`\n            command. Option names match command line option long names without\n            hyphens so that, for example, `--name` becomes `name`.\n\n    Most options that can be given from the command line work. An exception\n    is that options `--pythonpath`, `--argumentfile`, `--help` and\n    `--version` are not supported.\n\n    Options that can be given on the command line multiple times can be\n    passed as lists. For example, `include=['tag1', 'tag2']` is equivalent\n    to `--include tag1 --include tag2`. If such options are used only once,\n    they can be given also as a single string like `include='tag'`.\n\n    Options that accept no value can be given as Booleans. For example,\n    `dryrun=True` is same as using the `--dryrun` option.\n\n    Options that accept string `NONE` as a special value can also be used\n    with Python `None`. For example, using `log=None` is equivalent to\n    `--log NONE`.\n\n    `listener`, `prerunmodifier` and `prerebotmodifier` options allow\n    passing values as Python objects in addition to module names these command\n    line options support. For example, `#!py run('tests', listener=MyListener())`.\n\n    To capture the standard output and error streams, pass an open file or\n    file-like object as special keyword arguments `stdout` and `stderr`,\n    respectively.\n\n    A return code is returned similarly as when running on the command line.\n    Zero means that tests were executed and no test failed, values up to 250\n    denote the number of failed tests, and values between 251-255 are for other\n    statuses documented in the Robot Framework User Guide.\n\n    Example:\n\n        from robot import run\n\n        run('path/to/tests.robot')\n        run('tests.robot', include=['tag1', 'tag2'], splitlog=True)\n        with open('stdout.txt', 'w') as stdout:\n            run('t1.robot', 't2.robot', name='Example', log=None, stdout=stdout)\n\n    Equivalent command line usage:\n\n        robot path/to/tests.robot\n        robot --include tag1 --include tag2 --splitlog tests.robot\n        robot --name Example --log NONE t1.robot t2.robot &gt; stdout.txt\n    \"\"\"\n    return RobotFramework().execute(*sources, **options)\n</code></pre>"},{"location":"api/robot/testdoc/","title":"robot.testdoc","text":""},{"location":"api/robot/testdoc/#robot.testdoc","title":"robot.testdoc","text":"<p>Module implementing the command line entry point for the <code>Testdoc</code> tool.</p> <p>This module can be executed from the command line using the following approaches::</p> <pre><code>python -m robot.testdoc\npython path/to/robot/testdoc.py\n</code></pre> <p>Instead of <code>python</code> it is possible to use also other Python interpreters.</p> <p>This module also provides :func:<code>testdoc</code> and :func:<code>testdoc_cli</code> functions that can be used programmatically. Other code is for internal usage.</p>"},{"location":"api/robot/testdoc/#robot.testdoc.testdoc_cli","title":"testdoc_cli","text":"<pre><code>testdoc_cli(arguments)\n</code></pre> <p>Executes <code>Testdoc</code> similarly as from the command line.</p> <p>:param arguments: command line arguments as a list of strings.</p> <p>For programmatic usage the :func:<code>testdoc</code> function is typically better. It has a better API for that and does not call :func:<code>sys.exit</code> like this function.</p> <p>Example::</p> <pre><code>from robot.testdoc import testdoc_cli\n\ntestdoc_cli(['--title', 'Test Plan', 'mytests', 'plan.html'])\n</code></pre> Source code in <code>src/robot/testdoc.py</code> <pre><code>def testdoc_cli(arguments):\n    \"\"\"Executes `Testdoc` similarly as from the command line.\n\n    :param arguments: command line arguments as a list of strings.\n\n    For programmatic usage the :func:`testdoc` function is typically better. It\n    has a better API for that and does not call :func:`sys.exit` like\n    this function.\n\n    Example::\n\n        from robot.testdoc import testdoc_cli\n\n        testdoc_cli(['--title', 'Test Plan', 'mytests', 'plan.html'])\n    \"\"\"\n    TestDoc().execute_cli(arguments)\n</code></pre>"},{"location":"api/robot/testdoc/#robot.testdoc.testdoc","title":"testdoc","text":"<pre><code>testdoc(*arguments, **options)\n</code></pre> <p>Executes <code>Testdoc</code> programmatically.</p> <p>Arguments and options have same semantics, and options have same names, as arguments and options to Testdoc.</p> <p>Example::</p> <pre><code>from robot.testdoc import testdoc\n\ntestdoc('mytests', 'plan.html', title='Test Plan')\n</code></pre> Source code in <code>src/robot/testdoc.py</code> <pre><code>def testdoc(*arguments, **options):\n    \"\"\"Executes `Testdoc` programmatically.\n\n    Arguments and options have same semantics, and options have same names,\n    as arguments and options to Testdoc.\n\n    Example::\n\n        from robot.testdoc import testdoc\n\n        testdoc('mytests', 'plan.html', title='Test Plan')\n    \"\"\"\n    TestDoc().execute(*arguments, **options)\n</code></pre>"},{"location":"api/robot/version/","title":"robot.version","text":""},{"location":"api/robot/version/#robot.version","title":"robot.version","text":""},{"location":"api/robot/api/","title":"robot.api","text":""},{"location":"api/robot/api/#robot.api","title":"robot.api","text":"<p>:mod:<code>robot.api</code> package exposes the public APIs of Robot Framework.</p> <p>Unless stated otherwise, the APIs exposed in this package are considered stable, and thus safe to use when building external tools on top of Robot Framework. Notice that all parsing APIs were rewritten in Robot Framework 3.2.</p> <p>Currently exposed APIs are:</p> <ul> <li> <p>:mod:<code>.logger</code> module for libraries' logging purposes.</p> </li> <li> <p>:mod:<code>.deco</code> module with decorators libraries can utilize.</p> </li> <li> <p>:mod:<code>.exceptions</code> module containing exceptions that libraries can utilize for   reporting failures and other events. These exceptions can be imported also directly   via :mod:<code>robot.api</code> like <code>from robot.api import SkipExecution</code>.</p> </li> <li> <p>:mod:<code>.interfaces</code> module containing optional base classes that can be used   when creating libraries and other extensions. New in Robot Framework 6.1.</p> </li> <li> <p>:mod:<code>.parsing</code> module exposing the parsing APIs. This module is new in Robot   Framework 4.0. Various parsing related functions and classes were exposed   directly via :mod:<code>robot.api</code> already in Robot Framework 3.2, but they are   effectively deprecated and will be removed in the future.</p> </li> <li> <p>:class:<code>~robot.running.model.TestSuite</code> class for creating executable   test suites programmatically and   :class:<code>~robot.running.builder.builders.TestSuiteBuilder</code> class   for creating such suites based on existing test data on the file system.</p> </li> <li> <p>:class:<code>~robot.model.visitor.SuiteVisitor</code> abstract class for processing testdata   before execution. This can be used as a base for implementing a pre-run   modifier that is taken into use with <code>--prerunmodifier</code> commandline option.</p> </li> <li> <p>:func:<code>~robot.result.resultbuilder.ExecutionResult</code> factory method   for reading execution results from XML output files and   :class:<code>~robot.result.visitor.ResultVisitor</code> abstract class to ease   further processing the results.   :class:<code>~robot.result.visitor.ResultVisitor</code> can also be used as a base   for pre-Rebot modifier that is taken into use with <code>--prerebotmodifier</code>   commandline option.</p> </li> <li> <p>:class:<code>~robot.reporting.resultwriter.ResultWriter</code> class for writing   reports, logs, XML outputs, and XUnit files. Can write results based on   XML outputs on the file system, as well as based on the result objects   returned by the :func:<code>~robot.result.resultbuilder.ExecutionResult</code> or   an executed :class:<code>~robot.running.model.TestSuite</code>.</p> </li> <li> <p>:class:<code>~robot.running.arguments.typeinfo.TypeInfo</code> class for parsing   type hints and converting values based on them. New in Robot Framework 7.0.</p> </li> <li> <p>:class:<code>~robot.conf.languages.Languages</code> and :class:<code>~robot.conf.languages.Language</code>   classes for external tools that need to work with different translations.   The latter is also the base class to use with custom translations.</p> </li> </ul> <p>All of the above classes can be imported like::</p> <pre><code>from robot.api import ClassName\n</code></pre> <p>See documentations of the individual APIs for more details.</p> <p>.. tip:: APIs related to the command line entry points are exposed directly         via the :mod:<code>robot</code> root package.</p>"},{"location":"api/robot/api/deco/","title":"robot.api.deco","text":""},{"location":"api/robot/api/deco/#robot.api.deco","title":"robot.api.deco","text":"<p>Module defining decorators libraries can use.</p> <ul> <li>library: for marking and configuring library classes.</li> <li>keyword: for marking and configuring keyword functions   and methods.</li> <li>not_keyword: for marking functions and method not   to be keywords.</li> </ul> <p>Attributes in this module are used only in type hints of the aforementioned decorators.</p>"},{"location":"api/robot/api/deco/#robot.api.deco.F","title":"F  <code>module-attribute</code>","text":"<pre><code>F = TypeVar('F', bound=Callable[..., Any])\n</code></pre> <p>Type variable representing any function.</p>"},{"location":"api/robot/api/deco/#robot.api.deco.K","title":"K  <code>module-attribute</code>","text":"<pre><code>K = TypeVar('K', bound=Callable[..., Any])\n</code></pre> <p>Type variable representing a keyword function.</p>"},{"location":"api/robot/api/deco/#robot.api.deco.L","title":"L  <code>module-attribute</code>","text":"<pre><code>L = TypeVar('L', bound=type)\n</code></pre> <p>Type variable representing a library class.</p>"},{"location":"api/robot/api/deco/#robot.api.deco.KeywordDecorator","title":"KeywordDecorator  <code>module-attribute</code>","text":"<pre><code>KeywordDecorator = Callable[[K], K]\n</code></pre> <p>Keyword decorator. Sets attributes to the given keyword function and returns it.</p>"},{"location":"api/robot/api/deco/#robot.api.deco.LibraryDecorator","title":"LibraryDecorator  <code>module-attribute</code>","text":"<pre><code>LibraryDecorator = Callable[[L], L]\n</code></pre> <p>Library decorator. Sets attributes to the given library class and returns it.</p>"},{"location":"api/robot/api/deco/#robot.api.deco.Scope","title":"Scope  <code>module-attribute</code>","text":"<pre><code>Scope = Literal['GLOBAL', 'SUITE', 'TEST', 'TASK']\n</code></pre> <p>Library scope.</p> <ul> <li><code>GLOBAL</code>: Library has a global scope.</li> <li><code>SUITE</code>: Library has a suite level scope.</li> <li><code>TEST</code>: Library has a test level scope. The default if scope is not specified.</li> <li><code>TASK</code>: An alias for <code>TEST</code>.</li> </ul>"},{"location":"api/robot/api/deco/#robot.api.deco.Converter","title":"Converter  <code>module-attribute</code>","text":"<pre><code>Converter = Union[\n    Callable[[Any], Any], Callable[[Any, Any], Any]\n]\n</code></pre> <p>Custom argument converter.</p> <p>A callable accepting one or two arguments. If it accepts one, it only gets the value to be converted. If it accepts two, it gets the value and also the library the used keyword belongs to. The latter approach allows making conversion based on the library state.</p> <p>The converted value is returned. If the value is invalid, a ValueError should be raised.</p>"},{"location":"api/robot/api/deco/#robot.api.deco.DocFormat","title":"DocFormat  <code>module-attribute</code>","text":"<pre><code>DocFormat = Literal['ROBOT', 'HTML', 'TEXT', 'REST']\n</code></pre> <p>Library documentation format.</p> <ul> <li><code>ROBOT</code>: Use Robot Framework's own custom markup syntax. The default if format   is not specified.</li> <li><code>HTML</code>: Use documentation as HTML directly.</li> <li><code>TEXT</code>: Consider documentation to be plain text.</li> <li><code>REST</code>: Use reStructuredText    markup language.</li> </ul>"},{"location":"api/robot/api/deco/#robot.api.deco.not_keyword","title":"not_keyword","text":"<pre><code>not_keyword(func: F) -&gt; F\n</code></pre> <p>Decorator to disable exposing functions or methods as keywords.</p> <p>Examples:</p> <pre><code>@not_keyword\ndef not_exposed_as_keyword():\n    ...\n\ndef exposed_as_keyword():\n    ...\n</code></pre> <p>Alternatively, the automatic keyword discovery can be disabled with the library decorator or by setting the <code>ROBOT_AUTO_KEYWORDS</code> attribute to a false value.</p> Source code in <code>src/robot/api/deco.py</code> <pre><code>def not_keyword(func: F) -&gt; F:\n    \"\"\"Decorator to disable exposing functions or methods as keywords.\n\n    Examples:\n\n        @not_keyword\n        def not_exposed_as_keyword():\n            ...\n\n        def exposed_as_keyword():\n            ...\n\n    Alternatively, the automatic keyword discovery can be disabled with\n    the [library][robot.api.deco.library] decorator or by setting\n    the `ROBOT_AUTO_KEYWORDS` attribute to a false value.\n    \"\"\"\n    func.robot_not_keyword = True\n    return func\n</code></pre>"},{"location":"api/robot/api/deco/#robot.api.deco.keyword","title":"keyword","text":"<pre><code>keyword(func: K) -&gt; K\n</code></pre><pre><code>keyword(\n    name: str | None = None,\n    tags: Sequence[str] = (),\n    types: TypeHints | None = (),\n) -&gt; KeywordDecorator\n</code></pre> <pre><code>keyword(\n    name: K | str | None = None,\n    tags: Sequence[str] = (),\n    types: TypeHints | None = (),\n) -&gt; K | KeywordDecorator\n</code></pre> <p>Decorator to set custom name, tags and argument types to keywords.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>K | str | None</code> <p>Custom keyword name. Required if keyword accepts embedded arguments. Keyword name is generated based on function/method name by default. Sets <code>robot_name</code> attribute to the decorated method of function.</p> <code>None</code> <code>tags</code> <code>Sequence[str]</code> <p>Keyword tags. Sets <code>robot_tags</code> attribute.</p> <code>()</code> <code>types</code> <code>TypeHints | None</code> <p>Argument types. Sets <code>robot_types</code> attribute.</p> <p>Value can be:</p> <ul> <li>a dictionary mapping argument names to types,</li> <li>a list of types mapped to arguments based on position, or</li> <li><code>None</code> to disable argument conversion altogether.</li> </ul> <p>It is OK to specify types only to some arguments. In normal usage it is recommended to specify types using type hints.</p> <code>()</code> <p>If the automatic keyword discovery has been disabled with the library decorator or by setting the <code>ROBOT_AUTO_KEYWORDS</code> attribute to a false value, this decorator is needed to mark functions or methods keywords. In such usage this decorator is typically used without any arguments like <code>@keyword</code>.</p> <p>Examples:</p> <pre><code>@keyword\ndef example():\n    ...\n\n@keyword('Login as user \"${user}\" with password \"${password}\"',\n         tags=['custom name', 'embedded arguments', 'tags'])\ndef login(user, password):\n    ...\n\n@keyword(types={'length': int, 'case_insensitive': bool})\ndef types_as_dict(length, case_insensitive):\n    ...\n\n@keyword(types=[int, bool])\ndef types_as_list(length, case_insensitive):\n    ...\n\n@keyword\ndef types_using_type_hints(length: int, case_insensitive: bool):\n    ...\n\n@keyword(types=None)\ndef no_conversion(length, case_insensitive=False):\n    ...\n</code></pre> Source code in <code>src/robot/api/deco.py</code> <pre><code>@not_keyword\ndef keyword(name: 'K | str | None' = None,\n            tags: Sequence[str] = (),\n            types: 'TypeHints | None' = ()) -&gt; 'K | KeywordDecorator':\n    \"\"\"Decorator to set custom name, tags and argument types to keywords.\n\n    Parameters:\n        name: Custom keyword name. Required if keyword accepts embedded\n            arguments. Keyword name is generated based on function/method\n            name by default. Sets `robot_name` attribute to the decorated\n            method of function.\n        tags: Keyword tags. Sets `robot_tags` attribute.\n        types: Argument types. Sets `robot_types` attribute.\n\n            Value can be:\n\n            - a dictionary mapping argument names to types,\n            - a list of types mapped to arguments based on position, or\n            - `None` to disable argument conversion altogether.\n\n            It is OK to specify types only to some arguments. In normal usage\n            it is recommended to specify types using type hints.\n\n    If the automatic keyword discovery has been disabled with the\n    [library][robot.api.deco.library] decorator or by setting the\n    `ROBOT_AUTO_KEYWORDS` attribute to a false value, this decorator is\n    needed to mark functions or methods keywords. In such usage this decorator\n    is typically used without any arguments like `@keyword`.\n\n    Examples:\n\n        @keyword\n        def example():\n            ...\n\n        @keyword('Login as user \"${user}\" with password \"${password}\"',\n                 tags=['custom name', 'embedded arguments', 'tags'])\n        def login(user, password):\n            ...\n\n        @keyword(types={'length': int, 'case_insensitive': bool})\n        def types_as_dict(length, case_insensitive):\n            ...\n\n        @keyword(types=[int, bool])\n        def types_as_list(length, case_insensitive):\n            ...\n\n        @keyword\n        def types_using_type_hints(length: int, case_insensitive: bool):\n            ...\n\n        @keyword(types=None)\n        def no_conversion(length, case_insensitive=False):\n            ...\n    \"\"\"\n    if callable(name):\n        return keyword()(name)\n\n    def decorator(func: F) -&gt; F:\n        func.robot_name = name\n        func.robot_tags = tags\n        func.robot_types = types\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/robot/api/deco/#robot.api.deco.library","title":"library","text":"<pre><code>library(cls: L) -&gt; L\n</code></pre><pre><code>library(\n    scope: Scope | None = None,\n    version: str | None = None,\n    converters: dict[type, Converter] | None = None,\n    doc_format: DocFormat | None = None,\n    listener: Any | None = None,\n    auto_keywords: bool = False,\n) -&gt; LibraryDecorator\n</code></pre> <pre><code>library(\n    scope: L | Scope | None = None,\n    version: str | None = None,\n    converters: dict[type, Converter] | None = None,\n    doc_format: DocFormat | None = None,\n    listener: Any | None = None,\n    auto_keywords: bool = False,\n) -&gt; L | LibraryDecorator\n</code></pre> <p>Class decorator to control keyword discovery and other library settings.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>L | Scope | None</code> <p>Library scope. Sets class attribute <code>ROBOT_LIBRARY_SCOPE</code>.</p> <code>None</code> <code>version</code> <code>str | None</code> <p>Library version. Sets class attribute <code>ROBOT_LIBRARY_VERSION</code>.</p> <code>None</code> <code>converters</code> <code>dict[type, Converter] | None</code> <p>Custom argument converters. Sets class attribute <code>ROBOT_LIBRARY_CONVERTERS</code>.</p> <code>None</code> <code>doc_format</code> <code>DocFormat | None</code> <p>Library documentation format. Sets class attribute <code>ROBOT_LIBRARY_DOC_FORMAT</code>.</p> <code>None</code> <code>listener</code> <code>Any | None</code> <p>Library listener or listeners. Sets class attribute <code>ROBOT_LIBRARY_LISTENER</code>.</p> <code>None</code> <code>auto_keywords</code> <code>bool</code> <p>Controls keyword discovery. When <code>False</code> (default), keywords need to be explicitly decorated with the keyword decorator. When <code>True</code>, all public methods become keywords. Sets class attribute <code>ROBOT_AUTO_KEYWORDS</code>.</p> <code>False</code> <p>The <code>ROBOT_AUTO_KEYWORDS</code> class attribute is always set, but other class attributes are set only if parameters controlling them are used. All class attributes that are set override possible existing class attributes.</p> <p>This decorator can be used simply like <code>@library</code> to enable keyword discovery if there is no need to use any parameters.</p> <p>Examples:</p> <pre><code>@library\nclass KeywordDiscovery:\n\n    @keyword\n    def do_something(self):\n        ...\n\n    def not_keyword(self):\n        ...\n\n\n@library(scope='GLOBAL', version='3.2', auto_keywords=True)\nclass LibraryConfiguration:\n    ...\n</code></pre> <p>The <code>converters</code> argument is new in Robot Framework 5.0.</p> Source code in <code>src/robot/api/deco.py</code> <pre><code>@not_keyword\ndef library(scope: 'L | Scope | None' = None,\n            version: 'str | None' = None,\n            converters: 'dict[type, Converter] | None' = None,\n            doc_format: 'DocFormat | None' = None,\n            listener: 'Any | None' = None,\n            auto_keywords: bool = False) -&gt; 'L | LibraryDecorator':\n    \"\"\"Class decorator to control keyword discovery and other library settings.\n\n    Parameters:\n        scope: Library scope.\n            Sets class attribute `ROBOT_LIBRARY_SCOPE`.\n        version: Library version.\n            Sets class attribute `ROBOT_LIBRARY_VERSION`.\n        converters: Custom argument converters.\n            Sets class attribute `ROBOT_LIBRARY_CONVERTERS`.\n        doc_format: Library documentation format.\n            Sets class attribute `ROBOT_LIBRARY_DOC_FORMAT`.\n        listener: Library listener or listeners.\n            Sets class attribute `ROBOT_LIBRARY_LISTENER`.\n        auto_keywords: Controls keyword discovery. When `False` (default), keywords\n            need to be explicitly decorated with the [keyword][robot.api.deco.keyword]\n            decorator. When `True`, all public methods become keywords.\n            Sets class attribute `ROBOT_AUTO_KEYWORDS`.\n\n    The `ROBOT_AUTO_KEYWORDS` class attribute is always set, but other class\n    attributes are set only if parameters controlling them are used. All\n    class attributes that are set override possible existing class attributes.\n\n    This decorator can be used simply like `@library` to enable keyword discovery\n    if there is no need to use any parameters.\n\n    Examples:\n\n        @library\n        class KeywordDiscovery:\n\n            @keyword\n            def do_something(self):\n                ...\n\n            def not_keyword(self):\n                ...\n\n\n        @library(scope='GLOBAL', version='3.2', auto_keywords=True)\n        class LibraryConfiguration:\n            ...\n\n    The `converters` argument is new in Robot Framework 5.0.\n    \"\"\"\n    if isinstance(scope, type):\n        return library()(scope)\n\n    def decorator(cls: L) -&gt; L:\n        if scope is not None:\n            cls.ROBOT_LIBRARY_SCOPE = scope\n        if version is not None:\n            cls.ROBOT_LIBRARY_VERSION = version\n        if converters is not None:\n            cls.ROBOT_LIBRARY_CONVERTERS = converters\n        if doc_format is not None:\n            cls.ROBOT_LIBRARY_DOC_FORMAT = doc_format\n        if listener is not None:\n            cls.ROBOT_LIBRARY_LISTENER = listener\n        cls.ROBOT_AUTO_KEYWORDS = auto_keywords\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api/robot/api/exceptions/","title":"robot.api.exceptions","text":""},{"location":"api/robot/api/exceptions/#robot.api.exceptions","title":"robot.api.exceptions","text":"<p>Exceptions that libraries can use for communicating failures and other events.</p> <p>These exceptions can be imported also via the top level :mod:<code>robot.api</code> package like <code>from robot.api import SkipExecution</code>.</p> <p>This module and all exceptions are new in Robot Framework 4.0.</p>"},{"location":"api/robot/api/exceptions/#robot.api.exceptions.Failure","title":"Failure","text":"<pre><code>Failure(message: str, html: bool = False)\n</code></pre> <p>               Bases: <code>AssertionError</code></p> <p>Report failed validation.</p> <p>There is no practical difference in using this exception compared to using the standard <code>AssertionError</code>. The main benefits are HTML support and that the name of this exception is consistent with other exceptions in this module.</p> <p>:param message: Exception message. :param html: When <code>True</code>, message is considered to be HTML and not escaped.</p> Source code in <code>src/robot/api/exceptions.py</code> <pre><code>def __init__(self, message: str, html: bool = False):\n    \"\"\"\n    :param message: Exception message.\n    :param html: When ``True``, message is considered to be HTML and not escaped.\n    \"\"\"\n    super().__init__(message if not html else '*HTML* ' + message)\n</code></pre>"},{"location":"api/robot/api/exceptions/#robot.api.exceptions.ContinuableFailure","title":"ContinuableFailure","text":"<pre><code>ContinuableFailure(message: str, html: bool = False)\n</code></pre> <p>               Bases: <code>Failure</code></p> <p>Report failed validation but allow continuing execution.</p> <p>:param message: Exception message. :param html: When <code>True</code>, message is considered to be HTML and not escaped.</p> Source code in <code>src/robot/api/exceptions.py</code> <pre><code>def __init__(self, message: str, html: bool = False):\n    \"\"\"\n    :param message: Exception message.\n    :param html: When ``True``, message is considered to be HTML and not escaped.\n    \"\"\"\n    super().__init__(message if not html else '*HTML* ' + message)\n</code></pre>"},{"location":"api/robot/api/exceptions/#robot.api.exceptions.Error","title":"Error","text":"<pre><code>Error(message: str, html: bool = False)\n</code></pre> <p>               Bases: <code>RuntimeError</code></p> <p>Report error in execution.</p> <p>Failures related to the system not behaving as expected should typically be reported using the :class:<code>Failure</code> exception or the standard <code>AssertionError</code>. This exception can be used, for example, if the keyword is used incorrectly.</p> <p>There is no practical difference in using this exception compared to using the standard <code>RuntimeError</code>. The main benefits are HTML support and that the name of this exception is consistent with other exceptions in this module.</p> <p>:param message: Exception message. :param html: When <code>True</code>, message is considered to be HTML and not escaped.</p> Source code in <code>src/robot/api/exceptions.py</code> <pre><code>def __init__(self, message: str, html: bool = False):\n    \"\"\"\n    :param message: Exception message.\n    :param html: When ``True``, message is considered to be HTML and not escaped.\n    \"\"\"\n    super().__init__(message if not html else '*HTML* ' + message)\n</code></pre>"},{"location":"api/robot/api/exceptions/#robot.api.exceptions.FatalError","title":"FatalError","text":"<pre><code>FatalError(message: str, html: bool = False)\n</code></pre> <p>               Bases: <code>Error</code></p> <p>Report error that stops the whole execution.</p> <p>:param message: Exception message. :param html: When <code>True</code>, message is considered to be HTML and not escaped.</p> Source code in <code>src/robot/api/exceptions.py</code> <pre><code>def __init__(self, message: str, html: bool = False):\n    \"\"\"\n    :param message: Exception message.\n    :param html: When ``True``, message is considered to be HTML and not escaped.\n    \"\"\"\n    super().__init__(message if not html else '*HTML* ' + message)\n</code></pre>"},{"location":"api/robot/api/exceptions/#robot.api.exceptions.SkipExecution","title":"SkipExecution","text":"<pre><code>SkipExecution(message: str, html: bool = False)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Mark the executed test or task skipped.</p> <p>:param message: Exception message. :param html: When <code>True</code>, message is considered to be HTML and not escaped.</p> Source code in <code>src/robot/api/exceptions.py</code> <pre><code>def __init__(self, message: str, html: bool = False):\n    \"\"\"\n    :param message: Exception message.\n    :param html: When ``True``, message is considered to be HTML and not escaped.\n    \"\"\"\n    super().__init__(message if not html else '*HTML* ' + message)\n</code></pre>"},{"location":"api/robot/api/interfaces/","title":"robot.api.interfaces","text":""},{"location":"api/robot/api/interfaces/#robot.api.interfaces","title":"robot.api.interfaces","text":"<p>Optional base classes for libraries and other extensions.</p> <p>Module contents:</p> <ul> <li>:class:<code>DynamicLibrary</code> for libraries using the <code>dynamic library API</code>__.</li> <li>:class:<code>HybridLibrary</code> for libraries using the <code>hybrid library API</code>__.</li> <li>:class:<code>ListenerV2</code> for <code>listener interface version 2</code>__.</li> <li>:class:<code>ListenerV3</code> for <code>listener interface version 3</code>__.</li> <li>:class:<code>Parser</code> for <code>custom parsers</code>__. Also   :class:<code>~robot.running.builder.settings.TestDefaults</code> used in <code>Parser</code>   type hints can be imported via this module if needed.</li> <li>Type definitions used by the aforementioned classes.</li> </ul> <p>Main benefit of using these base classes is that editors can provide automatic completion, documentation and type information. Their usage is not required. Notice also that libraries typically use the static API and do not need any base class.</p> <p>.. note:: These classes are not exposed via the top level :mod:<code>robot.api</code>           package and need to imported via :mod:<code>robot.api.interfaces</code>.</p> <p>This module is new in Robot Framework 6.1.</p> <p>__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#dynamic-library-api __ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#hybrid-library-api __ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-version-2 __ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-version-3 __ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#parser-interface</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary","title":"DynamicLibrary","text":"<p>               Bases: <code>ABC</code></p> <p>Optional base class for libraries using the dynamic library API.</p> <p>The dynamic library API makes it possible to dynamically specify what keywords a library implements and run them by using :meth:<code>get_keyword_names</code> and :meth:<code>run_keyword</code> methods, respectively. In addition to that it has various optional methods for returning more information about the implemented keywords to Robot Framework.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_names","title":"get_keyword_names  <code>abstractmethod</code>","text":"<pre><code>get_keyword_names() -&gt; Sequence[Name]\n</code></pre> <p>Return names of the keywords this library implements.</p> <p>:return: Keyword names as a list of strings.</p> <p><code>name</code> passed to other methods is always in the same format as returned by this method.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>@abstractmethod\ndef get_keyword_names(self) -&gt; Sequence[Name]:\n    \"\"\"Return names of the keywords this library implements.\n\n    :return: Keyword names as a list of strings.\n\n    ``name`` passed to other methods is always in the same format as\n    returned by this method.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.run_keyword","title":"run_keyword  <code>abstractmethod</code>","text":"<pre><code>run_keyword(\n    name: Name, args: PositArgs, named: NamedArgs\n) -&gt; Any\n</code></pre> <p>Execute the specified keyword using the given arguments.</p> <p>:param name: Keyword name as a string. :param args: Positional arguments as a list. :param named: Named arguments as a dictionary. :raises: Reporting FAIL or SKIP status. :return: Keyword's return value.</p> <p>Reporting status, logging, returning values, etc. is handled the same way as with the normal static library API.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>@abstractmethod\ndef run_keyword(self, name: Name, args: PositArgs, named: NamedArgs) -&gt; Any:\n    \"\"\"Execute the specified keyword using the given arguments.\n\n    :param name: Keyword name as a string.\n    :param args: Positional arguments as a list.\n    :param named: Named arguments as a dictionary.\n    :raises: Reporting FAIL or SKIP status.\n    :return: Keyword's return value.\n\n    Reporting status, logging, returning values, etc. is handled the same\n    way as with the normal static library API.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_documentation","title":"get_keyword_documentation","text":"<pre><code>get_keyword_documentation(\n    name: Name,\n) -&gt; Documentation | None\n</code></pre> <p>Optional method to return keyword documentation.</p> <p>The first logical line of keyword documentation is shown in the execution log under the executed keyword. The whole documentation is shown in documentation generated by Libdoc.</p> <p>:param name: Keyword name as a string. :return: Documentation as a string oras <code>None</code> if there is no     documentation.</p> <p>This method is also used to get the overall library documentation as well as documentation related to importing the library. They are got by calling this method with special names <code>__intro__</code> and <code>__init__</code>, respectively.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def get_keyword_documentation(self, name: Name) -&gt; 'Documentation | None':\n    \"\"\"Optional method to return keyword documentation.\n\n    The first logical line of keyword documentation is shown in\n    the execution log under the executed keyword. The whole\n    documentation is shown in documentation generated by Libdoc.\n\n    :param name: Keyword name as a string.\n    :return: Documentation as a string oras ``None`` if there is no\n        documentation.\n\n    This method is also used to get the overall library documentation as\n    well as documentation related to importing the library. They are\n    got by calling this method with special names ``__intro__`` and\n    ``__init__``, respectively.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_arguments","title":"get_keyword_arguments","text":"<pre><code>get_keyword_arguments(name: Name) -&gt; Arguments | None\n</code></pre> <p>Optional method to return keyword's argument specification.</p> <p>Returned information is used during execution for argument validation. In addition to that, arguments are shown in documentation generated by Libdoc.</p> <p>:param name: Keyword name as a string. :return: Argument specification using format explained below.</p> <p>Argument specification defines what arguments the keyword accepts. Returning <code>None</code> means that the keywords accepts any arguments. Accepted arguments are returned as a list using these rules:</p> <ul> <li>Normal arguments are specified as a list of strings like   <code>['arg1', 'arg2']</code>. An empty list denotes that the keyword   accepts no arguments.</li> <li>Varargs must have a <code>*</code> prefix like <code>['*numbers']</code>. There can   be only one varargs, and it must follow normal arguments.</li> <li>Arguments after varargs like <code>['*items', 'arg']</code> are considered   named-only arguments.</li> <li>If keyword does not accept varargs, a lone <code>*</code> can be used   a separator between normal and named-only arguments like   <code>['normal', '*', 'named']</code>.</li> <li>Kwargs must have a <code>**</code>  prefix like <code>['**config']</code>. There can   be only one kwargs, and it must be last.</li> </ul> <p>Both normal arguments and named-only arguments can have default values:</p> <ul> <li>Default values can be embedded to argument names so that they are   separated with the equal sign like <code>name=default</code>. In this case   the default value type is always a string.</li> <li>Alternatively arguments and their default values can be represented   as two-tuples like <code>('name', 'default')</code>. This allows non-string   default values and automatic argument conversion based on them.</li> <li>Arguments without default values can also be specified as tuples   containing just the name like <code>('name',)</code>.</li> <li>With normal arguments, arguments with default values must follow   arguments without them. There is no such restriction with named-only   arguments.</li> </ul> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def get_keyword_arguments(self, name: Name) -&gt; 'Arguments | None':\n    \"\"\"Optional method to return keyword's argument specification.\n\n    Returned information is used during execution for argument validation.\n    In addition to that, arguments are shown in documentation generated\n    by Libdoc.\n\n    :param name: Keyword name as a string.\n    :return: Argument specification using format explained below.\n\n    Argument specification defines what arguments the keyword accepts.\n    Returning ``None`` means that the keywords accepts any arguments.\n    Accepted arguments are returned as a list using these rules:\n\n    - Normal arguments are specified as a list of strings like\n      ``['arg1', 'arg2']``. An empty list denotes that the keyword\n      accepts no arguments.\n    - Varargs must have a ``*`` prefix like ``['*numbers']``. There can\n      be only one varargs, and it must follow normal arguments.\n    - Arguments after varargs like ``['*items', 'arg']`` are considered\n      named-only arguments.\n    - If keyword does not accept varargs, a lone ``*`` can be used\n      a separator between normal and named-only arguments like\n      ``['normal', '*', 'named']``.\n    - Kwargs must have a ``**``  prefix like ``['**config']``. There can\n      be only one kwargs, and it must be last.\n\n    Both normal arguments and named-only arguments can have default values:\n\n    - Default values can be embedded to argument names so that they are\n      separated with the equal sign like ``name=default``. In this case\n      the default value type is always a string.\n    - Alternatively arguments and their default values can be represented\n      as two-tuples like ``('name', 'default')``. This allows non-string\n      default values and automatic argument conversion based on them.\n    - Arguments without default values can also be specified as tuples\n      containing just the name like ``('name',)``.\n    - With normal arguments, arguments with default values must follow\n      arguments without them. There is no such restriction with named-only\n      arguments.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_types","title":"get_keyword_types","text":"<pre><code>get_keyword_types(name: Name) -&gt; TypeHints | None\n</code></pre> <p>Optional method to return keyword's type specification.</p> <p>Type information is used for automatic argument conversion during execution. It is also shown in documentation generated by Libdoc.</p> <p>:param name: Keyword name as a string. :return: Type specification as a dictionary, as a list, or as <code>None</code>     if type information is not known.</p> <p>Type information can be mapped to arguments returned by :meth:<code>get_keyword_names</code> either by names using a dictionary or by position using a list. For example, if a keyword has argument specification <code>['arg', 'second']</code>, it would be possible to return types both like <code>{'arg': str, 'second': int}</code> and <code>[str, int]</code>.</p> <p>Regardless of the approach that is used, it is not necessarily to specify types for all arguments. When using a dictionary, some arguments can be omitted altogether. When using a list, it is possible to use <code>None</code> to mark that a certain argument does not have type information and arguments at the end can be omitted altogether.</p> <p>If is possible to specify that an argument has multiple possible types by using unions like <code>{'arg': Union[int, float]}</code> or tuples like <code>{'arg': (int, float)}</code>.</p> <p>In addition to specifying types using classes, it is also possible to use names or aliases like <code>{'a': 'int', 'b': 'boolean'}</code>. For an up-to-date list of supported types, names and aliases see the User Guide.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def get_keyword_types(self, name: Name) -&gt; 'TypeHints | None':\n    \"\"\"Optional method to return keyword's type specification.\n\n    Type information is used for automatic argument conversion during\n    execution. It is also shown in documentation generated by Libdoc.\n\n    :param name: Keyword name as a string.\n    :return: Type specification as a dictionary, as a list, or as ``None``\n        if type information is not known.\n\n    Type information can be mapped to arguments returned by\n    :meth:`get_keyword_names` either by names using a dictionary or\n    by position using a list. For example, if a keyword has argument\n    specification ``['arg', 'second']``, it would be possible to return\n    types both like ``{'arg': str, 'second': int}`` and ``[str, int]``.\n\n    Regardless of the approach that is used, it is not necessarily to\n    specify types for all arguments. When using a dictionary, some\n    arguments can be omitted altogether. When using a list, it is possible\n    to use ``None`` to mark that a certain argument does not have type\n    information and arguments at the end can be omitted altogether.\n\n    If is possible to specify that an argument has multiple possible types\n    by using unions like ``{'arg': Union[int, float]}`` or tuples like\n    ``{'arg': (int, float)}``.\n\n    In addition to specifying types using classes, it is also possible\n    to use names or aliases like ``{'a': 'int', 'b': 'boolean'}``.\n    For an up-to-date list of supported types, names and aliases see\n    the User Guide.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_tags","title":"get_keyword_tags","text":"<pre><code>get_keyword_tags(name: Name) -&gt; Tags | None\n</code></pre> <p>Optional method to return keyword's tags.</p> <p>Tags are shown in the execution log and in documentation generated by Libdoc. Tags can also be used with various command line options.</p> <p>:param name: Keyword name as a string. :return: Tags as a list of strings or <code>None</code> if there are no tags.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def get_keyword_tags(self, name: Name) -&gt; 'Tags | None':\n    \"\"\"Optional method to return keyword's tags.\n\n    Tags are shown in the execution log and in documentation generated by\n    Libdoc. Tags can also be used with various command line options.\n\n    :param name: Keyword name as a string.\n    :return: Tags as a list of strings or ``None`` if there are no tags.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_source","title":"get_keyword_source","text":"<pre><code>get_keyword_source(name: Name) -&gt; Source | None\n</code></pre> <p>Optional method to return keyword's source path and line number.</p> <p>Source information is used by IDEs to provide navigation from keyword usage to implementation.</p> <p>:param name: Keyword name as a string. :return: Source as a string in format <code>path:lineno</code> or <code>None</code>     if source is not known.</p> <p>The general format to return the source is <code>path:lineno</code> like <code>/example/Lib.py:42</code>. If the line number is not known, it is possible to return only the path. If the keyword is in the same file as the main library class, the path can be omitted and only the line number returned like <code>:42</code>.</p> <p>The source information of the library itself is got automatically from the imported library class. The library source path is used with all keywords that do not return their own path.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def get_keyword_source(self, name: Name) -&gt; 'Source | None':\n    \"\"\"Optional method to return keyword's source path and line number.\n\n    Source information is used by IDEs to provide navigation from\n    keyword usage to implementation.\n\n    :param name: Keyword name as a string.\n    :return: Source as a string in format ``path:lineno`` or ``None``\n        if source is not known.\n\n    The general format to return the source is ``path:lineno`` like\n    ``/example/Lib.py:42``. If the line number is not known, it is\n    possible to return only the path. If the keyword is in the same\n    file as the main library class, the path can be omitted and only\n    the line number returned like ``:42``.\n\n    The source information of the library itself is got automatically from\n    the imported library class. The library source path is used with all\n    keywords that do not return their own path.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.HybridLibrary","title":"HybridLibrary","text":"<p>               Bases: <code>ABC</code></p> <p>Optional base class for libraries using the hybrid library API.</p> <p>Hybrid library API makes it easy to specify what keywords a library implements by using the :meth:<code>get_keyword_names</code> method. After getting keyword names, Robot Framework uses <code>getattr</code> to get the actual keyword methods exactly like it does when using the normal static library API. Keyword name, arguments, documentation, tags, and so on are got directly from the keyword method.</p> <p>It is possible to implement keywords also outside the main library class. In such cases the library needs to have a <code>__getattr__</code> method that returns desired keyword methods.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.HybridLibrary.get_keyword_names","title":"get_keyword_names  <code>abstractmethod</code>","text":"<pre><code>get_keyword_names() -&gt; Sequence[Name]\n</code></pre> <p>Return names of the implemented keyword methods as a list or strings.</p> <p>Returned names must match names of the implemented keyword methods.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>@abstractmethod\ndef get_keyword_names(self) -&gt; Sequence[Name]:\n    \"\"\"Return names of the implemented keyword methods as a list or strings.\n\n    Returned names must match names of the implemented keyword methods.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.StartSuiteAttributes","title":"StartSuiteAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>start_suite</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.EndSuiteAttributes","title":"EndSuiteAttributes","text":"<p>               Bases: <code>StartSuiteAttributes</code></p> <p>Attributes passed to listener v2 <code>end_suite</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.StartTestAttributes","title":"StartTestAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>start_test</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.EndTestAttributes","title":"EndTestAttributes","text":"<p>               Bases: <code>StartTestAttributes</code></p> <p>Attributes passed to listener v2 <code>end_test</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.OptionalKeywordAttributes","title":"OptionalKeywordAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Extra attributes passed to listener v2 <code>start/end_keyword</code> methods.</p> <p>These attributes are included with control structures. For example, with IF structures attributes include <code>condition</code>.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.StartKeywordAttributes","title":"StartKeywordAttributes","text":"<p>               Bases: <code>OptionalKeywordAttributes</code></p> <p>Attributes passed to listener v2 <code>start_keyword</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.EndKeywordAttributes","title":"EndKeywordAttributes","text":"<p>               Bases: <code>StartKeywordAttributes</code></p> <p>Attributes passed to listener v2 <code>end_keyword</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.MessageAttributes","title":"MessageAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>log_message</code> and <code>messages</code> methods.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.LibraryAttributes","title":"LibraryAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>library_import</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ResourceAttributes","title":"ResourceAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>resource_import</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.VariablesAttributes","title":"VariablesAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>variables_import</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2","title":"ListenerV2","text":"<p>Optional base class for listeners using the listener API version 2.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.start_suite","title":"start_suite","text":"<pre><code>start_suite(name: str, attributes: StartSuiteAttributes)\n</code></pre> <p>Called when a suite starts.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_suite(self, name: str, attributes: StartSuiteAttributes):\n    \"\"\"Called when a suite starts.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.end_suite","title":"end_suite","text":"<pre><code>end_suite(name: str, attributes: EndSuiteAttributes)\n</code></pre> <p>Called when a suite end.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_suite(self, name: str, attributes: EndSuiteAttributes):\n    \"\"\"Called when a suite end.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.start_test","title":"start_test","text":"<pre><code>start_test(name: str, attributes: StartTestAttributes)\n</code></pre> <p>Called when a test or task starts.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_test(self, name: str, attributes: StartTestAttributes):\n    \"\"\"Called when a test or task starts.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.end_test","title":"end_test","text":"<pre><code>end_test(name: str, attributes: EndTestAttributes)\n</code></pre> <p>Called when a test or task ends.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_test(self, name: str, attributes: EndTestAttributes):\n    \"\"\"Called when a test or task ends.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.start_keyword","title":"start_keyword","text":"<pre><code>start_keyword(\n    name: str, attributes: StartKeywordAttributes\n)\n</code></pre> <p>Called when a keyword or a control structure like IF starts.</p> <p>The type of the started item is in <code>attributes['type']</code>. Control structures can contain extra attributes that are only relevant to them.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_keyword(self, name: str, attributes: StartKeywordAttributes):\n    \"\"\"Called when a keyword or a control structure like IF starts.\n\n    The type of the started item is in ``attributes['type']``. Control\n    structures can contain extra attributes that are only relevant to them.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.end_keyword","title":"end_keyword","text":"<pre><code>end_keyword(name: str, attributes: EndKeywordAttributes)\n</code></pre> <p>Called when a keyword or a control structure like IF ends.</p> <p>The type of the started item is in <code>attributes['type']</code>. Control structures can contain extra attributes that are only relevant to them.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_keyword(self, name: str, attributes: EndKeywordAttributes):\n    \"\"\"Called when a keyword or a control structure like IF ends.\n\n    The type of the started item is in ``attributes['type']``. Control\n    structures can contain extra attributes that are only relevant to them.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.log_message","title":"log_message","text":"<pre><code>log_message(message: MessageAttributes)\n</code></pre> <p>Called when a normal log message are emitted.</p> <p>The messages are typically logged by keywords, but also the framework itself logs some messages. These messages end up to output.xml and log.html.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def log_message(self, message: MessageAttributes):\n    \"\"\"Called when a normal log message are emitted.\n\n    The messages are typically logged by keywords, but also the framework\n    itself logs some messages. These messages end up to output.xml and\n    log.html.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.message","title":"message","text":"<pre><code>message(message: MessageAttributes)\n</code></pre> <p>Called when framework's internal messages are emitted.</p> <p>Only logged by the framework itself. These messages end up to the syslog if it is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def message(self, message: MessageAttributes):\n    \"\"\"Called when framework's internal messages are emitted.\n\n    Only logged by the framework itself. These messages end up to the syslog\n    if it is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.library_import","title":"library_import","text":"<pre><code>library_import(name: str, attributes: LibraryAttributes)\n</code></pre> <p>Called after a library has been imported.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def library_import(self, name: str, attributes: LibraryAttributes):\n    \"\"\"Called after a library has been imported.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.resource_import","title":"resource_import","text":"<pre><code>resource_import(name: str, attributes: ResourceAttributes)\n</code></pre> <p>Called after a resource file has been imported.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def resource_import(self, name: str, attributes: ResourceAttributes):\n    \"\"\"Called after a resource file has been imported.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.variables_import","title":"variables_import","text":"<pre><code>variables_import(\n    name: str, attributes: VariablesAttributes\n)\n</code></pre> <p>Called after a variable file has been imported.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def variables_import(self, name: str, attributes: VariablesAttributes):\n    \"\"\"Called after a variable file has been imported.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.output_file","title":"output_file","text":"<pre><code>output_file(path: str)\n</code></pre> <p>Called after the output file has been created.</p> <p><code>path</code> is an absolute path to the output file or a string <code>None</code> if creating the output file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def output_file(self, path: str):\n    \"\"\"Called after the output file has been created.\n\n    ``path`` is an absolute path to the output file or\n    a string ``None`` if creating the output file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.log_file","title":"log_file","text":"<pre><code>log_file(path: str)\n</code></pre> <p>Called after the log file has been created.</p> <p><code>path</code> is an absolute path to the log file. Not called if creating the log file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def log_file(self, path: str):\n    \"\"\"Called after the log file has been created.\n\n    ``path`` is an absolute path to the log file.\n    Not called if creating the log file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.report_file","title":"report_file","text":"<pre><code>report_file(path: str)\n</code></pre> <p>Called after the report file has been created.</p> <p><code>path</code> is an absolute path to the report file. Not called if creating the report file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def report_file(self, path: str):\n    \"\"\"Called after the report file has been created.\n\n    ``path`` is an absolute path to the report file.\n    Not called if creating the report file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.xunit_file","title":"xunit_file","text":"<pre><code>xunit_file(path: str)\n</code></pre> <p>Called after the xunit compatible output file has been created.</p> <p><code>path</code> is an absolute path to the xunit file. Only called if creating the xunit file is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def xunit_file(self, path: str):\n    \"\"\"Called after the xunit compatible output file has been created.\n\n    ``path`` is an absolute path to the xunit file.\n    Only called if creating the xunit file is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.debug_file","title":"debug_file","text":"<pre><code>debug_file(path: str)\n</code></pre> <p>Called after the debug file has been created.</p> <p><code>path</code> is an absolute path to the debug file. Only called if creating the debug file is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def debug_file(self, path: str):\n    \"\"\"Called after the debug file has been created.\n\n    ``path`` is an absolute path to the debug file.\n    Only called if creating the debug file is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Called when the whole execution ends.</p> <p>With library listeners called when the library goes out of scope.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def close(self):\n    \"\"\"Called when the whole execution ends.\n\n    With library listeners called when the library goes out of scope.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3","title":"ListenerV3","text":"<p>Optional base class for listeners using the listener API version 3.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_suite","title":"start_suite","text":"<pre><code>start_suite(data: TestSuite, result: TestSuite)\n</code></pre> <p>Called when a suite starts.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_suite(self, data: running.TestSuite, result: result.TestSuite):\n    \"\"\"Called when a suite starts.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_suite","title":"end_suite","text":"<pre><code>end_suite(data: TestSuite, result: TestSuite)\n</code></pre> <p>Called when a suite ends.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_suite(self, data: running.TestSuite, result: result.TestSuite):\n    \"\"\"Called when a suite ends.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_test","title":"start_test","text":"<pre><code>start_test(data: TestCase, result: TestCase)\n</code></pre> <p>Called when a test or task starts.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_test(self, data: running.TestCase, result: result.TestCase):\n    \"\"\"Called when a test or task starts.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_test","title":"end_test","text":"<pre><code>end_test(data: TestCase, result: TestCase)\n</code></pre> <p>Called when a test or tasks ends.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_test(self, data: running.TestCase, result: result.TestCase):\n    \"\"\"Called when a test or tasks ends.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_keyword","title":"start_keyword","text":"<pre><code>start_keyword(data: Keyword, result: Keyword)\n</code></pre> <p>Called when a keyword starts by default.</p> <p>This method is called, by default, with user keywords, library keywords and when a keyword call is invalid. It is not called, however, if a more specific :meth:<code>start_user_keyword</code>, :meth:<code>start_library_keyword</code> or :meth:<code>start_invalid_keyword</code> method is implemented.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_keyword(self, data: running.Keyword, result: result.Keyword):\n    \"\"\"Called when a keyword starts by default.\n\n    This method is called, by default, with user keywords, library keywords\n    and when a keyword call is invalid. It is not called, however, if a more\n    specific :meth:`start_user_keyword`, :meth:`start_library_keyword` or\n    :meth:`start_invalid_keyword` method is implemented.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_keyword","title":"end_keyword","text":"<pre><code>end_keyword(data: Keyword, result: Keyword)\n</code></pre> <p>Called when a keyword ends by default.</p> <p>This method is called, by default, with user keywords, library keywords and when a keyword call is invalid. It is not called, however, if a more specific :meth:<code>end_user_keyword</code>, :meth:<code>end_library_keyword</code> or :meth:<code>end_invalid_keyword</code> method is implemented.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_keyword(self, data: running.Keyword, result: result.Keyword):\n    \"\"\"Called when a keyword ends by default.\n\n    This method is called, by default, with user keywords, library keywords\n    and when a keyword call is invalid. It is not called, however, if a more\n    specific :meth:`end_user_keyword`, :meth:`end_library_keyword` or\n    :meth:`end_invalid_keyword` method is implemented.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_user_keyword","title":"start_user_keyword","text":"<pre><code>start_user_keyword(\n    data: Keyword,\n    implementation: UserKeyword,\n    result: Keyword,\n)\n</code></pre> <p>Called when a user keyword starts.</p> <p>The default implementation calls :meth:<code>start_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_user_keyword(self, data: running.Keyword,\n                       implementation: running.UserKeyword,\n                       result: result.Keyword):\n    \"\"\"Called when a user keyword starts.\n\n    The default implementation calls :meth:`start_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_user_keyword","title":"end_user_keyword","text":"<pre><code>end_user_keyword(\n    data: Keyword,\n    implementation: UserKeyword,\n    result: Keyword,\n)\n</code></pre> <p>Called when a user keyword ends.</p> <p>The default implementation calls :meth:<code>end_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_user_keyword(self, data: running.Keyword,\n                     implementation: running.UserKeyword,\n                     result: result.Keyword):\n    \"\"\"Called when a user keyword ends.\n\n    The default implementation calls :meth:`end_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_library_keyword","title":"start_library_keyword","text":"<pre><code>start_library_keyword(\n    data: Keyword,\n    implementation: LibraryKeyword,\n    result: Keyword,\n)\n</code></pre> <p>Called when a library keyword starts.</p> <p>The default implementation calls :meth:<code>start_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_library_keyword(self, data: running.Keyword,\n                          implementation: running.LibraryKeyword,\n                          result: result.Keyword):\n    \"\"\"Called when a library keyword starts.\n\n    The default implementation calls :meth:`start_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_library_keyword","title":"end_library_keyword","text":"<pre><code>end_library_keyword(\n    data: Keyword,\n    implementation: LibraryKeyword,\n    result: Keyword,\n)\n</code></pre> <p>Called when a library keyword ends.</p> <p>The default implementation calls :meth:<code>start_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_library_keyword(self, data: running.Keyword,\n                        implementation: running.LibraryKeyword,\n                        result: result.Keyword):\n    \"\"\"Called when a library keyword ends.\n\n    The default implementation calls :meth:`start_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_invalid_keyword","title":"start_invalid_keyword","text":"<pre><code>start_invalid_keyword(\n    data: Keyword,\n    implementation: KeywordImplementation,\n    result: Keyword,\n)\n</code></pre> <p>Called when an invalid keyword call starts.</p> <p>Keyword may not have been found, there could have been multiple matches, or the keyword call itself could have been invalid.</p> <p>The default implementation calls :meth:<code>start_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_invalid_keyword(self, data: running.Keyword,\n                          implementation: running.KeywordImplementation,\n                          result: result.Keyword):\n    \"\"\"Called when an invalid keyword call starts.\n\n    Keyword may not have been found, there could have been multiple matches,\n    or the keyword call itself could have been invalid.\n\n    The default implementation calls :meth:`start_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_invalid_keyword","title":"end_invalid_keyword","text":"<pre><code>end_invalid_keyword(\n    data: Keyword,\n    implementation: KeywordImplementation,\n    result: Keyword,\n)\n</code></pre> <p>Called when an invalid keyword call ends.</p> <p>Keyword may not have been found, there could have been multiple matches, or the keyword call itself could have been invalid.</p> <p>The default implementation calls :meth:<code>end_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_invalid_keyword(self, data: running.Keyword,\n                        implementation: running.KeywordImplementation,\n                        result: result.Keyword):\n    \"\"\"Called when an invalid keyword call ends.\n\n    Keyword may not have been found, there could have been multiple matches,\n    or the keyword call itself could have been invalid.\n\n    The default implementation calls :meth:`end_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_for","title":"start_for","text":"<pre><code>start_for(data: For, result: For)\n</code></pre> <p>Called when a FOR loop starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_for(self, data: running.For, result: result.For):\n    \"\"\"Called when a FOR loop starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_for","title":"end_for","text":"<pre><code>end_for(data: For, result: For)\n</code></pre> <p>Called when a FOR loop ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_for(self, data: running.For, result: result.For):\n    \"\"\"Called when a FOR loop ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_for_iteration","title":"start_for_iteration","text":"<pre><code>start_for_iteration(\n    data: ForIteration, result: ForIteration\n)\n</code></pre> <p>Called when a FOR loop iteration starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_for_iteration(self, data: running.ForIteration,\n                        result: result.ForIteration):\n    \"\"\"Called when a FOR loop iteration starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_for_iteration","title":"end_for_iteration","text":"<pre><code>end_for_iteration(data: ForIteration, result: ForIteration)\n</code></pre> <p>Called when a FOR loop iteration ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_for_iteration(self, data: running.ForIteration,\n                      result: result.ForIteration):\n    \"\"\"Called when a FOR loop iteration ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_while","title":"start_while","text":"<pre><code>start_while(data: While, result: While)\n</code></pre> <p>Called when a WHILE loop starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_while(self, data: running.While, result: result.While):\n    \"\"\"Called when a WHILE loop starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_while","title":"end_while","text":"<pre><code>end_while(data: While, result: While)\n</code></pre> <p>Called when a WHILE loop ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_while(self, data: running.While, result: result.While):\n    \"\"\"Called when a WHILE loop ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_while_iteration","title":"start_while_iteration","text":"<pre><code>start_while_iteration(\n    data: WhileIteration, result: WhileIteration\n)\n</code></pre> <p>Called when a WHILE loop iteration starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_while_iteration(self, data: running.WhileIteration,\n                          result: result.WhileIteration):\n    \"\"\"Called when a WHILE loop iteration starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_while_iteration","title":"end_while_iteration","text":"<pre><code>end_while_iteration(\n    data: WhileIteration, result: WhileIteration\n)\n</code></pre> <p>Called when a WHILE loop iteration ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_while_iteration(self, data: running.WhileIteration,\n                        result: result.WhileIteration):\n    \"\"\"Called when a WHILE loop iteration ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_if","title":"start_if","text":"<pre><code>start_if(data: If, result: If)\n</code></pre> <p>Called when an IF/ELSE structure starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_if(self, data: running.If, result: result.If):\n    \"\"\"Called when an IF/ELSE structure starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_if","title":"end_if","text":"<pre><code>end_if(data: If, result: If)\n</code></pre> <p>Called when an IF/ELSE structure ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_if(self, data: running.If, result: result.If):\n    \"\"\"Called when an IF/ELSE structure ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_if_branch","title":"start_if_branch","text":"<pre><code>start_if_branch(data: IfBranch, result: IfBranch)\n</code></pre> <p>Called when an individual IF/ELSE branch starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_if_branch(self, data: running.IfBranch, result: result.IfBranch):\n    \"\"\"Called when an individual IF/ELSE branch starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_if_branch","title":"end_if_branch","text":"<pre><code>end_if_branch(data: IfBranch, result: IfBranch)\n</code></pre> <p>Called when an individual IF/ELSE branch ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_if_branch(self, data: running.IfBranch, result: result.IfBranch):\n    \"\"\"Called when an individual IF/ELSE branch ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_try","title":"start_try","text":"<pre><code>start_try(data: Try, result: Try)\n</code></pre> <p>Called when a TRY/EXCEPT structure starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_try(self, data: running.Try, result: result.Try):\n    \"\"\"Called when a TRY/EXCEPT structure starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_try","title":"end_try","text":"<pre><code>end_try(data: Try, result: Try)\n</code></pre> <p>Called when a TRY/EXCEPT structure ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_try(self, data: running.Try, result: result.Try):\n    \"\"\"Called when a TRY/EXCEPT structure ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_try_branch","title":"start_try_branch","text":"<pre><code>start_try_branch(data: TryBranch, result: TryBranch)\n</code></pre> <p>Called when an individual TRY/EXCEPT branch starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_try_branch(self, data: running.TryBranch, result: result.TryBranch):\n    \"\"\"Called when an individual TRY/EXCEPT branch starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_try_branch","title":"end_try_branch","text":"<pre><code>end_try_branch(data: TryBranch, result: TryBranch)\n</code></pre> <p>Called when an individual TRY/EXCEPT branch ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_try_branch(self, data: running.TryBranch, result: result.TryBranch):\n    \"\"\"Called when an individual TRY/EXCEPT branch ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_var","title":"start_var","text":"<pre><code>start_var(data: Var, result: Var)\n</code></pre> <p>Called when VAR starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_var(self, data: running.Var, result: result.Var):\n    \"\"\"Called when VAR starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_var","title":"end_var","text":"<pre><code>end_var(data: Var, result: Var)\n</code></pre> <p>Called when VAR ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_var(self, data: running.Var, result: result.Var):\n    \"\"\"Called when VAR ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_break","title":"start_break","text":"<pre><code>start_break(data: Break, result: Break)\n</code></pre> <p>Called when BREAK starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_break(self, data: running.Break, result: result.Break):\n    \"\"\"Called when BREAK starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_break","title":"end_break","text":"<pre><code>end_break(data: Break, result: Break)\n</code></pre> <p>Called when BREAK ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_break(self, data: running.Break, result: result.Break):\n    \"\"\"Called when BREAK ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_continue","title":"start_continue","text":"<pre><code>start_continue(data: Continue, result: Continue)\n</code></pre> <p>Called when CONTINUE starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_continue(self, data: running.Continue, result: result.Continue):\n    \"\"\"Called when CONTINUE starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_continue","title":"end_continue","text":"<pre><code>end_continue(data: Continue, result: Continue)\n</code></pre> <p>Called when CONTINUE ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_continue(self, data: running.Continue, result: result.Continue):\n    \"\"\"Called when CONTINUE ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_return","title":"start_return","text":"<pre><code>start_return(data: Return, result: Return)\n</code></pre> <p>Called when RETURN starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_return(self, data: running.Return, result: result.Return):\n    \"\"\"Called when RETURN starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_return","title":"end_return","text":"<pre><code>end_return(data: Return, result: Return)\n</code></pre> <p>Called when RETURN ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_return(self, data: running.Return, result: result.Return):\n    \"\"\"Called when RETURN ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_error","title":"start_error","text":"<pre><code>start_error(data: Error, result: Error)\n</code></pre> <p>Called when encountered invalid syntax starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_error(self, data: running.Error, result: result.Error):\n    \"\"\"Called when encountered invalid syntax starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_error","title":"end_error","text":"<pre><code>end_error(data: Error, result: Error)\n</code></pre> <p>Called when encountered invalid syntax ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_error(self, data: running.Error, result: result.Error):\n    \"\"\"Called when encountered invalid syntax ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_body_item","title":"start_body_item","text":"<pre><code>start_body_item(data, result)\n</code></pre> <p>Called by default when a keyword or a control structure starts.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_body_item(self, data, result):\n    \"\"\"Called by default when a keyword or a control structure starts.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_body_item","title":"end_body_item","text":"<pre><code>end_body_item(data, result)\n</code></pre> <p>Called by default when a keyword or a control structure ends.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_body_item(self, data, result):\n    \"\"\"Called by default when a keyword or a control structure ends.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.log_message","title":"log_message","text":"<pre><code>log_message(message: Message)\n</code></pre> <p>Called when a normal log message are emitted.</p> <p>The messages are typically logged by keywords, but also the framework itself logs some messages. These messages end up to output.xml and log.html.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def log_message(self, message: Message):\n    \"\"\"Called when a normal log message are emitted.\n\n    The messages are typically logged by keywords, but also the framework\n    itself logs some messages. These messages end up to output.xml and\n    log.html.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.message","title":"message","text":"<pre><code>message(message: Message)\n</code></pre> <p>Called when framework's internal messages are emitted.</p> <p>Only logged by the framework itself. These messages end up to the syslog if it is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def message(self, message: Message):\n    \"\"\"Called when framework's internal messages are emitted.\n\n    Only logged by the framework itself. These messages end up to the syslog\n    if it is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.library_import","title":"library_import","text":"<pre><code>library_import(library: TestLibrary, importer: Import)\n</code></pre> <p>Called after a library has been imported.</p> <p><code>library</code> represents the imported library. It can be inspected and also modified. <code>importer</code> contains information about the location where the library was imported.</p> <p>New in Robot Framework 7.1.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def library_import(self, library: running.TestLibrary, importer: running.Import):\n    \"\"\"Called after a library has been imported.\n\n    ``library`` represents the imported library. It can be inspected and\n    also modified. ``importer`` contains information about the location where\n    the library was imported.\n\n    New in Robot Framework 7.1.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.resource_import","title":"resource_import","text":"<pre><code>resource_import(resource: ResourceFile, importer: Import)\n</code></pre> <p>Called after a resource file has been imported.</p> <p><code>resource</code> represents the imported resource file. It can be inspected and also modified. <code>importer</code> contains information about the location where the resource was imported.</p> <p>New in Robot Framework 7.1.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def resource_import(self, resource: running.ResourceFile, importer: running.Import):\n    \"\"\"Called after a resource file has been imported.\n\n    ``resource`` represents the imported resource file. It can be inspected and\n    also modified. ``importer`` contains information about the location where\n    the resource was imported.\n\n    New in Robot Framework 7.1.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.variables_import","title":"variables_import","text":"<pre><code>variables_import(attrs: dict, importer: Import)\n</code></pre> <p>Called after a variable file has been imported.</p> <p><code>attrs</code> contains information about the imported variable file. It can be inspected, but modifications to it have no effect. `importer`` contains information about the location where the variable file was imported.</p> <p>New in Robot Framework 7.1. This method will be changed in the future so that the <code>attrs</code> dictionary is replaced with an object representing the imported variable file.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def variables_import(self, attrs: dict, importer: running.Import):\n    \"\"\"Called after a variable file has been imported.\n\n    ``attrs`` contains information about the imported variable file. It can be\n    inspected, but modifications to it have no effect. `importer`` contains\n    information about the location where the variable file was imported.\n\n    New in Robot Framework 7.1. This method will be changed in the future\n    so that the ``attrs`` dictionary is replaced with an object representing\n    the imported variable file.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.output_file","title":"output_file","text":"<pre><code>output_file(path: Path | None)\n</code></pre> <p>Called after the output file has been created.</p> <p><code>path</code> is an absolute path to the output file or <code>None</code> if creating the output file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def output_file(self, path: 'Path | None'):\n    \"\"\"Called after the output file has been created.\n\n    ``path`` is an absolute path to the output file or\n    ``None`` if creating the output file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.log_file","title":"log_file","text":"<pre><code>log_file(path: Path)\n</code></pre> <p>Called after the log file has been created.</p> <p><code>path</code> is an absolute path to the log file. Not called if creating the log file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def log_file(self, path: Path):\n    \"\"\"Called after the log file has been created.\n\n    ``path`` is an absolute path to the log file.\n    Not called if creating the log file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.report_file","title":"report_file","text":"<pre><code>report_file(path: Path)\n</code></pre> <p>Called after the report file has been created.</p> <p><code>path</code> is an absolute path to the report file. Not called if creating the report file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def report_file(self, path: Path):\n    \"\"\"Called after the report file has been created.\n\n    ``path`` is an absolute path to the report file.\n    Not called if creating the report file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.xunit_file","title":"xunit_file","text":"<pre><code>xunit_file(path: Path)\n</code></pre> <p>Called after the xunit compatible output file has been created.</p> <p><code>path</code> is an absolute path to the xunit file. Only called if creating the xunit file is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def xunit_file(self, path: Path):\n    \"\"\"Called after the xunit compatible output file has been created.\n\n    ``path`` is an absolute path to the xunit file.\n    Only called if creating the xunit file is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.debug_file","title":"debug_file","text":"<pre><code>debug_file(path: Path)\n</code></pre> <p>Called after the debug file has been created.</p> <p><code>path</code> is an absolute path to the debug file. Only called if creating the debug file is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def debug_file(self, path: Path):\n    \"\"\"Called after the debug file has been created.\n\n    ``path`` is an absolute path to the debug file.\n    Only called if creating the debug file is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Called when the whole execution ends.</p> <p>With library listeners called when the library goes out of scope.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def close(self):\n    \"\"\"Called when the whole execution ends.\n\n    With library listeners called when the library goes out of scope.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.Parser","title":"Parser","text":"<p>               Bases: <code>ABC</code></p> <p>Optional base class for custom parsers.</p> <p>Parsers do not need to explicitly extend this class and in simple cases it is possible to implement them as modules. Regardless how a parser is implemented, it must have :attr:<code>extension</code> attribute and :meth:<code>parse</code> method. The :meth:<code>parse_init</code> method is optional and only needed if a parser supports parsing suite initialization files.</p> <p>The mandatory :attr:<code>extension</code> attribute specifies what file extension or extensions a parser supports. It can be set either as a class or instance attribute, and it can be either a string or a sequence of strings. The attribute can also be named <code>EXTENSION</code>, which typically works better when a parser is implemented as a module.</p> <p>Example::</p> <pre><code>from pathlib import Path\nfrom robot.api import TestSuite\nfrom robot.api.interfaces import Parser, TestDefaults\n\n\nclass ExampleParser(Parser):\n    extension = '.example'\n\n    def parse(self, source: Path, defaults: TestDefaults) -&gt; TestSuite:\n        suite = TestSuite(TestSuite.name_from_source(source), source=source)\n        # parse the source file and add tests to the created suite\n        return suite\n</code></pre> <p>The support for custom parsers is new in Robot Framework 6.1.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.Parser.parse","title":"parse  <code>abstractmethod</code>","text":"<pre><code>parse(source: Path, defaults: TestDefaults) -&gt; TestSuite\n</code></pre> <p>Mandatory method for parsing suite files.</p> <p>:param source: Path to the file to parse. :param defaults: Default values set for test in init files.</p> <p>The <code>defaults</code> argument is optional. It is possible to implement this method also so that it accepts only <code>source</code>.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>@abstractmethod\ndef parse(self, source: Path, defaults: TestDefaults) -&gt; TestSuite:\n    \"\"\"Mandatory method for parsing suite files.\n\n    :param source: Path to the file to parse.\n    :param defaults: Default values set for test in init files.\n\n    The ``defaults`` argument is optional. It is possible to implement\n    this method also so that it accepts only ``source``.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.Parser.parse_init","title":"parse_init","text":"<pre><code>parse_init(\n    source: Path, defaults: TestDefaults\n) -&gt; TestSuite\n</code></pre> <p>Optional method for parsing suite initialization files.</p> <p>:param source: Path to the file to parse. :param defaults: Default values to used with tests in child suites.</p> <p>The <code>defaults</code> argument is optional. It is possible to implement this method also so that it accepts only <code>source</code>.</p> <p>If this method is not implemented, possible initialization files cause an error.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def parse_init(self, source: Path, defaults: TestDefaults) -&gt; TestSuite:\n    \"\"\"Optional method for parsing suite initialization files.\n\n    :param source: Path to the file to parse.\n    :param defaults: Default values to used with tests in child suites.\n\n    The ``defaults`` argument is optional. It is possible to implement\n    this method also so that it accepts only ``source``.\n\n    If this method is not implemented, possible initialization files cause\n    an error.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/api/logger/","title":"robot.api.logger","text":""},{"location":"api/robot/api/logger/#robot.api.logger","title":"robot.api.logger","text":"<p>Public logging API for test libraries.</p> <p>This module provides a public API for writing messages to the log file and the console. Test libraries can use this API like::</p> <pre><code>logger.info('My message')\n</code></pre> <p>instead of logging through the standard output like::</p> <pre><code>print('*INFO* My message')\n</code></pre> <p>In addition to a programmatic interface being cleaner to use, this API has a benefit that the log messages have accurate timestamps.</p> <p>If the logging methods are used when Robot Framework is not running, the messages are redirected to the standard Python <code>logging</code> module using logger named <code>RobotFramework</code>.</p>"},{"location":"api/robot/api/logger/#robot.api.logger--log-levels","title":"Log levels","text":"<p>It is possible to log messages using levels <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code> and <code>ERROR</code> either using the :func:<code>write</code> function or, more commonly, with the log level specific :func:<code>trace</code>, :func:<code>debug</code>, :func:<code>info</code>, :func:<code>warn</code>, :func:<code>error</code> functions.</p> <p>The trace and debug messages are not logged by default, but that can be changed with the <code>--loglevel</code> command line option. Warnings and errors are automatically written also to the console and to the Test Execution Errors section in the log file.</p>"},{"location":"api/robot/api/logger/#robot.api.logger--logging-html","title":"Logging HTML","text":"<p>All methods that are used for writing messages to the log file have an optional <code>html</code> argument. If a message to be logged is supposed to be shown as HTML, this argument should be set to <code>True</code>. Alternatively, :func:<code>write</code> accepts a pseudo log level <code>HTML</code>.</p>"},{"location":"api/robot/api/logger/#robot.api.logger--example","title":"Example","text":"<p>::</p> <pre><code>from robot.api import logger\n\ndef my_keyword(arg):\n    logger.debug(f'Got argument {arg}.')\n    do_something()\n    logger.info('&lt;i&gt;This&lt;/i&gt; is a boring example.', html=True)\n</code></pre>"},{"location":"api/robot/api/logger/#robot.api.logger.write","title":"write","text":"<pre><code>write(\n    msg: str, level: LOGLEVEL = \"INFO\", html: bool = False\n)\n</code></pre> <p>Writes the message to the log file using the given level.</p> <p>Valid log levels are <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code> (default), <code>WARN</code>, and <code>ERROR</code>. In addition to that, there are pseudo log levels <code>HTML</code> and <code>CONSOLE</code> for logging messages as HTML and for logging messages both to the log file and to the console, respectively. With both of these pseudo levels the level in the log file will be <code>INFO</code>. The <code>CONSOLE</code> level is new in Robot Framework 6.1.</p> <p>Instead of using this method, it is generally better to use the level specific methods such as <code>info</code> and <code>debug</code> that have separate <code>html</code> argument to control the message format.</p> Source code in <code>src/robot/api/logger.py</code> <pre><code>def write(msg: str, level: LOGLEVEL = 'INFO', html: bool = False):\n    \"\"\"Writes the message to the log file using the given level.\n\n    Valid log levels are ``TRACE``, ``DEBUG``, ``INFO`` (default), ``WARN``,\n    and ``ERROR``. In addition to that, there are pseudo log levels ``HTML``\n    and ``CONSOLE`` for logging messages as HTML and for logging messages\n    both to the log file and to the console, respectively. With both of these\n    pseudo levels the level in the log file will be ``INFO``. The ``CONSOLE``\n    level is new in Robot Framework 6.1.\n\n    Instead of using this method, it is generally better to use the level\n    specific methods such as ``info`` and ``debug`` that have separate\n    ``html`` argument to control the message format.\n    \"\"\"\n    if EXECUTION_CONTEXTS.current is not None:\n        librarylogger.write(msg, level, html)\n    else:\n        logger = logging.getLogger(\"RobotFramework\")\n        level_int = {\n            'TRACE': logging.DEBUG // 2,\n            'DEBUG': logging.DEBUG,\n            'INFO': logging.INFO,\n            'CONSOLE': logging.INFO,\n            'HTML': logging.INFO,\n            'WARN': logging.WARN,\n            'ERROR': logging.ERROR\n        }[level]\n        logger.log(level_int, msg)\n</code></pre>"},{"location":"api/robot/api/logger/#robot.api.logger.trace","title":"trace","text":"<pre><code>trace(msg: str, html: bool = False)\n</code></pre> <p>Writes the message to the log file using the <code>TRACE</code> level.</p> Source code in <code>src/robot/api/logger.py</code> <pre><code>def trace(msg: str, html: bool = False):\n    \"\"\"Writes the message to the log file using the ``TRACE`` level.\"\"\"\n    write(msg, 'TRACE', html)\n</code></pre>"},{"location":"api/robot/api/logger/#robot.api.logger.debug","title":"debug","text":"<pre><code>debug(msg: str, html: bool = False)\n</code></pre> <p>Writes the message to the log file using the <code>DEBUG</code> level.</p> Source code in <code>src/robot/api/logger.py</code> <pre><code>def debug(msg: str, html: bool = False):\n    \"\"\"Writes the message to the log file using the ``DEBUG`` level.\"\"\"\n    write(msg, 'DEBUG', html)\n</code></pre>"},{"location":"api/robot/api/logger/#robot.api.logger.info","title":"info","text":"<pre><code>info(\n    msg: str, html: bool = False, also_console: bool = False\n)\n</code></pre> <p>Writes the message to the log file using the <code>INFO</code> level.</p> <p>If <code>also_console</code> argument is set to <code>True</code>, the message is written both to the log file and to the console.</p> Source code in <code>src/robot/api/logger.py</code> <pre><code>def info(msg: str, html: bool = False, also_console: bool = False):\n    \"\"\"Writes the message to the log file using the ``INFO`` level.\n\n    If ``also_console`` argument is set to ``True``, the message is\n    written both to the log file and to the console.\n    \"\"\"\n    write(msg, 'INFO', html)\n    if also_console:\n        console(msg)\n</code></pre>"},{"location":"api/robot/api/logger/#robot.api.logger.warn","title":"warn","text":"<pre><code>warn(msg: str, html: bool = False)\n</code></pre> <p>Writes the message to the log file using the <code>WARN</code> level.</p> Source code in <code>src/robot/api/logger.py</code> <pre><code>def warn(msg: str, html: bool = False):\n    \"\"\"Writes the message to the log file using the ``WARN`` level.\"\"\"\n    write(msg, 'WARN', html)\n</code></pre>"},{"location":"api/robot/api/logger/#robot.api.logger.error","title":"error","text":"<pre><code>error(msg: str, html: bool = False)\n</code></pre> <p>Writes the message to the log file using the <code>ERROR</code> level.</p> Source code in <code>src/robot/api/logger.py</code> <pre><code>def error(msg: str, html: bool = False):\n    \"\"\"Writes the message to the log file using the ``ERROR`` level.\n    \"\"\"\n    write(msg, 'ERROR', html)\n</code></pre>"},{"location":"api/robot/api/logger/#robot.api.logger.console","title":"console","text":"<pre><code>console(\n    msg: str,\n    newline: bool = True,\n    stream: Literal[\"stdout\", \"stderr\"] = \"stdout\",\n)\n</code></pre> <p>Writes the message to the console.</p> <p>If the <code>newline</code> argument is <code>True</code>, a newline character is automatically added to the message.</p> <p>The message is written to the standard output stream by default. Using the standard error stream is possibly by giving the <code>stream</code> argument value <code>'stderr'</code>.</p> Source code in <code>src/robot/api/logger.py</code> <pre><code>def console(msg: str, newline: bool = True,\n            stream: Literal['stdout', 'stderr'] = 'stdout'):\n    \"\"\"Writes the message to the console.\n\n    If the ``newline`` argument is ``True``, a newline character is\n    automatically added to the message.\n\n    The message is written to the standard output stream by default.\n    Using the standard error stream is possibly by giving the ``stream``\n    argument value ``'stderr'``.\n    \"\"\"\n    librarylogger.console(msg, newline, stream)\n</code></pre>"},{"location":"api/robot/api/parsing/","title":"robot.api.parsing","text":""},{"location":"api/robot/api/parsing/#robot.api.parsing","title":"robot.api.parsing","text":"<p>Public API for parsing, inspecting and modifying test data.</p>"},{"location":"api/robot/api/parsing/#robot.api.parsing--exposed-api","title":"Exposed API","text":"<p>The publicly exposed parsing entry points are the following:</p> <ul> <li> <p>:func:<code>~.lexer.lexer.get_tokens</code>,   :func:<code>~.lexer.lexer.get_resource_tokens</code>, and   :func:<code>~.lexer.lexer.get_init_tokens</code>   functions for <code>parsing data to tokens</code>_.</p> </li> <li> <p>:class:<code>~.lexer.tokens.Token</code> class that contains all token types as   class attributes.</p> </li> <li> <p>:func:<code>~.parser.parser.get_model</code>,   :func:<code>~.parser.parser.get_resource_model</code>, and   :func:<code>~.parser.parser.get_init_model</code>   functions for <code>parsing data to model</code>_ represented as   an abstract syntax tree (AST).</p> </li> <li> <p><code>Model objects</code>_ used by the AST model.</p> </li> <li> <p>:class:<code>~robot.parsing.model.visitor.ModelVisitor</code>   to ease <code>inspecting model</code> and <code>modifying data</code>.</p> </li> <li> <p>:class:<code>~robot.parsing.model.visitor.ModelTransformer</code>   for <code>adding and removing nodes</code>_.</p> </li> </ul> <p>.. note:: This module is new in Robot Framework 4.0. In Robot Framework 3.2 functions           for getting tokens and model as well as the :class:<code>~.lexer.tokens.Token</code>           class were exposed directly via the :mod:<code>robot.api</code> package, but other           parts of the parsing API were not publicly exposed. All code targeting           Robot Framework 4.0 or newer should use this module because parsing related           functions and classes will be removed from :mod:<code>robot.api</code> in the future.</p> <p>.. note:: Parsing was totally rewritten in Robot Framework 3.2 and external           tools using the parsing APIs need to be updated. Depending on           the use case, it may be possible to use the higher level           :func:<code>~robot.running.builder.builders.TestSuiteBuilder</code> instead.</p>"},{"location":"api/robot/api/parsing/#robot.api.parsing--parsing-data-to-tokens","title":"Parsing data to tokens","text":"<p>Data can be parsed to tokens by using :func:<code>~.lexer.lexer.get_tokens</code>, :func:<code>~.lexer.lexer.get_resource_tokens</code> or :func:<code>~.lexer.lexer.get_init_tokens</code> functions depending on whether the data represent a test case (or task) file, a resource file, or a suite initialization file. In practice the difference between these functions is what settings and sections are valid.</p> <p>Typically the data is easier to inspect and modify by using the higher level model discussed in the next section, but in some cases having just the tokens can be enough. Tokens returned by the aforementioned functions are :class:<code>~.lexer.tokens.Token</code> instances and they have the token type, value, and position easily available as their attributes. Tokens also have useful string representation used by the example below::</p> <pre><code>from robot.api.parsing import get_tokens\n\npath = 'example.robot'\n\nfor token in get_tokens(path):\n    print(repr(token))\n</code></pre> <p>If the :file:<code>example.robot</code> used by the above example would contain</p> <p>.. code-block:: robotframework</p> <pre><code>*** Test Cases ***\nExample\n    Keyword    argument\n\nSecond example\n    Keyword    xxx\n\n*** Keywords ***\nKeyword\n    [Arguments]    ${arg}\n    Log    ${arg}\n</code></pre> <p>then the beginning of the output got when running the earlier code would look like this::</p> <pre><code>Token(TESTCASE_HEADER, '*** Test Cases ***', 1, 0)\nToken(EOL, '\\n', 1, 18)\nToken(EOS, '', 1, 19)\nToken(TESTCASE_NAME, 'Example', 2, 0)\nToken(EOL, '\\n', 2, 7)\nToken(EOS, '', 2, 8)\nToken(SEPARATOR, '    ', 3, 0)\nToken(KEYWORD, 'Keyword', 3, 4)\nToken(SEPARATOR, '    ', 3, 11)\nToken(ARGUMENT, 'argument', 3, 15)\nToken(EOL, '\\n', 3, 23)\nToken(EOS, '', 3, 24)\nToken(EOL, '\\n', 4, 0)\nToken(EOS, '', 4, 1)\n</code></pre> <p>The output shows the token type, value, line number and column offset. When finding tokens by their type, the constants in the :class:<code>~.lexer.tokens.Token</code> class such as <code>Token.TESTCASE_NAME</code> and <code>Token.EOL</code> should be used instead the values of these constants like <code>'TESTCASE NAME'</code> and <code>'EOL'</code>. These values have changed slightly in Robot Framework 4.0 and they may change in the future as well.</p> <p>The <code>EOL</code> tokens denote end of a line and they include the newline character and possible trailing spaces. The <code>EOS</code> tokens denote end of a logical statement. Typically a single line forms a statement, but when the <code>...</code> syntax is used for continuation, a statement spans multiple lines. In special cases a single line can also contain multiple statements.</p> <p>Errors caused by unrecognized data such as non-existing section or setting names are handled during the tokenizing phase. Such errors are reported using tokens that have <code>ERROR</code> type and the actual error message in their <code>error</code> attribute. Syntax errors such as empty FOR loops are only handled when building the higher level model discussed below.</p> <p>See the documentation of :func:<code>~.lexer.lexer.get_tokens</code> for details about different ways how to specify the data to be parsed, how to control should all tokens or only data tokens be returned, and should variables in keyword arguments and elsewhere be tokenized or not.</p>"},{"location":"api/robot/api/parsing/#robot.api.parsing--parsing-data-to-model","title":"Parsing data to model","text":"<p>Data can be parsed to a higher level model by using :func:<code>~.parser.parser.get_model</code>, :func:<code>~.parser.parser.get_resource_model</code>, or :func:<code>~.parser.parser.get_init_model</code> functions depending on the type of the parsed file same way as when <code>parsing data to tokens</code>_.</p> <p>The model is represented as an abstract syntax tree (AST) implemented on top of Python's standard <code>ast.AST</code> class. To see how the model looks like, it is possible to use the <code>ast.dump()</code> function or the third-party astpretty_ module::</p> <pre><code>import ast\nimport astpretty\nfrom robot.api.parsing import get_model\n\nmodel = get_model('example.robot')\nprint(ast.dump(model, include_attributes=True))\nprint('-' * 72)\nastpretty.pprint(model)\n</code></pre> <p>Running this code with the :file:<code>example.robot</code> file from the previous section would produce so much output that it is not included here. If you are going to work with Robot Framework's AST, you are recommended to try that on your own.</p> <p>.. _ast: https://docs.python.org/library/ast.html .. _ast.AST: https://docs.python.org/library/ast.html#ast.AST .. _ast.NodeVisitor: https://docs.python.org/library/ast.html#ast.NodeVisitor .. _ast.NodeTransformer: https://docs.python.org/library/ast.html#ast.NodeTransformer .. _ast.dump(): https://docs.python.org/library/ast.html#ast.dump .. _astpretty: https://pypi.org/project/astpretty</p>"},{"location":"api/robot/api/parsing/#robot.api.parsing--model-objects","title":"Model objects","text":"<p>The model is build from nodes that are based <code>ast.AST</code>_ and further categorized to blocks and statements. Blocks can contain other blocks and statements as child nodes whereas statements only have tokens containing the actual data as :class:<code>~.lexer.tokens.Token</code> instances. Both statements and blocks expose their position information via <code>lineno</code>, <code>col_offset</code>, <code>end_lineno</code> and <code>end_col_offset</code> attributes and some nodes have also other special attributes available.</p> <p>Blocks:</p> <ul> <li>:class:<code>~robot.parsing.model.blocks.File</code> (the root of the model)</li> <li>:class:<code>~robot.parsing.model.blocks.SettingSection</code></li> <li>:class:<code>~robot.parsing.model.blocks.VariableSection</code></li> <li>:class:<code>~robot.parsing.model.blocks.TestCaseSection</code></li> <li>:class:<code>~robot.parsing.model.blocks.KeywordSection</code></li> <li>:class:<code>~robot.parsing.model.blocks.CommentSection</code></li> <li>:class:<code>~robot.parsing.model.blocks.TestCase</code></li> <li>:class:<code>~robot.parsing.model.blocks.Keyword</code></li> <li>:class:<code>~robot.parsing.model.blocks.If</code></li> <li>:class:<code>~robot.parsing.model.blocks.Try</code></li> <li>:class:<code>~robot.parsing.model.blocks.For</code></li> <li>:class:<code>~robot.parsing.model.blocks.While</code></li> </ul> <p>Statements:</p> <ul> <li>:class:<code>~robot.parsing.model.statements.SectionHeader</code></li> <li>:class:<code>~robot.parsing.model.statements.LibraryImport</code></li> <li>:class:<code>~robot.parsing.model.statements.ResourceImport</code></li> <li>:class:<code>~robot.parsing.model.statements.VariablesImport</code></li> <li>:class:<code>~robot.parsing.model.statements.Documentation</code></li> <li>:class:<code>~robot.parsing.model.statements.Metadata</code></li> <li>:class:<code>~robot.parsing.model.statements.ForceTags</code></li> <li>:class:<code>~robot.parsing.model.statements.DefaultTags</code></li> <li>:class:<code>~robot.parsing.model.statements.SuiteName</code></li> <li>:class:<code>~robot.parsing.model.statements.SuiteSetup</code></li> <li>:class:<code>~robot.parsing.model.statements.SuiteTeardown</code></li> <li>:class:<code>~robot.parsing.model.statements.TestSetup</code></li> <li>:class:<code>~robot.parsing.model.statements.TestTeardown</code></li> <li>:class:<code>~robot.parsing.model.statements.TestTemplate</code></li> <li>:class:<code>~robot.parsing.model.statements.TestTimeout</code></li> <li>:class:<code>~robot.parsing.model.statements.Variable</code></li> <li>:class:<code>~robot.parsing.model.statements.TestCaseName</code></li> <li>:class:<code>~robot.parsing.model.statements.KeywordName</code></li> <li>:class:<code>~robot.parsing.model.statements.Setup</code></li> <li>:class:<code>~robot.parsing.model.statements.Teardown</code></li> <li>:class:<code>~robot.parsing.model.statements.Tags</code></li> <li>:class:<code>~robot.parsing.model.statements.Template</code></li> <li>:class:<code>~robot.parsing.model.statements.Timeout</code></li> <li>:class:<code>~robot.parsing.model.statements.Arguments</code></li> <li>:class:<code>~robot.parsing.model.statements.Return</code> (deprecated, will mean <code>ReturnStatement</code> in RF 8.0)</li> <li>:class:<code>~robot.parsing.model.statements.ReturnSetting</code> (alias for <code>Return</code>, new in RF 6.1)</li> <li>:class:<code>~robot.parsing.model.statements.KeywordCall</code></li> <li>:class:<code>~robot.parsing.model.statements.TemplateArguments</code></li> <li>:class:<code>~robot.parsing.model.statements.IfHeader</code></li> <li>:class:<code>~robot.parsing.model.statements.InlineIfHeader</code></li> <li>:class:<code>~robot.parsing.model.statements.ElseIfHeader</code></li> <li>:class:<code>~robot.parsing.model.statements.ElseHeader</code></li> <li>:class:<code>~robot.parsing.model.statements.TryHeader</code></li> <li>:class:<code>~robot.parsing.model.statements.ExceptHeader</code></li> <li>:class:<code>~robot.parsing.model.statements.FinallyHeader</code></li> <li>:class:<code>~robot.parsing.model.statements.ForHeader</code></li> <li>:class:<code>~robot.parsing.model.statements.WhileHeader</code></li> <li>:class:<code>~robot.parsing.model.statements.Var</code> (new in RF 7.0)</li> <li>:class:<code>~robot.parsing.model.statements.End</code></li> <li>:class:<code>~robot.parsing.model.statements.ReturnStatement</code></li> <li>:class:<code>~robot.parsing.model.statements.Break</code></li> <li>:class:<code>~robot.parsing.model.statements.Continue</code></li> <li>:class:<code>~robot.parsing.model.statements.Comment</code></li> <li>:class:<code>~robot.parsing.model.statements.Config</code> (new in RF 6.0)</li> <li>:class:<code>~robot.parsing.model.statements.Error</code></li> <li>:class:<code>~robot.parsing.model.statements.EmptyLine</code></li> </ul>"},{"location":"api/robot/api/parsing/#robot.api.parsing--inspecting-model","title":"Inspecting model","text":"<p>The easiest way to inspect what data a model contains is implementing :class:<code>~robot.parsing.model.visitor.ModelVisitor</code> and creating <code>visit_NodeName</code> to visit nodes with name <code>NodeName</code> as needed. The following example illustrates how to find what tests a certain test case file contains::</p> <pre><code>from robot.api.parsing import get_model, ModelVisitor\n\n\nclass TestNamePrinter(ModelVisitor):\n\n    def visit_File(self, node):\n        print(f\"File '{node.source}' has the following tests:\")\n        # Call `generic_visit` to visit also child nodes.\n        self.generic_visit(node)\n\n    def visit_TestCaseName(self, node):\n        print(f\"- {node.name} (on line {node.lineno})\")\n\n\nmodel = get_model('example.robot')\nprinter = TestNamePrinter()\nprinter.visit(model)\n</code></pre> <p>When the above code is run using the earlier :file:<code>example.robot</code>, the output is this::</p> <pre><code>File 'example.robot' has the following tests:\n- Example (on line 2)\n- Second example (on line 5)\n</code></pre>"},{"location":"api/robot/api/parsing/#robot.api.parsing--handling-errors-in-model","title":"Handling errors in model","text":"<p>All nodes in the model have <code>errors</code> attribute that contains possible errors the node has. These errors include syntax errors such as empty FOR loops or IF without a condition as well as errors caused by unrecognized data such as non-existing section or setting names.</p> <p>Unrecognized data is handled already during the tokenizing__ phase. In the model such data is represented as :class:<code>~robot.parsing.model.statements.Error</code> nodes and their <code>errors</code> attribute contain error information got from the underlying <code>ERROR</code> tokens. Syntax errors do not create :class:<code>~robot.parsing.model.statements.Error</code> nodes, but instead the model has normal nodes such as :class:<code>~robot.parsing.model.blocks.If</code> with errors in their <code>errors</code> attribute.</p> <p>A simple way to go through the model and see are there errors is using the :class:<code>~robot.parsing.model.visitor.ModelVisitor</code> discussed in the previous section::</p> <pre><code>class ErrorReporter(ModelVisitor):\n\n    # Implement `generic_visit` to visit all nodes.\n    def generic_visit(self, node):\n        if node.errors:\n            print(f'Error on line {node.lineno}:')\n            for error in node.errors:\n                print(f'- {error}')\n        ModelVisitor.generic_visit(self, node)\n</code></pre> <p>__ <code>Parsing data to tokens</code>_</p>"},{"location":"api/robot/api/parsing/#robot.api.parsing--modifying-data","title":"Modifying data","text":"<p>Existing data the model contains can be modified simply by modifying values of the underlying tokens. If changes need to be saved, that is as easy as calling the :meth:<code>~.model.blocks.File.save</code> method of the root model object. When just modifying token values, it is possible to still use :class:<code>~robot.parsing.model.visitor.ModelVisitor</code> discussed in the above section. The next section discusses adding or removing nodes and then :class:<code>~robot.parsing.model.visitor.ModelTransformer</code> should be used instead.</p> <p>Modifications to tokens obviously require finding the tokens to be modified. The first step is finding nodes containing the tokens by implementing needed <code>visit_NodeName</code> methods. Then the exact token or tokens can be found using nodes' :meth:<code>~.model.statements.Statement.get_token</code> or :meth:<code>~.model.statements.Statement.get_tokens</code> methods. If only token values are needed, :meth:<code>~.model.statements.Statement.get_value</code> or :meth:<code>~.model.statements.Statement.get_values</code> can be used as a shortcut. First finding nodes and then the right tokens is illustrated by this keyword renaming example::</p> <pre><code>from robot.api.parsing import get_model, ModelVisitor, Token\n\n\nclass KeywordRenamer(ModelVisitor):\n\n    def __init__(self, old_name, new_name):\n        self.old_name = self.normalize(old_name)\n        self.new_name = new_name\n\n    def normalize(self, name):\n        return name.lower().replace(' ', '').replace('_', '')\n\n    def visit_KeywordName(self, node):\n        '''Rename keyword definitions.'''\n        if self.normalize(node.name) == self.old_name:\n            token = node.get_token(Token.KEYWORD_NAME)\n            token.value = self.new_name\n\n    def visit_KeywordCall(self, node):\n        '''Rename keyword usages.'''\n        if self.normalize(node.keyword) == self.old_name:\n            token = node.get_token(Token.KEYWORD)\n            token.value = self.new_name\n\n\nmodel = get_model('example.robot')\nrenamer = KeywordRenamer('Keyword', 'New Name')\nrenamer.visit(model)\nmodel.save()\n</code></pre> <p>If you run the above example using the earlier :file:<code>example.robot</code>, you can see that the <code>Keyword</code> keyword has been renamed to <code>New Name</code>. Notice that a real keyword renamer needed to take into account also keywords used with setups, teardowns and templates.</p> <p>When token values are changed, column offset of the other tokens on same line are likely to be wrong. This does not affect saving the model or other typical usages, but if it is a problem then the caller needs to updated offsets separately.</p>"},{"location":"api/robot/api/parsing/#robot.api.parsing--adding-and-removing-nodes","title":"Adding and removing nodes","text":"<p>Bigger changes to the model are somewhat more complicated than just modifying existing token values. When doing this kind of changes, :class:<code>~robot.parsing.model.visitor.ModelTransformer</code> should be used instead of :class:<code>~robot.parsing.model.visitor.ModelVisitor</code> that was discussed in the previous sections.</p> <p>Removing nodes is relative easy and is accomplished by returning <code>None</code> from <code>visit_NodeName</code> methods. Remember to return the original node, or possibly a replacement node, from all of these methods when you do not want a node to be removed.</p> <p>Adding nodes requires constructing needed <code>Model objects</code>_ and adding them to the model. The following example demonstrates both removing and adding nodes. If you run it against the earlier :file:<code>example.robot</code>, you see that the first test gets a new keyword, the second test is removed, and settings section with documentation is added.</p> <p>::</p> <pre><code>from robot.api.parsing import (\n    get_model, Documentation, EmptyLine, KeywordCall,\n    ModelTransformer, SettingSection, SectionHeader, Token\n)\n\n\nclass TestModifier(ModelTransformer):\n\n    def visit_TestCase(self, node):\n        # The matched `TestCase` node is a block with `header` and\n        # `body` attributes. `header` is a statement with familiar\n        # `get_token` and `get_value` methods for getting certain\n        # tokens or their value.\n        name = node.header.get_value(Token.TESTCASE_NAME)\n        # Returning `None` drops the node altogether i.e. removes\n        # this test.\n        if name == 'Second example':\n            return None\n        # Construct new keyword call statement from tokens. See `visit_File`\n        # below for an example creating statements using `from_params`.\n        new_keyword = KeywordCall([\n            Token(Token.SEPARATOR, '    '),\n            Token(Token.KEYWORD, 'New Keyword'),\n            Token(Token.SEPARATOR, '    '),\n            Token(Token.ARGUMENT, 'xxx'),\n            Token(Token.EOL)\n        ])\n        # Add the keyword call to test as the second item.\n        node.body.insert(1, new_keyword)\n        # No need to call `generic_visit` because we are not\n        # modifying child nodes. The node itself must to be\n        # returned to avoid dropping it.\n        return node\n\n    def visit_File(self, node):\n        # Create settings section with documentation. Needed header and body\n        # statements are created using `from_params` method. This is typically\n        # more convenient than creating statements based on tokens like above.\n        settings = SettingSection(\n            header=SectionHeader.from_params(Token.SETTING_HEADER),\n            body=[\n                Documentation.from_params('This is a really\\npowerful API!'),\n                EmptyLine.from_params()\n            ]\n        )\n        # Add settings to the beginning of the file.\n        node.sections.insert(0, settings)\n        # Call `generic_visit` to visit also child nodes.\n        return self.generic_visit(node)\n\n\nmodel = get_model('example.robot')\nTestModifier().visit(model)\nmodel.save('modified.robot')\n</code></pre>"},{"location":"api/robot/api/parsing/#robot.api.parsing--executing-model","title":"Executing model","text":"<p>It is possible to convert a parsed and possibly modified model into an executable :class:<code>~robot.running.model.TestSuite</code> structure by using its :func:<code>~robot.running.model.TestSuite.from_model</code> class method. In this case the :func:<code>~.parser.parser.get_model</code> function should be given the <code>curdir</code> argument to get possible <code>${CURDIR}</code> variable resolved correctly.</p> <p>::</p> <pre><code> from robot.api import TestSuite\n from robot.api.parsing import get_model\n\n model = get_model('example.robot', curdir='/home/robot/example')\n # modify model as needed\n suite = TestSuite.from_model(model)\n suite.run()\n</code></pre> <p>For more details about executing the created :class:<code>~robot.running.model.TestSuite</code> object, see the documentation of its :meth:<code>~robot.running.model.TestSuite.run</code> method. Notice also that if you do not need to modify the parsed model, it is easier to get the executable suite by using the :func:<code>~robot.running.model.TestSuite.from_file_system</code> class method.</p>"},{"location":"api/robot/conf/","title":"robot.conf","text":""},{"location":"api/robot/conf/#robot.conf","title":"robot.conf","text":"<p>Implements settings for both test execution and output processing.</p> <p>This package implements :class:<code>~robot.conf.settings.RobotSettings</code> and :class:<code>~robot.conf.settings.RebotSettings</code> classes used internally by the framework. There should be no need to use these classes externally.</p> <p>This package can be considered relatively stable. Aforementioned classes are likely to be rewritten at some point to be more convenient to use. Instantiating them is not likely to change, though.</p>"},{"location":"api/robot/conf/gatherfailed/","title":"robot.conf.gatherfailed","text":""},{"location":"api/robot/conf/gatherfailed/#robot.conf.gatherfailed","title":"robot.conf.gatherfailed","text":""},{"location":"api/robot/conf/languages/","title":"robot.conf.languages","text":""},{"location":"api/robot/conf/languages/#robot.conf.languages","title":"robot.conf.languages","text":""},{"location":"api/robot/conf/languages/#robot.conf.languages.Languages","title":"Languages","text":"<pre><code>Languages(\n    languages: (\n        Iterable[LanguageLike] | LanguageLike | None\n    ) = (),\n    add_english: bool = True,\n)\n</code></pre> <p>Stores languages and unifies translations.</p> <p>Example::</p> <pre><code>languages = Languages('de', add_english=False)\nprint(languages.settings)\nlanguages = Languages(['pt-BR', 'Finnish', 'MyLang.py'])\nfor lang in languages:\n    print(lang.name, lang.code)\n</code></pre> <p>:param languages: Initial language or list of languages.     Languages can be given as language codes or names, paths or names of     language modules to load, or as :class:<code>Language</code> instances. :param add_english: If True, English is added automatically. :raises: :class:<code>~robot.errors.DataError</code> if a given language is not found.</p> <p>:meth:<code>add_language</code> can be used to add languages after initialization.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>def __init__(self, languages: 'Iterable[LanguageLike]|LanguageLike|None' = (),\n             add_english: bool = True):\n    \"\"\"\n    :param languages: Initial language or list of languages.\n        Languages can be given as language codes or names, paths or names of\n        language modules to load, or as :class:`Language` instances.\n    :param add_english: If True, English is added automatically.\n    :raises: :class:`~robot.errors.DataError` if a given language is not found.\n\n    :meth:`add_language` can be used to add languages after initialization.\n    \"\"\"\n    self.languages: 'list[Language]' = []\n    self.headers: 'dict[str, str]' = {}\n    self.settings: 'dict[str, str]' = {}\n    self.bdd_prefixes: 'set[str]' = set()\n    self.true_strings: 'set[str]' = {'True', '1'}\n    self.false_strings: 'set[str]' = {'False', '0', 'None', ''}\n    for lang in self._get_languages(languages, add_english):\n        self._add_language(lang)\n    self._bdd_prefix_regexp = None\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Languages.reset","title":"reset","text":"<pre><code>reset(\n    languages: Iterable[LanguageLike] = (),\n    add_english: bool = True,\n)\n</code></pre> <p>Resets the instance to the given languages.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>def reset(self, languages: Iterable[LanguageLike] = (), add_english: bool = True):\n    \"\"\"Resets the instance to the given languages.\"\"\"\n    self.__init__(languages, add_english)\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Languages.add_language","title":"add_language","text":"<pre><code>add_language(lang: LanguageLike)\n</code></pre> <p>Add new language.</p> <p>:param lang: Language to add. Can be a language code or name, name or     path of a language module to load, or a :class:<code>Language</code> instance. :raises: :class:<code>~robot.errors.DataError</code> if the language is not found.</p> <p>Language codes and names are passed to by :meth:<code>Language.from_name</code>. Language modules are imported and :class:<code>Language</code> subclasses in them loaded.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>def add_language(self, lang: LanguageLike):\n    \"\"\"Add new language.\n\n    :param lang: Language to add. Can be a language code or name, name or\n        path of a language module to load, or a :class:`Language` instance.\n    :raises: :class:`~robot.errors.DataError` if the language is not found.\n\n    Language codes and names are passed to by :meth:`Language.from_name`.\n    Language modules are imported and :class:`Language` subclasses in them\n    loaded.\n    \"\"\"\n    if isinstance(lang, Language):\n        languages = [lang]\n    elif isinstance(lang, Path) or self._exists(Path(lang)):\n        languages = self._import_language_module(Path(lang))\n    else:\n        try:\n            languages = [Language.from_name(lang)]\n        except ValueError as err1:\n            try:\n                languages = self._import_language_module(lang)\n            except DataError as err2:\n                raise DataError(f'{err1} {err2}') from None\n    for lang in languages:\n        self._add_language(lang)\n    self._bdd_prefix_regexp = None\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Language","title":"Language","text":"<p>Base class for language definitions.</p> <p>New translations can be added by extending this class and setting class attributes listed below.</p> <p>Language :attr:<code>code</code> is got based on the class name and :attr:<code>name</code> based on the docstring.</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Language.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Language.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Language.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.En","title":"En","text":"<p>               Bases: <code>Language</code></p> <p>English</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.En.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.En.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.En.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Cs","title":"Cs","text":"<p>               Bases: <code>Language</code></p> <p>Czech</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Cs.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Cs.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Cs.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Nl","title":"Nl","text":"<p>               Bases: <code>Language</code></p> <p>Dutch</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Nl.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Nl.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Nl.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Bs","title":"Bs","text":"<p>               Bases: <code>Language</code></p> <p>Bosnian</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Bs.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Bs.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Bs.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Fi","title":"Fi","text":"<p>               Bases: <code>Language</code></p> <p>Finnish</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Fi.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Fi.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Fi.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Fr","title":"Fr","text":"<p>               Bases: <code>Language</code></p> <p>French</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Fr.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Fr.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Fr.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.De","title":"De","text":"<p>               Bases: <code>Language</code></p> <p>German</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.De.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.De.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.De.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.PtBr","title":"PtBr","text":"<p>               Bases: <code>Language</code></p> <p>Brazilian Portuguese</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.PtBr.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.PtBr.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.PtBr.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Pt","title":"Pt","text":"<p>               Bases: <code>Language</code></p> <p>Portuguese</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Pt.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Pt.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Pt.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Th","title":"Th","text":"<p>               Bases: <code>Language</code></p> <p>Thai</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Th.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Th.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Th.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Pl","title":"Pl","text":"<p>               Bases: <code>Language</code></p> <p>Polish</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Pl.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Pl.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Pl.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Uk","title":"Uk","text":"<p>               Bases: <code>Language</code></p> <p>Ukrainian</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Uk.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Uk.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Uk.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Es","title":"Es","text":"<p>               Bases: <code>Language</code></p> <p>Spanish</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Es.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Es.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Es.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ru","title":"Ru","text":"<p>               Bases: <code>Language</code></p> <p>Russian</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ru.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ru.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ru.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.ZhCn","title":"ZhCn","text":"<p>               Bases: <code>Language</code></p> <p>Chinese Simplified</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.ZhCn.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.ZhCn.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.ZhCn.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.ZhTw","title":"ZhTw","text":"<p>               Bases: <code>Language</code></p> <p>Chinese Traditional</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.ZhTw.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.ZhTw.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.ZhTw.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Tr","title":"Tr","text":"<p>               Bases: <code>Language</code></p> <p>Turkish</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Tr.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Tr.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Tr.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Sv","title":"Sv","text":"<p>               Bases: <code>Language</code></p> <p>Swedish</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Sv.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Sv.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Sv.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Bg","title":"Bg","text":"<p>               Bases: <code>Language</code></p> <p>Bulgarian</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Bg.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Bg.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Bg.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ro","title":"Ro","text":"<p>               Bases: <code>Language</code></p> <p>Romanian</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ro.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ro.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ro.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.It","title":"It","text":"<p>               Bases: <code>Language</code></p> <p>Italian</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.It.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.It.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.It.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Hi","title":"Hi","text":"<p>               Bases: <code>Language</code></p> <p>Hindi</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Hi.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Hi.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Hi.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Vi","title":"Vi","text":"<p>               Bases: <code>Language</code></p> <p>Vietnamese</p> <p>New in Robot Framework 6.1.</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Vi.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Vi.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Vi.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ja","title":"Ja","text":"<p>               Bases: <code>Language</code></p> <p>Japanese</p> <p>New in Robot Framework 7.0.1.</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ja.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ja.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ja.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ko","title":"Ko","text":"<p>               Bases: <code>Language</code></p> <p>Korean</p> <p>New in Robot Framework 7.1.</p>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ko.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name) -&gt; Language\n</code></pre> <p>Return language class based on given <code>name</code>.</p> <p>Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese') or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space insensitive and the hyphen is ignored when matching language codes.</p> <p>Raises <code>ValueError</code> if no matching language is found.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classmethod\ndef from_name(cls, name) -&gt; 'Language':\n    \"\"\"Return language class based on given `name`.\n\n    Name can either be a language name (e.g. 'Finnish' or 'Brazilian Portuguese')\n    or a language code (e.g. 'fi' or 'pt-BR'). Matching is case and space\n    insensitive and the hyphen is ignored when matching language codes.\n\n    Raises `ValueError` if no matching language is found.\n    \"\"\"\n    normalized = normalize(name, ignore='-')\n    for lang in cls.__subclasses__():\n        if normalized == normalize(lang.__name__):\n            return lang()\n        if lang.__doc__ and normalized == normalize(lang.__doc__.splitlines()[0]):\n            return lang()\n    raise ValueError(f\"No language with name '{name}' found.\")\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ko.code","title":"code","text":"<pre><code>code() -&gt; str\n</code></pre> <p>Language code like 'fi' or 'pt-BR'.</p> <p>Got based on the class name. If the class name is two characters (or less), the code is just the name in lower case. If it is longer, a hyphen is added and the remainder of the class name is upper-cased.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef code(cls) -&gt; str:\n    \"\"\"Language code like 'fi' or 'pt-BR'.\n\n    Got based on the class name. If the class name is two characters (or less),\n    the code is just the name in lower case. If it is longer, a hyphen is added\n    and the remainder of the class name is upper-cased.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['code']\n    code = cast(type, cls).__name__.lower()\n    if len(code) &lt; 3:\n        return code\n    return f'{code[:2]}-{code[2:].upper()}'\n</code></pre>"},{"location":"api/robot/conf/languages/#robot.conf.languages.Ko.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Language name like 'Finnish' or 'Brazilian Portuguese'.</p> <p>Got from the first line of the class docstring.</p> <p>This special property can be accessed also directly from the class.</p> Source code in <code>src/robot/conf/languages.py</code> <pre><code>@classproperty\ndef name(cls) -&gt; str:\n    \"\"\"Language name like 'Finnish' or 'Brazilian Portuguese'.\n\n    Got from the first line of the class docstring.\n\n    This special property can be accessed also directly from the class.\n    \"\"\"\n    if cls is Language:\n        return cls.__dict__['name']\n    return cls.__doc__.splitlines()[0] if cls.__doc__ else ''\n</code></pre>"},{"location":"api/robot/conf/settings/","title":"robot.conf.settings","text":""},{"location":"api/robot/conf/settings/#robot.conf.settings","title":"robot.conf.settings","text":""},{"location":"api/robot/htmldata/","title":"robot.htmldata","text":""},{"location":"api/robot/htmldata/#robot.htmldata","title":"robot.htmldata","text":"<p>Package for writing output files in HTML format.</p> <p>This package is considered stable, but it is not part of the public API.</p>"},{"location":"api/robot/htmldata/htmlfilewriter/","title":"robot.htmldata.htmlfilewriter","text":""},{"location":"api/robot/htmldata/htmlfilewriter/#robot.htmldata.htmlfilewriter","title":"robot.htmldata.htmlfilewriter","text":""},{"location":"api/robot/htmldata/jsonwriter/","title":"robot.htmldata.jsonwriter","text":""},{"location":"api/robot/htmldata/jsonwriter/#robot.htmldata.jsonwriter","title":"robot.htmldata.jsonwriter","text":""},{"location":"api/robot/htmldata/template/","title":"robot.htmldata.template","text":""},{"location":"api/robot/htmldata/template/#robot.htmldata.template","title":"robot.htmldata.template","text":""},{"location":"api/robot/htmldata/common/","title":"robot.htmldata.common","text":""},{"location":"api/robot/htmldata/common/#robot.htmldata.common","title":"robot.htmldata.common","text":""},{"location":"api/robot/htmldata/libdoc/","title":"robot.htmldata.libdoc","text":""},{"location":"api/robot/htmldata/libdoc/#robot.htmldata.libdoc","title":"robot.htmldata.libdoc","text":""},{"location":"api/robot/htmldata/rebot/","title":"robot.htmldata.rebot","text":""},{"location":"api/robot/htmldata/rebot/#robot.htmldata.rebot","title":"robot.htmldata.rebot","text":""},{"location":"api/robot/htmldata/testdoc/","title":"robot.htmldata.testdoc","text":""},{"location":"api/robot/htmldata/testdoc/#robot.htmldata.testdoc","title":"robot.htmldata.testdoc","text":""},{"location":"api/robot/libdocpkg/","title":"robot.libdocpkg","text":""},{"location":"api/robot/libdocpkg/#robot.libdocpkg","title":"robot.libdocpkg","text":"<p>Implements the <code>Libdoc</code> tool.</p> <p>The public Libdoc API is exposed via the :mod:<code>robot.libdoc</code> module.</p>"},{"location":"api/robot/libdocpkg/builder/","title":"robot.libdocpkg.builder","text":""},{"location":"api/robot/libdocpkg/builder/#robot.libdocpkg.builder","title":"robot.libdocpkg.builder","text":""},{"location":"api/robot/libdocpkg/builder/#robot.libdocpkg.builder.LibraryDocumentation","title":"LibraryDocumentation","text":"<pre><code>LibraryDocumentation(\n    library_or_resource,\n    name=None,\n    version=None,\n    doc_format=None,\n)\n</code></pre> <p>Generate keyword documentation for the given library, resource or suite file.</p> <p>:param library_or_resource:     Name or path of the library, or path of a resource or a suite file. :param name:     Set name with the given value. :param version:     Set version to the given value. :param doc_format:     Set documentation format to the given value. :return:     :class:<code>~.model.LibraryDoc</code> instance.</p> <p>This factory method is the recommended API to generate keyword documentation programmatically. It should be imported via the :mod:<code>robot.libdoc</code> module.</p> <p>Example::</p> <pre><code>from robot.libdoc import LibraryDocumentation\n\nlib = LibraryDocumentation('OperatingSystem')\nprint(lib.name, lib.version)\nfor kw in lib.keywords:\n    print(kw.name)\n</code></pre> Source code in <code>src/robot/libdocpkg/builder.py</code> <pre><code>def LibraryDocumentation(library_or_resource, name=None, version=None, doc_format=None):\n    \"\"\"Generate keyword documentation for the given library, resource or suite file.\n\n    :param library_or_resource:\n        Name or path of the library, or path of a resource or a suite file.\n    :param name:\n        Set name with the given value.\n    :param version:\n        Set version to the given value.\n    :param doc_format:\n        Set documentation format to the given value.\n    :return:\n        :class:`~.model.LibraryDoc` instance.\n\n    This factory method is the recommended API to generate keyword documentation\n    programmatically. It should be imported via the :mod:`robot.libdoc` module.\n\n    Example::\n\n        from robot.libdoc import LibraryDocumentation\n\n        lib = LibraryDocumentation('OperatingSystem')\n        print(lib.name, lib.version)\n        for kw in lib.keywords:\n            print(kw.name)\n    \"\"\"\n    libdoc = DocumentationBuilder().build(library_or_resource)\n    if name:\n        libdoc.name = name\n    if version:\n        libdoc.version = version\n    if doc_format:\n        libdoc.doc_format = doc_format\n    return libdoc\n</code></pre>"},{"location":"api/robot/libdocpkg/builder/#robot.libdocpkg.builder.DocumentationBuilder","title":"DocumentationBuilder","text":"<p>Keyword documentation builder.</p> <p>This is not part of Libdoc's public API. Use :func:<code>LibraryDocumentation</code> instead.</p>"},{"location":"api/robot/libdocpkg/consoleviewer/","title":"robot.libdocpkg.consoleviewer","text":""},{"location":"api/robot/libdocpkg/consoleviewer/#robot.libdocpkg.consoleviewer","title":"robot.libdocpkg.consoleviewer","text":""},{"location":"api/robot/libdocpkg/datatypes/","title":"robot.libdocpkg.datatypes","text":""},{"location":"api/robot/libdocpkg/datatypes/#robot.libdocpkg.datatypes","title":"robot.libdocpkg.datatypes","text":""},{"location":"api/robot/libdocpkg/htmlutils/","title":"robot.libdocpkg.htmlutils","text":""},{"location":"api/robot/libdocpkg/htmlutils/#robot.libdocpkg.htmlutils","title":"robot.libdocpkg.htmlutils","text":""},{"location":"api/robot/libdocpkg/htmlwriter/","title":"robot.libdocpkg.htmlwriter","text":""},{"location":"api/robot/libdocpkg/htmlwriter/#robot.libdocpkg.htmlwriter","title":"robot.libdocpkg.htmlwriter","text":""},{"location":"api/robot/libdocpkg/jsonbuilder/","title":"robot.libdocpkg.jsonbuilder","text":""},{"location":"api/robot/libdocpkg/jsonbuilder/#robot.libdocpkg.jsonbuilder","title":"robot.libdocpkg.jsonbuilder","text":""},{"location":"api/robot/libdocpkg/jsonwriter/","title":"robot.libdocpkg.jsonwriter","text":""},{"location":"api/robot/libdocpkg/jsonwriter/#robot.libdocpkg.jsonwriter","title":"robot.libdocpkg.jsonwriter","text":""},{"location":"api/robot/libdocpkg/model/","title":"robot.libdocpkg.model","text":""},{"location":"api/robot/libdocpkg/model/#robot.libdocpkg.model","title":"robot.libdocpkg.model","text":""},{"location":"api/robot/libdocpkg/model/#robot.libdocpkg.model.LibraryDoc","title":"LibraryDoc","text":"<pre><code>LibraryDoc(\n    name=\"\",\n    doc=\"\",\n    version=\"\",\n    type=\"LIBRARY\",\n    scope=\"TEST\",\n    doc_format=\"ROBOT\",\n    source=None,\n    lineno=-1,\n)\n</code></pre> <p>Documentation for a library, a resource file or a suite file.</p> Source code in <code>src/robot/libdocpkg/model.py</code> <pre><code>def __init__(self, name='', doc='', version='', type='LIBRARY', scope='TEST',\n             doc_format='ROBOT', source=None, lineno=-1):\n    self.name = name\n    self._doc = doc\n    self.version = version\n    self.type = type\n    self.scope = scope\n    self.doc_format = doc_format\n    self.source = source\n    self.lineno = lineno\n    self.inits = ()\n    self.keywords = ()\n    self.type_docs = ()\n</code></pre>"},{"location":"api/robot/libdocpkg/model/#robot.libdocpkg.model.LibraryDoc.inits","title":"inits","text":"<pre><code>inits(inits)\n</code></pre> <p>Initializer docs as :class:<code>~KeywordDoc</code> instances.</p> Source code in <code>src/robot/libdocpkg/model.py</code> <pre><code>@setter\ndef inits(self, inits):\n    \"\"\"Initializer docs as :class:`~KeywordDoc` instances.\"\"\"\n    return self._process_keywords(inits)\n</code></pre>"},{"location":"api/robot/libdocpkg/model/#robot.libdocpkg.model.LibraryDoc.keywords","title":"keywords","text":"<pre><code>keywords(kws)\n</code></pre> <p>Keyword docs as :class:<code>~KeywordDoc</code> instances.</p> Source code in <code>src/robot/libdocpkg/model.py</code> <pre><code>@setter\ndef keywords(self, kws):\n    \"\"\"Keyword docs as :class:`~KeywordDoc` instances.\"\"\"\n    return self._process_keywords(kws)\n</code></pre>"},{"location":"api/robot/libdocpkg/model/#robot.libdocpkg.model.KeywordDoc","title":"KeywordDoc","text":"<pre><code>KeywordDoc(\n    name=\"\",\n    args=None,\n    doc=\"\",\n    short_doc=\"\",\n    tags=(),\n    private=False,\n    deprecated=False,\n    source=None,\n    lineno=-1,\n    parent=None,\n)\n</code></pre> <p>               Bases: <code>Sortable</code></p> <p>Documentation for a single keyword or an initializer.</p> Source code in <code>src/robot/libdocpkg/model.py</code> <pre><code>def __init__(self, name='', args=None, doc='', short_doc='', tags=(), private=False,\n             deprecated=False, source=None, lineno=-1, parent=None):\n    self.name = name\n    self.args = args if args is not None else ArgumentSpec()\n    self.doc = doc\n    self._short_doc = short_doc\n    self.tags = Tags(tags)\n    self.private = private\n    self.deprecated = deprecated\n    self.source = source\n    self.lineno = lineno\n    self.parent = parent\n    # Map argument types to type documentations.\n    self.type_docs = {arg.name: {} for arg in self.args}\n</code></pre>"},{"location":"api/robot/libdocpkg/output/","title":"robot.libdocpkg.output","text":""},{"location":"api/robot/libdocpkg/output/#robot.libdocpkg.output","title":"robot.libdocpkg.output","text":""},{"location":"api/robot/libdocpkg/output/#robot.libdocpkg.output.get_generation_time","title":"get_generation_time","text":"<pre><code>get_generation_time()\n</code></pre> <p>Return a timestamp that honors <code>SOURCE_DATE_EPOCH</code>.</p> <p>This timestamp is to be used for embedding in output files, so that builds can be made reproducible.</p> Source code in <code>src/robot/libdocpkg/output.py</code> <pre><code>def get_generation_time():\n    \"\"\"Return a timestamp that honors `SOURCE_DATE_EPOCH`.\n\n    This timestamp is to be used for embedding in output files, so\n    that builds can be made reproducible.\n    \"\"\"\n    ts = float(os.getenv('SOURCE_DATE_EPOCH', time.time()))\n    dt = datetime.datetime.fromtimestamp(round(ts), datetime.timezone.utc)\n    return dt.isoformat()\n</code></pre>"},{"location":"api/robot/libdocpkg/robotbuilder/","title":"robot.libdocpkg.robotbuilder","text":""},{"location":"api/robot/libdocpkg/robotbuilder/#robot.libdocpkg.robotbuilder","title":"robot.libdocpkg.robotbuilder","text":""},{"location":"api/robot/libdocpkg/standardtypes/","title":"robot.libdocpkg.standardtypes","text":""},{"location":"api/robot/libdocpkg/standardtypes/#robot.libdocpkg.standardtypes","title":"robot.libdocpkg.standardtypes","text":""},{"location":"api/robot/libdocpkg/writer/","title":"robot.libdocpkg.writer","text":""},{"location":"api/robot/libdocpkg/writer/#robot.libdocpkg.writer","title":"robot.libdocpkg.writer","text":""},{"location":"api/robot/libdocpkg/xmlbuilder/","title":"robot.libdocpkg.xmlbuilder","text":""},{"location":"api/robot/libdocpkg/xmlbuilder/#robot.libdocpkg.xmlbuilder","title":"robot.libdocpkg.xmlbuilder","text":""},{"location":"api/robot/libdocpkg/xmlwriter/","title":"robot.libdocpkg.xmlwriter","text":""},{"location":"api/robot/libdocpkg/xmlwriter/#robot.libdocpkg.xmlwriter","title":"robot.libdocpkg.xmlwriter","text":""},{"location":"api/robot/libraries/","title":"robot.libraries","text":""},{"location":"api/robot/libraries/#robot.libraries","title":"robot.libraries","text":"<p>Package hosting Robot Framework standard test libraries.</p> <p>Libraries are mainly used externally in the test data, but they can be also used by custom test libraries if there is a need. Especially the :class:<code>~robot.libraries.BuiltIn.BuiltIn</code> library is often useful when there is a need to interact with the framework.</p> <p>Because libraries are documented using Robot Framework's own documentation syntax, the generated API docs are not that well formed. It is thus better to find the generated library documentations, for example, via the http://robotframework.org web site.</p>"},{"location":"api/robot/libraries/BuiltIn/","title":"robot.libraries.BuiltIn","text":""},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn","title":"robot.libraries.BuiltIn","text":""},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn","title":"BuiltIn","text":"<p>               Bases: <code>_Verify</code>, <code>_Converter</code>, <code>_Variables</code>, <code>_RunKeyword</code>, <code>_Control</code>, <code>_Misc</code></p> <p>An always available standard library with often needed keywords.</p> <p><code>BuiltIn</code> is Robot Framework's standard library that provides a set of generic keywords needed often. It is imported automatically and thus always available. The provided keywords can be used, for example, for verifications (e.g. <code>Should Be Equal</code>, <code>Should Contain</code>), conversions (e.g. <code>Convert To Integer</code>) and for various other purposes (e.g. <code>Log</code>, <code>Sleep</code>, <code>Run Keyword If</code>, <code>Set Global Variable</code>).</p> <p>== Table of contents ==</p> <p>%TOC%</p> <p>= HTML error messages =</p> <p>Many of the keywords accept an optional error message to use if the keyword fails, and it is possible to use HTML in these messages by prefixing them with <code>*HTML*</code>. See <code>Fail</code> keyword for a usage example. Notice that using HTML in messages is not limited to BuiltIn library but works with any error message.</p> <p>= Evaluating expressions =</p> <p>Many keywords, such as <code>Evaluate</code>, <code>Run Keyword If</code> and <code>Should Be True</code>, accept an expression that is evaluated in Python.</p> <p>== Evaluation namespace ==</p> <p>Expressions are evaluated using Python's [http://docs.python.org/library/functions.html#eval|eval] function so that all Python built-ins like <code>len()</code> and <code>int()</code> are available. In addition to that, all unrecognized variables are considered to be modules that are automatically imported. It is possible to use all available Python modules, including the standard modules and the installed third party modules.</p> <p>Examples: | <code>Should Be True</code>    len('${result}') &gt; 3 | <code>Run Keyword If</code>    os.sep == '/'    Non-Windows Keyword | ${version} =    <code>Evaluate</code>    robot.version</p> <p><code>Evaluate</code> also allows configuring the execution namespace with a custom namespace and with custom modules to be imported. The latter functionality is useful in special cases where the automatic module import does not work such as when using nested modules like <code>rootmod.submod</code> or list comprehensions. See the documentation of the <code>Evaluate</code> keyword for mode details.</p> <p>== Variables in expressions ==</p> <p>When a variable is used in the expressing using the normal <code>${variable}</code> syntax, its value is replaced before the expression is evaluated. This means that the value used in the expression will be the string representation of the variable value, not the variable value itself. This is not a problem with numbers and other objects that have a string representation that can be evaluated directly, but with other objects the behavior depends on the string representation. Most importantly, strings must always be quoted, and if they can contain newlines, they must be triple quoted.</p> <p>Examples: | <code>Should Be True</code>    ${rc} &lt; 10                   Return code greater than 10 | <code>Run Keyword If</code>    '${status}' == 'PASS'        Log    Passed | <code>Run Keyword If</code>    'FAIL' in '''${output}'''    Log    Output contains FAIL</p> <p>Actual variables values are also available in the evaluation namespace. They can be accessed using special variable syntax without the curly braces like <code>$variable</code>. These variables should never be quoted.</p> <p>Examples: | <code>Should Be True</code>    $rc &lt; 10             Return code greater than 10 | <code>Run Keyword If</code>    $status == 'PASS'    <code>Log</code>    Passed | <code>Run Keyword If</code>    'FAIL' in $output    <code>Log</code>    Output contains FAIL | <code>Should Be True</code>    len($result) &gt; 1 and $result[1] == 'OK' | <code>Should Be True</code>    $result is not None</p> <p>Using the <code>$variable</code> syntax slows down expression evaluation a little. This should not typically matter, but should be taken into account if complex expressions are evaluated often and there are strict time constrains.</p> <p>Notice that instead of creating complicated expressions, it is often better to move the logic into a library. That eases maintenance and can also enhance execution speed.</p> <p>= Using variables with keywords creating or accessing variables =</p> <p>This library has special keywords <code>Set Global Variable</code>, <code>Set Suite Variable</code>, <code>Set Test Variable</code> and <code>Set Local Variable</code> for creating variables in different scopes. These keywords take the variable name and its value as arguments. The name can be given using the normal <code>${variable}</code> syntax or in escaped format either like <code>$variable</code> or <code>\\${variable}</code>. For example, these are typically equivalent and create new suite level variable <code>${name}</code> with value <code>value</code>:</p> <p>| Set Suite Variable    ${name}     value | Set Suite Variable    $name       value | Set Suite Variable    \\${name}    value</p> <p>A problem with using the normal <code>${variable}</code> syntax is that these keywords cannot easily know is the idea to create a variable with exactly that name or does that variable actually contain the name of the variable to create. If the variable does not initially exist, it will always be created. If it exists and its value is a variable name either in the normal or in the escaped syntax, variable with that name is created instead. For example, if <code>${name}</code> variable would exist and contain value <code>$example</code>, these examples would create different variables:</p> <p>| Set Suite Variable    ${name}     value    # Creates ${example}. | Set Suite Variable    $name       value    # Creates ${name}. | Set Suite Variable    \\${name}    value    # Creates ${name}.</p> <p>Because the behavior when using the normal <code>${variable}</code> syntax depends on the possible existing value of the variable, it is highly recommended to use the escaped <code>$variable</code> or <code>\\${variable}</code> format instead.</p> <p>This same problem occurs also with special keywords for accessing variables <code>Get Variable Value</code>, <code>Variable Should Exist</code> and <code>Variable Should Not Exist</code>.</p> <p>NOTE: It is recommended to use the <code>VAR</code> syntax introduced in Robot Framework 7.0 for creating variables in different scopes instead of the <code>Set Global/Suite/Test/Local Variable</code> keywords. It makes creating variables uniform and avoids all the problems discussed above.</p> <p>= Boolean arguments =</p> <p>Some keywords accept arguments that are handled as Boolean values true or false. If such an argument is given as a string, it is considered false if it is an empty string or equal to <code>FALSE</code>, <code>NONE</code>, <code>NO</code>, <code>OFF</code> or <code>0</code>, case-insensitively. Keywords verifying something that allow dropping actual and expected values from the possible error message also consider string <code>no values</code> to be false. Other strings are considered true unless the keyword documentation explicitly states otherwise, and other argument types are tested using the same [http://docs.python.org/library/stdtypes.html#truth|rules as in Python].</p> <p>True examples: | <code>Should Be Equal</code>    ${x}    ${y}    Custom error    values=True         # Strings are generally true. | <code>Should Be Equal</code>    ${x}    ${y}    Custom error    values=yes          # Same as the above. | <code>Should Be Equal</code>    ${x}    ${y}    Custom error    values=${TRUE}      # Python <code>True</code> is true. | <code>Should Be Equal</code>    ${x}    ${y}    Custom error    values=${42}        # Numbers other than 0 are true.</p> <p>False examples: | <code>Should Be Equal</code>    ${x}    ${y}    Custom error    values=False        # String <code>false</code> is false. | <code>Should Be Equal</code>    ${x}    ${y}    Custom error    values=no           # Also string <code>no</code> is false. | <code>Should Be Equal</code>    ${x}    ${y}    Custom error    values=${EMPTY}     # Empty string is false. | <code>Should Be Equal</code>    ${x}    ${y}    Custom error    values=${FALSE}     # Python <code>False</code> is false. | <code>Should Be Equal</code>    ${x}    ${y}    Custom error    values=no values    # <code>no values</code> works with <code>values</code> argument</p> <p>= Pattern matching =</p> <p>Many keywords accept arguments as either glob or regular expression patterns.</p> <p>== Glob patterns ==</p> <p>Some keywords, for example <code>Should Match</code>, support so called [http://en.wikipedia.org/wiki/Glob_(programming)|glob patterns] where:</p> <p>| <code>*</code>        | matches any string, even an empty string                | | <code>?</code>        | matches any single character                            | | <code>[chars]</code>  | matches one character in the bracket                    | | <code>[!chars]</code> | matches one character not in the bracket                | | <code>[a-z]</code>    | matches one character from the range in the bracket     | | <code>[!a-z]</code>   | matches one character not from the range in the bracket |</p> <p>Unlike with glob patterns normally, path separator characters <code>/</code> and <code>\\</code> and the newline character <code>\\n</code> are matches by the above wildcards.</p> <p>== Regular expressions ==</p> <p>Some keywords, for example <code>Should Match Regexp</code>, support [http://en.wikipedia.org/wiki/Regular_expression|regular expressions] that are more powerful but also more complicated that glob patterns. The regular expression support is implemented using Python's [http://docs.python.org/library/re.html|re module] and its documentation should be consulted for more information about the syntax.</p> <p>Because the backslash character (<code>\\</code>) is an escape character in Robot Framework test data, possible backslash characters in regular expressions need to be escaped with another backslash like <code>\\\\d\\\\w+</code>. Strings that may contain special characters but should be handled as literal strings, can be escaped with the <code>Regexp Escape</code> keyword.</p> <p>= Multiline string comparison =</p> <p><code>Should Be Equal</code> and <code>Should Be Equal As Strings</code> report the failures using [http://en.wikipedia.org/wiki/Diff_utility#Unified_format|unified diff format] if both strings have more than two lines.</p> <p>Example: | ${first} =     <code>Catenate</code>    SEPARATOR=\\n    Not in second    Same    Differs    Same | ${second} =    <code>Catenate</code>    SEPARATOR=\\n    Same    Differs2    Same    Not in first | <code>Should Be Equal</code>    ${first}    ${second}</p> <p>Results in the following error message:</p> <p>| Multiline strings are different: | --- first | +++ second | @@ -1,4 +1,4 @@ | -Not in second |  Same | -Differs | +Differs2 |  Same | +Not in first</p> <p>= String representations =</p> <p>Several keywords log values explicitly (e.g. <code>Log</code>) or implicitly (e.g. <code>Should Be Equal</code> when there are failures). By default, keywords log values using human-readable string representation, which means that strings like <code>Hello</code> and numbers like <code>42</code> are logged as-is. Most of the time this is the desired behavior, but there are some problems as well:</p> <ul> <li> <p>It is not possible to see difference between different objects that   have the same string representation like string <code>42</code> and integer <code>42</code>.   <code>Should Be Equal</code> and some other keywords add the type information to   the error message in these cases, though.</p> </li> <li> <p>Non-printable characters such as the null byte are not visible.</p> </li> <li> <p>Trailing whitespace is not visible.</p> </li> <li> <p>Different newlines (<code>\\r\\n</code> on Windows, <code>\\n</code> elsewhere) cannot   be separated from each others.</p> </li> <li> <p>There are several Unicode characters that are different but look the   same. One example is the Latin <code>a</code> (<code>\\u0061</code>) and the Cyrillic   <code>\u0430</code> (<code>\\u0430</code>). Error messages like <code>a != \u0430</code> are not very helpful.</p> </li> <li> <p>Some Unicode characters can be represented using   [https://en.wikipedia.org/wiki/Unicode_equivalence|different forms].   For example, <code>\u00e4</code> can be represented either as a single code point   <code>\\u00e4</code> or using two combined code points <code>\\u0061</code> and <code>\\u0308</code>.   Such forms are considered canonically equivalent, but strings   containing them are not considered equal when compared in Python. Error   messages like <code>\u00e4 != \u00e4</code> are not that helpful either.</p> </li> <li> <p>Containers such as lists and dictionaries are formatted into a single   line making it hard to see individual items they contain.</p> </li> </ul> <p>To overcome the above problems, some keywords such as <code>Log</code> and <code>Should Be Equal</code> have an optional <code>formatter</code> argument that can be used to configure the string representation. The supported values are <code>str</code> (default), <code>repr</code>, and <code>ascii</code> that work similarly as [https://docs.python.org/library/functions.html|Python built-in functions] with same names. More detailed semantics are explained below.</p> <p>== str ==</p> <p>Use the human-readable string representation. Equivalent to using <code>str()</code> in Python. This is the default.</p> <p>== repr ==</p> <p>Use the machine-readable string representation. Similar to using <code>repr()</code> in Python, which means that strings like <code>Hello</code> are logged like <code>'Hello'</code>, newlines and non-printable characters are escaped like <code>\\n</code> and <code>\\x00</code>, and so on. Non-ASCII characters are shown as-is like <code>\u00e4</code>.</p> <p>In this mode bigger lists, dictionaries and other containers are pretty-printed so that there is one item per row.</p> <p>== ascii ==</p> <p>Same as using <code>ascii()</code> in Python. Similar to using <code>repr</code> explained above but with the following differences:</p> <ul> <li>Non-ASCII characters are escaped like <code>\\xe4</code> instead of   showing them as-is like <code>\u00e4</code>. This makes it easier to see differences   between Unicode characters that look the same but are not equal.</li> <li>Containers are not pretty-printed.</li> </ul>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.robot_running","title":"robot_running  <code>property</code>","text":"<pre><code>robot_running: bool\n</code></pre> <p>Return True/False depending on is Robot Framework running or not.</p> <p>Can be used by libraries and other extensions.</p> <p>New in Robot Framework 6.1.</p>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.dry_run_active","title":"dry_run_active  <code>property</code>","text":"<pre><code>dry_run_active: bool\n</code></pre> <p>Return True/False depending on is dry-run active or not.</p> <p>Can be used by libraries and other extensions. Notice that library keywords are not run at all in dry-run, but library <code>__init__</code> can utilize this information.</p> <p>New in Robot Framework 6.1.</p>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.no_operation","title":"no_operation","text":"<pre><code>no_operation()\n</code></pre> <p>Does absolutely nothing.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def no_operation(self):\n    \"\"\"Does absolutely nothing.\"\"\"\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.sleep","title":"sleep","text":"<pre><code>sleep(time_, reason=None)\n</code></pre> <p>Pauses the test executed for the given time.</p> <p><code>time</code> may be either a number or a time string. Time strings are in a format such as <code>1 day 2 hours 3 minutes 4 seconds 5milliseconds</code> or <code>1d 2h 3m 4s 5ms</code>, and they are fully explained in an appendix of Robot Framework User Guide. Providing a value without specifying minutes or seconds, defaults to seconds. Optional <code>reason</code> can be used to explain why sleeping is necessary. Both the time slept and the reason are logged.</p> <p>Examples: | Sleep | 42                   | | Sleep | 1.5                  | | Sleep | 2 minutes 10 seconds | | Sleep | 10s                  | Wait for a reply |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def sleep(self, time_, reason=None):\n    \"\"\"Pauses the test executed for the given time.\n\n    ``time`` may be either a number or a time string. Time strings are in\n    a format such as ``1 day 2 hours 3 minutes 4 seconds 5milliseconds`` or\n    ``1d 2h 3m 4s 5ms``, and they are fully explained in an appendix of\n    Robot Framework User Guide. Providing a value without specifying minutes\n    or seconds, defaults to seconds.\n    Optional `reason` can be used to explain why\n    sleeping is necessary. Both the time slept and the reason are logged.\n\n    Examples:\n    | Sleep | 42                   |\n    | Sleep | 1.5                  |\n    | Sleep | 2 minutes 10 seconds |\n    | Sleep | 10s                  | Wait for a reply |\n    \"\"\"\n    seconds = timestr_to_secs(time_)\n    # Python hangs with negative values\n    if seconds &lt; 0:\n        seconds = 0\n    self._sleep_in_parts(seconds)\n    self.log(f'Slept {secs_to_timestr(seconds)}.')\n    if reason:\n        self.log(reason)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.catenate","title":"catenate","text":"<pre><code>catenate(*items)\n</code></pre> <p>Catenates the given items together and returns the resulted string.</p> <p>By default, items are catenated with spaces, but if the first item contains the string <code>SEPARATOR=&lt;sep&gt;</code>, the separator <code>&lt;sep&gt;</code> is used instead. Items are converted into strings when necessary.</p> <p>Examples: | ${str1} = | Catenate | Hello         | world |       | | ${str2} = | Catenate | SEPARATOR=--- | Hello | world | | ${str3} = | Catenate | SEPARATOR=    | Hello | world | =&gt; | ${str1} = 'Hello world' | ${str2} = 'Hello---world' | ${str3} = 'Helloworld'</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def catenate(self, *items):\n    \"\"\"Catenates the given items together and returns the resulted string.\n\n    By default, items are catenated with spaces, but if the first item\n    contains the string ``SEPARATOR=&lt;sep&gt;``, the separator ``&lt;sep&gt;`` is\n    used instead. Items are converted into strings when necessary.\n\n    Examples:\n    | ${str1} = | Catenate | Hello         | world |       |\n    | ${str2} = | Catenate | SEPARATOR=--- | Hello | world |\n    | ${str3} = | Catenate | SEPARATOR=    | Hello | world |\n    =&gt;\n    | ${str1} = 'Hello world'\n    | ${str2} = 'Hello---world'\n    | ${str3} = 'Helloworld'\n    \"\"\"\n    if not items:\n        return ''\n    items = [str(item) for item in items]\n    if items[0].startswith('SEPARATOR='):\n        sep = items[0][len('SEPARATOR='):]\n        items = items[1:]\n    else:\n        sep = ' '\n    return sep.join(items)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.log","title":"log","text":"<pre><code>log(\n    message,\n    level=\"INFO\",\n    html=False,\n    console=False,\n    repr=\"DEPRECATED\",\n    formatter=\"str\",\n)\n</code></pre> <p>Logs the given message with the given level.</p> <p>Valid levels are TRACE, DEBUG, INFO (default), WARN and ERROR. In addition to that, there are pseudo log levels HTML and CONSOLE that both log messages using INFO.</p> <p>Messages below the current active log level are ignored. See <code>Set Log Level</code> keyword and <code>--loglevel</code> command line option for more details about setting the level.</p> <p>Messages logged with the WARN or ERROR levels are automatically visible also in the console and in the Test Execution Errors section in the log file.</p> <p>If the <code>html</code> argument is given a true value (see <code>Boolean arguments</code>) or the HTML pseudo log level is used, the message is considered to be HTML and special characters such as <code>&lt;</code> are not escaped. For example, logging <code>&lt;img src=\"image.png\"&gt;</code> creates an image in this case, but otherwise the message is that exact string. When using the HTML pseudo level, the messages is logged using the INFO level.</p> <p>If the <code>console</code> argument is true or the CONSOLE pseudo level is used, the message is written both to the console and to the log file. When using the CONSOLE pseudo level, the message is logged using the INFO level. If the message should not be logged to the log file or there are special formatting needs, use the <code>Log To Console</code> keyword instead.</p> <p>The <code>formatter</code> argument controls how to format the string representation of the message. Possible values are <code>str</code> (default), <code>repr</code>, <code>ascii</code>, <code>len</code>, and <code>type</code>. They work similarly to Python built-in functions with same names. When using <code>repr</code>, bigger lists, dictionaries and other containers are also pretty-printed so that there is one item per row. For more details see <code>String representations</code>.</p> <p>The old way to control string representation was using the <code>repr</code> argument. This argument has been deprecated and <code>formatter=repr</code> should be used instead.</p> <p>Examples: | Log | Hello, world!        |          |   | # Normal INFO message.   | | Log | Warning, world!      | WARN     |   | # Warning.               | | Log | Hello, world! | html=yes |   | # INFO message as HTML.  | | Log | Hello, world! | HTML     |   | # Same as above.         | | Log | Hello, world! | DEBUG    | html=true | # DEBUG as HTML. | | Log | Hello, console!   | console=yes | | # Log also to the console. | | Log | Hello, console!   | CONSOLE     | | # Log also to the console. | | Log | Null is \\x00    | formatter=repr | | # Log <code>'Null is \\x00'</code>. |</p> <p>See <code>Log Many</code> if you want to log multiple messages in one go, and <code>Log To Console</code> if you only want to write to the console.</p> <p>Formatter options <code>type</code> and <code>len</code> are new in Robot Framework 5.0. The CONSOLE level is new in Robot Framework 6.1.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def log(self, message, level='INFO', html=False, console=False,\n        repr='DEPRECATED', formatter='str'):\n    r\"\"\"Logs the given message with the given level.\n\n    Valid levels are TRACE, DEBUG, INFO (default), WARN and ERROR.\n    In addition to that, there are pseudo log levels HTML and CONSOLE that\n    both log messages using INFO.\n\n    Messages below the current active log\n    level are ignored. See `Set Log Level` keyword and ``--loglevel``\n    command line option for more details about setting the level.\n\n    Messages logged with the WARN or ERROR levels are automatically\n    visible also in the console and in the Test Execution Errors section\n    in the log file.\n\n    If the ``html`` argument is given a true value (see `Boolean\n    arguments`) or the HTML pseudo log level is used, the message is\n    considered to be HTML and special characters\n    such as ``&lt;`` are not escaped. For example, logging\n    ``&lt;img src=\"image.png\"&gt;`` creates an image in this case, but\n    otherwise the message is that exact string. When using the HTML pseudo\n    level, the messages is logged using the INFO level.\n\n    If the ``console`` argument is true or the CONSOLE pseudo level is\n    used, the message is written both to the console and to the log file.\n    When using the CONSOLE pseudo level, the message is logged using the\n    INFO level. If the message should not be logged to the log file or there\n    are special formatting needs, use the `Log To Console` keyword instead.\n\n    The ``formatter`` argument controls how to format the string\n    representation of the message. Possible values are ``str`` (default),\n    ``repr``, ``ascii``, ``len``, and ``type``. They work similarly to\n    Python built-in functions with same names. When using ``repr``, bigger\n    lists, dictionaries and other containers are also pretty-printed so\n    that there is one item per row. For more details see `String\n    representations`.\n\n    The old way to control string representation was using the ``repr``\n    argument. This argument has been deprecated and ``formatter=repr``\n    should be used instead.\n\n    Examples:\n    | Log | Hello, world!        |          |   | # Normal INFO message.   |\n    | Log | Warning, world!      | WARN     |   | # Warning.               |\n    | Log | &lt;b&gt;Hello&lt;/b&gt;, world! | html=yes |   | # INFO message as HTML.  |\n    | Log | &lt;b&gt;Hello&lt;/b&gt;, world! | HTML     |   | # Same as above.         |\n    | Log | &lt;b&gt;Hello&lt;/b&gt;, world! | DEBUG    | html=true | # DEBUG as HTML. |\n    | Log | Hello, console!   | console=yes | | # Log also to the console. |\n    | Log | Hello, console!   | CONSOLE     | | # Log also to the console. |\n    | Log | Null is \\x00    | formatter=repr | | # Log ``'Null is \\x00'``. |\n\n    See `Log Many` if you want to log multiple messages in one go, and\n    `Log To Console` if you only want to write to the console.\n\n    Formatter options ``type`` and ``len`` are new in Robot Framework 5.0.\n    The CONSOLE level is new in Robot Framework 6.1.\n    \"\"\"\n    # TODO: Remove `repr` altogether in RF 7.0. It was deprecated in RF 5.0.\n    if repr == 'DEPRECATED':\n        formatter = self._get_formatter(formatter)\n    else:\n        logger.warn(\"The 'repr' argument of 'BuiltIn.Log' is deprecated. \"\n                    \"Use 'formatter=repr' instead.\")\n        formatter = prepr if is_truthy(repr) else self._get_formatter(formatter)\n    message = formatter(message)\n    logger.write(message, level, html)\n    if console:\n        logger.console(message)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.log_many","title":"log_many","text":"<pre><code>log_many(*messages)\n</code></pre> <p>Logs the given messages as separate entries using the INFO level.</p> <p>Supports also logging list and dictionary variable items individually.</p> <p>Examples: | Log Many | Hello   | ${var}  | | Log Many | @{list} | &amp;{dict} |</p> <p>See <code>Log</code> and <code>Log To Console</code> keywords if you want to use alternative log levels, use HTML, or log to the console.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef log_many(self, *messages):\n    \"\"\"Logs the given messages as separate entries using the INFO level.\n\n    Supports also logging list and dictionary variable items individually.\n\n    Examples:\n    | Log Many | Hello   | ${var}  |\n    | Log Many | @{list} | &amp;{dict} |\n\n    See `Log` and `Log To Console` keywords if you want to use alternative\n    log levels, use HTML, or log to the console.\n    \"\"\"\n    for msg in self._yield_logged_messages(messages):\n        self.log(msg)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.log_to_console","title":"log_to_console","text":"<pre><code>log_to_console(\n    message, stream=\"STDOUT\", no_newline=False, format=\"\"\n)\n</code></pre> <p>Logs the given message to the console.</p> <p>By default uses the standard output stream. Using the standard error stream is possible by giving the <code>stream</code> argument value <code>STDERR</code> (case-insensitive).</p> <p>By default appends a newline to the logged message. This can be disabled by giving the <code>no_newline</code> argument a true value (see <code>Boolean arguments</code>).</p> <p>By default adds no alignment formatting. The <code>format</code> argument allows, for example, alignment and customized padding of the log message. Please see the [https://docs.python.org/3/library/string.html#formatspec|format specification] for detailed alignment possibilities. This argument is new in Robot Framework 5.0.</p> <p>Examples: | Log To Console | Hello, console!             |                 | | Log To Console | Hello, stderr!              | STDERR          | | Log To Console | Message starts here and is  | no_newline=true | | Log To Console | continued without newline.  |                 | | Log To Console | center message with * pad   | format=*^60     | | Log To Console | 30 spaces before msg starts | format=&gt;30      |</p> <p>This keyword does not log the message to the normal log file. Use <code>Log</code> keyword, possibly with argument <code>console</code>, if that is desired.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def log_to_console(self, message, stream='STDOUT', no_newline=False, format=''):\n    \"\"\"Logs the given message to the console.\n\n    By default uses the standard output stream. Using the standard error\n    stream is possible by giving the ``stream`` argument value ``STDERR``\n    (case-insensitive).\n\n    By default appends a newline to the logged message. This can be\n    disabled by giving the ``no_newline`` argument a true value (see\n    `Boolean arguments`).\n\n    By default adds no alignment formatting. The ``format`` argument allows,\n    for example, alignment and customized padding of the log message. Please see the\n    [https://docs.python.org/3/library/string.html#formatspec|format specification] for\n    detailed alignment possibilities. This argument is new in Robot\n    Framework 5.0.\n\n    Examples:\n    | Log To Console | Hello, console!             |                 |\n    | Log To Console | Hello, stderr!              | STDERR          |\n    | Log To Console | Message starts here and is  | no_newline=true |\n    | Log To Console | continued without newline.  |                 |\n    | Log To Console | center message with * pad   | format=*^60     |\n    | Log To Console | 30 spaces before msg starts | format=&gt;30      |\n\n    This keyword does not log the message to the normal log file. Use\n    `Log` keyword, possibly with argument ``console``, if that is desired.\n    \"\"\"\n    if format:\n        format = \"{:\" + format + \"}\"\n        message = format.format(message)\n    logger.console(message, newline=is_falsy(no_newline), stream=stream)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.comment","title":"comment","text":"<pre><code>comment(*messages)\n</code></pre> <p>Displays the given messages in the log file as keyword arguments.</p> <p>This keyword does nothing with the arguments it receives, but as they are visible in the log, this keyword can be used to display simple messages. Given arguments are ignored so thoroughly that they can even contain non-existing variables. If you are interested about variable values, you can use the <code>Log</code> or <code>Log Many</code> keywords.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef comment(self, *messages):\n    \"\"\"Displays the given messages in the log file as keyword arguments.\n\n    This keyword does nothing with the arguments it receives, but as they\n    are visible in the log, this keyword can be used to display simple\n    messages. Given arguments are ignored so thoroughly that they can even\n    contain non-existing variables. If you are interested about variable\n    values, you can use the `Log` or `Log Many` keywords.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_log_level","title":"set_log_level","text":"<pre><code>set_log_level(level)\n</code></pre> <p>Sets the log threshold to the specified level.</p> <p>Messages below the level will not logged. The default logging level is INFO, but it can be overridden with the <code>--loglevel</code> command line option. The available levels are TRACE, DEBUG, INFO (default), WARN, ERROR and NONE (no logging).</p> <p>The old level is returned and can be used for setting the level back later. An alternative way to reset the level is using the dedicated <code>Reset Log Level</code> keyword.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def set_log_level(self, level):\n    \"\"\"Sets the log threshold to the specified level.\n\n    Messages below the level will not logged. The default logging level is\n    INFO, but it can be overridden with the ``--loglevel`` command line option.\n    The available levels are TRACE, DEBUG, INFO (default), WARN, ERROR and NONE\n    (no logging).\n\n    The old level is returned and can be used for setting the level back\n    later. An alternative way to reset the level is using the dedicated\n    `Reset Log Level` keyword.\n    \"\"\"\n    old = self._context.output.set_log_level(level)\n    self._namespace.variables.set_global('${LOG_LEVEL}', level.upper())\n    self.log(f'Log level changed from {old} to {level.upper()}.', level='DEBUG')\n    return old\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.reset_log_level","title":"reset_log_level","text":"<pre><code>reset_log_level()\n</code></pre> <p>Resets the log level to the original value.</p> <p>The original log level is set from the command line with the <code>--loglevel</code> option and is INFO by default. The active log level can be changed using the <code>Set Log Level</code> keyword.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def reset_log_level(self):\n    \"\"\"Resets the log level to the original value.\n\n    The original log level is set from the command line with the ``--loglevel``\n    option and is INFO by default. The active log level can be changed using\n    the `Set Log Level` keyword.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    level = self._context.output.initial_log_level\n    return self.set_log_level(level)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.reload_library","title":"reload_library","text":"<pre><code>reload_library(name_or_instance)\n</code></pre> <p>Rechecks what keywords the specified library provides.</p> <p>Can be called explicitly in the test data or by a library itself when keywords it provides have changed.</p> <p>The library can be specified by its name or as the active instance of the library. The latter is especially useful if the library itself calls this keyword as a method.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def reload_library(self, name_or_instance):\n    \"\"\"Rechecks what keywords the specified library provides.\n\n    Can be called explicitly in the test data or by a library itself\n    when keywords it provides have changed.\n\n    The library can be specified by its name or as the active instance of\n    the library. The latter is especially useful if the library itself\n    calls this keyword as a method.\n    \"\"\"\n    lib = self._namespace.reload_library(name_or_instance)\n    self.log(f'Reloaded library {lib.name} with {len(lib.keywords)} keywords.')\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.import_library","title":"import_library","text":"<pre><code>import_library(name, *args)\n</code></pre> <p>Imports a library with the given name and optional arguments.</p> <p>This functionality allows dynamic importing of libraries while tests are running. That may be necessary, if the library itself is dynamic and not yet available when test data is processed. In a normal case, libraries should be imported using the Library setting in the Setting section.</p> <p>This keyword supports importing libraries both using library names and physical paths. When paths are used, they must be given in absolute format or found from [http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#module-search-path| search path]. Forward slashes can be used as path separators in all operating systems.</p> <p>It is possible to pass arguments to the imported library and also named argument syntax works if the library supports it. <code>AS</code> syntax can be used to give a custom name to the imported library.</p> <p>Examples: | Import Library | MyLibrary | | Import Library | ${CURDIR}/Lib.py | arg1 | named=arg2 | AS | Custom |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef import_library(self, name, *args):\n    \"\"\"Imports a library with the given name and optional arguments.\n\n    This functionality allows dynamic importing of libraries while tests\n    are running. That may be necessary, if the library itself is dynamic\n    and not yet available when test data is processed. In a normal case,\n    libraries should be imported using the Library setting in the Setting\n    section.\n\n    This keyword supports importing libraries both using library\n    names and physical paths. When paths are used, they must be\n    given in absolute format or found from\n    [http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#module-search-path|\n    search path]. Forward slashes can be used as path separators in all\n    operating systems.\n\n    It is possible to pass arguments to the imported library and also\n    named argument syntax works if the library supports it. ``AS``\n    syntax can be used to give a custom name to the imported library.\n\n    Examples:\n    | Import Library | MyLibrary |\n    | Import Library | ${CURDIR}/Lib.py | arg1 | named=arg2 | AS | Custom |\n    \"\"\"\n    args, alias = self._split_alias(args)\n    try:\n        self._namespace.import_library(name, args, alias)\n    except DataError as err:\n        raise RuntimeError(str(err))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.import_variables","title":"import_variables","text":"<pre><code>import_variables(path, *args)\n</code></pre> <p>Imports a variable file with the given path and optional arguments.</p> <p>Variables imported with this keyword are set into the test suite scope similarly when importing them in the Setting table using the Variables setting. These variables override possible existing variables with the same names. This functionality can thus be used to import new variables, for example, for each test in a test suite.</p> <p>The given path must be absolute or found from [http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html##module-search-path|search path]. Forward slashes can be used as path separator regardless the operating system.</p> <p>Examples: | Import Variables | ${CURDIR}/variables.py   |      |      | | Import Variables | ${CURDIR}/../vars/env.py | arg1 | arg2 | | Import Variables | file_from_pythonpath.py  |      |      |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef import_variables(self, path, *args):\n    \"\"\"Imports a variable file with the given path and optional arguments.\n\n    Variables imported with this keyword are set into the test suite scope\n    similarly when importing them in the Setting table using the Variables\n    setting. These variables override possible existing variables with\n    the same names. This functionality can thus be used to import new\n    variables, for example, for each test in a test suite.\n\n    The given path must be absolute or found from\n    [http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html##module-search-path|search path].\n    Forward slashes can be used as path separator regardless\n    the operating system.\n\n    Examples:\n    | Import Variables | ${CURDIR}/variables.py   |      |      |\n    | Import Variables | ${CURDIR}/../vars/env.py | arg1 | arg2 |\n    | Import Variables | file_from_pythonpath.py  |      |      |\n    \"\"\"\n    try:\n        self._namespace.import_variables(path, list(args), overwrite=True)\n    except DataError as err:\n        raise RuntimeError(str(err))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.import_resource","title":"import_resource","text":"<pre><code>import_resource(path)\n</code></pre> <p>Imports a resource file with the given path.</p> <p>Resources imported with this keyword are set into the test suite scope similarly when importing them in the Setting table using the Resource setting.</p> <p>The given path must be absolute or found from [http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#module-search-path|search path]. Forward slashes can be used as path separator regardless the operating system.</p> <p>Examples: | Import Resource | ${CURDIR}/resource.txt | | Import Resource | ${CURDIR}/../resources/resource.html | | Import Resource | found_from_pythonpath.robot |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef import_resource(self, path):\n    \"\"\"Imports a resource file with the given path.\n\n    Resources imported with this keyword are set into the test suite scope\n    similarly when importing them in the Setting table using the Resource\n    setting.\n\n    The given path must be absolute or found from\n    [http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#module-search-path|search path].\n    Forward slashes can be used as path separator regardless\n    the operating system.\n\n    Examples:\n    | Import Resource | ${CURDIR}/resource.txt |\n    | Import Resource | ${CURDIR}/../resources/resource.html |\n    | Import Resource | found_from_pythonpath.robot |\n    \"\"\"\n    try:\n        self._namespace.import_resource(path)\n    except DataError as err:\n        raise RuntimeError(str(err))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_library_search_order","title":"set_library_search_order","text":"<pre><code>set_library_search_order(*search_order)\n</code></pre> <p>Sets the resolution order to use when a name matches multiple keywords.</p> <p>The library search order is used to resolve conflicts when a keyword name that is used matches multiple keyword implementations. The first library (or resource, see below) containing the keyword is selected and that keyword implementation used. If the keyword is not found from any library (or resource), execution fails the same way as when the search order is not set.</p> <p>When this keyword is used, there is no need to use the long <code>LibraryName.Keyword Name</code> notation.  For example, instead of having</p> <p>| MyLibrary.Keyword | arg | | MyLibrary.Another Keyword | | MyLibrary.Keyword | xxx |</p> <p>you can have</p> <p>| Set Library Search Order | MyLibrary | | Keyword | arg | | Another Keyword | | Keyword | xxx |</p> <p>This keyword can be used also to set the order of keywords in different resource files. In this case resource names must be given without paths or extensions like:</p> <p>| Set Library Search Order | resource | another_resource |</p> <p>NOTE: - The search order is valid only in the suite where this keyword is used. - Keywords in resources always have higher priority than   keywords in libraries regardless the search order. - The old order is returned and can be used to reset the search order later. - Calling this keyword without arguments removes possible search order. - Library and resource names in the search order are both case and space   insensitive.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def set_library_search_order(self, *search_order):\n    \"\"\"Sets the resolution order to use when a name matches multiple keywords.\n\n    The library search order is used to resolve conflicts when a keyword name\n    that is used matches multiple keyword implementations. The first library\n    (or resource, see below) containing the keyword is selected and that\n    keyword implementation used. If the keyword is not found from any library\n    (or resource), execution fails the same way as when the search order is\n    not set.\n\n    When this keyword is used, there is no need to use the long\n    ``LibraryName.Keyword Name`` notation.  For example, instead of\n    having\n\n    | MyLibrary.Keyword | arg |\n    | MyLibrary.Another Keyword |\n    | MyLibrary.Keyword | xxx |\n\n    you can have\n\n    | Set Library Search Order | MyLibrary |\n    | Keyword | arg |\n    | Another Keyword |\n    | Keyword | xxx |\n\n    This keyword can be used also to set the order of keywords in different\n    resource files. In this case resource names must be given without paths\n    or extensions like:\n\n    | Set Library Search Order | resource | another_resource |\n\n    *NOTE:*\n    - The search order is valid only in the suite where this keyword is used.\n    - Keywords in resources always have higher priority than\n      keywords in libraries regardless the search order.\n    - The old order is returned and can be used to reset the search order later.\n    - Calling this keyword without arguments removes possible search order.\n    - Library and resource names in the search order are both case and space\n      insensitive.\n    \"\"\"\n    return self._namespace.set_search_order(search_order)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.keyword_should_exist","title":"keyword_should_exist","text":"<pre><code>keyword_should_exist(name, msg=None)\n</code></pre> <p>Fails unless the given keyword exists in the current scope.</p> <p>Fails also if there is more than one keyword with the same name. Works both with the short name (e.g. <code>Log</code>) and the full name (e.g. <code>BuiltIn.Log</code>).</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> <p>See also <code>Variable Should Exist</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def keyword_should_exist(self, name, msg=None):\n    \"\"\"Fails unless the given keyword exists in the current scope.\n\n    Fails also if there is more than one keyword with the same name.\n    Works both with the short name (e.g. ``Log``) and the full name\n    (e.g. ``BuiltIn.Log``).\n\n    The default error message can be overridden with the ``msg`` argument.\n\n    See also `Variable Should Exist`.\n    \"\"\"\n    try:\n        kw = self._namespace.get_runner(name, recommend_on_failure=False).keyword\n        if kw.error:\n            raise DataError(kw.error)\n    except DataError as err:\n        raise AssertionError(msg or err.message)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.get_time","title":"get_time","text":"<pre><code>get_time(format='timestamp', time_='NOW')\n</code></pre> <p>Returns the given time in the requested format.</p> <p>NOTE: DateTime library contains much more flexible keywords for getting the current date and time and for date and time handling in general.</p> <p>How time is returned is determined based on the given <code>format</code> string as follows. Note that all checks are case-insensitive.</p> <p>1) If <code>format</code> contains the word <code>epoch</code>, the time is returned    in seconds after the UNIX epoch (1970-01-01 00:00:00 UTC).    The return value is always an integer.</p> <p>2) If <code>format</code> contains any of the words <code>year</code>, <code>month</code>,    <code>day</code>, <code>hour</code>, <code>min</code>, or <code>sec</code>, only the selected parts are    returned. The order of the returned parts is always the one    in the previous sentence and the order of words in <code>format</code>    is not significant. The parts are returned as zero-padded    strings (e.g. May -&gt; <code>05</code>).</p> <p>3) Otherwise (and by default) the time is returned as a    timestamp string in the format <code>2006-02-24 15:08:31</code>.</p> <p>By default this keyword returns the current local time, but that can be altered using <code>time</code> argument as explained below. Note that all checks involving strings are case-insensitive.</p> <p>1) If <code>time</code> is a number, or a string that can be converted to    a number, it is interpreted as seconds since the UNIX epoch.    This documentation was originally written about 1177654467    seconds after the epoch.</p> <p>2) If <code>time</code> is a timestamp, that time will be used. Valid    timestamp formats are <code>YYYY-MM-DD hh:mm:ss</code> and    <code>YYYYMMDD hhmmss</code>.</p> <p>3) If <code>time</code> is equal to <code>NOW</code> (default), the current local    time is used.</p> <p>4) If <code>time</code> is equal to <code>UTC</code>, the current time in    [http://en.wikipedia.org/wiki/Coordinated_Universal_Time|UTC]    is used.</p> <p>5) If <code>time</code> is in the format like <code>NOW - 1 day</code> or <code>UTC + 1 hour    30 min</code>, the current local/UTC time plus/minus the time    specified with the time string is used. The time string format    is described in an appendix of Robot Framework User Guide.</p> <p>Examples (expecting the current local time is 2006-03-29 15:06:21): | ${time} = | Get Time |             |  |  | | ${secs} = | Get Time | epoch       |  |  | | ${year} = | Get Time | return year |  |  | | ${yyyy}   | ${mm}    | ${dd} =     | Get Time | year,month,day | | @{time} = | Get Time | year month day hour min sec |  |  | | ${y}      | ${s} =   | Get Time    | seconds and year |  | =&gt; | ${time} = '2006-03-29 15:06:21' | ${secs} = 1143637581 | ${year} = '2006' | ${yyyy} = '2006', ${mm} = '03', ${dd} = '29' | @{time} = ['2006', '03', '29', '15', '06', '21'] | ${y} = '2006' | ${s} = '21'</p> <p>Examples (expecting the current local time is 2006-03-29 15:06:21 and UTC time is 2006-03-29 12:06:21): | ${time} = | Get Time |              | 1177654467          | # Time given as epoch seconds        | | ${secs} = | Get Time | sec          | 2007-04-27 09:14:27 | # Time given as a timestamp          | | ${year} = | Get Time | year         | NOW                 | # The local time of execution        | | @{time} = | Get Time | hour min sec | NOW + 1h 2min 3s    | # 1h 2min 3s added to the local time | | @{utc} =  | Get Time | hour min sec | UTC                 | # The UTC time of execution          | | ${hour} = | Get Time | hour         | UTC - 1 hour        | # 1h subtracted from the UTC  time   | =&gt; | ${time} = '2007-04-27 09:14:27' | ${secs} = 27 | ${year} = '2006' | @{time} = ['16', '08', '24'] | @{utc} = ['12', '06', '21'] | ${hour} = '11'</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def get_time(self, format='timestamp', time_='NOW'):\n    \"\"\"Returns the given time in the requested format.\n\n    *NOTE:* DateTime library contains much more flexible keywords for\n    getting the current date and time and for date and time handling in\n    general.\n\n    How time is returned is determined based on the given ``format``\n    string as follows. Note that all checks are case-insensitive.\n\n    1) If ``format`` contains the word ``epoch``, the time is returned\n       in seconds after the UNIX epoch (1970-01-01 00:00:00 UTC).\n       The return value is always an integer.\n\n    2) If ``format`` contains any of the words ``year``, ``month``,\n       ``day``, ``hour``, ``min``, or ``sec``, only the selected parts are\n       returned. The order of the returned parts is always the one\n       in the previous sentence and the order of words in ``format``\n       is not significant. The parts are returned as zero-padded\n       strings (e.g. May -&gt; ``05``).\n\n    3) Otherwise (and by default) the time is returned as a\n       timestamp string in the format ``2006-02-24 15:08:31``.\n\n    By default this keyword returns the current local time, but\n    that can be altered using ``time`` argument as explained below.\n    Note that all checks involving strings are case-insensitive.\n\n    1) If ``time`` is a number, or a string that can be converted to\n       a number, it is interpreted as seconds since the UNIX epoch.\n       This documentation was originally written about 1177654467\n       seconds after the epoch.\n\n    2) If ``time`` is a timestamp, that time will be used. Valid\n       timestamp formats are ``YYYY-MM-DD hh:mm:ss`` and\n       ``YYYYMMDD hhmmss``.\n\n    3) If ``time`` is equal to ``NOW`` (default), the current local\n       time is used.\n\n    4) If ``time`` is equal to ``UTC``, the current time in\n       [http://en.wikipedia.org/wiki/Coordinated_Universal_Time|UTC]\n       is used.\n\n    5) If ``time`` is in the format like ``NOW - 1 day`` or ``UTC + 1 hour\n       30 min``, the current local/UTC time plus/minus the time\n       specified with the time string is used. The time string format\n       is described in an appendix of Robot Framework User Guide.\n\n    Examples (expecting the current local time is 2006-03-29 15:06:21):\n    | ${time} = | Get Time |             |  |  |\n    | ${secs} = | Get Time | epoch       |  |  |\n    | ${year} = | Get Time | return year |  |  |\n    | ${yyyy}   | ${mm}    | ${dd} =     | Get Time | year,month,day |\n    | @{time} = | Get Time | year month day hour min sec |  |  |\n    | ${y}      | ${s} =   | Get Time    | seconds and year |  |\n    =&gt;\n    | ${time} = '2006-03-29 15:06:21'\n    | ${secs} = 1143637581\n    | ${year} = '2006'\n    | ${yyyy} = '2006', ${mm} = '03', ${dd} = '29'\n    | @{time} = ['2006', '03', '29', '15', '06', '21']\n    | ${y} = '2006'\n    | ${s} = '21'\n\n    Examples (expecting the current local time is 2006-03-29 15:06:21 and\n    UTC time is 2006-03-29 12:06:21):\n    | ${time} = | Get Time |              | 1177654467          | # Time given as epoch seconds        |\n    | ${secs} = | Get Time | sec          | 2007-04-27 09:14:27 | # Time given as a timestamp          |\n    | ${year} = | Get Time | year         | NOW                 | # The local time of execution        |\n    | @{time} = | Get Time | hour min sec | NOW + 1h 2min 3s    | # 1h 2min 3s added to the local time |\n    | @{utc} =  | Get Time | hour min sec | UTC                 | # The UTC time of execution          |\n    | ${hour} = | Get Time | hour         | UTC - 1 hour        | # 1h subtracted from the UTC  time   |\n    =&gt;\n    | ${time} = '2007-04-27 09:14:27'\n    | ${secs} = 27\n    | ${year} = '2006'\n    | @{time} = ['16', '08', '24']\n    | @{utc} = ['12', '06', '21']\n    | ${hour} = '11'\n    \"\"\"\n    return get_time(format, parse_time(time_))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.evaluate","title":"evaluate","text":"<pre><code>evaluate(expression, modules=None, namespace=None)\n</code></pre> <p>Evaluates the given expression in Python and returns the result.</p> <p><code>expression</code> is evaluated in Python as explained in the <code>Evaluating expressions</code> section.</p> <p><code>modules</code> argument can be used to specify a comma separated list of Python modules to be imported and added to the evaluation namespace.</p> <p><code>namespace</code> argument can be used to pass a custom evaluation namespace as a dictionary. Possible <code>modules</code> are added to this namespace.</p> <p>Variables used like <code>${variable}</code> are replaced in the expression before evaluation. Variables are also available in the evaluation namespace and can be accessed using the special <code>$variable</code> syntax as explained in the <code>Evaluating expressions</code> section.</p> <p>Starting from Robot Framework 3.2, modules used in the expression are imported automatically. There are, however, two cases where they need to be explicitly specified using the <code>modules</code> argument:</p> <ul> <li> <p>When nested modules like <code>rootmod.submod</code> are implemented so that   the root module does not automatically import sub modules. This is   illustrated by the <code>selenium.webdriver</code> example below.</p> </li> <li> <p>When using a module in the expression part of a list comprehension.   This is illustrated by the <code>json</code> example below.</p> </li> </ul> <p>Examples (expecting <code>${result}</code> is number 3.14): | ${status} =  | Evaluate | 0 &lt; ${result} &lt; 10 | # Would also work with string '3.14' | | ${status} =  | Evaluate | 0 &lt; $result &lt; 10   | # Using variable itself, not string representation | | ${random} =  | Evaluate | random.randint(0, sys.maxsize) | | ${options} = | Evaluate | selenium.webdriver.ChromeOptions() | modules=selenium.webdriver | | ${items} =   | Evaluate | [json.loads(item) for item in ('1', '\"b\"')] | modules=json | | ${ns} =      | Create Dictionary | x=${4}    | y=${2}              | | ${result} =  | Evaluate | x*10 + y           | namespace=${ns}     | =&gt; | ${status} = True | ${random} =  | ${options} = ChromeOptions instance | ${items} = [1, 'b'] | ${result} = 42 <p>NOTE: Prior to Robot Framework 3.2 using <code>modules=rootmod.submod</code> was not enough to make the root module itself available in the evaluation namespace. It needed to be taken into use explicitly like <code>modules=rootmod, rootmod.submod</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def evaluate(self, expression, modules=None, namespace=None):\n    \"\"\"Evaluates the given expression in Python and returns the result.\n\n    ``expression`` is evaluated in Python as explained in the\n    `Evaluating expressions` section.\n\n    ``modules`` argument can be used to specify a comma separated\n    list of Python modules to be imported and added to the evaluation\n    namespace.\n\n    ``namespace`` argument can be used to pass a custom evaluation\n    namespace as a dictionary. Possible ``modules`` are added to this\n    namespace.\n\n    Variables used like ``${variable}`` are replaced in the expression\n    before evaluation. Variables are also available in the evaluation\n    namespace and can be accessed using the special ``$variable`` syntax\n    as explained in the `Evaluating expressions` section.\n\n    Starting from Robot Framework 3.2, modules used in the expression are\n    imported automatically. There are, however, two cases where they need to\n    be explicitly specified using the ``modules`` argument:\n\n    - When nested modules like ``rootmod.submod`` are implemented so that\n      the root module does not automatically import sub modules. This is\n      illustrated by the ``selenium.webdriver`` example below.\n\n    - When using a module in the expression part of a list comprehension.\n      This is illustrated by the ``json`` example below.\n\n    Examples (expecting ``${result}`` is number 3.14):\n    | ${status} =  | Evaluate | 0 &lt; ${result} &lt; 10 | # Would also work with string '3.14' |\n    | ${status} =  | Evaluate | 0 &lt; $result &lt; 10   | # Using variable itself, not string representation |\n    | ${random} =  | Evaluate | random.randint(0, sys.maxsize) |\n    | ${options} = | Evaluate | selenium.webdriver.ChromeOptions() | modules=selenium.webdriver |\n    | ${items} =   | Evaluate | [json.loads(item) for item in ('1', '\"b\"')] | modules=json |\n    | ${ns} =      | Create Dictionary | x=${4}    | y=${2}              |\n    | ${result} =  | Evaluate | x*10 + y           | namespace=${ns}     |\n    =&gt;\n    | ${status} = True\n    | ${random} = &lt;random integer&gt;\n    | ${options} = ChromeOptions instance\n    | ${items} = [1, 'b']\n    | ${result} = 42\n\n    *NOTE*: Prior to Robot Framework 3.2 using ``modules=rootmod.submod``\n    was not enough to make the root module itself available in the\n    evaluation namespace. It needed to be taken into use explicitly like\n    ``modules=rootmod, rootmod.submod``.\n    \"\"\"\n    try:\n        return evaluate_expression(expression, self._variables.current,\n                                   modules, namespace)\n    except DataError as err:\n        raise RuntimeError(err.message)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.call_method","title":"call_method","text":"<pre><code>call_method(object, method_name, *args, **kwargs)\n</code></pre> <p>Calls the named method of the given object with the provided arguments.</p> <p>The possible return value from the method is returned and can be assigned to a variable. Keyword fails both if the object does not have a method with the given name or if executing the method raises an exception.</p> <p>Possible equal signs in arguments must be escaped with a backslash like <code>\\=</code>.</p> <p>Examples: | Call Method      | ${hashtable} | put          | myname  | myvalue | | ${isempty} =     | Call Method  | ${hashtable} | isEmpty |         | | Should Not Be True | ${isempty} |              |         |         | | ${value} =       | Call Method  | ${hashtable} | get     | myname  | | Should Be Equal  | ${value}     | myvalue      |         |         | | Call Method      | ${object}    | kwargs    | name=value | foo=bar | | Call Method      | ${object}    | positional   | escaped\\=equals  |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def call_method(self, object, method_name, *args, **kwargs):\n    \"\"\"Calls the named method of the given object with the provided arguments.\n\n    The possible return value from the method is returned and can be\n    assigned to a variable. Keyword fails both if the object does not have\n    a method with the given name or if executing the method raises an\n    exception.\n\n    Possible equal signs in arguments must be escaped with a backslash\n    like ``\\\\=``.\n\n    Examples:\n    | Call Method      | ${hashtable} | put          | myname  | myvalue |\n    | ${isempty} =     | Call Method  | ${hashtable} | isEmpty |         |\n    | Should Not Be True | ${isempty} |              |         |         |\n    | ${value} =       | Call Method  | ${hashtable} | get     | myname  |\n    | Should Be Equal  | ${value}     | myvalue      |         |         |\n    | Call Method      | ${object}    | kwargs    | name=value | foo=bar |\n    | Call Method      | ${object}    | positional   | escaped\\\\=equals  |\n    \"\"\"\n    try:\n        method = getattr(object, method_name)\n    except AttributeError:\n        raise RuntimeError(f\"{type(object).__name__} object does not have \"\n                           f\"method '{method_name}'.\")\n    try:\n        return method(*args, **kwargs)\n    except Exception as err:\n        msg = get_error_message()\n        raise RuntimeError(f\"Calling method '{method_name}' failed: {msg}\") from err\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.regexp_escape","title":"regexp_escape","text":"<pre><code>regexp_escape(*patterns)\n</code></pre> <p>Returns each argument string escaped for use as a regular expression.</p> <p>This keyword can be used to escape strings to be used with <code>Should Match Regexp</code> and <code>Should Not Match Regexp</code> keywords.</p> <p>Escaping is done with Python's <code>re.escape()</code> function.</p> <p>Examples: | ${escaped} = | Regexp Escape | ${original} | | @{strings} = | Regexp Escape | @{strings}  |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def regexp_escape(self, *patterns):\n    \"\"\"Returns each argument string escaped for use as a regular expression.\n\n    This keyword can be used to escape strings to be used with\n    `Should Match Regexp` and `Should Not Match Regexp` keywords.\n\n    Escaping is done with Python's ``re.escape()`` function.\n\n    Examples:\n    | ${escaped} = | Regexp Escape | ${original} |\n    | @{strings} = | Regexp Escape | @{strings}  |\n    \"\"\"\n    if len(patterns) == 0:\n        return ''\n    if len(patterns) == 1:\n        return re.escape(patterns[0])\n    return [re.escape(p) for p in patterns]\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_test_message","title":"set_test_message","text":"<pre><code>set_test_message(message, append=False)\n</code></pre> <p>Sets message for the current test case.</p> <p>If the optional <code>append</code> argument is given a true value (see <code>Boolean arguments</code>), the given <code>message</code> is added after the possible earlier message by joining the messages with a space.</p> <p>In test teardown this keyword can alter the possible failure message, but otherwise failures override messages set by this keyword. Notice that in teardown the message is available as a built-in variable <code>${TEST MESSAGE}</code>.</p> <p>It is possible to use HTML format in the message by starting the message with <code>*HTML*</code>.</p> <p>Examples: | Set Test Message | My message           |                          | | Set Test Message | is continued.        | append=yes               | | Should Be Equal  | ${TEST MESSAGE}      | My message is continued. | | Set Test Message | <code>*</code>HTML<code>*</code> Hello! |                      |</p> <p>This keyword can not be used in suite setup or suite teardown.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def set_test_message(self, message, append=False):\n    \"\"\"Sets message for the current test case.\n\n    If the optional ``append`` argument is given a true value (see `Boolean\n    arguments`), the given ``message`` is added after the possible earlier\n    message by joining the messages with a space.\n\n    In test teardown this keyword can alter the possible failure message,\n    but otherwise failures override messages set by this keyword. Notice\n    that in teardown the message is available as a built-in variable\n    ``${TEST MESSAGE}``.\n\n    It is possible to use HTML format in the message by starting the message\n    with ``*HTML*``.\n\n    Examples:\n    | Set Test Message | My message           |                          |\n    | Set Test Message | is continued.        | append=yes               |\n    | Should Be Equal  | ${TEST MESSAGE}      | My message is continued. |\n    | Set Test Message | `*`HTML`*` &lt;b&gt;Hello!&lt;/b&gt; |                      |\n\n    This keyword can not be used in suite setup or suite teardown.\n    \"\"\"\n    test = self._context.test\n    if not test:\n        raise RuntimeError(\"'Set Test Message' keyword cannot be used in \"\n                           \"suite setup or teardown.\")\n    test.message = self._get_new_text(test.message, message,\n                                      append, handle_html=True)\n    if self._context.in_test_teardown:\n        self._variables.set_test(\"${TEST_MESSAGE}\", test.message)\n    message, level = self._get_logged_test_message_and_level(test.message)\n    self.log(f'Set test message to:\\n{message}', level)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_test_documentation","title":"set_test_documentation","text":"<pre><code>set_test_documentation(doc, append=False)\n</code></pre> <p>Sets documentation for the current test case.</p> <p>By default the possible existing documentation is overwritten, but this can be changed using the optional <code>append</code> argument similarly as with <code>Set Test Message</code> keyword.</p> <p>The current test documentation is available as a built-in variable <code>${TEST DOCUMENTATION}</code>. This keyword can not be used in suite setup or suite teardown.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def set_test_documentation(self, doc, append=False):\n    \"\"\"Sets documentation for the current test case.\n\n    By default the possible existing documentation is overwritten, but\n    this can be changed using the optional ``append`` argument similarly\n    as with `Set Test Message` keyword.\n\n    The current test documentation is available as a built-in variable\n    ``${TEST DOCUMENTATION}``. This keyword can not be used in suite\n    setup or suite teardown.\n    \"\"\"\n    test = self._context.test\n    if not test:\n        raise RuntimeError(\"'Set Test Documentation' keyword cannot be \"\n                           \"used in suite setup or teardown.\")\n    test.doc = self._get_new_text(test.doc, doc, append)\n    self._variables.set_test('${TEST_DOCUMENTATION}', test.doc)\n    self.log(f'Set test documentation to:\\n{test.doc}')\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_suite_documentation","title":"set_suite_documentation","text":"<pre><code>set_suite_documentation(doc, append=False, top=False)\n</code></pre> <p>Sets documentation for the current test suite.</p> <p>By default, the possible existing documentation is overwritten, but this can be changed using the optional <code>append</code> argument similarly as with <code>Set Test Message</code> keyword.</p> <p>This keyword sets the documentation of the current suite by default. If the optional <code>top</code> argument is given a true value (see <code>Boolean arguments</code>), the documentation of the top level suite is altered instead.</p> <p>The documentation of the current suite is available as a built-in variable <code>${SUITE DOCUMENTATION}</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def set_suite_documentation(self, doc, append=False, top=False):\n    \"\"\"Sets documentation for the current test suite.\n\n    By default, the possible existing documentation is overwritten, but\n    this can be changed using the optional ``append`` argument similarly\n    as with `Set Test Message` keyword.\n\n    This keyword sets the documentation of the current suite by default.\n    If the optional ``top`` argument is given a true value (see `Boolean\n    arguments`), the documentation of the top level suite is altered\n    instead.\n\n    The documentation of the current suite is available as a built-in\n    variable ``${SUITE DOCUMENTATION}``.\n    \"\"\"\n    suite = self._get_context(top).suite\n    suite.doc = self._get_new_text(suite.doc, doc, append)\n    self._variables.set_suite('${SUITE_DOCUMENTATION}', suite.doc, top)\n    self.log(f'Set suite documentation to:\\n{suite.doc}')\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_suite_metadata","title":"set_suite_metadata","text":"<pre><code>set_suite_metadata(name, value, append=False, top=False)\n</code></pre> <p>Sets metadata for the current test suite.</p> <p>By default, possible existing metadata values are overwritten, but this can be changed using the optional <code>append</code> argument similarly as with <code>Set Test Message</code> keyword.</p> <p>This keyword sets the metadata of the current suite by default. If the optional <code>top</code> argument is given a true value (see <code>Boolean arguments</code>), the metadata of the top level suite is altered instead.</p> <p>The metadata of the current suite is available as a built-in variable <code>${SUITE METADATA}</code> in a Python dictionary. Notice that modifying this variable directly has no effect on the actual metadata the suite has.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def set_suite_metadata(self, name, value, append=False, top=False):\n    \"\"\"Sets metadata for the current test suite.\n\n    By default, possible existing metadata values are overwritten, but\n    this can be changed using the optional ``append`` argument similarly\n    as with `Set Test Message` keyword.\n\n    This keyword sets the metadata of the current suite by default.\n    If the optional ``top`` argument is given a true value (see `Boolean\n    arguments`), the metadata of the top level suite is altered instead.\n\n    The metadata of the current suite is available as a built-in variable\n    ``${SUITE METADATA}`` in a Python dictionary. Notice that modifying this\n    variable directly has no effect on the actual metadata the suite has.\n    \"\"\"\n    if not is_string(name):\n        name = str(name)\n    metadata = self._get_context(top).suite.metadata\n    original = metadata.get(name, '')\n    metadata[name] = self._get_new_text(original, value, append)\n    self._variables.set_suite('${SUITE_METADATA}', metadata.copy(), top)\n    self.log(f\"Set suite metadata '{name}' to value '{metadata[name]}'.\")\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_tags","title":"set_tags","text":"<pre><code>set_tags(*tags)\n</code></pre> <p>Adds given <code>tags</code> for the current test or all tests in a suite.</p> <p>When this keyword is used inside a test case, that test gets the specified tags and other tests are not affected.</p> <p>If this keyword is used in a suite setup, all test cases in that suite, recursively, gets the given tags. It is a failure to use this keyword in a suite teardown.</p> <p>The current tags are available as a built-in variable <code>@{TEST TAGS}</code>.</p> <p>See <code>Remove Tags</code> if you want to remove certain tags and <code>Fail</code> if you want to fail the test case after setting and/or removing tags.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def set_tags(self, *tags):\n    \"\"\"Adds given ``tags`` for the current test or all tests in a suite.\n\n    When this keyword is used inside a test case, that test gets\n    the specified tags and other tests are not affected.\n\n    If this keyword is used in a suite setup, all test cases in\n    that suite, recursively, gets the given tags. It is a failure\n    to use this keyword in a suite teardown.\n\n    The current tags are available as a built-in variable ``@{TEST TAGS}``.\n\n    See `Remove Tags` if you want to remove certain tags and `Fail` if\n    you want to fail the test case after setting and/or removing tags.\n    \"\"\"\n    ctx = self._context\n    if ctx.test:\n        ctx.test.tags.add(tags)\n        ctx.variables.set_test('@{TEST_TAGS}', list(ctx.test.tags))\n    elif not ctx.in_suite_teardown:\n        ctx.suite.set_tags(tags, persist=True)\n    else:\n        raise RuntimeError(\"'Set Tags' cannot be used in suite teardown.\")\n    self.log(f'Set tag{s(tags)} {seq2str((tags))}.')\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.remove_tags","title":"remove_tags","text":"<pre><code>remove_tags(*tags)\n</code></pre> <p>Removes given <code>tags</code> from the current test or all tests in a suite.</p> <p>Tags can be given exactly or using a pattern with <code>*</code>, <code>?</code> and <code>[chars]</code> acting as wildcards. See the <code>Glob patterns</code> section for more information.</p> <p>This keyword can affect either one test case or all test cases in a test suite similarly as <code>Set Tags</code> keyword.</p> <p>The current tags are available as a built-in variable <code>@{TEST TAGS}</code>.</p> <p>Example: | Remove Tags | mytag | something-* | ?ython |</p> <p>See <code>Set Tags</code> if you want to add certain tags and <code>Fail</code> if you want to fail the test case after setting and/or removing tags.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def remove_tags(self, *tags):\n    \"\"\"Removes given ``tags`` from the current test or all tests in a suite.\n\n    Tags can be given exactly or using a pattern with ``*``, ``?`` and\n    ``[chars]`` acting as wildcards. See the `Glob patterns` section\n    for more information.\n\n    This keyword can affect either one test case or all test cases in a\n    test suite similarly as `Set Tags` keyword.\n\n    The current tags are available as a built-in variable ``@{TEST TAGS}``.\n\n    Example:\n    | Remove Tags | mytag | something-* | ?ython |\n\n    See `Set Tags` if you want to add certain tags and `Fail` if you want\n    to fail the test case after setting and/or removing tags.\n    \"\"\"\n    ctx = self._context\n    if ctx.test:\n        ctx.test.tags.remove(tags)\n        ctx.variables.set_test('@{TEST_TAGS}', list(ctx.test.tags))\n    elif not ctx.in_suite_teardown:\n        ctx.suite.set_tags(remove=tags, persist=True)\n    else:\n        raise RuntimeError(\"'Remove Tags' cannot be used in suite teardown.\")\n    self.log(f'Removed tag{s(tags)} {seq2str((tags))}.')\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.get_library_instance","title":"get_library_instance","text":"<pre><code>get_library_instance(name=None, all=False)\n</code></pre> <p>Returns the currently active instance of the specified library.</p> <p>This keyword makes it easy for libraries to interact with other libraries that have state. This is illustrated by the Python example below:</p> from robot.libraries.BuiltIn import BuiltIn def title_should_start_with(expected): seleniumlib = BuiltIn().get_library_instance('SeleniumLibrary') title = seleniumlib.get_title() if not title.startswith(expected): raise AssertionError(f\"Title '{title}' did not start with '{expected}'.\") <p>It is also possible to use this keyword in the test data and pass the returned library instance to another keyword. If a library is imported with a custom name, the <code>name</code> used to get the instance must be that name and not the original library name.</p> <p>If the optional argument <code>all</code> is given a true value, then a dictionary mapping all library names to instances will be returned.</p> <p>Example: | &amp;{all libs} = | Get library instance | all=True |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def get_library_instance(self, name=None, all=False):\n    \"\"\"Returns the currently active instance of the specified library.\n\n    This keyword makes it easy for libraries to interact with\n    other libraries that have state. This is illustrated by\n    the Python example below:\n\n    | from robot.libraries.BuiltIn import BuiltIn\n    |\n    | def title_should_start_with(expected):\n    |     seleniumlib = BuiltIn().get_library_instance('SeleniumLibrary')\n    |     title = seleniumlib.get_title()\n    |     if not title.startswith(expected):\n    |         raise AssertionError(f\"Title '{title}' did not start with '{expected}'.\")\n\n    It is also possible to use this keyword in the test data and\n    pass the returned library instance to another keyword. If a\n    library is imported with a custom name, the ``name`` used to get\n    the instance must be that name and not the original library name.\n\n    If the optional argument ``all`` is given a true value, then a\n    dictionary mapping all library names to instances will be returned.\n\n    Example:\n    | &amp;{all libs} = | Get library instance | all=True |\n    \"\"\"\n    if all:\n        return self._namespace.get_library_instances()\n    try:\n        return self._namespace.get_library_instance(name)\n    except DataError as err:\n        raise RuntimeError(str(err))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.skip","title":"skip","text":"<pre><code>skip(msg='Skipped with Skip keyword.')\n</code></pre> <p>Skips the rest of the current test.</p> <p>Skips the remaining keywords in the current test and sets the given message to the test. If the test has teardown, it will be executed.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def skip(self, msg='Skipped with Skip keyword.'):\n    \"\"\"Skips the rest of the current test.\n\n    Skips the remaining keywords in the current test and sets the given\n    message to the test. If the test has teardown, it will be executed.\n    \"\"\"\n    raise SkipExecution(msg)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.skip_if","title":"skip_if","text":"<pre><code>skip_if(condition, msg=None)\n</code></pre> <p>Skips the rest of the current test if the <code>condition</code> is True.</p> <p>Skips the remaining keywords in the current test and sets the given message to the test. If <code>msg</code> is not given, the <code>condition</code> will be used as the message. If the test has teardown, it will be executed.</p> <p>If the <code>condition</code> evaluates to False, does nothing.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def skip_if(self, condition, msg=None):\n    \"\"\"Skips the rest of the current test if the ``condition`` is True.\n\n    Skips the remaining keywords in the current test and sets the given\n    message to the test. If ``msg`` is not given, the ``condition`` will\n    be used as the message. If the test has teardown, it will be executed.\n\n    If the ``condition`` evaluates to False, does nothing.\n    \"\"\"\n    if self._is_true(condition):\n        raise SkipExecution(msg or condition)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.continue_for_loop","title":"continue_for_loop","text":"<pre><code>continue_for_loop()\n</code></pre> <p>Skips the current FOR loop iteration and continues from the next.</p> <p>NOTE: Robot Framework 5.0 added support for native <code>CONTINUE</code> statement that is recommended over this keyword. In the examples below, <code>Continue For Loop</code> can simply be replaced with <code>CONTINUE</code>. In addition to that, native <code>IF</code> syntax (new in RF 4.0) or inline <code>IF</code> syntax (new in RF 5.0) can be used instead of <code>Run Keyword If</code>. For example, the first example below could be written like this instead:</p> <p>| IF    '${var}' == 'CONTINUE'    CONTINUE</p> <p>This keyword will eventually be deprecated and removed.</p> <p>Skips the remaining keywords in the current FOR loop iteration and continues from the next one. Starting from Robot Framework 5.0, this keyword can only be used inside a loop, not in a keyword used in a loop.</p> <p>Example: | FOR | ${var}         | IN                     | @{VALUES}         | |     | Run Keyword If | '${var}' == 'CONTINUE' | Continue For Loop | |     | Do Something   | ${var}                 | | END |</p> <p>See <code>Continue For Loop If</code> to conditionally continue a FOR loop without using <code>Run Keyword If</code> or other wrapper keywords.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def continue_for_loop(self):\n    \"\"\"Skips the current FOR loop iteration and continues from the next.\n\n    ---\n\n    *NOTE:* Robot Framework 5.0 added support for native ``CONTINUE`` statement that\n    is recommended over this keyword. In the examples below, ``Continue For Loop``\n    can simply be replaced with ``CONTINUE``. In addition to that, native ``IF``\n    syntax (new in RF 4.0) or inline ``IF`` syntax (new in RF 5.0) can be used\n    instead of ``Run Keyword If``. For example, the first example below could be\n    written like this instead:\n\n    | IF    '${var}' == 'CONTINUE'    CONTINUE\n\n    This keyword will eventually be deprecated and removed.\n\n    ---\n\n    Skips the remaining keywords in the current FOR loop iteration and\n    continues from the next one. Starting from Robot Framework 5.0, this\n    keyword can only be used inside a loop, not in a keyword used in a loop.\n\n    Example:\n    | FOR | ${var}         | IN                     | @{VALUES}         |\n    |     | Run Keyword If | '${var}' == 'CONTINUE' | Continue For Loop |\n    |     | Do Something   | ${var}                 |\n    | END |\n\n    See `Continue For Loop If` to conditionally continue a FOR loop without\n    using `Run Keyword If` or other wrapper keywords.\n    \"\"\"\n    if not self._context.allow_loop_control:\n        raise DataError(\"'Continue For Loop' can only be used inside a loop.\")\n    self.log(\"Continuing for loop from the next iteration.\")\n    raise ContinueLoop()\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.continue_for_loop_if","title":"continue_for_loop_if","text":"<pre><code>continue_for_loop_if(condition)\n</code></pre> <p>Skips the current FOR loop iteration if the <code>condition</code> is true.</p> <p>NOTE: Robot Framework 5.0 added support for native <code>CONTINUE</code> statement and for inline <code>IF</code>, and that combination should be used instead of this keyword. For example, <code>Continue For Loop If</code> usage in the example below could be replaced with</p> <p>| IF    '${var}' == 'CONTINUE'    CONTINUE</p> <p>This keyword will eventually be deprecated and removed.</p> <p>A wrapper for <code>Continue For Loop</code> to continue a FOR loop based on the given condition. The condition is evaluated using the same semantics as with <code>Should Be True</code> keyword.</p> <p>Example: | FOR | ${var}               | IN                     | @{VALUES} | |     | Continue For Loop If | '${var}' == 'CONTINUE' | |     | Do Something         | ${var}                 | | END |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def continue_for_loop_if(self, condition):\n    \"\"\"Skips the current FOR loop iteration if the ``condition`` is true.\n\n    ---\n\n    *NOTE:* Robot Framework 5.0 added support for native ``CONTINUE`` statement\n    and for inline ``IF``, and that combination should be used instead of this\n    keyword. For example, ``Continue For Loop If`` usage in the example below\n    could be replaced with\n\n    | IF    '${var}' == 'CONTINUE'    CONTINUE\n\n    This keyword will eventually be deprecated and removed.\n\n    ---\n\n    A wrapper for `Continue For Loop` to continue a FOR loop based on\n    the given condition. The condition is evaluated using the same\n    semantics as with `Should Be True` keyword.\n\n    Example:\n    | FOR | ${var}               | IN                     | @{VALUES} |\n    |     | Continue For Loop If | '${var}' == 'CONTINUE' |\n    |     | Do Something         | ${var}                 |\n    | END |\n    \"\"\"\n    if not self._context.allow_loop_control:\n        raise DataError(\"'Continue For Loop If' can only be used inside a loop.\")\n    if self._is_true(condition):\n        self.continue_for_loop()\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.exit_for_loop","title":"exit_for_loop","text":"<pre><code>exit_for_loop()\n</code></pre> <p>Stops executing the enclosing FOR loop.</p> <p>NOTE: Robot Framework 5.0 added support for native <code>BREAK</code> statement that is recommended over this keyword. In the examples below, <code>Exit For Loop</code> can simply be replaced with <code>BREAK</code>. In addition to that, native <code>IF</code> syntax (new in RF 4.0) or inline <code>IF</code> syntax (new in RF 5.0) can be used instead of <code>Run Keyword If</code>. For example, the first example below could be written like this instead:</p> <p>| IF    '${var}' == 'EXIT'    BREAK</p> <p>This keyword will eventually be deprecated and removed.</p> <p>Exits the enclosing FOR loop and continues execution after it. Starting from Robot Framework 5.0, this keyword can only be used inside a loop, not in a keyword used in a loop.</p> <p>Example: | FOR | ${var}         | IN                 | @{VALUES}     | |     | Run Keyword If | '${var}' == 'EXIT' | Exit For Loop | |     | Do Something   | ${var} | | END |</p> <p>See <code>Exit For Loop If</code> to conditionally exit a FOR loop without using <code>Run Keyword If</code> or other wrapper keywords.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def exit_for_loop(self):\n    \"\"\"Stops executing the enclosing FOR loop.\n\n    ---\n\n    *NOTE:* Robot Framework 5.0 added support for native ``BREAK`` statement that\n    is recommended over this keyword. In the examples below, ``Exit For Loop``\n    can simply be replaced with ``BREAK``. In addition to that, native ``IF``\n    syntax (new in RF 4.0) or inline ``IF`` syntax (new in RF 5.0) can be used\n    instead of ``Run Keyword If``. For example, the first example below could be\n    written like this instead:\n\n    | IF    '${var}' == 'EXIT'    BREAK\n\n    This keyword will eventually be deprecated and removed.\n\n    ---\n\n    Exits the enclosing FOR loop and continues execution after it. Starting\n    from Robot Framework 5.0, this keyword can only be used inside a loop,\n    not in a keyword used in a loop.\n\n    Example:\n    | FOR | ${var}         | IN                 | @{VALUES}     |\n    |     | Run Keyword If | '${var}' == 'EXIT' | Exit For Loop |\n    |     | Do Something   | ${var} |\n    | END |\n\n    See `Exit For Loop If` to conditionally exit a FOR loop without\n    using `Run Keyword If` or other wrapper keywords.\n    \"\"\"\n    if not self._context.allow_loop_control:\n        raise DataError(\"'Exit For Loop' can only be used inside a loop.\")\n    self.log(\"Exiting for loop altogether.\")\n    raise BreakLoop()\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.exit_for_loop_if","title":"exit_for_loop_if","text":"<pre><code>exit_for_loop_if(condition)\n</code></pre> <p>Stops executing the enclosing FOR loop if the <code>condition</code> is true.</p> <p>NOTE: Robot Framework 5.0 added support for native <code>BREAK</code> statement and for inline <code>IF</code>, and that combination should be used instead of this keyword. For example, <code>Exit For Loop If</code> usage in the example below could be replaced with</p> <p>| IF    '${var}' == 'EXIT'    BREAK</p> <p>This keyword will eventually be deprecated and removed.</p> <p>A wrapper for <code>Exit For Loop</code> to exit a FOR loop based on the given condition. The condition is evaluated using the same semantics as with <code>Should Be True</code> keyword.</p> <p>Example: | FOR | ${var}           | IN                 | @{VALUES} | |     | Exit For Loop If | '${var}' == 'EXIT' | |     | Do Something     | ${var}             | | END |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def exit_for_loop_if(self, condition):\n    \"\"\"Stops executing the enclosing FOR loop if the ``condition`` is true.\n\n    ---\n\n    *NOTE:* Robot Framework 5.0 added support for native ``BREAK`` statement\n    and for inline ``IF``, and that combination should be used instead of this\n    keyword. For example, ``Exit For Loop If`` usage in the example below\n    could be replaced with\n\n    | IF    '${var}' == 'EXIT'    BREAK\n\n    This keyword will eventually be deprecated and removed.\n\n    ---\n\n    A wrapper for `Exit For Loop` to exit a FOR loop based on\n    the given condition. The condition is evaluated using the same\n    semantics as with `Should Be True` keyword.\n\n    Example:\n    | FOR | ${var}           | IN                 | @{VALUES} |\n    |     | Exit For Loop If | '${var}' == 'EXIT' |\n    |     | Do Something     | ${var}             |\n    | END |\n    \"\"\"\n    if not self._context.allow_loop_control:\n        raise DataError(\"'Exit For Loop If' can only be used inside a loop.\")\n    if self._is_true(condition):\n        self.exit_for_loop()\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.return_from_keyword","title":"return_from_keyword","text":"<pre><code>return_from_keyword(*return_values)\n</code></pre> <p>Returns from the enclosing user keyword.</p> <p>NOTE: Robot Framework 5.0 added support for native <code>RETURN</code> statement that is recommended over this keyword. In the examples below, <code>Return From Keyword</code> can simply be replaced with <code>RETURN</code>. In addition to that, native <code>IF</code> syntax (new in RF 4.0) or inline <code>IF</code> syntax (new in RF 5.0) can be used instead of <code>Run Keyword If</code>. For example, the first example below could be written like this instead:</p> <p>| IF    ${rc} &lt; 0    RETURN</p> <p>This keyword will eventually be deprecated and removed.</p> <p>This keyword can be used to return from a user keyword with PASS status without executing it fully. It is also possible to return values similarly as with the <code>[Return]</code> setting. For more detailed information about working with the return values, see the User Guide.</p> <p>This keyword is typically wrapped to some other keyword, such as <code>Run Keyword If</code>, to return based on a condition:</p> <p>| Run Keyword If    ${rc} &lt; 0    Return From Keyword</p> <p>It is possible to use this keyword to return from a keyword also inside a for loop. That, as well as returning values, is demonstrated by the <code>Find Index</code> keyword in the following somewhat advanced example. Notice that it is often a good idea to move this kind of complicated logic into a library.</p> <p>| * Variables  | @{LIST} =    foo    baz | |  Test Cases  | Example |     ${index} =    Find Index    baz    @{LIST} |     Should Be Equal    ${index}    ${1} |     ${index} =    Find Index    non existing    @{LIST} |     Should Be Equal    ${index}    ${-1} | |  Keywords *** | Find Index |    [Arguments]    ${element}    @{items} |    ${index} =    Set Variable    ${0} |    FOR    ${item}    IN    @{items} |        Run Keyword If    '${item}' == '${element}'    Return From Keyword    ${index} |        ${index} =    Set Variable    ${index + 1} |    END |    Return From Keyword    ${-1}</p> <p>The most common use case, returning based on an expression, can be accomplished directly with <code>Return From Keyword If</code>. See also <code>Run Keyword And Return</code> and <code>Run Keyword And Return If</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef return_from_keyword(self, *return_values):\n    \"\"\"Returns from the enclosing user keyword.\n\n    ---\n\n    *NOTE:* Robot Framework 5.0 added support for native ``RETURN`` statement that\n    is recommended over this keyword. In the examples below, ``Return From Keyword``\n    can simply be replaced with ``RETURN``. In addition to that, native ``IF``\n    syntax (new in RF 4.0) or inline ``IF`` syntax (new in RF 5.0) can be used\n    instead of ``Run Keyword If``. For example, the first example below could be\n    written like this instead:\n\n    | IF    ${rc} &lt; 0    RETURN\n\n    This keyword will eventually be deprecated and removed.\n\n    ---\n\n    This keyword can be used to return from a user keyword with PASS status\n    without executing it fully. It is also possible to return values\n    similarly as with the ``[Return]`` setting. For more detailed information\n    about working with the return values, see the User Guide.\n\n    This keyword is typically wrapped to some other keyword, such as\n    `Run Keyword If`, to return based on a condition:\n\n    | Run Keyword If    ${rc} &lt; 0    Return From Keyword\n\n    It is possible to use this keyword to return from a keyword also inside\n    a for loop. That, as well as returning values, is demonstrated by the\n    `Find Index` keyword in the following somewhat advanced example.\n    Notice that it is often a good idea to move this kind of complicated\n    logic into a library.\n\n    | ***** Variables *****\n    | @{LIST} =    foo    baz\n    |\n    | ***** Test Cases *****\n    | Example\n    |     ${index} =    Find Index    baz    @{LIST}\n    |     Should Be Equal    ${index}    ${1}\n    |     ${index} =    Find Index    non existing    @{LIST}\n    |     Should Be Equal    ${index}    ${-1}\n    |\n    | ***** Keywords *****\n    | Find Index\n    |    [Arguments]    ${element}    @{items}\n    |    ${index} =    Set Variable    ${0}\n    |    FOR    ${item}    IN    @{items}\n    |        Run Keyword If    '${item}' == '${element}'    Return From Keyword    ${index}\n    |        ${index} =    Set Variable    ${index + 1}\n    |    END\n    |    Return From Keyword    ${-1}\n\n    The most common use case, returning based on an expression, can be\n    accomplished directly with `Return From Keyword If`. See also\n    `Run Keyword And Return` and `Run Keyword And Return If`.\n    \"\"\"\n    self._return_from_keyword(return_values)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.return_from_keyword_if","title":"return_from_keyword_if","text":"<pre><code>return_from_keyword_if(condition, *return_values)\n</code></pre> <p>Returns from the enclosing user keyword if <code>condition</code> is true.</p> <p>NOTE: Robot Framework 5.0 added support for native <code>RETURN</code> statement and for inline <code>IF</code>, and that combination should be used instead of this keyword. For example, <code>Return From Keyword</code> usage in the example below could be replaced with</p> <p>| IF    '${item}' == '${element}'    RETURN    ${index}</p> <p>This keyword will eventually be deprecated and removed.</p> <p>A wrapper for <code>Return From Keyword</code> to return based on the given condition. The condition is evaluated using the same semantics as with <code>Should Be True</code> keyword.</p> <p>Given the same example as in <code>Return From Keyword</code>, we can rewrite the <code>Find Index</code> keyword as follows:</p> <p>| * Keywords *** | Find Index |    [Arguments]    ${element}    @{items} |    ${index} =    Set Variable    ${0} |    FOR    ${item}    IN    @{items} |        Return From Keyword If    '${item}' == '${element}'    ${index} |        ${index} =    Set Variable    ${index + 1} |    END |    Return From Keyword    ${-1}</p> <p>See also <code>Run Keyword And Return</code> and <code>Run Keyword And Return If</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=1)\ndef return_from_keyword_if(self, condition, *return_values):\n    \"\"\"Returns from the enclosing user keyword if ``condition`` is true.\n\n    ---\n\n    *NOTE:* Robot Framework 5.0 added support for native ``RETURN`` statement\n    and for inline ``IF``, and that combination should be used instead of this\n    keyword. For example, ``Return From Keyword`` usage in the example below\n    could be replaced with\n\n    | IF    '${item}' == '${element}'    RETURN    ${index}\n\n    This keyword will eventually be deprecated and removed.\n\n    ---\n\n    A wrapper for `Return From Keyword` to return based on the given\n    condition. The condition is evaluated using the same semantics as\n    with `Should Be True` keyword.\n\n    Given the same example as in `Return From Keyword`, we can rewrite the\n    `Find Index` keyword as follows:\n\n    | ***** Keywords *****\n    | Find Index\n    |    [Arguments]    ${element}    @{items}\n    |    ${index} =    Set Variable    ${0}\n    |    FOR    ${item}    IN    @{items}\n    |        Return From Keyword If    '${item}' == '${element}'    ${index}\n    |        ${index} =    Set Variable    ${index + 1}\n    |    END\n    |    Return From Keyword    ${-1}\n\n    See also `Run Keyword And Return` and `Run Keyword And Return If`.\n    \"\"\"\n    if self._is_true(condition):\n        self._return_from_keyword(return_values)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_and_return","title":"run_keyword_and_return","text":"<pre><code>run_keyword_and_return(name, *args)\n</code></pre> <p>Runs the specified keyword and returns from the enclosing user keyword.</p> <p>The keyword to execute is defined with <code>name</code> and <code>*args</code> exactly like with <code>Run Keyword</code>. After running the keyword, returns from the enclosing user keyword and passes possible return value from the executed keyword further. Returning from a keyword has exactly same semantics as with <code>Return From Keyword</code>.</p> <p>Example: | <code>Run Keyword And Return</code>  | <code>My Keyword</code> | arg1 | arg2 | | # Above is equivalent to: | | ${result} =               | <code>My Keyword</code> | arg1 | arg2 | | <code>Return From Keyword</code>     | ${result}    |      |      |</p> <p>Use <code>Run Keyword And Return If</code> if you want to run keyword and return based on a condition.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keyword_and_return(self, name, *args):\n    \"\"\"Runs the specified keyword and returns from the enclosing user keyword.\n\n    The keyword to execute is defined with ``name`` and ``*args`` exactly\n    like with `Run Keyword`. After running the keyword, returns from the\n    enclosing user keyword and passes possible return value from the\n    executed keyword further. Returning from a keyword has exactly same\n    semantics as with `Return From Keyword`.\n\n    Example:\n    | `Run Keyword And Return`  | `My Keyword` | arg1 | arg2 |\n    | # Above is equivalent to: |\n    | ${result} =               | `My Keyword` | arg1 | arg2 |\n    | `Return From Keyword`     | ${result}    |      |      |\n\n    Use `Run Keyword And Return If` if you want to run keyword and return\n    based on a condition.\n    \"\"\"\n    try:\n        ret = self.run_keyword(name, *args)\n    except ExecutionFailed as err:\n        self._return_from_keyword(failures=[err])\n    else:\n        self._return_from_keyword(return_values=[escape(ret)])\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_and_return_if","title":"run_keyword_and_return_if","text":"<pre><code>run_keyword_and_return_if(condition, name, *args)\n</code></pre> <p>Runs the specified keyword and returns from the enclosing user keyword.</p> <p>A wrapper for <code>Run Keyword And Return</code> to run and return based on the given <code>condition</code>. The condition is evaluated using the same semantics as with <code>Should Be True</code> keyword.</p> <p>Example: | <code>Run Keyword And Return If</code> | ${rc} &gt; 0 | <code>My Keyword</code> | arg1 | arg2 | | # Above is equivalent to:   | | <code>Run Keyword If</code>            | ${rc} &gt; 0 | <code>Run Keyword And Return</code> | <code>My Keyword</code> | arg1 | arg2 |</p> <p>Use <code>Return From Keyword If</code> if you want to return a certain value based on a condition.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=1, dry_run=True)\ndef run_keyword_and_return_if(self, condition, name, *args):\n    \"\"\"Runs the specified keyword and returns from the enclosing user keyword.\n\n    A wrapper for `Run Keyword And Return` to run and return based on\n    the given ``condition``. The condition is evaluated using the same\n    semantics as with `Should Be True` keyword.\n\n    Example:\n    | `Run Keyword And Return If` | ${rc} &gt; 0 | `My Keyword` | arg1 | arg2 |\n    | # Above is equivalent to:   |\n    | `Run Keyword If`            | ${rc} &gt; 0 | `Run Keyword And Return` | `My Keyword ` | arg1 | arg2 |\n\n    Use `Return From Keyword If` if you want to return a certain value\n    based on a condition.\n    \"\"\"\n    if self._is_true(condition):\n        self.run_keyword_and_return(name, *args)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.pass_execution","title":"pass_execution","text":"<pre><code>pass_execution(message, *tags)\n</code></pre> <p>Skips rest of the current test, setup, or teardown with PASS status.</p> <p>This keyword can be used anywhere in the test data, but the place where used affects the behavior:</p> <ul> <li>When used in any setup or teardown (suite, test or keyword), passes   that setup or teardown. Possible keyword teardowns of the started   keywords are executed. Does not affect execution or statuses   otherwise.</li> <li>When used in a test outside setup or teardown, passes that particular   test case. Possible test and keyword teardowns are executed.</li> </ul> <p>Possible continuable failures before this keyword is used, as well as failures in executed teardowns, will fail the execution.</p> <p>It is mandatory to give a message explaining why execution was passed. By default the message is considered plain text, but starting it with <code>*HTML*</code> allows using HTML formatting.</p> <p>It is also possible to modify test tags passing tags after the message similarly as with <code>Fail</code> keyword. Tags starting with a hyphen (e.g. <code>-regression</code>) are removed and others added. Tags are modified using <code>Set Tags</code> and <code>Remove Tags</code> internally, and the semantics setting and removing them are the same as with these keywords.</p> <p>Examples: | Pass Execution | All features available in this version tested. | | Pass Execution | Deprecated test. | deprecated | -regression    |</p> <p>This keyword is typically wrapped to some other keyword, such as <code>Run Keyword If</code>, to pass based on a condition. The most common case can be handled also with <code>Pass Execution If</code>:</p> <p>| Run Keyword If    | ${rc} &lt; 0 | Pass Execution | Negative values are cool. | | Pass Execution If | ${rc} &lt; 0 | Negative values are cool. |</p> <p>Passing execution in the middle of a test, setup or teardown should be used with care. In the worst case it leads to tests that skip all the parts that could actually uncover problems in the tested application. In cases where execution cannot continue due to external factors, it is often safer to fail the test case and make it non-critical.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def pass_execution(self, message, *tags):\n    \"\"\"Skips rest of the current test, setup, or teardown with PASS status.\n\n    This keyword can be used anywhere in the test data, but the place where\n    used affects the behavior:\n\n    - When used in any setup or teardown (suite, test or keyword), passes\n      that setup or teardown. Possible keyword teardowns of the started\n      keywords are executed. Does not affect execution or statuses\n      otherwise.\n    - When used in a test outside setup or teardown, passes that particular\n      test case. Possible test and keyword teardowns are executed.\n\n    Possible continuable failures before this keyword is used, as well as\n    failures in executed teardowns, will fail the execution.\n\n    It is mandatory to give a message explaining why execution was passed.\n    By default the message is considered plain text, but starting it with\n    ``*HTML*`` allows using HTML formatting.\n\n    It is also possible to modify test tags passing tags after the message\n    similarly as with `Fail` keyword. Tags starting with a hyphen\n    (e.g. ``-regression``) are removed and others added. Tags are modified\n    using `Set Tags` and `Remove Tags` internally, and the semantics\n    setting and removing them are the same as with these keywords.\n\n    Examples:\n    | Pass Execution | All features available in this version tested. |\n    | Pass Execution | Deprecated test. | deprecated | -regression    |\n\n    This keyword is typically wrapped to some other keyword, such as\n    `Run Keyword If`, to pass based on a condition. The most common case\n    can be handled also with `Pass Execution If`:\n\n    | Run Keyword If    | ${rc} &lt; 0 | Pass Execution | Negative values are cool. |\n    | Pass Execution If | ${rc} &lt; 0 | Negative values are cool. |\n\n    Passing execution in the middle of a test, setup or teardown should be\n    used with care. In the worst case it leads to tests that skip all the\n    parts that could actually uncover problems in the tested application.\n    In cases where execution cannot continue due to external factors,\n    it is often safer to fail the test case and make it non-critical.\n    \"\"\"\n    message = message.strip()\n    if not message:\n        raise RuntimeError('Message cannot be empty.')\n    self._set_and_remove_tags(tags)\n    log_message, level = self._get_logged_test_message_and_level(message)\n    self.log(f'Execution passed with message:\\n{log_message}', level)\n    raise PassExecution(message)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.pass_execution_if","title":"pass_execution_if","text":"<pre><code>pass_execution_if(condition, message, *tags)\n</code></pre> <p>Conditionally skips rest of the current test, setup, or teardown with PASS status.</p> <p>A wrapper for <code>Pass Execution</code> to skip rest of the current test, setup or teardown based the given <code>condition</code>. The condition is evaluated similarly as with <code>Should Be True</code> keyword, and <code>message</code> and <code>*tags</code> have same semantics as with <code>Pass Execution</code>.</p> <p>Example: | FOR | ${var}            | IN                     | @{VALUES}               | |     | Pass Execution If | '${var}' == 'EXPECTED' | Correct value was found | |     | Do Something      | ${var}                 | | END |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=1)\ndef pass_execution_if(self, condition, message, *tags):\n    \"\"\"Conditionally skips rest of the current test, setup, or teardown with PASS status.\n\n    A wrapper for `Pass Execution` to skip rest of the current test,\n    setup or teardown based the given ``condition``. The condition is\n    evaluated similarly as with `Should Be True` keyword, and ``message``\n    and ``*tags`` have same semantics as with `Pass Execution`.\n\n    Example:\n    | FOR | ${var}            | IN                     | @{VALUES}               |\n    |     | Pass Execution If | '${var}' == 'EXPECTED' | Correct value was found |\n    |     | Do Something      | ${var}                 |\n    | END |\n    \"\"\"\n    if self._is_true(condition):\n        message = self._variables.replace_string(message)\n        tags = self._variables.replace_list(tags)\n        self.pass_execution(message, *tags)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword","title":"run_keyword","text":"<pre><code>run_keyword(name, *args)\n</code></pre> <p>Executes the given keyword with the given arguments.</p> <p>Because the name of the keyword to execute is given as an argument, it can be a variable and thus set dynamically, e.g. from a return value of another keyword or from the command line.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keyword(self, name, *args):\n    \"\"\"Executes the given keyword with the given arguments.\n\n    Because the name of the keyword to execute is given as an argument, it\n    can be a variable and thus set dynamically, e.g. from a return value of\n    another keyword or from the command line.\n    \"\"\"\n    if not is_string(name):\n        raise RuntimeError('Keyword name must be a string.')\n    ctx = self._context\n    if not (ctx.dry_run or self._accepts_embedded_arguments(name, ctx)):\n        name, args = self._replace_variables_in_name([name] + list(args))\n    if ctx.steps:\n        data, result = ctx.steps[-1]\n        lineno = data.lineno\n    else:    # Called, typically by a listener, when no keyword started.\n        data = lineno = None\n        result = ctx.test or (ctx.suite.setup if not ctx.suite.has_tests\n                              else ctx.suite.teardown)\n    kw = Keyword(name, args=args, parent=data, lineno=lineno)\n    return kw.run(result, ctx)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keywords","title":"run_keywords","text":"<pre><code>run_keywords(*keywords)\n</code></pre> <p>Executes all the given keywords in a sequence.</p> <p>This keyword is mainly useful in setups and teardowns when they need to take care of multiple actions and creating a new higher level user keyword would be an overkill.</p> <p>By default all arguments are expected to be keywords to be executed.</p> <p>Examples: | <code>Run Keywords</code> | <code>Initialize database</code> | <code>Start servers</code> | <code>Clear logs</code> | | <code>Run Keywords</code> | ${KW 1} | ${KW 2} | | <code>Run Keywords</code> | @{KEYWORDS} |</p> <p>Keywords can also be run with arguments using upper case <code>AND</code> as a separator between keywords. The keywords are executed so that the first argument is the first keyword and proceeding arguments until the first <code>AND</code> are arguments to it. First argument after the first <code>AND</code> is the second keyword and proceeding arguments until the next <code>AND</code> are its arguments. And so on.</p> <p>Examples: | <code>Run Keywords</code> | <code>Initialize database</code> | db1 | AND | <code>Start servers</code> | server1 | server2 | | <code>Run Keywords</code> | <code>Initialize database</code> | ${DB NAME} | AND | <code>Start servers</code> | @{SERVERS} | AND | <code>Clear logs</code> | | <code>Run Keywords</code> | ${KW} | AND | @{KW WITH ARGS} |</p> <p>Notice that the <code>AND</code> control argument must be used explicitly and cannot itself come from a variable. If you need to use literal <code>AND</code> string as argument, you can either use variables or escape it with a backslash like <code>\\AND</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keywords(self, *keywords):\n    \"\"\"Executes all the given keywords in a sequence.\n\n    This keyword is mainly useful in setups and teardowns when they need\n    to take care of multiple actions and creating a new higher level user\n    keyword would be an overkill.\n\n    By default all arguments are expected to be keywords to be executed.\n\n    Examples:\n    | `Run Keywords` | `Initialize database` | `Start servers` | `Clear logs` |\n    | `Run Keywords` | ${KW 1} | ${KW 2} |\n    | `Run Keywords` | @{KEYWORDS} |\n\n    Keywords can also be run with arguments using upper case ``AND`` as\n    a separator between keywords. The keywords are executed so that the\n    first argument is the first keyword and proceeding arguments until\n    the first ``AND`` are arguments to it. First argument after the first\n    ``AND`` is the second keyword and proceeding arguments until the next\n    ``AND`` are its arguments. And so on.\n\n    Examples:\n    | `Run Keywords` | `Initialize database` | db1 | AND | `Start servers` | server1 | server2 |\n    | `Run Keywords` | `Initialize database` | ${DB NAME} | AND | `Start servers` | @{SERVERS} | AND | `Clear logs` |\n    | `Run Keywords` | ${KW} | AND | @{KW WITH ARGS} |\n\n    Notice that the ``AND`` control argument must be used explicitly and\n    cannot itself come from a variable. If you need to use literal ``AND``\n    string as argument, you can either use variables or escape it with\n    a backslash like ``\\\\AND``.\n    \"\"\"\n    self._run_keywords(self._split_run_keywords(list(keywords)))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_if","title":"run_keyword_if","text":"<pre><code>run_keyword_if(condition, name, *args)\n</code></pre> <p>Runs the given keyword with the given arguments, if <code>condition</code> is true.</p> <p>NOTE: Robot Framework 4.0 introduced built-in IF/ELSE support and using that is generally recommended over using this keyword.</p> <p>The given <code>condition</code> is evaluated in Python as explained in the <code>Evaluating expressions</code> section, and <code>name</code> and <code>*args</code> have same semantics as with <code>Run Keyword</code>.</p> <p>Example, a simple if/else construct: | <code>Run Keyword If</code> | '${status}' == 'OK' | Some Action    | arg | | <code>Run Keyword If</code> | '${status}' != 'OK' | Another Action |</p> <p>In this example, only either <code>Some Action</code> or <code>Another Action</code> is executed, based on the value of the <code>${status}</code> variable.</p> <p>Variables used like <code>${variable}</code>, as in the examples above, are replaced in the expression before evaluation. Variables are also available in the evaluation namespace and can be accessed using special <code>$variable</code> syntax as explained in the <code>Evaluating expressions</code> section.</p> <p>Example: | <code>Run Keyword If</code> | $result is None or $result == 'FAIL' | Keyword |</p> <p>This keyword supports also optional ELSE and ELSE IF branches. Both of them are defined in <code>*args</code> and must use exactly format <code>ELSE</code> or <code>ELSE IF</code>, respectively. ELSE branches must contain first the name of the keyword to execute and then its possible arguments. ELSE IF branches must first contain a condition, like the first argument to this keyword, and then the keyword to execute and its possible arguments. It is possible to have ELSE branch after ELSE IF and to have multiple ELSE IF branches. Nested <code>Run Keyword If</code> usage is not supported when using ELSE and/or ELSE IF branches.</p> <p>Given previous example, if/else construct can also be created like this: | <code>Run Keyword If</code> | '${status}' == 'PASS' | Some Action | arg | ELSE | Another Action |</p> <p>The return value of this keyword is the return value of the actually executed keyword or Python <code>None</code> if no keyword was executed (i.e. if <code>condition</code> was false). Hence, it is recommended to use ELSE and/or ELSE IF branches to conditionally assign return values from keyword to variables (see <code>Set Variable If</code> you need to set fixed values conditionally). This is illustrated by the example below:</p> <p>| ${var1} =   | <code>Run Keyword If</code> | ${rc} == 0     | Some keyword returning a value | | ...         | ELSE IF          | 0 &lt; ${rc} &lt; 42 | Another keyword | | ...         | ELSE IF          | ${rc} &lt; 0      | Another keyword with args | ${rc} | arg2 | | ...         | ELSE             | Final keyword to handle abnormal cases | ${rc} | | ${var2} =   | <code>Run Keyword If</code> | ${condition}  | Some keyword |</p> <p>In this example, ${var2} will be set to <code>None</code> if ${condition} is false.</p> <p>Notice that <code>ELSE</code> and <code>ELSE IF</code> control words must be used explicitly and thus cannot come from variables. If you need to use literal <code>ELSE</code> and <code>ELSE IF</code> strings as arguments, you can escape them with a backslash like <code>\\ELSE</code> and <code>\\ELSE IF</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=1, dry_run=True)\ndef run_keyword_if(self, condition, name, *args):\n    \"\"\"Runs the given keyword with the given arguments, if ``condition`` is true.\n\n    *NOTE:* Robot Framework 4.0 introduced built-in IF/ELSE support and using\n    that is generally recommended over using this keyword.\n\n    The given ``condition`` is evaluated in Python as explained in the\n    `Evaluating expressions` section, and ``name`` and ``*args`` have same\n    semantics as with `Run Keyword`.\n\n    Example, a simple if/else construct:\n    | `Run Keyword If` | '${status}' == 'OK' | Some Action    | arg |\n    | `Run Keyword If` | '${status}' != 'OK' | Another Action |\n\n    In this example, only either ``Some Action`` or ``Another Action`` is\n    executed, based on the value of the ``${status}`` variable.\n\n    Variables used like ``${variable}``, as in the examples above, are\n    replaced in the expression before evaluation. Variables are also\n    available in the evaluation namespace and can be accessed using special\n    ``$variable`` syntax as explained in the `Evaluating expressions` section.\n\n    Example:\n    | `Run Keyword If` | $result is None or $result == 'FAIL' | Keyword |\n\n    This keyword supports also optional ELSE and ELSE IF branches. Both\n    of them are defined in ``*args`` and must use exactly format ``ELSE``\n    or ``ELSE IF``, respectively. ELSE branches must contain first the\n    name of the keyword to execute and then its possible arguments. ELSE\n    IF branches must first contain a condition, like the first argument\n    to this keyword, and then the keyword to execute and its possible\n    arguments. It is possible to have ELSE branch after ELSE IF and to\n    have multiple ELSE IF branches. Nested `Run Keyword If` usage is not\n    supported when using ELSE and/or ELSE IF branches.\n\n    Given previous example, if/else construct can also be created like this:\n    | `Run Keyword If` | '${status}' == 'PASS' | Some Action | arg | ELSE | Another Action |\n\n    The return value of this keyword is the return value of the actually\n    executed keyword or Python ``None`` if no keyword was executed (i.e.\n    if ``condition`` was false). Hence, it is recommended to use ELSE\n    and/or ELSE IF branches to conditionally assign return values from\n    keyword to variables (see `Set Variable If` you need to set fixed\n    values conditionally). This is illustrated by the example below:\n\n    | ${var1} =   | `Run Keyword If` | ${rc} == 0     | Some keyword returning a value |\n    | ...         | ELSE IF          | 0 &lt; ${rc} &lt; 42 | Another keyword |\n    | ...         | ELSE IF          | ${rc} &lt; 0      | Another keyword with args | ${rc} | arg2 |\n    | ...         | ELSE             | Final keyword to handle abnormal cases | ${rc} |\n    | ${var2} =   | `Run Keyword If` | ${condition}  | Some keyword |\n\n    In this example, ${var2} will be set to ``None`` if ${condition} is\n    false.\n\n    Notice that ``ELSE`` and ``ELSE IF`` control words must be used\n    explicitly and thus cannot come from variables. If you need to use\n    literal ``ELSE`` and ``ELSE IF`` strings as arguments, you can escape\n    them with a backslash like ``\\\\ELSE`` and ``\\\\ELSE IF``.\n    \"\"\"\n    args, branch = self._split_elif_or_else_branch(args)\n    if self._is_true(condition):\n        return self.run_keyword(name, *args)\n    return branch()\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_unless","title":"run_keyword_unless","text":"<pre><code>run_keyword_unless(condition, name, *args)\n</code></pre> <p>DEPRECATED since RF 5.0. Use Native IF/ELSE or <code>Run Keyword If</code> instead.</p> <p>Runs the given keyword with the given arguments if <code>condition</code> is false.</p> <p>See <code>Run Keyword If</code> for more information and an example. Notice that this keyword does not support ELSE or ELSE IF branches like <code>Run Keyword If</code> does.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=1, dry_run=True)\ndef run_keyword_unless(self, condition, name, *args):\n    \"\"\"*DEPRECATED since RF 5.0. Use Native IF/ELSE or `Run Keyword If` instead.*\n\n    Runs the given keyword with the given arguments if ``condition`` is false.\n\n    See `Run Keyword If` for more information and an example. Notice that this\n    keyword does not support ELSE or ELSE IF branches like `Run Keyword If` does.\n    \"\"\"\n    if not self._is_true(condition):\n        return self.run_keyword(name, *args)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_and_ignore_error","title":"run_keyword_and_ignore_error","text":"<pre><code>run_keyword_and_ignore_error(name, *args)\n</code></pre> <p>Runs the given keyword with the given arguments and ignores possible error.</p> <p>This keyword returns two values, so that the first is either string <code>PASS</code> or <code>FAIL</code>, depending on the status of the executed keyword. The second value is either the return value of the keyword or the received error message. See <code>Run Keyword And Return Status</code> If you are only interested in the execution status.</p> <p>The keyword name and arguments work as in <code>Run Keyword</code>. See <code>Run Keyword If</code> for a usage example.</p> <p>Errors caused by invalid syntax, timeouts, or fatal exceptions are not caught by this keyword. Otherwise this keyword itself never fails.</p> <p>NOTE: Robot Framework 5.0 introduced native TRY/EXCEPT functionality that is generally recommended for error handling.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keyword_and_ignore_error(self, name, *args):\n    \"\"\"Runs the given keyword with the given arguments and ignores possible error.\n\n    This keyword returns two values, so that the first is either string\n    ``PASS`` or ``FAIL``, depending on the status of the executed keyword.\n    The second value is either the return value of the keyword or the\n    received error message. See `Run Keyword And Return Status` If you are\n    only interested in the execution status.\n\n    The keyword name and arguments work as in `Run Keyword`. See\n    `Run Keyword If` for a usage example.\n\n    Errors caused by invalid syntax, timeouts, or fatal exceptions are not\n    caught by this keyword. Otherwise this keyword itself never fails.\n\n    *NOTE:* Robot Framework 5.0 introduced native TRY/EXCEPT functionality\n    that is generally recommended for error handling.\n    \"\"\"\n    try:\n        return 'PASS', self.run_keyword(name, *args)\n    except ExecutionFailed as err:\n        if err.dont_continue or err.skip:\n            raise\n        return 'FAIL', str(err)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_and_warn_on_failure","title":"run_keyword_and_warn_on_failure","text":"<pre><code>run_keyword_and_warn_on_failure(name, *args)\n</code></pre> <p>Runs the specified keyword logs a warning if the keyword fails.</p> <p>This keyword is similar to <code>Run Keyword And Ignore Error</code> but if the executed keyword fails, the error message is logged as a warning to make it more visible. Returns status and possible return value or error message exactly like <code>Run Keyword And Ignore Error</code> does.</p> <p>Errors caused by invalid syntax, timeouts, or fatal exceptions are not caught by this keyword. Otherwise this keyword itself never fails.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keyword_and_warn_on_failure(self, name, *args):\n    \"\"\"Runs the specified keyword logs a warning if the keyword fails.\n\n    This keyword is similar to `Run Keyword And Ignore Error` but if the executed\n    keyword fails, the error message is logged as a warning to make it more\n    visible. Returns status and possible return value or error message exactly\n    like `Run Keyword And Ignore Error` does.\n\n    Errors caused by invalid syntax, timeouts, or fatal exceptions are not\n    caught by this keyword. Otherwise this keyword itself never fails.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    status, message = self.run_keyword_and_ignore_error(name, *args)\n    if status == 'FAIL':\n        logger.warn(f\"Executing keyword '{name}' failed:\\n{message}\")\n    return status, message\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_and_return_status","title":"run_keyword_and_return_status","text":"<pre><code>run_keyword_and_return_status(name, *args)\n</code></pre> <p>Runs the given keyword with given arguments and returns the status as a Boolean value.</p> <p>This keyword returns Boolean <code>True</code> if the keyword that is executed succeeds and <code>False</code> if it fails. This is useful, for example, in combination with <code>Run Keyword If</code>. If you are interested in the error message or return value, use <code>Run Keyword And Ignore Error</code> instead.</p> <p>The keyword name and arguments work as in <code>Run Keyword</code>.</p> <p>Example: | ${passed} = | <code>Run Keyword And Return Status</code> | Keyword | args | | <code>Run Keyword If</code> | ${passed} | Another keyword |</p> <p>Errors caused by invalid syntax, timeouts, or fatal exceptions are not caught by this keyword. Otherwise this keyword itself never fails.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keyword_and_return_status(self, name, *args):\n    \"\"\"Runs the given keyword with given arguments and returns the status as a Boolean value.\n\n    This keyword returns Boolean ``True`` if the keyword that is executed\n    succeeds and ``False`` if it fails. This is useful, for example, in\n    combination with `Run Keyword If`. If you are interested in the error\n    message or return value, use `Run Keyword And Ignore Error` instead.\n\n    The keyword name and arguments work as in `Run Keyword`.\n\n    Example:\n    | ${passed} = | `Run Keyword And Return Status` | Keyword | args |\n    | `Run Keyword If` | ${passed} | Another keyword |\n\n    Errors caused by invalid syntax, timeouts, or fatal exceptions are not\n    caught by this keyword. Otherwise this keyword itself never fails.\n    \"\"\"\n    status, _ = self.run_keyword_and_ignore_error(name, *args)\n    return status == 'PASS'\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_and_continue_on_failure","title":"run_keyword_and_continue_on_failure","text":"<pre><code>run_keyword_and_continue_on_failure(name, *args)\n</code></pre> <p>Runs the keyword and continues execution even if a failure occurs.</p> <p>The keyword name and arguments work as with <code>Run Keyword</code>.</p> <p>Example: | Run Keyword And Continue On Failure | Fail | This is a stupid example | | Log | This keyword is executed |</p> <p>The execution is not continued if the failure is caused by invalid syntax, timeout, or fatal exception.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keyword_and_continue_on_failure(self, name, *args):\n    \"\"\"Runs the keyword and continues execution even if a failure occurs.\n\n    The keyword name and arguments work as with `Run Keyword`.\n\n    Example:\n    | Run Keyword And Continue On Failure | Fail | This is a stupid example |\n    | Log | This keyword is executed |\n\n    The execution is not continued if the failure is caused by invalid syntax,\n    timeout, or fatal exception.\n    \"\"\"\n    try:\n        return self.run_keyword(name, *args)\n    except ExecutionFailed as err:\n        if not err.dont_continue:\n            err.continue_on_failure = True\n        raise err\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_and_expect_error","title":"run_keyword_and_expect_error","text":"<pre><code>run_keyword_and_expect_error(expected_error, name, *args)\n</code></pre> <p>Runs the keyword and checks that the expected error occurred.</p> <p>The keyword to execute and its arguments are specified using <code>name</code> and <code>*args</code> exactly like with <code>Run Keyword</code>.</p> <p>The expected error must be given in the same format as in Robot Framework reports. By default it is interpreted as a glob pattern with <code>*</code>, <code>?</code> and <code>[chars]</code> as wildcards, but that can be changed by using various prefixes explained in the table below. Prefixes are case-sensitive and they must be separated from the actual message with a colon and an optional space like <code>PREFIX: Message</code> or <code>PREFIX:Message</code>.</p> <p>| = Prefix = | = Explanation = | | <code>EQUALS</code> | Exact match. Especially useful if the error contains glob wildcards. | | <code>STARTS</code> | Error must start with the specified error. | | <code>REGEXP</code> | Regular expression match. | | <code>GLOB</code>   | Same as the default behavior. |</p> <p>See the <code>Pattern matching</code> section for more information about glob patterns and regular expressions.</p> <p>If the expected error occurs, the error message is returned and it can be further processed or tested if needed. If there is no error, or the error does not match the expected error, this keyword fails.</p> <p>Examples: | Run Keyword And Expect Error | My error            | Keyword | arg | | Run Keyword And Expect Error | ValueError: *       | Some Keyword  | | Run Keyword And Expect Error | STARTS: ValueError: | Some Keyword  | | Run Keyword And Expect Error | EQUALS:No match for '//input[@type=\"text\"]' | | ...                          | Find Element | //input[@type=\"text\"] | | ${msg} =                     | Run Keyword And Expect Error | * | | ...                          | Keyword | arg1 | arg2 | | Log To Console | ${msg} |</p> <p>Errors caused by invalid syntax, timeouts, or fatal exceptions are not caught by this keyword.</p> <p>NOTE: Regular expression matching used to require only the beginning of the error to match the given pattern. That was changed in Robot Framework 5.0 and nowadays the pattern must match the error fully. To match only the beginning, add <code>.*</code> at the end of the pattern like <code>REGEXP: Start.*</code>.</p> <p>NOTE: Robot Framework 5.0 introduced native TRY/EXCEPT functionality that is generally recommended for error handling. It supports same pattern matching syntax as this keyword.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=1, dry_run=True)\ndef run_keyword_and_expect_error(self, expected_error, name, *args):\n    \"\"\"Runs the keyword and checks that the expected error occurred.\n\n    The keyword to execute and its arguments are specified using ``name``\n    and ``*args`` exactly like with `Run Keyword`.\n\n    The expected error must be given in the same format as in Robot Framework\n    reports. By default it is interpreted as a glob pattern with ``*``, ``?``\n    and ``[chars]`` as wildcards, but that can be changed by using various\n    prefixes explained in the table below. Prefixes are case-sensitive and\n    they must be separated from the actual message with a colon and an\n    optional space like ``PREFIX: Message`` or ``PREFIX:Message``.\n\n    | = Prefix = | = Explanation = |\n    | ``EQUALS`` | Exact match. Especially useful if the error contains glob wildcards. |\n    | ``STARTS`` | Error must start with the specified error. |\n    | ``REGEXP`` | Regular expression match. |\n    | ``GLOB``   | Same as the default behavior. |\n\n    See the `Pattern matching` section for more information about glob\n    patterns and regular expressions.\n\n    If the expected error occurs, the error message is returned and it can\n    be further processed or tested if needed. If there is no error, or the\n    error does not match the expected error, this keyword fails.\n\n    Examples:\n    | Run Keyword And Expect Error | My error            | Keyword | arg |\n    | Run Keyword And Expect Error | ValueError: *       | Some Keyword  |\n    | Run Keyword And Expect Error | STARTS: ValueError: | Some Keyword  |\n    | Run Keyword And Expect Error | EQUALS:No match for '//input[@type=\"text\"]' |\n    | ...                          | Find Element | //input[@type=\"text\"] |\n    | ${msg} =                     | Run Keyword And Expect Error | * |\n    | ...                          | Keyword | arg1 | arg2 |\n    | Log To Console | ${msg} |\n\n    Errors caused by invalid syntax, timeouts, or fatal exceptions are not\n    caught by this keyword.\n\n    *NOTE:* Regular expression matching used to require only the beginning\n    of the error to match the given pattern. That was changed in Robot\n    Framework 5.0 and nowadays the pattern must match the error fully.\n    To match only the beginning, add ``.*`` at the end of the pattern like\n    ``REGEXP: Start.*``.\n\n    *NOTE:* Robot Framework 5.0 introduced native TRY/EXCEPT functionality\n    that is generally recommended for error handling. It supports same\n    pattern matching syntax as this keyword.\n    \"\"\"\n    try:\n        self.run_keyword(name, *args)\n    except ExecutionFailed as err:\n        if err.dont_continue or err.skip:\n            raise\n        error = err.message\n    else:\n        raise AssertionError(f\"Expected error '{expected_error}' did not occur.\")\n    if not self._error_is_expected(error, expected_error):\n        raise AssertionError(f\"Expected error '{expected_error}' but got '{error}'.\")\n    return error\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.repeat_keyword","title":"repeat_keyword","text":"<pre><code>repeat_keyword(repeat, name, *args)\n</code></pre> <p>Executes the specified keyword multiple times.</p> <p><code>name</code> and <code>args</code> define the keyword that is executed similarly as with <code>Run Keyword</code>. <code>repeat</code> specifies how many times (as a count) or how long time (as a timeout) the keyword should be executed.</p> <p>If <code>repeat</code> is given as count, it specifies how many times the keyword should be executed. <code>repeat</code> can be given as an integer or as a string that can be converted to an integer. If it is a string, it can have postfix <code>times</code> or <code>x</code> (case and space insensitive) to make the expression more explicit.</p> <p>If <code>repeat</code> is given as timeout, it must be in Robot Framework's time format (e.g. <code>1 minute</code>, <code>2 min 3 s</code>). Using a number alone (e.g. <code>1</code> or <code>1.5</code>) does not work in this context.</p> <p>If <code>repeat</code> is zero or negative, the keyword is not executed at all. This keyword fails immediately if any of the execution rounds fails.</p> <p>Examples: | Repeat Keyword | 5 times   | Go to Previous Page | | Repeat Keyword | ${var}    | Some Keyword | arg1 | arg2 | | Repeat Keyword | 2 minutes | Some Keyword | arg1 | arg2 |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=1, dry_run=True)\ndef repeat_keyword(self, repeat, name, *args):\n    \"\"\"Executes the specified keyword multiple times.\n\n    ``name`` and ``args`` define the keyword that is executed similarly as\n    with `Run Keyword`. ``repeat`` specifies how many times (as a count) or\n    how long time (as a timeout) the keyword should be executed.\n\n    If ``repeat`` is given as count, it specifies how many times the\n    keyword should be executed. ``repeat`` can be given as an integer or\n    as a string that can be converted to an integer. If it is a string,\n    it can have postfix ``times`` or ``x`` (case and space insensitive)\n    to make the expression more explicit.\n\n    If ``repeat`` is given as timeout, it must be in Robot Framework's\n    time format (e.g. ``1 minute``, ``2 min 3 s``). Using a number alone\n    (e.g. ``1`` or ``1.5``) does not work in this context.\n\n    If ``repeat`` is zero or negative, the keyword is not executed at\n    all. This keyword fails immediately if any of the execution\n    rounds fails.\n\n    Examples:\n    | Repeat Keyword | 5 times   | Go to Previous Page |\n    | Repeat Keyword | ${var}    | Some Keyword | arg1 | arg2 |\n    | Repeat Keyword | 2 minutes | Some Keyword | arg1 | arg2 |\n    \"\"\"\n    try:\n        count = self._get_repeat_count(repeat)\n    except RuntimeError as err:\n        timeout = self._get_repeat_timeout(repeat)\n        if timeout is None:\n            raise err\n        keywords = self._keywords_repeated_by_timeout(timeout, name, args)\n    else:\n        keywords = self._keywords_repeated_by_count(count, name, args)\n    self._run_keywords(keywords)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.wait_until_keyword_succeeds","title":"wait_until_keyword_succeeds","text":"<pre><code>wait_until_keyword_succeeds(\n    retry, retry_interval, name, *args\n)\n</code></pre> <p>Runs the specified keyword and retries if it fails.</p> <p><code>name</code> and <code>args</code> define the keyword that is executed similarly as with <code>Run Keyword</code>. How long to retry running the keyword is defined using <code>retry</code> argument either as timeout or count. <code>retry_interval</code> is the time to wait between execution attempts.</p> <p>If <code>retry</code> is given as timeout, it must be in Robot Framework's time format (e.g. <code>1 minute</code>, <code>2 min 3 s</code>, <code>4.5</code>) that is explained in an appendix of Robot Framework User Guide. If it is given as count, it must have <code>times</code> or <code>x</code> postfix (e.g. <code>5 times</code>, <code>10 x</code>). <code>retry_interval</code> must always be given in Robot Framework's time format.</p> <p>By default, <code>retry_interval</code> is the time to wait after a keyword has failed. For example, if the first run takes 2 seconds and the retry interval is 3 seconds, the second run starts 5 seconds after the first run started. If <code>retry_interval</code> start with prefix <code>strict:</code>, the execution time of the previous keyword is subtracted from the retry time. With the earlier example the second run would thus start 3 seconds after the first run started. A warning is logged if keyword execution time is longer than a strict interval.</p> <p>If the keyword does not succeed regardless of retries, this keyword fails. If the executed keyword passes, its return value is returned.</p> <p>Examples: | Wait Until Keyword Succeeds | 2 min | 5 sec | My keyword | argument | | ${result} = | Wait Until Keyword Succeeds | 3x | 200ms | My keyword | | ${result} = | Wait Until Keyword Succeeds | 3x | strict: 200ms | My keyword |</p> <p>All normal failures are caught by this keyword. Errors caused by invalid syntax, test or keyword timeouts, or fatal exceptions (caused e.g. by <code>Fatal Error</code>) are not caught.</p> <p>Running the same keyword multiple times inside this keyword can create lots of output and considerably increase the size of the generated output files. It is possible to remove unnecessary keywords from the outputs using the <code>--remove-keywords WUKS</code> command line option.</p> <p>Support for \"strict\" retry interval is new in Robot Framework 4.1.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=2, dry_run=True)\ndef wait_until_keyword_succeeds(self, retry, retry_interval, name, *args):\n    \"\"\"Runs the specified keyword and retries if it fails.\n\n    ``name`` and ``args`` define the keyword that is executed similarly\n    as with `Run Keyword`. How long to retry running the keyword is\n    defined using ``retry`` argument either as timeout or count.\n    ``retry_interval`` is the time to wait between execution attempts.\n\n    If ``retry`` is given as timeout, it must be in Robot Framework's\n    time format (e.g. ``1 minute``, ``2 min 3 s``, ``4.5``) that is\n    explained in an appendix of Robot Framework User Guide. If it is\n    given as count, it must have ``times`` or ``x`` postfix (e.g.\n    ``5 times``, ``10 x``). ``retry_interval`` must always be given in\n    Robot Framework's time format.\n\n    By default, ``retry_interval`` is the time to wait _after_ a keyword has\n    failed. For example, if the first run takes 2 seconds and the retry\n    interval is 3 seconds, the second run starts 5 seconds after the first\n    run started. If ``retry_interval`` start with prefix ``strict:``, the\n    execution time of the previous keyword is subtracted from the retry time.\n    With the earlier example the second run would thus start 3 seconds after\n    the first run started. A warning is logged if keyword execution time is\n    longer than a strict interval.\n\n    If the keyword does not succeed regardless of retries, this keyword\n    fails. If the executed keyword passes, its return value is returned.\n\n    Examples:\n    | Wait Until Keyword Succeeds | 2 min | 5 sec | My keyword | argument |\n    | ${result} = | Wait Until Keyword Succeeds | 3x | 200ms | My keyword |\n    | ${result} = | Wait Until Keyword Succeeds | 3x | strict: 200ms | My keyword |\n\n    All normal failures are caught by this keyword. Errors caused by\n    invalid syntax, test or keyword timeouts, or fatal exceptions (caused\n    e.g. by `Fatal Error`) are not caught.\n\n    Running the same keyword multiple times inside this keyword can create\n    lots of output and considerably increase the size of the generated\n    output files. It is possible to remove unnecessary keywords from\n    the outputs using the ``--remove-keywords WUKS`` command line option.\n\n    Support for \"strict\" retry interval is new in Robot Framework 4.1.\n    \"\"\"\n    maxtime = count = -1\n    try:\n        count = self._get_repeat_count(retry, require_postfix=True)\n    except ValueError:\n        timeout = timestr_to_secs(retry)\n        maxtime = time.time() + timeout\n        message = f'for {secs_to_timestr(timeout)}'\n    else:\n        if count &lt;= 0:\n            raise ValueError(f'Retry count {count} is not positive.')\n        message = f'{count} time{s(count)}'\n    if is_string(retry_interval) and normalize(retry_interval).startswith('strict:'):\n        retry_interval = retry_interval.split(':', 1)[1].strip()\n        strict_interval = True\n    else:\n        strict_interval = False\n    retry_interval = sleep_time = timestr_to_secs(retry_interval)\n    while True:\n        start_time = time.time()\n        try:\n            return self.run_keyword(name, *args)\n        except ExecutionFailed as err:\n            if err.dont_continue or err.skip:\n                raise\n            count -= 1\n            if time.time() &gt; maxtime &gt; 0 or count == 0:\n                name = self._variables.replace_scalar(name)\n                raise AssertionError(f\"Keyword '{name}' failed after retrying \"\n                                     f\"{message}. The last error was: {err}\")\n        finally:\n            if strict_interval:\n                execution_time = time.time() - start_time\n                sleep_time = retry_interval - execution_time\n                if sleep_time &lt; 0:\n                    logger.warn(\n                        f\"Keyword execution time {secs_to_timestr(execution_time)} \"\n                        f\"is longer than retry interval \"\n                        f\"{secs_to_timestr(retry_interval)}.\"\n                    )\n        self._sleep_in_parts(sleep_time)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_variable_if","title":"set_variable_if","text":"<pre><code>set_variable_if(condition, *values)\n</code></pre> <p>Sets variable based on the given condition.</p> <p>The basic usage is giving a condition and two values. The given condition is first evaluated the same way as with the <code>Should Be True</code> keyword. If the condition is true, then the first value is returned, and otherwise the second value is returned. The second value can also be omitted, in which case it has a default value None. This usage is illustrated in the examples below, where <code>${rc}</code> is assumed to be zero.</p> <p>| ${var1} = | Set Variable If | ${rc} == 0 | zero     | nonzero | | ${var2} = | Set Variable If | ${rc} &gt; 0  | value1   | value2  | | ${var3} = | Set Variable If | ${rc} &gt; 0  | whatever |         | =&gt; | ${var1} = 'zero' | ${var2} = 'value2' | ${var3} = None</p> <p>It is also possible to have 'else if' support by replacing the second value with another condition, and having two new values after it. If the first condition is not true, the second is evaluated and one of the values after it is returned based on its truth value. This can be continued by adding more conditions without a limit.</p> <p>| ${var} = | Set Variable If | ${rc} == 0        | zero           | | ...      | ${rc} &gt; 0       | greater than zero | less then zero | |          | | ${var} = | Set Variable If | | ...      | ${rc} == 0      | zero              | | ...      | ${rc} == 1      | one               | | ...      | ${rc} == 2      | two               | | ...      | ${rc} &gt; 2       | greater than two  | | ...      | ${rc} &lt; 0       | less than zero    |</p> <p>Use <code>Get Variable Value</code> if you need to set variables dynamically based on whether a variable exist or not.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=1)\ndef set_variable_if(self, condition, *values):\n    \"\"\"Sets variable based on the given condition.\n\n    The basic usage is giving a condition and two values. The\n    given condition is first evaluated the same way as with the\n    `Should Be True` keyword. If the condition is true, then the\n    first value is returned, and otherwise the second value is\n    returned. The second value can also be omitted, in which case\n    it has a default value None. This usage is illustrated in the\n    examples below, where ``${rc}`` is assumed to be zero.\n\n    | ${var1} = | Set Variable If | ${rc} == 0 | zero     | nonzero |\n    | ${var2} = | Set Variable If | ${rc} &gt; 0  | value1   | value2  |\n    | ${var3} = | Set Variable If | ${rc} &gt; 0  | whatever |         |\n    =&gt;\n    | ${var1} = 'zero'\n    | ${var2} = 'value2'\n    | ${var3} = None\n\n    It is also possible to have 'else if' support by replacing the\n    second value with another condition, and having two new values\n    after it. If the first condition is not true, the second is\n    evaluated and one of the values after it is returned based on\n    its truth value. This can be continued by adding more\n    conditions without a limit.\n\n    | ${var} = | Set Variable If | ${rc} == 0        | zero           |\n    | ...      | ${rc} &gt; 0       | greater than zero | less then zero |\n    |          |\n    | ${var} = | Set Variable If |\n    | ...      | ${rc} == 0      | zero              |\n    | ...      | ${rc} == 1      | one               |\n    | ...      | ${rc} == 2      | two               |\n    | ...      | ${rc} &gt; 2       | greater than two  |\n    | ...      | ${rc} &lt; 0       | less than zero    |\n\n    Use `Get Variable Value` if you need to set variables\n    dynamically based on whether a variable exist or not.\n    \"\"\"\n    values = list(values)\n    while True:\n        values = self._verify_values_for_set_variable_if(values)\n        if self._is_true(condition):\n            return self._variables.replace_scalar(values[0])\n        if len(values) == 1:\n            return None\n        if len(values) == 2:\n            return self._variables.replace_scalar(values[1])\n        condition, *values = values[1:]\n        condition = self._variables.replace_scalar(condition)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_if_test_failed","title":"run_keyword_if_test_failed","text":"<pre><code>run_keyword_if_test_failed(name, *args)\n</code></pre> <p>Runs the given keyword with the given arguments, if the test failed.</p> <p>This keyword can only be used in a test teardown. Trying to use it anywhere else results in an error.</p> <p>Otherwise, this keyword works exactly like <code>Run Keyword</code>, see its documentation for more details.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keyword_if_test_failed(self, name, *args):\n    \"\"\"Runs the given keyword with the given arguments, if the test failed.\n\n    This keyword can only be used in a test teardown. Trying to use it\n    anywhere else results in an error.\n\n    Otherwise, this keyword works exactly like `Run Keyword`, see its\n    documentation for more details.\n    \"\"\"\n    test = self._get_test_in_teardown('Run Keyword If Test Failed')\n    if test.failed:\n        return self.run_keyword(name, *args)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_if_test_passed","title":"run_keyword_if_test_passed","text":"<pre><code>run_keyword_if_test_passed(name, *args)\n</code></pre> <p>Runs the given keyword with the given arguments, if the test passed.</p> <p>This keyword can only be used in a test teardown. Trying to use it anywhere else results in an error.</p> <p>Otherwise, this keyword works exactly like <code>Run Keyword</code>, see its documentation for more details.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keyword_if_test_passed(self, name, *args):\n    \"\"\"Runs the given keyword with the given arguments, if the test passed.\n\n    This keyword can only be used in a test teardown. Trying to use it\n    anywhere else results in an error.\n\n    Otherwise, this keyword works exactly like `Run Keyword`, see its\n    documentation for more details.\n    \"\"\"\n    test = self._get_test_in_teardown('Run Keyword If Test Passed')\n    if test.passed:\n        return self.run_keyword(name, *args)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_if_timeout_occurred","title":"run_keyword_if_timeout_occurred","text":"<pre><code>run_keyword_if_timeout_occurred(name, *args)\n</code></pre> <p>Runs the given keyword if either a test or a keyword timeout has occurred.</p> <p>This keyword can only be used in a test teardown. Trying to use it anywhere else results in an error.</p> <p>Otherwise, this keyword works exactly like <code>Run Keyword</code>, see its documentation for more details.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keyword_if_timeout_occurred(self, name, *args):\n    \"\"\"Runs the given keyword if either a test or a keyword timeout has occurred.\n\n    This keyword can only be used in a test teardown. Trying to use it\n    anywhere else results in an error.\n\n    Otherwise, this keyword works exactly like `Run Keyword`, see its\n    documentation for more details.\n    \"\"\"\n    self._get_test_in_teardown('Run Keyword If Timeout Occurred')\n    if self._context.timeout_occurred:\n        return self.run_keyword(name, *args)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_if_all_tests_passed","title":"run_keyword_if_all_tests_passed","text":"<pre><code>run_keyword_if_all_tests_passed(name, *args)\n</code></pre> <p>Runs the given keyword with the given arguments, if all tests passed.</p> <p>This keyword can only be used in a suite teardown. Trying to use it anywhere else results in an error.</p> <p>Otherwise, this keyword works exactly like <code>Run Keyword</code>, see its documentation for more details.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keyword_if_all_tests_passed(self, name, *args):\n    \"\"\"Runs the given keyword with the given arguments, if all tests passed.\n\n    This keyword can only be used in a suite teardown. Trying to use it\n    anywhere else results in an error.\n\n    Otherwise, this keyword works exactly like `Run Keyword`, see its\n    documentation for more details.\n    \"\"\"\n    suite = self._get_suite_in_teardown('Run Keyword If All Tests Passed')\n    if suite.statistics.failed == 0:\n        return self.run_keyword(name, *args)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.run_keyword_if_any_tests_failed","title":"run_keyword_if_any_tests_failed","text":"<pre><code>run_keyword_if_any_tests_failed(name, *args)\n</code></pre> <p>Runs the given keyword with the given arguments, if one or more tests failed.</p> <p>This keyword can only be used in a suite teardown. Trying to use it anywhere else results in an error.</p> <p>Otherwise, this keyword works exactly like <code>Run Keyword</code>, see its documentation for more details.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0, dry_run=True)\ndef run_keyword_if_any_tests_failed(self, name, *args):\n    \"\"\"Runs the given keyword with the given arguments, if one or more tests failed.\n\n    This keyword can only be used in a suite teardown. Trying to use it\n    anywhere else results in an error.\n\n    Otherwise, this keyword works exactly like `Run Keyword`, see its\n    documentation for more details.\n    \"\"\"\n    suite = self._get_suite_in_teardown('Run Keyword If Any Tests Failed')\n    if suite.statistics.failed &gt; 0:\n        return self.run_keyword(name, *args)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.get_variables","title":"get_variables","text":"<pre><code>get_variables(no_decoration=False)\n</code></pre> <p>Returns a dictionary containing all variables in the current scope.</p> <p>Variables are returned as a special dictionary that allows accessing variables in space, case, and underscore insensitive manner similarly as accessing variables in the test data. This dictionary supports all same operations as normal Python dictionaries and, for example, Collections library can be used to access or modify it. Modifying the returned dictionary has no effect on the variables available in the current scope.</p> <p>By default variables are returned with <code>${}</code>, <code>@{}</code> or <code>&amp;{}</code> decoration based on variable types. Giving a true value (see <code>Boolean arguments</code>) to the optional argument <code>no_decoration</code> will return the variables without the decoration.</p> <p>Example: | ${example_variable} =         | Set Variable | example value         | | ${variables} =                | Get Variables |                      | | Dictionary Should Contain Key | ${variables} | \\${example_variable} | | Dictionary Should Contain Key | ${variables} | \\${ExampleVariable}  | | Set To Dictionary             | ${variables} | \\${name} | value     | | Variable Should Not Exist     | \\${name}    |           |           | | ${no decoration} =            | Get Variables | no_decoration=Yes | | Dictionary Should Contain Key | ${no decoration} | example_variable |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def get_variables(self, no_decoration=False):\n    \"\"\"Returns a dictionary containing all variables in the current scope.\n\n    Variables are returned as a special dictionary that allows accessing\n    variables in space, case, and underscore insensitive manner similarly\n    as accessing variables in the test data. This dictionary supports all\n    same operations as normal Python dictionaries and, for example,\n    Collections library can be used to access or modify it. Modifying the\n    returned dictionary has no effect on the variables available in the\n    current scope.\n\n    By default variables are returned with ``${}``, ``@{}`` or ``&amp;{}``\n    decoration based on variable types. Giving a true value (see `Boolean\n    arguments`) to the optional argument ``no_decoration`` will return\n    the variables without the decoration.\n\n    Example:\n    | ${example_variable} =         | Set Variable | example value         |\n    | ${variables} =                | Get Variables |                      |\n    | Dictionary Should Contain Key | ${variables} | \\\\${example_variable} |\n    | Dictionary Should Contain Key | ${variables} | \\\\${ExampleVariable}  |\n    | Set To Dictionary             | ${variables} | \\\\${name} | value     |\n    | Variable Should Not Exist     | \\\\${name}    |           |           |\n    | ${no decoration} =            | Get Variables | no_decoration=Yes |\n    | Dictionary Should Contain Key | ${no decoration} | example_variable |\n    \"\"\"\n    return self._variables.as_dict(decoration=is_falsy(no_decoration))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.get_variable_value","title":"get_variable_value","text":"<pre><code>get_variable_value(name, default=None)\n</code></pre> <p>Returns variable value or <code>default</code> if the variable does not exist.</p> <p>The name of the variable can be given either as a normal variable name like <code>${name}</code> or in escaped format like <code>$name</code> or <code>\\${name}</code>. For the reasons explained in the <code>Using variables with keywords creating or accessing variables</code> section, using the escaped format is recommended.</p> <p>Examples: | ${x} =    <code>Get Variable Value</code>    $a    default | ${y} =    <code>Get Variable Value</code>    $a    ${b} | ${z} =    <code>Get Variable Value</code>    $z =&gt; - <code>${x}</code> gets value of <code>${a}</code> if <code>${a}</code> exists and string <code>default</code> otherwise - <code>${y}</code> gets value of <code>${a}</code> if <code>${a}</code> exists and value of <code>${b}</code> otherwise - <code>${z}</code> is set to Python <code>None</code> if it does not exist previously</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@keyword(types=None)\n@run_keyword_variant(resolve=0)\ndef get_variable_value(self, name, default=None):\n    r\"\"\"Returns variable value or ``default`` if the variable does not exist.\n\n    The name of the variable can be given either as a normal variable name\n    like ``${name}`` or in escaped format like ``$name`` or ``\\${name}``.\n    For the reasons explained in the `Using variables with keywords creating\n    or accessing variables` section, using the escaped format is recommended.\n\n    Examples:\n    | ${x} =    `Get Variable Value`    $a    default\n    | ${y} =    `Get Variable Value`    $a    ${b}\n    | ${z} =    `Get Variable Value`    $z\n    =&gt;\n    - ``${x}`` gets value of ``${a}`` if ``${a}`` exists and string ``default`` otherwise\n    - ``${y}`` gets value of ``${a}`` if ``${a}`` exists and value of ``${b}`` otherwise\n    - ``${z}`` is set to Python ``None`` if it does not exist previously\n    \"\"\"\n    try:\n        name = self._get_var_name(name, require_assign=False)\n        return self._variables.replace_scalar(name)\n    except VariableError:\n        return self._variables.replace_scalar(default)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.log_variables","title":"log_variables","text":"<pre><code>log_variables(level='INFO')\n</code></pre> <p>Logs all variables in the current scope with given log level.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def log_variables(self, level='INFO'):\n    \"\"\"Logs all variables in the current scope with given log level.\"\"\"\n    variables = self.get_variables()\n    for name in sorted(variables, key=lambda s: s[2:-1].casefold()):\n        name, value = self._get_logged_variable(name, variables)\n        msg = format_assign_message(name, value, cut_long=False)\n        self.log(msg, level)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.variable_should_exist","title":"variable_should_exist","text":"<pre><code>variable_should_exist(name, msg=None)\n</code></pre> <p>Fails unless the given variable exists within the current scope.</p> <p>The name of the variable can be given either as a normal variable name like <code>${name}</code> or in escaped format like <code>$name</code> or <code>\\${name}</code>. For the reasons explained in the <code>Using variables with keywords creating or accessing variables</code> section, using the escaped format is recommended.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> <p>See also <code>Variable Should Not Exist</code> and <code>Keyword Should Exist</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef variable_should_exist(self, name, msg=None):\n    r\"\"\"Fails unless the given variable exists within the current scope.\n\n    The name of the variable can be given either as a normal variable name\n    like ``${name}`` or in escaped format like ``$name`` or ``\\${name}``.\n    For the reasons explained in the `Using variables with keywords creating\n    or accessing variables` section, using the escaped format is recommended.\n\n    The default error message can be overridden with the ``msg`` argument.\n\n    See also `Variable Should Not Exist` and `Keyword Should Exist`.\n    \"\"\"\n    name = self._get_var_name(name)\n    try:\n        self._variables.replace_scalar(name)\n    except VariableError:\n        raise AssertionError(self._variables.replace_string(msg)\n                             if msg else f\"Variable '{name}' does not exist.\")\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.variable_should_not_exist","title":"variable_should_not_exist","text":"<pre><code>variable_should_not_exist(name, msg=None)\n</code></pre> <p>Fails if the given variable exists within the current scope.</p> <p>The name of the variable can be given either as a normal variable name like <code>${name}</code> or in escaped format like <code>$name</code> or <code>\\${name}</code>. For the reasons explained in the <code>Using variables with keywords creating or accessing variables</code> section, using the escaped format is recommended.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> <p>See also <code>Variable Should Exist</code> and <code>Keyword Should Exist</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef variable_should_not_exist(self, name, msg=None):\n    r\"\"\"Fails if the given variable exists within the current scope.\n\n    The name of the variable can be given either as a normal variable name\n    like ``${name}`` or in escaped format like ``$name`` or ``\\${name}``.\n    For the reasons explained in the `Using variables with keywords creating\n    or accessing variables` section, using the escaped format is recommended.\n\n    The default error message can be overridden with the ``msg`` argument.\n\n    See also `Variable Should Exist` and `Keyword Should Exist`.\n    \"\"\"\n    name = self._get_var_name(name)\n    try:\n        self._variables.replace_scalar(name)\n    except VariableError:\n        pass\n    else:\n        raise AssertionError(self._variables.replace_string(msg)\n                             if msg else f\"Variable '{name}' exists.\")\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.replace_variables","title":"replace_variables","text":"<pre><code>replace_variables(text)\n</code></pre> <p>Replaces variables in the given text with their current values.</p> <p>If the text contains undefined variables, this keyword fails. If the given <code>text</code> contains only a single variable, its value is returned as-is and it can be any object. Otherwise, this keyword always returns a string.</p> <p>Example:</p> <p>The file <code>template.txt</code> contains <code>Hello ${NAME}!</code> and variable <code>${NAME}</code> has the value <code>Robot</code>.</p> <p>| ${template} =   | Get File          | ${CURDIR}/template.txt | | ${message} =    | Replace Variables | ${template}            | | Should Be Equal | ${message}        | Hello Robot!           |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def replace_variables(self, text):\n    \"\"\"Replaces variables in the given text with their current values.\n\n    If the text contains undefined variables, this keyword fails.\n    If the given ``text`` contains only a single variable, its value is\n    returned as-is and it can be any object. Otherwise, this keyword\n    always returns a string.\n\n    Example:\n\n    The file ``template.txt`` contains ``Hello ${NAME}!`` and variable\n    ``${NAME}`` has the value ``Robot``.\n\n    | ${template} =   | Get File          | ${CURDIR}/template.txt |\n    | ${message} =    | Replace Variables | ${template}            |\n    | Should Be Equal | ${message}        | Hello Robot!           |\n    \"\"\"\n    return self._variables.replace_scalar(text)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_variable","title":"set_variable","text":"<pre><code>set_variable(*values)\n</code></pre> <p>Returns the given values which can then be assigned to a variables.</p> <p>This keyword is mainly used for setting scalar variables. Additionally it can be used for converting a scalar variable containing a list to a list variable or to multiple scalar variables. It is recommended to use <code>Create List</code> when creating new lists.</p> <p>Examples: | ${hi} =    Set Variable    Hello, world! | ${hi2} =    Set Variable    I said: ${hi} | ${var1}    ${var2} =    Set Variable    Hello    world | @{list} =    Set Variable    ${list with some items} | ${item1}    ${item2} =    Set Variable    ${list with 2 items}</p> <p>Variables created with this keyword are available only in the scope where they are created. See <code>Set Global Variable</code>, <code>Set Test Variable</code> and <code>Set Suite Variable</code> for information on how to set variables so that they are available also in a larger scope.</p> <p>NOTE: The <code>VAR</code> syntax introduced in Robot Framework 7.0 is generally recommended over this keyword. The basic usage is shown below and the Robot Framework User Guide explains the syntax in detail.</p> <p>| VAR    ${hi}     Hello, world! | VAR    ${hi2}    I said: ${hi}</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def set_variable(self, *values):\n    \"\"\"Returns the given values which can then be assigned to a variables.\n\n    This keyword is mainly used for setting scalar variables.\n    Additionally it can be used for converting a scalar variable\n    containing a list to a list variable or to multiple scalar variables.\n    It is recommended to use `Create List` when creating new lists.\n\n    Examples:\n    | ${hi} =    Set Variable    Hello, world!\n    | ${hi2} =    Set Variable    I said: ${hi}\n    | ${var1}    ${var2} =    Set Variable    Hello    world\n    | @{list} =    Set Variable    ${list with some items}\n    | ${item1}    ${item2} =    Set Variable    ${list with 2 items}\n\n    Variables created with this keyword are available only in the\n    scope where they are created. See `Set Global Variable`,\n    `Set Test Variable` and `Set Suite Variable` for information on how to\n    set variables so that they are available also in a larger scope.\n\n    *NOTE:* The ``VAR`` syntax introduced in Robot Framework 7.0 is generally\n    recommended over this keyword. The basic usage is shown below and the Robot\n    Framework User Guide explains the syntax in detail.\n\n    | VAR    ${hi}     Hello, world!\n    | VAR    ${hi2}    I said: ${hi}\n    \"\"\"\n    if len(values) == 0:\n        return ''\n    elif len(values) == 1:\n        return values[0]\n    else:\n        return list(values)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_local_variable","title":"set_local_variable","text":"<pre><code>set_local_variable(name, *values)\n</code></pre> <p>Makes a variable available everywhere within the local scope.</p> <p>Variables set with this keyword are available within the local scope of the currently executed test case or in the local scope of the keyword in which they are defined. For example, if you set a variable in a user keyword, it is available only in that keyword. Other test cases or keywords will not see variables set with this keyword.</p> <p>This keyword is equivalent to a normal variable assignment based on a keyword return value. For example,</p> <p>| ${var} =    <code>Set Variable</code>    value | @{list} =    <code>Create List</code>    item1    item2    item3</p> <p>are equivalent with</p> <p>| <code>Set Local Variable</code> @var    value | <code>Set Local Variable</code> @list    item1    item2    item3</p> <p>The main use case for this keyword is creating local variables in libraries.</p> <p>See <code>Set Suite Variable</code> for more information and usage examples. See also the <code>Using variables with keywords creating or accessing variables</code> section for information why it is recommended to give the variable name in escaped format like <code>$name</code> or <code>\\${name}</code> instead of the normal <code>${name}</code>.</p> <p>See also <code>Set Global Variable</code> and <code>Set Test Variable</code>.</p> <p>NOTE: The <code>VAR</code> syntax introduced in Robot Framework 7.0 is recommended over this keyword.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef set_local_variable(self, name, *values):\n    r\"\"\"Makes a variable available everywhere within the local scope.\n\n    Variables set with this keyword are available within the\n    local scope of the currently executed test case or in the local scope\n    of the keyword in which they are defined. For example, if you set a\n    variable in a user keyword, it is available only in that keyword. Other\n    test cases or keywords will not see variables set with this keyword.\n\n    This keyword is equivalent to a normal variable assignment based on a\n    keyword return value. For example,\n\n    | ${var} =    `Set Variable`    value\n    | @{list} =    `Create List`    item1    item2    item3\n\n    are equivalent with\n\n    | `Set Local Variable`    @var    value\n    | `Set Local Variable`    @list    item1    item2    item3\n\n    The main use case for this keyword is creating local variables in\n    libraries.\n\n    See `Set Suite Variable` for more information and usage examples. See\n    also the `Using variables with keywords creating or accessing variables`\n    section for information why it is recommended to give the variable name\n    in escaped format like ``$name`` or ``\\${name}`` instead of the normal\n    ``${name}``.\n\n    See also `Set Global Variable` and `Set Test Variable`.\n\n    *NOTE:* The ``VAR`` syntax introduced in Robot Framework 7.0 is recommended\n    over this keyword.\n    \"\"\"\n    name = self._get_var_name(name)\n    value = self._get_var_value(name, values)\n    self._variables.set_local(name, value)\n    self._log_set_variable(name, value)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_test_variable","title":"set_test_variable","text":"<pre><code>set_test_variable(name, *values)\n</code></pre> <p>Makes a variable available everywhere within the scope of the current test.</p> <p>Variables set with this keyword are available everywhere within the scope of the currently executed test case. For example, if you set a variable in a user keyword, it is available both in the test case level and also in all other user keywords used in the current test. Other test cases will not see variables set with this keyword. It is an error to call <code>Set Test Variable</code> outside the scope of a test (e.g. in a Suite Setup or Teardown).</p> <p>See <code>Set Suite Variable</code> for more information and usage examples. See also the <code>Using variables with keywords creating or accessing variables</code> section for information why it is recommended to give the variable name in escaped format like <code>$name</code> or <code>\\${name}</code> instead of the normal <code>${name}</code>.</p> <p>When creating automated tasks, not tests, it is possible to use <code>Set Task Variable</code>. See also <code>Set Global Variable</code> and <code>Set Local Variable</code>.</p> <p>NOTE: The <code>VAR</code> syntax introduced in Robot Framework 7.0 is recommended over this keyword.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef set_test_variable(self, name, *values):\n    r\"\"\"Makes a variable available everywhere within the scope of the current test.\n\n    Variables set with this keyword are available everywhere within the\n    scope of the currently executed test case. For example, if you set a\n    variable in a user keyword, it is available both in the test case level\n    and also in all other user keywords used in the current test. Other\n    test cases will not see variables set with this keyword.\n    It is an error to call `Set Test Variable` outside the\n    scope of a test (e.g. in a Suite Setup or Teardown).\n\n    See `Set Suite Variable` for more information and usage examples. See\n    also the `Using variables with keywords creating or accessing variables`\n    section for information why it is recommended to give the variable name\n    in escaped format like ``$name`` or ``\\${name}`` instead of the normal\n    ``${name}``.\n\n    When creating automated tasks, not tests, it is possible to use `Set\n    Task Variable`. See also `Set Global Variable` and `Set Local Variable`.\n\n    *NOTE:* The ``VAR`` syntax introduced in Robot Framework 7.0 is recommended\n    over this keyword.\n    \"\"\"\n    name = self._get_var_name(name)\n    value = self._get_var_value(name, values)\n    self._variables.set_test(name, value)\n    self._log_set_variable(name, value)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_task_variable","title":"set_task_variable","text":"<pre><code>set_task_variable(name, *values)\n</code></pre> <p>Makes a variable available everywhere within the scope of the current task.</p> <p>This is an alias for <code>Set Test Variable</code> that is more applicable when creating tasks, not tests.</p> <p>NOTE: The <code>VAR</code> syntax introduced in Robot Framework 7.0 is recommended over this keyword.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef set_task_variable(self, name, *values):\n    \"\"\"Makes a variable available everywhere within the scope of the current task.\n\n    This is an alias for `Set Test Variable` that is more applicable when\n    creating tasks, not tests.\n\n    *NOTE:* The ``VAR`` syntax introduced in Robot Framework 7.0 is recommended\n    over this keyword.\n    \"\"\"\n    self.set_test_variable(name, *values)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_suite_variable","title":"set_suite_variable","text":"<pre><code>set_suite_variable(name, *values)\n</code></pre> <p>Makes a variable available everywhere within the scope of the current suite.</p> <p>Variables set with this keyword are available everywhere within the scope of the currently executed test suite. Setting variables with this keyword thus has the same effect as creating them using the Variables section in the data file or importing them from variable files.</p> <p>Possible child test suites do not see variables set with this keyword by default, but that can be controlled by using <code>children=&lt;option&gt;</code> as the last argument. If the specified <code>&lt;option&gt;</code> is given a true value (see <code>Boolean arguments</code>), the variable is set also to the child suites. Parent and sibling suites will never see variables set with this keyword.</p> <p>The name of the variable can be given either as a normal variable name like <code>${NAME}</code> or in escaped format as <code>\\${NAME}</code> or <code>$NAME</code>. For the reasons explained in the <code>Using variables with keywords creating or accessing variables</code> section, using the escaped format is highly recommended.</p> <p>Variable value can be specified using the same syntax as when variables are created in the Variables section. Same way as in that section, it is possible to create scalar values, lists and dictionaries. The type is got from the variable name prefix <code>$</code>, <code>@</code> and <code>&amp;</code>, respectively.</p> <p>If a variable already exists within the new scope, its value will be overwritten. If a variable already exists within the current scope, the value can be left empty and the variable within the new scope gets the value within the current scope.</p> <p>Examples: | Set Suite Variable    $SCALAR    Hello, world! | Set Suite Variable    $SCALAR    Hello, world!    children=True | Set Suite Variable    @LIST      First item       Second item | Set Suite Variable    &amp;DICT      key=value        foo=bar | ${ID} =    Get ID | Set Suite Variable    $ID</p> <p>To override an existing value with an empty value, use built-in variables <code>${EMPTY}</code>, <code>@{EMPTY}</code> or <code>&amp;{EMPTY}</code>:</p> <p>| Set Suite Variable    $SCALAR    ${EMPTY} | Set Suite Variable    @LIST      @{EMPTY} | Set Suite Variable    &amp;DICT      &amp;{EMPTY}</p> <p>See also <code>Set Global Variable</code>, <code>Set Test Variable</code> and <code>Set Local Variable</code>.</p> <p>NOTE: The <code>VAR</code> syntax introduced in Robot Framework 7.0 is recommended over this keyword. The basic usage is shown below and the Robot Framework User Guide explains the syntax in detail.</p> <p>| VAR    ${SCALAR}    Hello, world!                scope=SUITE | VAR    @{LIST}      First item    Second item    scope=SUITE | VAR    &amp;{DICT}      key=value     foo=bar        scope=SUITE</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef set_suite_variable(self, name, *values):\n    r\"\"\"Makes a variable available everywhere within the scope of the current suite.\n\n    Variables set with this keyword are available everywhere within the\n    scope of the currently executed test suite. Setting variables with this\n    keyword thus has the same effect as creating them using the Variables\n    section in the data file or importing them from variable files.\n\n    Possible child test suites do not see variables set with this keyword\n    by default, but that can be controlled by using ``children=&lt;option&gt;``\n    as the last argument. If the specified ``&lt;option&gt;`` is given a true value\n    (see `Boolean arguments`), the variable is set also to the child\n    suites. Parent and sibling suites will never see variables set with\n    this keyword.\n\n    The name of the variable can be given either as a normal variable name\n    like ``${NAME}`` or in escaped format as ``\\${NAME}`` or ``$NAME``.\n    For the reasons explained in the `Using variables with keywords creating\n    or accessing variables` section, *using the escaped format is highly\n    recommended*.\n\n    Variable value can be specified using the same syntax as when variables\n    are created in the Variables section. Same way as in that section,\n    it is possible to create scalar values, lists and dictionaries.\n    The type is got from the variable name prefix ``$``, ``@`` and ``&amp;``,\n    respectively.\n\n    If a variable already exists within the new scope, its value will be\n    overwritten. If a variable already exists within the current scope,\n    the value can be left empty and the variable within the new scope gets\n    the value within the current scope.\n\n    Examples:\n    | Set Suite Variable    $SCALAR    Hello, world!\n    | Set Suite Variable    $SCALAR    Hello, world!    children=True\n    | Set Suite Variable    @LIST      First item       Second item\n    | Set Suite Variable    &amp;DICT      key=value        foo=bar\n    | ${ID} =    Get ID\n    | Set Suite Variable    $ID\n\n    To override an existing value with an empty value, use built-in\n    variables ``${EMPTY}``, ``@{EMPTY}`` or ``&amp;{EMPTY}``:\n\n    | Set Suite Variable    $SCALAR    ${EMPTY}\n    | Set Suite Variable    @LIST      @{EMPTY}\n    | Set Suite Variable    &amp;DICT      &amp;{EMPTY}\n\n    See also `Set Global Variable`, `Set Test Variable` and `Set Local Variable`.\n\n    *NOTE:* The ``VAR`` syntax introduced in Robot Framework 7.0 is recommended\n    over this keyword. The basic usage is shown below and the Robot Framework\n    User Guide explains the syntax in detail.\n\n    | VAR    ${SCALAR}    Hello, world!                scope=SUITE\n    | VAR    @{LIST}      First item    Second item    scope=SUITE\n    | VAR    &amp;{DICT}      key=value     foo=bar        scope=SUITE\n    \"\"\"\n    name = self._get_var_name(name)\n    if values and is_string(values[-1]) and values[-1].startswith('children='):\n        children = self._variables.replace_scalar(values[-1][9:])\n        children = is_truthy(children)\n        values = values[:-1]\n    else:\n        children = False\n    value = self._get_var_value(name, values)\n    self._variables.set_suite(name, value, children=children)\n    self._log_set_variable(name, value)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.set_global_variable","title":"set_global_variable","text":"<pre><code>set_global_variable(name, *values)\n</code></pre> <p>Makes a variable available globally in all tests and suites.</p> <p>Variables set with this keyword are globally available in all subsequent test suites, test cases and user keywords. Also variables created Variables sections are overridden. Variables assigned locally based on keyword return values or by using <code>Set Suite Variable</code>, <code>Set Test Variable</code> or <code>Set Local Variable</code> override these variables in that scope, but the global value is not changed in those cases.</p> <p>In practice setting variables with this keyword has the same effect as using command line options <code>--variable</code> and <code>--variablefile</code>. Because this keyword can change variables everywhere, it should be used with care.</p> <p>See <code>Set Suite Variable</code> for more information and usage examples. See also the <code>Using variables with keywords creating or accessing variables</code> section for information why it is recommended to give the variable name in escaped format like <code>$name</code> or <code>\\${name}</code> instead of the normal <code>${name}</code>.</p> <p>NOTE: The <code>VAR</code> syntax introduced in Robot Framework 7.0 is recommended over this keyword.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef set_global_variable(self, name, *values):\n    r\"\"\"Makes a variable available globally in all tests and suites.\n\n    Variables set with this keyword are globally available in all\n    subsequent test suites, test cases and user keywords. Also variables\n    created Variables sections are overridden. Variables assigned locally\n    based on keyword return values or by using `Set Suite Variable`,\n    `Set Test Variable` or `Set Local Variable` override these variables\n    in that scope, but the global value is not changed in those cases.\n\n    In practice setting variables with this keyword has the same effect\n    as using command line options ``--variable`` and ``--variablefile``.\n    Because this keyword can change variables everywhere, it should be\n    used with care.\n\n    See `Set Suite Variable` for more information and usage examples. See\n    also the `Using variables with keywords creating or accessing variables`\n    section for information why it is recommended to give the variable name\n    in escaped format like ``$name`` or ``\\${name}`` instead of the normal\n    ``${name}``.\n\n    *NOTE:* The ``VAR`` syntax introduced in Robot Framework 7.0 is recommended\n    over this keyword.\n    \"\"\"\n    name = self._get_var_name(name)\n    value = self._get_var_value(name, values)\n    self._variables.set_global(name, value)\n    self._log_set_variable(name, value)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.convert_to_integer","title":"convert_to_integer","text":"<pre><code>convert_to_integer(item, base=None)\n</code></pre> <p>Converts the given item to an integer number.</p> <p>If the given item is a string, it is by default expected to be an integer in base 10. There are two ways to convert from other bases:</p> <ul> <li> <p>Give base explicitly to the keyword as <code>base</code> argument.</p> </li> <li> <p>Prefix the given string with the base so that <code>0b</code> means binary   (base 2), <code>0o</code> means octal (base 8), and <code>0x</code> means hex (base 16).   The prefix is considered only when <code>base</code> argument is not given and   may itself be prefixed with a plus or minus sign.</p> </li> </ul> <p>The syntax is case-insensitive and possible spaces are ignored.</p> <p>Examples: | ${result} = | Convert To Integer | 100    |    | # Result is 100   | | ${result} = | Convert To Integer | FF AA  | 16 | # Result is 65450 | | ${result} = | Convert To Integer | 100    | 8  | # Result is 64    | | ${result} = | Convert To Integer | -100   | 2  | # Result is -4    | | ${result} = | Convert To Integer | 0b100  |    | # Result is 4     | | ${result} = | Convert To Integer | -0x100 |    | # Result is -256  |</p> <p>See also <code>Convert To Number</code>, <code>Convert To Binary</code>, <code>Convert To Octal</code>, <code>Convert To Hex</code>, and <code>Convert To Bytes</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def convert_to_integer(self, item, base=None):\n    \"\"\"Converts the given item to an integer number.\n\n    If the given item is a string, it is by default expected to be an\n    integer in base 10. There are two ways to convert from other bases:\n\n    - Give base explicitly to the keyword as ``base`` argument.\n\n    - Prefix the given string with the base so that ``0b`` means binary\n      (base 2), ``0o`` means octal (base 8), and ``0x`` means hex (base 16).\n      The prefix is considered only when ``base`` argument is not given and\n      may itself be prefixed with a plus or minus sign.\n\n    The syntax is case-insensitive and possible spaces are ignored.\n\n    Examples:\n    | ${result} = | Convert To Integer | 100    |    | # Result is 100   |\n    | ${result} = | Convert To Integer | FF AA  | 16 | # Result is 65450 |\n    | ${result} = | Convert To Integer | 100    | 8  | # Result is 64    |\n    | ${result} = | Convert To Integer | -100   | 2  | # Result is -4    |\n    | ${result} = | Convert To Integer | 0b100  |    | # Result is 4     |\n    | ${result} = | Convert To Integer | -0x100 |    | # Result is -256  |\n\n    See also `Convert To Number`, `Convert To Binary`, `Convert To Octal`,\n    `Convert To Hex`, and `Convert To Bytes`.\n    \"\"\"\n    self._log_types(item)\n    return self._convert_to_integer(item, base)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.convert_to_binary","title":"convert_to_binary","text":"<pre><code>convert_to_binary(\n    item, base=None, prefix=None, length=None\n)\n</code></pre> <p>Converts the given item to a binary string.</p> <p>The <code>item</code>, with an optional <code>base</code>, is first converted to an integer using <code>Convert To Integer</code> internally. After that it is converted to a binary number (base 2) represented as a string such as <code>1011</code>.</p> <p>The returned value can contain an optional <code>prefix</code> and can be required to be of minimum <code>length</code> (excluding the prefix and a possible minus sign). If the value is initially shorter than the required length, it is padded with zeros.</p> <p>Examples: | ${result} = | Convert To Binary | 10 |         |           | # Result is 1010   | | ${result} = | Convert To Binary | F  | base=16 | prefix=0b | # Result is 0b1111 | | ${result} = | Convert To Binary | -2 | prefix=B | length=4 | # Result is -B0010 |</p> <p>See also <code>Convert To Integer</code>, <code>Convert To Octal</code> and <code>Convert To Hex</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def convert_to_binary(self, item, base=None, prefix=None, length=None):\n    \"\"\"Converts the given item to a binary string.\n\n    The ``item``, with an optional ``base``, is first converted to an\n    integer using `Convert To Integer` internally. After that it\n    is converted to a binary number (base 2) represented as a\n    string such as ``1011``.\n\n    The returned value can contain an optional ``prefix`` and can be\n    required to be of minimum ``length`` (excluding the prefix and a\n    possible minus sign). If the value is initially shorter than\n    the required length, it is padded with zeros.\n\n    Examples:\n    | ${result} = | Convert To Binary | 10 |         |           | # Result is 1010   |\n    | ${result} = | Convert To Binary | F  | base=16 | prefix=0b | # Result is 0b1111 |\n    | ${result} = | Convert To Binary | -2 | prefix=B | length=4 | # Result is -B0010 |\n\n    See also `Convert To Integer`, `Convert To Octal` and `Convert To Hex`.\n    \"\"\"\n    return self._convert_to_bin_oct_hex(item, base, prefix, length, 'b')\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.convert_to_octal","title":"convert_to_octal","text":"<pre><code>convert_to_octal(item, base=None, prefix=None, length=None)\n</code></pre> <p>Converts the given item to an octal string.</p> <p>The <code>item</code>, with an optional <code>base</code>, is first converted to an integer using <code>Convert To Integer</code> internally. After that it is converted to an octal number (base 8) represented as a string such as <code>775</code>.</p> <p>The returned value can contain an optional <code>prefix</code> and can be required to be of minimum <code>length</code> (excluding the prefix and a possible minus sign). If the value is initially shorter than the required length, it is padded with zeros.</p> <p>Examples: | ${result} = | Convert To Octal | 10 |            |          | # Result is 12      | | ${result} = | Convert To Octal | -F | base=16    | prefix=0 | # Result is -017    | | ${result} = | Convert To Octal | 16 | prefix=oct | length=4 | # Result is oct0020 |</p> <p>See also <code>Convert To Integer</code>, <code>Convert To Binary</code> and <code>Convert To Hex</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def convert_to_octal(self, item, base=None, prefix=None, length=None):\n    \"\"\"Converts the given item to an octal string.\n\n    The ``item``, with an optional ``base``, is first converted to an\n    integer using `Convert To Integer` internally. After that it\n    is converted to an octal number (base 8) represented as a\n    string such as ``775``.\n\n    The returned value can contain an optional ``prefix`` and can be\n    required to be of minimum ``length`` (excluding the prefix and a\n    possible minus sign). If the value is initially shorter than\n    the required length, it is padded with zeros.\n\n    Examples:\n    | ${result} = | Convert To Octal | 10 |            |          | # Result is 12      |\n    | ${result} = | Convert To Octal | -F | base=16    | prefix=0 | # Result is -017    |\n    | ${result} = | Convert To Octal | 16 | prefix=oct | length=4 | # Result is oct0020 |\n\n    See also `Convert To Integer`, `Convert To Binary` and `Convert To Hex`.\n    \"\"\"\n    return self._convert_to_bin_oct_hex(item, base, prefix, length, 'o')\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.convert_to_hex","title":"convert_to_hex","text":"<pre><code>convert_to_hex(\n    item,\n    base=None,\n    prefix=None,\n    length=None,\n    lowercase=False,\n)\n</code></pre> <p>Converts the given item to a hexadecimal string.</p> <p>The <code>item</code>, with an optional <code>base</code>, is first converted to an integer using <code>Convert To Integer</code> internally. After that it is converted to a hexadecimal number (base 16) represented as a string such as <code>FF0A</code>.</p> <p>The returned value can contain an optional <code>prefix</code> and can be required to be of minimum <code>length</code> (excluding the prefix and a possible minus sign). If the value is initially shorter than the required length, it is padded with zeros.</p> <p>By default the value is returned as an upper case string, but the <code>lowercase</code> argument a true value (see <code>Boolean arguments</code>) turns the value (but not the given prefix) to lower case.</p> <p>Examples: | ${result} = | Convert To Hex | 255 |           |              | # Result is FF    | | ${result} = | Convert To Hex | -10 | prefix=0x | length=2     | # Result is -0x0A | | ${result} = | Convert To Hex | 255 | prefix=X | lowercase=yes | # Result is Xff   |</p> <p>See also <code>Convert To Integer</code>, <code>Convert To Binary</code> and <code>Convert To Octal</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def convert_to_hex(self, item, base=None, prefix=None, length=None,\n                   lowercase=False):\n    \"\"\"Converts the given item to a hexadecimal string.\n\n    The ``item``, with an optional ``base``, is first converted to an\n    integer using `Convert To Integer` internally. After that it\n    is converted to a hexadecimal number (base 16) represented as\n    a string such as ``FF0A``.\n\n    The returned value can contain an optional ``prefix`` and can be\n    required to be of minimum ``length`` (excluding the prefix and a\n    possible minus sign). If the value is initially shorter than\n    the required length, it is padded with zeros.\n\n    By default the value is returned as an upper case string, but the\n    ``lowercase`` argument a true value (see `Boolean arguments`) turns\n    the value (but not the given prefix) to lower case.\n\n    Examples:\n    | ${result} = | Convert To Hex | 255 |           |              | # Result is FF    |\n    | ${result} = | Convert To Hex | -10 | prefix=0x | length=2     | # Result is -0x0A |\n    | ${result} = | Convert To Hex | 255 | prefix=X | lowercase=yes | # Result is Xff   |\n\n    See also `Convert To Integer`, `Convert To Binary` and `Convert To Octal`.\n    \"\"\"\n    spec = 'x' if lowercase else 'X'\n    return self._convert_to_bin_oct_hex(item, base, prefix, length, spec)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.convert_to_number","title":"convert_to_number","text":"<pre><code>convert_to_number(item, precision=None)\n</code></pre> <p>Converts the given item to a floating point number.</p> <p>If the optional <code>precision</code> is positive or zero, the returned number is rounded to that number of decimal digits. Negative precision means that the number is rounded to the closest multiple of 10 to the power of the absolute precision. If a number is equally close to a certain precision, it is always rounded away from zero.</p> <p>Examples: | ${result} = | Convert To Number | 42.512 |    | # Result is 42.512 | | ${result} = | Convert To Number | 42.512 | 1  | # Result is 42.5   | | ${result} = | Convert To Number | 42.512 | 0  | # Result is 43.0   | | ${result} = | Convert To Number | 42.512 | -1 | # Result is 40.0   |</p> <p>Notice that machines generally cannot store floating point numbers accurately. This may cause surprises with these numbers in general and also when they are rounded. For more information see, for example, these resources:</p> <ul> <li>http://docs.python.org/tutorial/floatingpoint.html</li> <li>http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition</li> </ul> <p>If you want to avoid possible problems with floating point numbers, you can implement custom keywords using Python's [http://docs.python.org/library/decimal.html|decimal] or [http://docs.python.org/library/fractions.html|fractions] modules.</p> <p>If you need an integer number, use <code>Convert To Integer</code> instead.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def convert_to_number(self, item, precision=None):\n    \"\"\"Converts the given item to a floating point number.\n\n    If the optional ``precision`` is positive or zero, the returned number\n    is rounded to that number of decimal digits. Negative precision means\n    that the number is rounded to the closest multiple of 10 to the power\n    of the absolute precision. If a number is equally close to a certain\n    precision, it is always rounded away from zero.\n\n    Examples:\n    | ${result} = | Convert To Number | 42.512 |    | # Result is 42.512 |\n    | ${result} = | Convert To Number | 42.512 | 1  | # Result is 42.5   |\n    | ${result} = | Convert To Number | 42.512 | 0  | # Result is 43.0   |\n    | ${result} = | Convert To Number | 42.512 | -1 | # Result is 40.0   |\n\n    Notice that machines generally cannot store floating point numbers\n    accurately. This may cause surprises with these numbers in general\n    and also when they are rounded. For more information see, for example,\n    these resources:\n\n    - http://docs.python.org/tutorial/floatingpoint.html\n    - http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition\n\n    If you want to avoid possible problems with floating point numbers,\n    you can implement custom keywords using Python's\n    [http://docs.python.org/library/decimal.html|decimal] or\n    [http://docs.python.org/library/fractions.html|fractions] modules.\n\n    If you need an integer number, use `Convert To Integer` instead.\n    \"\"\"\n    self._log_types(item)\n    return self._convert_to_number(item, precision)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.convert_to_string","title":"convert_to_string","text":"<pre><code>convert_to_string(item)\n</code></pre> <p>Converts the given item to a Unicode string.</p> <p>Strings are also [https://en.wikipedia.org/wiki/Unicode_equivalence| NFC normalized].</p> <p>Use <code>Encode String To Bytes</code> and <code>Decode Bytes To String</code> keywords in <code>String</code> library if you need to convert between Unicode and byte strings using different encodings. Use <code>Convert To Bytes</code> if you just want to create byte strings.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def convert_to_string(self, item):\n    \"\"\"Converts the given item to a Unicode string.\n\n    Strings are also [https://en.wikipedia.org/wiki/Unicode_equivalence|\n    NFC normalized].\n\n    Use `Encode String To Bytes` and `Decode Bytes To String` keywords\n    in ``String`` library if you need to convert between Unicode and byte\n    strings using different encodings. Use `Convert To Bytes` if you just\n    want to create byte strings.\n    \"\"\"\n    self._log_types(item)\n    return safe_str(item)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.convert_to_boolean","title":"convert_to_boolean","text":"<pre><code>convert_to_boolean(item)\n</code></pre> <p>Converts the given item to Boolean true or false.</p> <p>Handles strings <code>True</code> and <code>False</code> (case-insensitive) as expected, otherwise returns item's [http://docs.python.org/library/stdtypes.html#truth|truth value] using Python's <code>bool()</code> method.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def convert_to_boolean(self, item):\n    \"\"\"Converts the given item to Boolean true or false.\n\n    Handles strings ``True`` and ``False`` (case-insensitive) as expected,\n    otherwise returns item's\n    [http://docs.python.org/library/stdtypes.html#truth|truth value]\n    using Python's ``bool()`` method.\n    \"\"\"\n    self._log_types(item)\n    if is_string(item):\n        if item.upper() == 'TRUE':\n            return True\n        if item.upper() == 'FALSE':\n            return False\n    return bool(item)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.convert_to_bytes","title":"convert_to_bytes","text":"<pre><code>convert_to_bytes(input, input_type='text')\n</code></pre> <p>Converts the given <code>input</code> to bytes according to the <code>input_type</code>.</p> <p>Valid input types are listed below:</p> <ul> <li> <p><code>text:</code> Converts text to bytes character by character. All   characters with ordinal below 256 can be used and are converted to   bytes with same values. Many characters are easiest to represent   using escapes like <code>\\x00</code> or <code>\\xff</code>. Supports both Unicode   strings and bytes.</p> </li> <li> <p><code>int:</code> Converts integers separated by spaces to bytes. Similarly as   with <code>Convert To Integer</code>, it is possible to use binary, octal, or   hex values by prefixing the values with <code>0b</code>, <code>0o</code>, or <code>0x</code>,   respectively.</p> </li> <li> <p><code>hex:</code> Converts hexadecimal values to bytes. Single byte is always   two characters long (e.g. <code>01</code> or <code>FF</code>). Spaces are ignored and   can be used freely as a visual separator.</p> </li> <li> <p><code>bin:</code> Converts binary values to bytes. Single byte is always eight   characters long (e.g. <code>00001010</code>). Spaces are ignored and can be   used freely as a visual separator.</p> </li> </ul> <p>In addition to giving the input as a string, it is possible to use lists or other iterables containing individual characters or numbers. In that case numbers do not need to be padded to certain length and they cannot contain extra spaces.</p> <p>Examples (last column shows returned bytes): | ${bytes} = | Convert To Bytes | hyv\u00e4      |     | # hyv\\xe4      | | ${bytes} = | Convert To Bytes | hyv\\xe4   |     | # hyv\\xe4      | | ${bytes} = | Convert To Bytes | \\xff\\x07  |     | # \\xff\\x07     | | ${bytes} = | Convert To Bytes | 82 70     | int | # RF           | | ${bytes} = | Convert To Bytes | 0b10 0x10 | int | # \\x02\\x10     | | ${bytes} = | Convert To Bytes | ff 00 07  | hex | # \\xff\\x00\\x07 | | ${bytes} = | Convert To Bytes | 52462121  | hex | # RF!!         | | ${bytes} = | Convert To Bytes | 0000 1000 | bin | # \\x08         | | ${input} = | Create List      | 1         | 2   | 12             | | ${bytes} = | Convert To Bytes | ${input}  | int | # \\x01\\x02\\x0c | | ${bytes} = | Convert To Bytes | ${input}  | hex | # \\x01\\x02\\x12 |</p> <p>Use <code>Encode String To Bytes</code> in <code>String</code> library if you need to convert text to bytes using a certain encoding.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def convert_to_bytes(self, input, input_type='text'):\n    r\"\"\"Converts the given ``input`` to bytes according to the ``input_type``.\n\n    Valid input types are listed below:\n\n    - ``text:`` Converts text to bytes character by character. All\n      characters with ordinal below 256 can be used and are converted to\n      bytes with same values. Many characters are easiest to represent\n      using escapes like ``\\x00`` or ``\\xff``. Supports both Unicode\n      strings and bytes.\n\n    - ``int:`` Converts integers separated by spaces to bytes. Similarly as\n      with `Convert To Integer`, it is possible to use binary, octal, or\n      hex values by prefixing the values with ``0b``, ``0o``, or ``0x``,\n      respectively.\n\n    - ``hex:`` Converts hexadecimal values to bytes. Single byte is always\n      two characters long (e.g. ``01`` or ``FF``). Spaces are ignored and\n      can be used freely as a visual separator.\n\n    - ``bin:`` Converts binary values to bytes. Single byte is always eight\n      characters long (e.g. ``00001010``). Spaces are ignored and can be\n      used freely as a visual separator.\n\n    In addition to giving the input as a string, it is possible to use\n    lists or other iterables containing individual characters or numbers.\n    In that case numbers do not need to be padded to certain length and\n    they cannot contain extra spaces.\n\n    Examples (last column shows returned bytes):\n    | ${bytes} = | Convert To Bytes | hyv\u00e4      |     | # hyv\\xe4      |\n    | ${bytes} = | Convert To Bytes | hyv\\xe4   |     | # hyv\\xe4      |\n    | ${bytes} = | Convert To Bytes | \\xff\\x07  |     | # \\xff\\x07     |\n    | ${bytes} = | Convert To Bytes | 82 70     | int | # RF           |\n    | ${bytes} = | Convert To Bytes | 0b10 0x10 | int | # \\x02\\x10     |\n    | ${bytes} = | Convert To Bytes | ff 00 07  | hex | # \\xff\\x00\\x07 |\n    | ${bytes} = | Convert To Bytes | 52462121  | hex | # RF!!         |\n    | ${bytes} = | Convert To Bytes | 0000 1000 | bin | # \\x08         |\n    | ${input} = | Create List      | 1         | 2   | 12             |\n    | ${bytes} = | Convert To Bytes | ${input}  | int | # \\x01\\x02\\x0c |\n    | ${bytes} = | Convert To Bytes | ${input}  | hex | # \\x01\\x02\\x12 |\n\n    Use `Encode String To Bytes` in ``String`` library if you need to\n    convert text to bytes using a certain encoding.\n    \"\"\"\n    try:\n        try:\n            ordinals = getattr(self, f'_get_ordinals_from_{input_type}')\n        except AttributeError:\n            raise RuntimeError(f\"Invalid input type '{input_type}'.\")\n        return bytes(bytearray(o for o in ordinals(input)))\n    except:\n        raise RuntimeError(\"Creating bytes failed: \" + get_error_message())\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.create_list","title":"create_list","text":"<pre><code>create_list(*items)\n</code></pre> <p>Returns a list containing given items.</p> <p>The returned list can be assigned both to <code>${scalar}</code> and <code>@{list}</code> variables.</p> <p>Examples: | @{list} =   | Create List | a    | b    | c    | | ${scalar} = | Create List | a    | b    | c    | | ${ints} =   | Create List | ${1} | ${2} | ${3} |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def create_list(self, *items):\n    \"\"\"Returns a list containing given items.\n\n    The returned list can be assigned both to ``${scalar}`` and ``@{list}``\n    variables.\n\n    Examples:\n    | @{list} =   | Create List | a    | b    | c    |\n    | ${scalar} = | Create List | a    | b    | c    |\n    | ${ints} =   | Create List | ${1} | ${2} | ${3} |\n    \"\"\"\n    return list(items)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.create_dictionary","title":"create_dictionary","text":"<pre><code>create_dictionary(*items)\n</code></pre> <p>Creates and returns a dictionary based on the given <code>items</code>.</p> <p>Items are typically given using the <code>key=value</code> syntax same way as <code>&amp;{dictionary}</code> variables are created in the Variable table. Both keys and values can contain variables, and possible equal sign in key can be escaped with a backslash like <code>escaped\\=key=value</code>. It is also possible to get items from existing dictionaries by simply using them like <code>&amp;{dict}</code>.</p> <p>Alternatively items can be specified so that keys and values are given separately. This and the <code>key=value</code> syntax can even be combined, but separately given items must be first. If same key is used multiple times, the last value has precedence.</p> <p>The returned dictionary is ordered, and values with strings as keys can also be accessed using a convenient dot-access syntax like <code>${dict.key}</code>. Technically the returned dictionary is Robot Framework's own <code>DotDict</code> instance. If there is a need, it can be converted into a regular Python <code>dict</code> instance by using the <code>Convert To Dictionary</code> keyword from the Collections library.</p> <p>Examples: | &amp;{dict} = | Create Dictionary | key=value | foo=bar | | | # key=value syntax | | Should Be True | ${dict} == {'key': 'value', 'foo': 'bar'} | | &amp;{dict2} = | Create Dictionary | key | value | foo | bar | # separate key and value | | Should Be Equal | ${dict} | ${dict2} | | &amp;{dict} = | Create Dictionary | ${1}=${2} | &amp;{dict} | foo=new | | # using variables | | Should Be True | ${dict} == {1: 2, 'key': 'value', 'foo': 'new'} | | Should Be Equal | ${dict.key} | value | | | | # dot-access |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>@run_keyword_variant(resolve=0)\ndef create_dictionary(self, *items):\n    \"\"\"Creates and returns a dictionary based on the given ``items``.\n\n    Items are typically given using the ``key=value`` syntax same way as\n    ``&amp;{dictionary}`` variables are created in the Variable table. Both\n    keys and values can contain variables, and possible equal sign in key\n    can be escaped with a backslash like ``escaped\\\\=key=value``. It is\n    also possible to get items from existing dictionaries by simply using\n    them like ``&amp;{dict}``.\n\n    Alternatively items can be specified so that keys and values are given\n    separately. This and the ``key=value`` syntax can even be combined,\n    but separately given items must be first. If same key is used multiple\n    times, the last value has precedence.\n\n    The returned dictionary is ordered, and values with strings as keys\n    can also be accessed using a convenient dot-access syntax like\n    ``${dict.key}``. Technically the returned dictionary is Robot\n    Framework's own ``DotDict`` instance. If there is a need, it can be\n    converted into a regular Python ``dict`` instance by using the\n    `Convert To Dictionary` keyword from the Collections library.\n\n    Examples:\n    | &amp;{dict} = | Create Dictionary | key=value | foo=bar | | | # key=value syntax |\n    | Should Be True | ${dict} == {'key': 'value', 'foo': 'bar'} |\n    | &amp;{dict2} = | Create Dictionary | key | value | foo | bar | # separate key and value |\n    | Should Be Equal | ${dict} | ${dict2} |\n    | &amp;{dict} = | Create Dictionary | ${1}=${2} | &amp;{dict} | foo=new | | # using variables |\n    | Should Be True | ${dict} == {1: 2, 'key': 'value', 'foo': 'new'} |\n    | Should Be Equal | ${dict.key} | value | | | | # dot-access |\n    \"\"\"\n    separate, combined = self._split_dict_items(items)\n    result = DotDict(self._format_separate_dict_items(separate))\n    combined = DictVariableResolver(combined).resolve(self._variables)\n    result.update(combined)\n    return result\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.fail","title":"fail","text":"<pre><code>fail(msg=None, *tags)\n</code></pre> <p>Fails the test with the given message and optionally alters its tags.</p> <p>The error message is specified using the <code>msg</code> argument. It is possible to use HTML in the given error message, similarly as with any other keyword accepting an error message, by prefixing the error with <code>*HTML*</code>.</p> <p>It is possible to modify tags of the current test case by passing tags after the message. Tags starting with a hyphen (e.g. <code>-regression</code>) are removed and others added. Tags are modified using <code>Set Tags</code> and <code>Remove Tags</code> internally, and the semantics setting and removing them are the same as with these keywords.</p> <p>Examples: | Fail | Test not ready   |             | | # Fails with the given message.    | | Fail | HTMLTest not ready | | | # Fails using HTML in the message. | | Fail | Test not ready   | not-ready   | | # Fails and adds 'not-ready' tag.  | | Fail | OS not supported | -regression | | # Removes tag 'regression'.        | | Fail | My message       | tag    | -t*  | # Removes all tags starting with 't' except the newly added 'tag'. |</p> <p>See <code>Fatal Error</code> if you need to stop the whole test execution.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def fail(self, msg=None, *tags):\n    \"\"\"Fails the test with the given message and optionally alters its tags.\n\n    The error message is specified using the ``msg`` argument.\n    It is possible to use HTML in the given error message, similarly\n    as with any other keyword accepting an error message, by prefixing\n    the error with ``*HTML*``.\n\n    It is possible to modify tags of the current test case by passing tags\n    after the message. Tags starting with a hyphen (e.g. ``-regression``)\n    are removed and others added. Tags are modified using `Set Tags` and\n    `Remove Tags` internally, and the semantics setting and removing them\n    are the same as with these keywords.\n\n    Examples:\n    | Fail | Test not ready   |             | | # Fails with the given message.    |\n    | Fail | *HTML*&lt;b&gt;Test not ready&lt;/b&gt; | | | # Fails using HTML in the message. |\n    | Fail | Test not ready   | not-ready   | | # Fails and adds 'not-ready' tag.  |\n    | Fail | OS not supported | -regression | | # Removes tag 'regression'.        |\n    | Fail | My message       | tag    | -t*  | # Removes all tags starting with 't' except the newly added 'tag'. |\n\n    See `Fatal Error` if you need to stop the whole test execution.\n    \"\"\"\n    self._set_and_remove_tags(tags)\n    raise AssertionError(msg) if msg is not None else AssertionError()\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.fatal_error","title":"fatal_error","text":"<pre><code>fatal_error(msg=None)\n</code></pre> <p>Stops the whole test execution.</p> <p>The test or suite where this keyword is used fails with the provided message, and subsequent tests fail with a canned message. Possible teardowns will nevertheless be executed.</p> <p>See <code>Fail</code> if you only want to stop one test case unconditionally.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def fatal_error(self, msg=None):\n    \"\"\"Stops the whole test execution.\n\n    The test or suite where this keyword is used fails with the provided\n    message, and subsequent tests fail with a canned message.\n    Possible teardowns will nevertheless be executed.\n\n    See `Fail` if you only want to stop one test case unconditionally.\n    \"\"\"\n    error = AssertionError(msg) if msg else AssertionError()\n    error.ROBOT_EXIT_ON_FAILURE = True\n    raise error\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_be_true","title":"should_not_be_true","text":"<pre><code>should_not_be_true(condition, msg=None)\n</code></pre> <p>Fails if the given condition is true.</p> <p>See <code>Should Be True</code> for details about how <code>condition</code> is evaluated and how <code>msg</code> can be used to override the default error message.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_be_true(self, condition, msg=None):\n    \"\"\"Fails if the given condition is true.\n\n    See `Should Be True` for details about how ``condition`` is evaluated\n    and how ``msg`` can be used to override the default error message.\n    \"\"\"\n    if self._is_true(condition):\n        raise AssertionError(msg or f\"'{condition}' should not be true.\")\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_be_true","title":"should_be_true","text":"<pre><code>should_be_true(condition, msg=None)\n</code></pre> <p>Fails if the given condition is not true.</p> <p>If <code>condition</code> is a string (e.g. <code>${rc} &lt; 10</code>), it is evaluated as a Python expression as explained in <code>Evaluating expressions</code> and the keyword status is decided based on the result. If a non-string item is given, the status is got directly from its [http://docs.python.org/library/stdtypes.html#truth|truth value].</p> <p>The default error message (<code>&lt;condition&gt; should be true</code>) is not very informative, but it can be overridden with the <code>msg</code> argument.</p> <p>Examples: | Should Be True | ${rc} &lt; 10            | | Should Be True | '${status}' == 'PASS' | # Strings must be quoted | | Should Be True | ${number}   | # Passes if ${number} is not zero | | Should Be True | ${list}     | # Passes if ${list} is not empty  |</p> <p>Variables used like <code>${variable}</code>, as in the examples above, are replaced in the expression before evaluation. Variables are also available in the evaluation namespace, and can be accessed using special <code>$variable</code> syntax as explained in the <code>Evaluating expressions</code> section.</p> <p>Examples: | Should Be True | $rc &lt; 10          | | Should Be True | $status == 'PASS' | # Expected string must be quoted |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_be_true(self, condition, msg=None):\n    \"\"\"Fails if the given condition is not true.\n\n    If ``condition`` is a string (e.g. ``${rc} &lt; 10``), it is evaluated as\n    a Python expression as explained in `Evaluating expressions` and the\n    keyword status is decided based on the result. If a non-string item is\n    given, the status is got directly from its\n    [http://docs.python.org/library/stdtypes.html#truth|truth value].\n\n    The default error message (``&lt;condition&gt; should be true``) is not very\n    informative, but it can be overridden with the ``msg`` argument.\n\n    Examples:\n    | Should Be True | ${rc} &lt; 10            |\n    | Should Be True | '${status}' == 'PASS' | # Strings must be quoted |\n    | Should Be True | ${number}   | # Passes if ${number} is not zero |\n    | Should Be True | ${list}     | # Passes if ${list} is not empty  |\n\n    Variables used like ``${variable}``, as in the examples above, are\n    replaced in the expression before evaluation. Variables are also\n    available in the evaluation namespace, and can be accessed using\n    special ``$variable`` syntax as explained in the `Evaluating\n    expressions` section.\n\n    Examples:\n    | Should Be True | $rc &lt; 10          |\n    | Should Be True | $status == 'PASS' | # Expected string must be quoted |\n    \"\"\"\n    if not self._is_true(condition):\n        raise AssertionError(msg or f\"'{condition}' should be true.\")\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_be_equal","title":"should_be_equal","text":"<pre><code>should_be_equal(\n    first,\n    second,\n    msg=None,\n    values=True,\n    ignore_case=False,\n    formatter=\"str\",\n    strip_spaces=False,\n    collapse_spaces=False,\n)\n</code></pre> <p>Fails if the given objects are unequal.</p> <p>Optional <code>msg</code>, <code>values</code> and <code>formatter</code> arguments specify how to construct the error message if this keyword fails:</p> <ul> <li>If <code>msg</code> is not given, the error message is <code>&lt;first&gt; != &lt;second&gt;</code>.</li> <li>If <code>msg</code> is given and <code>values</code> gets a true value (default),   the error message is <code>&lt;msg&gt;: &lt;first&gt; != &lt;second&gt;</code>.</li> <li>If <code>msg</code> is given and <code>values</code> gets a false value (see   <code>Boolean arguments</code>), the error message is simply <code>&lt;msg&gt;</code>.</li> <li><code>formatter</code> controls how to format the values. Possible values are   <code>str</code> (default), <code>repr</code> and <code>ascii</code>, and they work similarly   as Python built-in functions with same names. See <code>String   representations</code> for more details.</li> </ul> <p>If <code>ignore_case</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, comparison is done case-insensitively. If both arguments are multiline strings, this keyword uses <code>multiline string comparison</code>.</p> <p>If <code>strip_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done without leading and trailing spaces. If <code>strip_spaces</code> is given a string value <code>LEADING</code> or <code>TRAILING</code> (case-insensitive), the comparison is done without leading or trailing spaces, respectively.</p> <p>If <code>collapse_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done with all white spaces replaced by a single space character.</p> <p>Examples: | Should Be Equal | ${x} | expected | | Should Be Equal | ${x} | expected | Custom error message | | Should Be Equal | ${x} | expected | Custom message | values=False | | Should Be Equal | ${x} | expected | ignore_case=True | formatter=repr |</p> <p><code>strip_spaces</code> is new in Robot Framework 4.0 and <code>collapse_spaces</code> is new in Robot Framework 4.1.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_be_equal(self, first, second, msg=None, values=True,\n                    ignore_case=False, formatter='str', strip_spaces=False,\n                    collapse_spaces=False):\n    \"\"\"Fails if the given objects are unequal.\n\n    Optional ``msg``, ``values`` and ``formatter`` arguments specify how\n    to construct the error message if this keyword fails:\n\n    - If ``msg`` is not given, the error message is ``&lt;first&gt; != &lt;second&gt;``.\n    - If ``msg`` is given and ``values`` gets a true value (default),\n      the error message is ``&lt;msg&gt;: &lt;first&gt; != &lt;second&gt;``.\n    - If ``msg`` is given and ``values`` gets a false value (see\n      `Boolean arguments`), the error message is simply ``&lt;msg&gt;``.\n    - ``formatter`` controls how to format the values. Possible values are\n      ``str`` (default), ``repr`` and ``ascii``, and they work similarly\n      as Python built-in functions with same names. See `String\n      representations` for more details.\n\n    If ``ignore_case`` is given a true value (see `Boolean arguments`) and\n    both arguments are strings, comparison is done case-insensitively.\n    If both arguments are multiline strings, this keyword uses\n    `multiline string comparison`.\n\n    If ``strip_spaces`` is given a true value (see `Boolean arguments`)\n    and both arguments are strings, the comparison is done without leading\n    and trailing spaces. If ``strip_spaces`` is given a string value\n    ``LEADING`` or ``TRAILING`` (case-insensitive), the comparison is done\n    without leading or trailing spaces, respectively.\n\n    If ``collapse_spaces`` is given a true value (see `Boolean arguments`) and both\n    arguments are strings, the comparison is done with all white spaces replaced by\n    a single space character.\n\n    Examples:\n    | Should Be Equal | ${x} | expected |\n    | Should Be Equal | ${x} | expected | Custom error message |\n    | Should Be Equal | ${x} | expected | Custom message | values=False |\n    | Should Be Equal | ${x} | expected | ignore_case=True | formatter=repr |\n\n    ``strip_spaces`` is new in Robot Framework 4.0 and\n    ``collapse_spaces`` is new in Robot Framework 4.1.\n    \"\"\"\n    self._log_types_at_info_if_different(first, second)\n    if is_string(first) and is_string(second):\n        if ignore_case:\n            first = first.casefold()\n            second = second.casefold()\n        if strip_spaces:\n            first = self._strip_spaces(first, strip_spaces)\n            second = self._strip_spaces(second, strip_spaces)\n        if collapse_spaces:\n            first = self._collapse_spaces(first)\n            second = self._collapse_spaces(second)\n    self._should_be_equal(first, second, msg, values, formatter)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_be_equal","title":"should_not_be_equal","text":"<pre><code>should_not_be_equal(\n    first,\n    second,\n    msg=None,\n    values=True,\n    ignore_case=False,\n    strip_spaces=False,\n    collapse_spaces=False,\n)\n</code></pre> <p>Fails if the given objects are equal.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>values</code>.</p> <p>If <code>ignore_case</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, comparison is done case-insensitively.</p> <p>If <code>strip_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done without leading and trailing spaces. If <code>strip_spaces</code> is given a string value <code>LEADING</code> or <code>TRAILING</code> (case-insensitive), the comparison is done without leading or trailing spaces, respectively.</p> <p>If <code>collapse_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done with all white spaces replaced by a single space character.</p> <p><code>strip_spaces</code> is new in Robot Framework 4.0 and <code>collapse_spaces</code> is new in Robot Framework 4.1.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_be_equal(self, first, second, msg=None, values=True,\n                        ignore_case=False, strip_spaces=False,\n                        collapse_spaces=False):\n    \"\"\"Fails if the given objects are equal.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg`` and ``values``.\n\n    If ``ignore_case`` is given a true value (see `Boolean arguments`) and\n    both arguments are strings, comparison is done case-insensitively.\n\n    If ``strip_spaces`` is given a true value (see `Boolean arguments`)\n    and both arguments are strings, the comparison is done without leading\n    and trailing spaces. If ``strip_spaces`` is given a string value\n    ``LEADING`` or ``TRAILING`` (case-insensitive), the comparison is done\n    without leading or trailing spaces, respectively.\n\n    If ``collapse_spaces`` is given a true value (see `Boolean arguments`) and both\n    arguments are strings, the comparison is done with all white spaces replaced by\n    a single space character.\n\n    ``strip_spaces`` is new in Robot Framework 4.0 and ``collapse_spaces`` is new\n    in Robot Framework 4.1.\n    \"\"\"\n    self._log_types_at_info_if_different(first, second)\n    if is_string(first) and is_string(second):\n        if ignore_case:\n            first = first.casefold()\n            second = second.casefold()\n        if strip_spaces:\n            first = self._strip_spaces(first, strip_spaces)\n            second = self._strip_spaces(second, strip_spaces)\n        if collapse_spaces:\n            first = self._collapse_spaces(first)\n            second = self._collapse_spaces(second)\n    self._should_not_be_equal(first, second, msg, values)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_be_equal_as_integers","title":"should_not_be_equal_as_integers","text":"<pre><code>should_not_be_equal_as_integers(\n    first, second, msg=None, values=True, base=None\n)\n</code></pre> <p>Fails if objects are equal after converting them to integers.</p> <p>See <code>Convert To Integer</code> for information how to convert integers from other bases than 10 using <code>base</code> argument or <code>0b/0o/0x</code> prefixes.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>values</code>.</p> <p>See <code>Should Be Equal As Integers</code> for some usage examples.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_be_equal_as_integers(self, first, second, msg=None,\n                                    values=True, base=None):\n    \"\"\"Fails if objects are equal after converting them to integers.\n\n    See `Convert To Integer` for information how to convert integers from\n    other bases than 10 using ``base`` argument or ``0b/0o/0x`` prefixes.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg`` and ``values``.\n\n    See `Should Be Equal As Integers` for some usage examples.\n    \"\"\"\n    self._log_types_at_info_if_different(first, second)\n    self._should_not_be_equal(self._convert_to_integer(first, base),\n                              self._convert_to_integer(second, base),\n                              msg, values)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_be_equal_as_integers","title":"should_be_equal_as_integers","text":"<pre><code>should_be_equal_as_integers(\n    first, second, msg=None, values=True, base=None\n)\n</code></pre> <p>Fails if objects are unequal after converting them to integers.</p> <p>See <code>Convert To Integer</code> for information how to convert integers from other bases than 10 using <code>base</code> argument or <code>0b/0o/0x</code> prefixes.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>values</code>.</p> <p>Examples: | Should Be Equal As Integers | 42   | ${42} | Error message | | Should Be Equal As Integers | ABCD | abcd  | base=16 | | Should Be Equal As Integers | 0b1011 | 11  |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_be_equal_as_integers(self, first, second, msg=None, values=True,\n                                base=None):\n    \"\"\"Fails if objects are unequal after converting them to integers.\n\n    See `Convert To Integer` for information how to convert integers from\n    other bases than 10 using ``base`` argument or ``0b/0o/0x`` prefixes.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg`` and ``values``.\n\n    Examples:\n    | Should Be Equal As Integers | 42   | ${42} | Error message |\n    | Should Be Equal As Integers | ABCD | abcd  | base=16 |\n    | Should Be Equal As Integers | 0b1011 | 11  |\n    \"\"\"\n    self._log_types_at_info_if_different(first, second)\n    self._should_be_equal(self._convert_to_integer(first, base),\n                          self._convert_to_integer(second, base),\n                          msg, values)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_be_equal_as_numbers","title":"should_not_be_equal_as_numbers","text":"<pre><code>should_not_be_equal_as_numbers(\n    first, second, msg=None, values=True, precision=6\n)\n</code></pre> <p>Fails if objects are equal after converting them to real numbers.</p> <p>The conversion is done with <code>Convert To Number</code> keyword using the given <code>precision</code>.</p> <p>See <code>Should Be Equal As Numbers</code> for examples on how to use <code>precision</code> and why it does not always work as expected. See also <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>values</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_be_equal_as_numbers(self, first, second, msg=None,\n                                   values=True, precision=6):\n    \"\"\"Fails if objects are equal after converting them to real numbers.\n\n    The conversion is done with `Convert To Number` keyword using the\n    given ``precision``.\n\n    See `Should Be Equal As Numbers` for examples on how to use\n    ``precision`` and why it does not always work as expected. See also\n    `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg`` and ``values``.\n    \"\"\"\n    self._log_types_at_info_if_different(first, second)\n    first = self._convert_to_number(first, precision)\n    second = self._convert_to_number(second, precision)\n    self._should_not_be_equal(first, second, msg, values)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_be_equal_as_numbers","title":"should_be_equal_as_numbers","text":"<pre><code>should_be_equal_as_numbers(\n    first, second, msg=None, values=True, precision=6\n)\n</code></pre> <p>Fails if objects are unequal after converting them to real numbers.</p> <p>The conversion is done with <code>Convert To Number</code> keyword using the given <code>precision</code>.</p> <p>Examples: | Should Be Equal As Numbers | ${x} | 1.1 | | # Passes if ${x} is 1.1 | | Should Be Equal As Numbers | 1.123 | 1.1 | precision=1  | # Passes | | Should Be Equal As Numbers | 1.123 | 1.4 | precision=0  | # Passes | | Should Be Equal As Numbers | 112.3 | 75  | precision=-2 | # Passes |</p> <p>As discussed in the documentation of <code>Convert To Number</code>, machines generally cannot store floating point numbers accurately. Because of this limitation, comparing floats for equality is problematic and a correct approach to use depends on the context. This keyword uses a very naive approach of rounding the numbers before comparing them, which is both prone to rounding errors and does not work very well if numbers are really big or small. For more information about comparing floats, and ideas on how to implement your own context specific comparison algorithm, see http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/.</p> <p>If you want to avoid possible problems with floating point numbers, you can implement custom keywords using Python's [http://docs.python.org/library/decimal.html|decimal] or [http://docs.python.org/library/fractions.html|fractions] modules.</p> <p>See <code>Should Not Be Equal As Numbers</code> for a negative version of this keyword and <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>values</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_be_equal_as_numbers(self, first, second, msg=None, values=True,\n                               precision=6):\n    \"\"\"Fails if objects are unequal after converting them to real numbers.\n\n    The conversion is done with `Convert To Number` keyword using the\n    given ``precision``.\n\n    Examples:\n    | Should Be Equal As Numbers | ${x} | 1.1 | | # Passes if ${x} is 1.1 |\n    | Should Be Equal As Numbers | 1.123 | 1.1 | precision=1  | # Passes |\n    | Should Be Equal As Numbers | 1.123 | 1.4 | precision=0  | # Passes |\n    | Should Be Equal As Numbers | 112.3 | 75  | precision=-2 | # Passes |\n\n    As discussed in the documentation of `Convert To Number`, machines\n    generally cannot store floating point numbers accurately. Because of\n    this limitation, comparing floats for equality is problematic and\n    a correct approach to use depends on the context. This keyword uses\n    a very naive approach of rounding the numbers before comparing them,\n    which is both prone to rounding errors and does not work very well if\n    numbers are really big or small. For more information about comparing\n    floats, and ideas on how to implement your own context specific\n    comparison algorithm, see\n    http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/.\n\n    If you want to avoid possible problems with floating point numbers,\n    you can implement custom keywords using Python's\n    [http://docs.python.org/library/decimal.html|decimal] or\n    [http://docs.python.org/library/fractions.html|fractions] modules.\n\n    See `Should Not Be Equal As Numbers` for a negative version of this\n    keyword and `Should Be Equal` for an explanation on how to override\n    the default error message with ``msg`` and ``values``.\n    \"\"\"\n    self._log_types_at_info_if_different(first, second)\n    first = self._convert_to_number(first, precision)\n    second = self._convert_to_number(second, precision)\n    self._should_be_equal(first, second, msg, values)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_be_equal_as_strings","title":"should_not_be_equal_as_strings","text":"<pre><code>should_not_be_equal_as_strings(\n    first,\n    second,\n    msg=None,\n    values=True,\n    ignore_case=False,\n    strip_spaces=False,\n    collapse_spaces=False,\n)\n</code></pre> <p>Fails if objects are equal after converting them to strings.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>values</code>.</p> <p>If <code>ignore_case</code> is given a true value (see <code>Boolean arguments</code>), comparison is done case-insensitively.</p> <p>If <code>strip_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done without leading and trailing spaces. If <code>strip_spaces</code> is given a string value <code>LEADING</code> or <code>TRAILING</code> (case-insensitive), the comparison is done without leading or trailing spaces, respectively.</p> <p>If <code>collapse_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done with all white spaces replaced by a single space character.</p> <p>Strings are always [https://en.wikipedia.org/wiki/Unicode_equivalence| NFC normalized].</p> <p><code>strip_spaces</code> is new in Robot Framework 4.0 and <code>collapse_spaces</code> is new in Robot Framework 4.1.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_be_equal_as_strings(self, first, second, msg=None, values=True,\n                                   ignore_case=False, strip_spaces=False,\n                                   collapse_spaces=False):\n    \"\"\"Fails if objects are equal after converting them to strings.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg`` and ``values``.\n\n    If ``ignore_case`` is given a true value (see `Boolean arguments`),\n    comparison is done case-insensitively.\n\n    If ``strip_spaces`` is given a true value (see `Boolean arguments`)\n    and both arguments are strings, the comparison is done without leading\n    and trailing spaces. If ``strip_spaces`` is given a string value\n    ``LEADING`` or ``TRAILING`` (case-insensitive), the comparison is done\n    without leading or trailing spaces, respectively.\n\n    If ``collapse_spaces`` is given a true value (see `Boolean arguments`) and both\n    arguments are strings, the comparison is done with all white spaces replaced by\n    a single space character.\n\n    Strings are always [https://en.wikipedia.org/wiki/Unicode_equivalence|\n    NFC normalized].\n\n    ``strip_spaces`` is new in Robot Framework 4.0 and ``collapse_spaces`` is new\n    in Robot Framework 4.1.\n    \"\"\"\n    self._log_types_at_info_if_different(first, second)\n    first = safe_str(first)\n    second = safe_str(second)\n    if ignore_case:\n        first = first.casefold()\n        second = second.casefold()\n    if strip_spaces:\n        first = self._strip_spaces(first, strip_spaces)\n        second = self._strip_spaces(second, strip_spaces)\n    if collapse_spaces:\n        first = self._collapse_spaces(first)\n        second = self._collapse_spaces(second)\n    self._should_not_be_equal(first, second, msg, values)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_be_equal_as_strings","title":"should_be_equal_as_strings","text":"<pre><code>should_be_equal_as_strings(\n    first,\n    second,\n    msg=None,\n    values=True,\n    ignore_case=False,\n    strip_spaces=False,\n    formatter=\"str\",\n    collapse_spaces=False,\n)\n</code></pre> <p>Fails if objects are unequal after converting them to strings.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code>, <code>values</code> and <code>formatter</code>.</p> <p>If <code>ignore_case</code> is given a true value (see <code>Boolean arguments</code>), comparison is done case-insensitively. If both arguments are multiline strings, this keyword uses <code>multiline string comparison</code>.</p> <p>If <code>strip_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done without leading and trailing spaces. If <code>strip_spaces</code> is given a string value <code>LEADING</code> or <code>TRAILING</code> (case-insensitive), the comparison is done without leading or trailing spaces, respectively.</p> <p>If <code>collapse_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done with all white spaces replaced by a single space character.</p> <p>Strings are always [https://en.wikipedia.org/wiki/Unicode_equivalence|NFC normalized].</p> <p><code>strip_spaces</code> is new in Robot Framework 4.0 and <code>collapse_spaces</code> is new in Robot Framework 4.1.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_be_equal_as_strings(self, first, second, msg=None, values=True,\n                               ignore_case=False, strip_spaces=False,\n                               formatter='str', collapse_spaces=False):\n    \"\"\"Fails if objects are unequal after converting them to strings.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg``, ``values`` and ``formatter``.\n\n    If ``ignore_case`` is given a true value (see `Boolean arguments`),\n    comparison is done case-insensitively. If both arguments are\n    multiline strings, this keyword uses `multiline string comparison`.\n\n    If ``strip_spaces`` is given a true value (see `Boolean arguments`)\n    and both arguments are strings, the comparison is done without leading\n    and trailing spaces. If ``strip_spaces`` is given a string value\n    ``LEADING`` or ``TRAILING`` (case-insensitive), the comparison is done\n    without leading or trailing spaces, respectively.\n\n    If ``collapse_spaces`` is given a true value (see `Boolean arguments`) and both\n    arguments are strings, the comparison is done with all white spaces replaced by\n    a single space character.\n\n    Strings are always [https://en.wikipedia.org/wiki/Unicode_equivalence|NFC normalized].\n\n    ``strip_spaces`` is new in Robot Framework 4.0\n    and ``collapse_spaces`` is new in Robot Framework 4.1.\n    \"\"\"\n    self._log_types_at_info_if_different(first, second)\n    first = safe_str(first)\n    second = safe_str(second)\n    if ignore_case:\n        first = first.casefold()\n        second = second.casefold()\n    if strip_spaces:\n        first = self._strip_spaces(first, strip_spaces)\n        second = self._strip_spaces(second, strip_spaces)\n    if collapse_spaces:\n        first = self._collapse_spaces(first)\n        second = self._collapse_spaces(second)\n    self._should_be_equal(first, second, msg, values, formatter)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_start_with","title":"should_not_start_with","text":"<pre><code>should_not_start_with(\n    str1,\n    str2,\n    msg=None,\n    values=True,\n    ignore_case=False,\n    strip_spaces=False,\n    collapse_spaces=False,\n)\n</code></pre> <p>Fails if the string <code>str1</code> starts with the string <code>str2</code>.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>values</code>, as well as for semantics of the <code>ignore_case</code>, <code>strip_spaces</code>, and <code>collapse_spaces</code> options.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_start_with(self, str1, str2, msg=None, values=True,\n                          ignore_case=False, strip_spaces=False,\n                          collapse_spaces=False):\n    \"\"\"Fails if the string ``str1`` starts with the string ``str2``.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg`` and ``values``, as well as for semantics\n    of the ``ignore_case``, ``strip_spaces``, and ``collapse_spaces`` options.\n    \"\"\"\n    if ignore_case:\n        str1 = str1.casefold()\n        str2 = str2.casefold()\n    if strip_spaces:\n        str1 = self._strip_spaces(str1, strip_spaces)\n        str2 = self._strip_spaces(str2, strip_spaces)\n    if collapse_spaces:\n        str1 = self._collapse_spaces(str1)\n        str2 = self._collapse_spaces(str2)\n    if str1.startswith(str2):\n        raise AssertionError(self._get_string_msg(str1, str2, msg, values,\n                                                  'starts with'))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_start_with","title":"should_start_with","text":"<pre><code>should_start_with(\n    str1,\n    str2,\n    msg=None,\n    values=True,\n    ignore_case=False,\n    strip_spaces=False,\n    collapse_spaces=False,\n)\n</code></pre> <p>Fails if the string <code>str1</code> does not start with the string <code>str2</code>.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>values</code>, as well as for semantics of the <code>ignore_case</code>, <code>strip_spaces</code>, and <code>collapse_spaces</code> options.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_start_with(self, str1, str2, msg=None, values=True,\n                      ignore_case=False, strip_spaces=False, collapse_spaces=False):\n    \"\"\"Fails if the string ``str1`` does not start with the string ``str2``.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg`` and ``values``, as well as for semantics\n    of the ``ignore_case``, ``strip_spaces``, and ``collapse_spaces`` options.\n    \"\"\"\n    if ignore_case:\n        str1 = str1.casefold()\n        str2 = str2.casefold()\n    if strip_spaces:\n        str1 = self._strip_spaces(str1, strip_spaces)\n        str2 = self._strip_spaces(str2, strip_spaces)\n    if collapse_spaces:\n        str1 = self._collapse_spaces(str1)\n        str2 = self._collapse_spaces(str2)\n    if not str1.startswith(str2):\n        raise AssertionError(self._get_string_msg(str1, str2, msg, values,\n                                                  'does not start with'))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_end_with","title":"should_not_end_with","text":"<pre><code>should_not_end_with(\n    str1,\n    str2,\n    msg=None,\n    values=True,\n    ignore_case=False,\n    strip_spaces=False,\n    collapse_spaces=False,\n)\n</code></pre> <p>Fails if the string <code>str1</code> ends with the string <code>str2</code>.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>values</code>, as well as for semantics of the <code>ignore_case</code>, <code>strip_spaces</code>, and <code>collapse_spaces</code> options.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_end_with(self, str1, str2, msg=None, values=True,\n                        ignore_case=False, strip_spaces=False,\n                        collapse_spaces=False):\n    \"\"\"Fails if the string ``str1`` ends with the string ``str2``.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg`` and ``values``, as well as for semantics\n    of the ``ignore_case``, ``strip_spaces``, and ``collapse_spaces`` options.\n    \"\"\"\n    if ignore_case:\n        str1 = str1.casefold()\n        str2 = str2.casefold()\n    if strip_spaces:\n        str1 = self._strip_spaces(str1, strip_spaces)\n        str2 = self._strip_spaces(str2, strip_spaces)\n    if collapse_spaces:\n        str1 = self._collapse_spaces(str1)\n        str2 = self._collapse_spaces(str2)\n    if str1.endswith(str2):\n        raise AssertionError(self._get_string_msg(str1, str2, msg, values,\n                                                  'ends with'))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_end_with","title":"should_end_with","text":"<pre><code>should_end_with(\n    str1,\n    str2,\n    msg=None,\n    values=True,\n    ignore_case=False,\n    strip_spaces=False,\n    collapse_spaces=False,\n)\n</code></pre> <p>Fails if the string <code>str1</code> does not end with the string <code>str2</code>.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>values</code>, as well as for semantics of the <code>ignore_case</code>, <code>strip_spaces</code>, and <code>collapse_spaces</code> options.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_end_with(self, str1, str2, msg=None, values=True,\n                    ignore_case=False, strip_spaces=False, collapse_spaces=False):\n    \"\"\"Fails if the string ``str1`` does not end with the string ``str2``.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg`` and ``values``, as well as for semantics\n    of the ``ignore_case``, ``strip_spaces``, and ``collapse_spaces`` options.\n    \"\"\"\n    if ignore_case:\n        str1 = str1.casefold()\n        str2 = str2.casefold()\n    if strip_spaces:\n        str1 = self._strip_spaces(str1, strip_spaces)\n        str2 = self._strip_spaces(str2, strip_spaces)\n    if collapse_spaces:\n        str1 = self._collapse_spaces(str1)\n        str2 = self._collapse_spaces(str2)\n    if not str1.endswith(str2):\n        raise AssertionError(self._get_string_msg(str1, str2, msg, values,\n                                                  'does not end with'))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_contain","title":"should_not_contain","text":"<pre><code>should_not_contain(\n    container,\n    item,\n    msg=None,\n    values=True,\n    ignore_case=False,\n    strip_spaces=False,\n    collapse_spaces=False,\n)\n</code></pre> <p>Fails if <code>container</code> contains <code>item</code> one or more times.</p> <p>Works with strings, lists, and anything that supports Python's <code>in</code> operator.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with arguments <code>msg</code> and <code>values</code>. <code>ignore_case</code> has exactly the same semantics as with <code>Should Contain</code>.</p> <p>If <code>strip_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done without leading and trailing spaces. If <code>strip_spaces</code> is given a string value <code>LEADING</code> or <code>TRAILING</code> (case-insensitive), the comparison is done without leading or trailing spaces, respectively.</p> <p>If <code>collapse_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done with all white spaces replaced by a single space character.</p> <p>Examples: | Should Not Contain | ${some list} | value  | | Should Not Contain | ${output}    | FAILED | ignore_case=True |</p> <p><code>strip_spaces</code> is new in Robot Framework 4.0 and <code>collapse_spaces</code> is new in Robot Framework 4.1.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_contain(self, container, item, msg=None, values=True,\n                       ignore_case=False, strip_spaces=False,\n                       collapse_spaces=False):\n    \"\"\"Fails if ``container`` contains ``item`` one or more times.\n\n    Works with strings, lists, and anything that supports Python's ``in``\n    operator.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with arguments ``msg`` and ``values``. ``ignore_case``\n    has exactly the same semantics as with `Should Contain`.\n\n    If ``strip_spaces`` is given a true value (see `Boolean arguments`)\n    and both arguments are strings, the comparison is done without leading\n    and trailing spaces. If ``strip_spaces`` is given a string value\n    ``LEADING`` or ``TRAILING`` (case-insensitive), the comparison is done\n    without leading or trailing spaces, respectively.\n\n    If ``collapse_spaces`` is given a true value (see `Boolean arguments`) and both\n    arguments are strings, the comparison is done with all white spaces replaced by\n    a single space character.\n\n    Examples:\n    | Should Not Contain | ${some list} | value  |\n    | Should Not Contain | ${output}    | FAILED | ignore_case=True |\n\n    ``strip_spaces`` is new in Robot Framework 4.0 and ``collapse_spaces`` is new\n    in Robot Framework 4.1.\n    \"\"\"\n    # TODO: It is inconsistent that errors show original case in 'container'\n    # 'item' is in lower case. Should rather show original case everywhere\n    # and add separate '(case-insensitive)' not to the error message.\n    # This same logic should be used with all keywords supporting\n    # case-insensitive comparisons.\n    orig_container = container\n    if ignore_case and is_string(item):\n        item = item.casefold()\n        if is_string(container):\n            container = container.casefold()\n        elif is_list_like(container):\n            container = set(x.casefold() if is_string(x) else x for x in container)\n    if strip_spaces and is_string(item):\n        item = self._strip_spaces(item, strip_spaces)\n        if is_string(container):\n            container = self._strip_spaces(container, strip_spaces)\n        elif is_list_like(container):\n            container = set(self._strip_spaces(x, strip_spaces) for x in container)\n    if collapse_spaces and is_string(item):\n        item = self._collapse_spaces(item)\n        if is_string(container):\n            container = self._collapse_spaces(container)\n        elif is_list_like(container):\n            container = set(self._collapse_spaces(x) for x in container)\n    if item in container:\n        raise AssertionError(self._get_string_msg(orig_container, item, msg,\n                                                  values, 'contains'))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_contain","title":"should_contain","text":"<pre><code>should_contain(\n    container,\n    item,\n    msg=None,\n    values=True,\n    ignore_case=False,\n    strip_spaces=False,\n    collapse_spaces=False,\n)\n</code></pre> <p>Fails if <code>container</code> does not contain <code>item</code> one or more times.</p> <p>Works with strings, lists, bytes, and anything that supports Python's <code>in</code> operator.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with arguments <code>msg</code> and <code>values</code>.</p> <p>If <code>ignore_case</code> is given a true value (see <code>Boolean arguments</code>) and compared items are strings, it indicates that comparison should be case-insensitive. If the <code>container</code> is a list-like object, string items in it are compared case-insensitively.</p> <p>If <code>strip_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done without leading and trailing spaces. If <code>strip_spaces</code> is given a string value <code>LEADING</code> or <code>TRAILING</code> (case-insensitive), the comparison is done without leading or trailing spaces, respectively.</p> <p>If <code>collapse_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done with all white spaces replaced by a single space character.</p> <p>If the <code>container</code> is bytes and the <code>item</code> is a string, the <code>item</code> is automatically converted to bytes. Conversion is done using the ISO-8859-1 encoding that maps each Unicode code point directly to a matching byte.</p> <p>Examples: | Should Contain | ${output}    | PASS  | | Should Contain | ${some list} | value | msg=Failure! | values=False | | Should Contain | ${some list} | value | ignore_case=True |</p> <p><code>strip_spaces</code> is new in Robot Framework 4.0, <code>collapse_spaces</code> is new in Robot Framework 4.1 and automatically converting <code>item</code> to bytes is new in Robot Framework 7.1.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_contain(self, container, item, msg=None, values=True,\n                   ignore_case=False, strip_spaces=False, collapse_spaces=False):\n    \"\"\"Fails if ``container`` does not contain ``item`` one or more times.\n\n    Works with strings, lists, bytes, and anything that supports Python's ``in``\n    operator.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with arguments ``msg`` and ``values``.\n\n    If ``ignore_case`` is given a true value (see `Boolean arguments`) and\n    compared items are strings, it indicates that comparison should be\n    case-insensitive. If the ``container`` is a list-like object, string\n    items in it are compared case-insensitively.\n\n    If ``strip_spaces`` is given a true value (see `Boolean arguments`)\n    and both arguments are strings, the comparison is done without leading\n    and trailing spaces. If ``strip_spaces`` is given a string value\n    ``LEADING`` or ``TRAILING`` (case-insensitive), the comparison is done\n    without leading or trailing spaces, respectively.\n\n    If ``collapse_spaces`` is given a true value (see `Boolean arguments`) and both\n    arguments are strings, the comparison is done with all white spaces replaced by\n    a single space character.\n\n    If the ``container`` is bytes and the ``item`` is a string, the ``item``\n    is automatically converted to bytes. Conversion is done using the ISO-8859-1\n    encoding that maps each Unicode code point directly to a matching byte.\n\n    Examples:\n    | Should Contain | ${output}    | PASS  |\n    | Should Contain | ${some list} | value | msg=Failure! | values=False |\n    | Should Contain | ${some list} | value | ignore_case=True |\n\n    ``strip_spaces`` is new in Robot Framework 4.0, ``collapse_spaces`` is new\n    in Robot Framework 4.1 and automatically converting ``item`` to bytes\n    is new in Robot Framework 7.1.\n    \"\"\"\n    orig_container = container\n    if isinstance(container, (bytes, bytearray)):\n        if isinstance(item, str):\n            try:\n                item = item.encode('ISO-8859-1')\n            except UnicodeEncodeError:\n                raise ValueError(f'{item!r} cannot be encoded into bytes.')\n        elif isinstance(item, int) and item not in range(256):\n            raise ValueError(f'Byte must be in range 0-255, got {item}.')\n    if ignore_case and is_string(item):\n        item = item.casefold()\n        if is_string(container):\n            container = container.casefold()\n        elif is_list_like(container):\n            container = set(x.casefold() if is_string(x) else x for x in container)\n    if strip_spaces and is_string(item):\n        item = self._strip_spaces(item, strip_spaces)\n        if is_string(container):\n            container = self._strip_spaces(container, strip_spaces)\n        elif is_list_like(container):\n            container = set(self._strip_spaces(x, strip_spaces) for x in container)\n    if collapse_spaces and is_string(item):\n        item = self._collapse_spaces(item)\n        if is_string(container):\n            container = self._collapse_spaces(container)\n        elif is_list_like(container):\n            container = set(self._collapse_spaces(x) for x in container)\n    if item not in container:\n        raise AssertionError(self._get_string_msg(orig_container, item, msg,\n                                                  values, 'does not contain'))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_contain_any","title":"should_contain_any","text":"<pre><code>should_contain_any(container, *items, **configuration)\n</code></pre> <p>Fails if <code>container</code> does not contain any of the <code>*items</code>.</p> <p>Works with strings, lists, and anything that supports Python's <code>in</code> operator.</p> <p>Supports additional configuration parameters <code>msg</code>, <code>values</code>, <code>ignore_case</code> and <code>strip_spaces</code>, and <code>collapse_spaces</code> which have exactly the same semantics as arguments with same names have with <code>Should Contain</code>. These arguments must always be given using <code>name=value</code> syntax after all <code>items</code>.</p> <p>Note that possible equal signs in <code>items</code> must be escaped with a backslash (e.g. <code>foo\\=bar</code>) to avoid them to be passed in as <code>**configuration</code>.</p> <p>Examples: | Should Contain Any | ${string} | substring 1 | substring 2 | | Should Contain Any | ${list}   | item 1 | item 2 | item 3 | | Should Contain Any | ${list}   | item 1 | item 2 | item 3 | ignore_case=True | | Should Contain Any | ${list}   | @{items} | msg=Custom message | values=False |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_contain_any(self, container, *items, **configuration):\n    \"\"\"Fails if ``container`` does not contain any of the ``*items``.\n\n    Works with strings, lists, and anything that supports Python's ``in``\n    operator.\n\n    Supports additional configuration parameters ``msg``, ``values``,\n    ``ignore_case`` and ``strip_spaces``, and ``collapse_spaces``\n    which have exactly the same semantics as arguments with same\n    names have with `Should Contain`. These arguments must always\n    be given using ``name=value`` syntax after all ``items``.\n\n    Note that possible equal signs in ``items`` must be escaped with\n    a backslash (e.g. ``foo\\\\=bar``) to avoid them to be passed in\n    as ``**configuration``.\n\n    Examples:\n    | Should Contain Any | ${string} | substring 1 | substring 2 |\n    | Should Contain Any | ${list}   | item 1 | item 2 | item 3 |\n    | Should Contain Any | ${list}   | item 1 | item 2 | item 3 | ignore_case=True |\n    | Should Contain Any | ${list}   | @{items} | msg=Custom message | values=False |\n    \"\"\"\n    msg = configuration.pop('msg', None)\n    values = configuration.pop('values', True)\n    ignore_case = is_truthy(configuration.pop('ignore_case', False))\n    strip_spaces = configuration.pop('strip_spaces', False)\n    collapse_spaces = is_truthy(configuration.pop('collapse_spaces', False))\n    if configuration:\n        raise RuntimeError(f\"Unsupported configuration parameter{s(configuration)}: \"\n                           f\"{seq2str(sorted(configuration))}.\")\n    if not items:\n        raise RuntimeError('One or more items required.')\n    orig_container = container\n    if ignore_case:\n        items = [x.casefold() if is_string(x) else x for x in items]\n        if is_string(container):\n            container = container.casefold()\n        elif is_list_like(container):\n            container = set(x.casefold() if is_string(x) else x for x in container)\n    if strip_spaces:\n        items = [self._strip_spaces(x, strip_spaces) for x in items]\n        if is_string(container):\n            container = self._strip_spaces(container, strip_spaces)\n        elif is_list_like(container):\n            container = set(self._strip_spaces(x, strip_spaces) for x in container)\n    if collapse_spaces:\n        items = [self._collapse_spaces(x) for x in items]\n        if is_string(container):\n            container = self._collapse_spaces(container)\n        elif is_list_like(container):\n            container = set(self._collapse_spaces(x) for x in container)\n    if not any(item in container for item in items):\n        msg = self._get_string_msg(orig_container,\n                                   seq2str(items, lastsep=' or '),\n                                   msg, values,\n                                   'does not contain any of',\n                                   quote_item2=False)\n        raise AssertionError(msg)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_contain_any","title":"should_not_contain_any","text":"<pre><code>should_not_contain_any(container, *items, **configuration)\n</code></pre> <p>Fails if <code>container</code> contains one or more of the <code>*items</code>.</p> <p>Works with strings, lists, and anything that supports Python's <code>in</code> operator.</p> <p>Supports additional configuration parameters <code>msg</code>, <code>values</code>, <code>ignore_case</code> and <code>strip_spaces</code>, and <code>collapse_spaces</code> which have exactly the same semantics as arguments with same names have with <code>Should Contain</code>. These arguments must always be given using <code>name=value</code> syntax after all <code>items</code>.</p> <p>Note that possible equal signs in <code>items</code> must be escaped with a backslash (e.g. <code>foo\\=bar</code>) to avoid them to be passed in as <code>**configuration</code>.</p> <p>Examples: | Should Not Contain Any | ${string} | substring 1 | substring 2 | | Should Not Contain Any | ${list}   | item 1 | item 2 | item 3 | | Should Not Contain Any | ${list}   | item 1 | item 2 | item 3 | ignore_case=True | | Should Not Contain Any | ${list}   | @{items} | msg=Custom message | values=False |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_contain_any(self, container, *items, **configuration):\n    \"\"\"Fails if ``container`` contains one or more of the ``*items``.\n\n    Works with strings, lists, and anything that supports Python's ``in``\n    operator.\n\n    Supports additional configuration parameters ``msg``, ``values``,\n    ``ignore_case`` and ``strip_spaces``, and ``collapse_spaces`` which have exactly\n    the same semantics as arguments with same names have with `Should Contain`.\n    These arguments must always be given using ``name=value`` syntax after all ``items``.\n\n    Note that possible equal signs in ``items`` must be escaped with\n    a backslash (e.g. ``foo\\\\=bar``) to avoid them to be passed in\n    as ``**configuration``.\n\n    Examples:\n    | Should Not Contain Any | ${string} | substring 1 | substring 2 |\n    | Should Not Contain Any | ${list}   | item 1 | item 2 | item 3 |\n    | Should Not Contain Any | ${list}   | item 1 | item 2 | item 3 | ignore_case=True |\n    | Should Not Contain Any | ${list}   | @{items} | msg=Custom message | values=False |\n    \"\"\"\n    msg = configuration.pop('msg', None)\n    values = configuration.pop('values', True)\n    ignore_case = is_truthy(configuration.pop('ignore_case', False))\n    strip_spaces = configuration.pop('strip_spaces', False)\n    collapse_spaces = is_truthy(configuration.pop('collapse_spaces', False))\n    if configuration:\n        raise RuntimeError(f\"Unsupported configuration parameter{s(configuration)}: \"\n                           f\"{seq2str(sorted(configuration))}.\")\n    if not items:\n        raise RuntimeError('One or more items required.')\n    orig_container = container\n    if ignore_case:\n        items = [x.casefold() if is_string(x) else x for x in items]\n        if is_string(container):\n            container = container.casefold()\n        elif is_list_like(container):\n            container = set(x.casefold() if is_string(x) else x for x in container)\n    if strip_spaces:\n        items = [self._strip_spaces(x, strip_spaces) for x in items]\n        if is_string(container):\n            container = self._strip_spaces(container, strip_spaces)\n        elif is_list_like(container):\n            container = set(self._strip_spaces(x, strip_spaces) for x in container)\n    if collapse_spaces:\n        items = [self._collapse_spaces(x) for x in items]\n        if is_string(container):\n            container = self._collapse_spaces(container)\n        elif is_list_like(container):\n            container = set(self._collapse_spaces(x) for x in container)\n    if any(item in container for item in items):\n        msg = self._get_string_msg(orig_container,\n                                   seq2str(items, lastsep=' or '),\n                                   msg, values,\n                                   'contains one or more of',\n                                   quote_item2=False)\n        raise AssertionError(msg)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_contain_x_times","title":"should_contain_x_times","text":"<pre><code>should_contain_x_times(\n    container,\n    item,\n    count,\n    msg=None,\n    ignore_case=False,\n    strip_spaces=False,\n    collapse_spaces=False,\n)\n</code></pre> <p>Fails if <code>container</code> does not contain <code>item</code> <code>count</code> times.</p> <p>Works with strings, lists and all objects that <code>Get Count</code> works with. The default error message can be overridden with <code>msg</code> and the actual count is always logged.</p> <p>If <code>ignore_case</code> is given a true value (see <code>Boolean arguments</code>) and compared items are strings, it indicates that comparison should be case-insensitive. If the <code>container</code> is a list-like object, string items in it are compared case-insensitively.</p> <p>If <code>strip_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done without leading and trailing spaces. If <code>strip_spaces</code> is given a string value <code>LEADING</code> or <code>TRAILING</code> (case-insensitive), the comparison is done without leading or trailing spaces, respectively.</p> <p>If <code>collapse_spaces</code> is given a true value (see <code>Boolean arguments</code>) and both arguments are strings, the comparison is done with all white spaces replaced by a single space character.</p> <p>Examples: | Should Contain X Times | ${output}    | hello | 2 | | Should Contain X Times | ${some list} | value | 3 | ignore_case=True |</p> <p><code>strip_spaces</code> is new in Robot Framework 4.0 and <code>collapse_spaces</code> is new in Robot Framework 4.1.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_contain_x_times(self, container, item, count, msg=None,\n                           ignore_case=False, strip_spaces=False,\n                           collapse_spaces=False):\n    \"\"\"Fails if ``container`` does not contain ``item`` ``count`` times.\n\n    Works with strings, lists and all objects that `Get Count` works\n    with. The default error message can be overridden with ``msg`` and\n    the actual count is always logged.\n\n    If ``ignore_case`` is given a true value (see `Boolean arguments`) and\n    compared items are strings, it indicates that comparison should be\n    case-insensitive. If the ``container`` is a list-like object, string\n    items in it are compared case-insensitively.\n\n    If ``strip_spaces`` is given a true value (see `Boolean arguments`)\n    and both arguments are strings, the comparison is done without leading\n    and trailing spaces. If ``strip_spaces`` is given a string value\n    ``LEADING`` or ``TRAILING`` (case-insensitive), the comparison is done\n    without leading or trailing spaces, respectively.\n\n    If ``collapse_spaces`` is given a true value (see `Boolean arguments`) and both\n    arguments are strings, the comparison is done with all white spaces replaced by\n    a single space character.\n\n    Examples:\n    | Should Contain X Times | ${output}    | hello | 2 |\n    | Should Contain X Times | ${some list} | value | 3 | ignore_case=True |\n\n    ``strip_spaces`` is new in Robot Framework 4.0 and ``collapse_spaces`` is new\n    in Robot Framework 4.1.\n    \"\"\"\n    count = self._convert_to_integer(count)\n    orig_container = container\n    if is_string(item):\n        if ignore_case:\n            item = item.casefold()\n            if is_string(container):\n                container = container.casefold()\n            elif is_list_like(container):\n                container = [x.casefold() if is_string(x) else x for x in container]\n        if strip_spaces:\n            item = self._strip_spaces(item, strip_spaces)\n            if is_string(container):\n                container = self._strip_spaces(container, strip_spaces)\n            elif is_list_like(container):\n                container = [self._strip_spaces(x, strip_spaces) for x in container]\n        if collapse_spaces:\n            item = self._collapse_spaces(item)\n            if is_string(container):\n                container = self._collapse_spaces(container)\n            elif is_list_like(container):\n                container = [self._collapse_spaces(x) for x in container]\n    x = self.get_count(container, item)\n    if not msg:\n        msg = (f\"{orig_container!r} contains '{item}' {x} time{s(x)}, \"\n               f\"not {count} time{s(count)}.\")\n    self.should_be_equal_as_integers(x, count, msg, values=False)\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.get_count","title":"get_count","text":"<pre><code>get_count(container, item)\n</code></pre> <p>Returns and logs how many times <code>item</code> is found from <code>container</code>.</p> <p>This keyword works with Python strings and lists and all objects that either have <code>count</code> method or can be converted to Python lists.</p> <p>Example: | ${count} = | Get Count | ${some item} | interesting value | | Should Be True | 5 &lt; ${count} &lt; 10 |</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def get_count(self, container, item):\n    \"\"\"Returns and logs how many times ``item`` is found from ``container``.\n\n    This keyword works with Python strings and lists and all objects\n    that either have ``count`` method or can be converted to Python lists.\n\n    Example:\n    | ${count} = | Get Count | ${some item} | interesting value |\n    | Should Be True | 5 &lt; ${count} &lt; 10 |\n    \"\"\"\n    if not hasattr(container, 'count'):\n        try:\n            container = list(container)\n        except:\n            raise RuntimeError(f\"Converting '{container}' to list failed: \"\n                               f\"{get_error_message()}\")\n    count = container.count(item)\n    self.log(f'Item found from container {count} time{s(count)}.')\n    return count\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_match","title":"should_not_match","text":"<pre><code>should_not_match(\n    string,\n    pattern,\n    msg=None,\n    values=True,\n    ignore_case=False,\n)\n</code></pre> <p>Fails if the given <code>string</code> matches the given <code>pattern</code>.</p> <p>Pattern matching is similar as matching files in a shell with <code>*</code>, <code>?</code> and <code>[chars]</code> acting as wildcards. See the <code>Glob patterns</code> section for more information.</p> <p>If <code>ignore_case</code> is given a true value (see <code>Boolean arguments</code>), the comparison is case-insensitive.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>`values</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_match(self, string, pattern, msg=None, values=True,\n                     ignore_case=False):\n    \"\"\"Fails if the given ``string`` matches the given ``pattern``.\n\n    Pattern matching is similar as matching files in a shell with\n    ``*``, ``?`` and ``[chars]`` acting as wildcards. See the\n    `Glob patterns` section for more information.\n\n    If ``ignore_case`` is given a true value (see `Boolean arguments`),\n    the comparison is case-insensitive.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg`` and ``values`.\n    \"\"\"\n    if self._matches(string, pattern, caseless=ignore_case):\n        raise AssertionError(self._get_string_msg(string, pattern, msg,\n                                                  values, 'matches'))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_match","title":"should_match","text":"<pre><code>should_match(\n    string,\n    pattern,\n    msg=None,\n    values=True,\n    ignore_case=False,\n)\n</code></pre> <p>Fails if the given <code>string</code> does not match the given <code>pattern</code>.</p> <p>Pattern matching is similar as matching files in a shell with <code>*</code>, <code>?</code> and <code>[chars]</code> acting as wildcards. See the <code>Glob patterns</code> section for more information.</p> <p>If <code>ignore_case</code> is given a true value (see <code>Boolean arguments</code>) and compared items are strings, it indicates that comparison should be case-insensitive.</p> <p>See <code>Should Be Equal</code> for an explanation on how to override the default error message with <code>msg</code> and <code>values</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_match(self, string, pattern, msg=None, values=True,\n                 ignore_case=False):\n    \"\"\"Fails if the given ``string`` does not match the given ``pattern``.\n\n    Pattern matching is similar as matching files in a shell with\n    ``*``, ``?`` and ``[chars]`` acting as wildcards. See the\n    `Glob patterns` section for more information.\n\n    If ``ignore_case`` is given a true value (see `Boolean arguments`) and\n    compared items are strings, it indicates that comparison should be\n    case-insensitive.\n\n    See `Should Be Equal` for an explanation on how to override the default\n    error message with ``msg`` and ``values``.\n    \"\"\"\n    if not self._matches(string, pattern, caseless=ignore_case):\n        raise AssertionError(self._get_string_msg(string, pattern, msg,\n                                                  values, 'does not match'))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_match_regexp","title":"should_match_regexp","text":"<pre><code>should_match_regexp(\n    string, pattern, msg=None, values=True, flags=None\n)\n</code></pre> <p>Fails if <code>string</code> does not match <code>pattern</code> as a regular expression.</p> <p>See the <code>Regular expressions</code> section for more information about regular expressions and how to use then in Robot Framework test data.</p> <p>Notice that the given pattern does not need to match the whole string. For example, the pattern <code>ello</code> matches the string <code>Hello world!</code>. If a full match is needed, the <code>^</code> and <code>$</code> characters can be used to denote the beginning and end of the string, respectively. For example, <code>^ello$</code> only matches the exact string <code>ello</code>.</p> <p>Possible flags altering how the expression is parsed (e.g. <code>re.IGNORECASE</code>, <code>re.MULTILINE</code>) can be given using the <code>flags</code> argument (e.g. <code>flags=IGNORECASE | MULTILINE</code>) or embedded to the pattern (e.g. <code>(?im)pattern</code>).</p> <p>If this keyword passes, it returns the portion of the string that matched the pattern. Additionally, the possible captured groups are returned.</p> <p>See the <code>Should Be Equal</code> keyword for an explanation on how to override the default error message with the <code>msg</code> and <code>values</code> arguments.</p> <p>Examples: | Should Match Regexp | ${output} | \\d{6}   | # Output contains six numbers  | | Should Match Regexp | ${output} | ^\\d{6}$ | # Six numbers and nothing more | | ${ret} = | Should Match Regexp | Foo: 42 | foo: \\d+ | flags=IGNORECASE | | ${ret} = | Should Match Regexp | Foo: 42 | (?i)foo: \\d+ | | ${match} | ${group1} | ${group2} = | | ...      | Should Match Regexp | Bar: 43 | (Foo|Bar): (\\d+) | =&gt; | ${ret} = 'Foo: 42' | ${match} = 'Bar: 43' | ${group1} = 'Bar' | ${group2} = '43'</p> <p>The <code>flags</code> argument is new in Robot Framework 6.0.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_match_regexp(self, string, pattern, msg=None, values=True, flags=None):\n    \"\"\"Fails if ``string`` does not match ``pattern`` as a regular expression.\n\n    See the `Regular expressions` section for more information about\n    regular expressions and how to use then in Robot Framework test data.\n\n    Notice that the given pattern does not need to match the whole string.\n    For example, the pattern ``ello`` matches the string ``Hello world!``.\n    If a full match is needed, the ``^`` and ``$`` characters can be used\n    to denote the beginning and end of the string, respectively.\n    For example, ``^ello$`` only matches the exact string ``ello``.\n\n    Possible flags altering how the expression is parsed (e.g. ``re.IGNORECASE``,\n    ``re.MULTILINE``) can be given using the ``flags`` argument (e.g.\n    ``flags=IGNORECASE | MULTILINE``) or embedded to the pattern (e.g.\n    ``(?im)pattern``).\n\n    If this keyword passes, it returns the portion of the string that\n    matched the pattern. Additionally, the possible captured groups are\n    returned.\n\n    See the `Should Be Equal` keyword for an explanation on how to override\n    the default error message with the ``msg`` and ``values`` arguments.\n\n    Examples:\n    | Should Match Regexp | ${output} | \\\\\\\\d{6}   | # Output contains six numbers  |\n    | Should Match Regexp | ${output} | ^\\\\\\\\d{6}$ | # Six numbers and nothing more |\n    | ${ret} = | Should Match Regexp | Foo: 42 | foo: \\\\\\\\d+ | flags=IGNORECASE |\n    | ${ret} = | Should Match Regexp | Foo: 42 | (?i)foo: \\\\\\\\d+ |\n    | ${match} | ${group1} | ${group2} = |\n    | ...      | Should Match Regexp | Bar: 43 | (Foo|Bar): (\\\\\\\\d+) |\n    =&gt;\n    | ${ret} = 'Foo: 42'\n    | ${match} = 'Bar: 43'\n    | ${group1} = 'Bar'\n    | ${group2} = '43'\n\n    The ``flags`` argument is new in Robot Framework 6.0.\n    \"\"\"\n    res = re.search(pattern, string, flags=parse_re_flags(flags))\n    if res is None:\n        raise AssertionError(self._get_string_msg(string, pattern, msg,\n                                                  values, 'does not match'))\n    match = res.group(0)\n    groups = res.groups()\n    if groups:\n        return [match] + list(groups)\n    return match\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_match_regexp","title":"should_not_match_regexp","text":"<pre><code>should_not_match_regexp(\n    string, pattern, msg=None, values=True, flags=None\n)\n</code></pre> <p>Fails if <code>string</code> matches <code>pattern</code> as a regular expression.</p> <p>See <code>Should Match Regexp</code> for more information about arguments.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_match_regexp(self, string, pattern, msg=None, values=True, flags=None):\n    \"\"\"Fails if ``string`` matches ``pattern`` as a regular expression.\n\n    See `Should Match Regexp` for more information about arguments.\n    \"\"\"\n    if re.search(pattern, string, flags=parse_re_flags(flags)) is not None:\n        raise AssertionError(self._get_string_msg(string, pattern, msg,\n                                                  values, 'matches'))\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.get_length","title":"get_length","text":"<pre><code>get_length(item)\n</code></pre> <p>Returns and logs the length of the given item as an integer.</p> <p>The item can be anything that has a length, for example, a string, a list, or a mapping. The keyword first tries to get the length with the Python function <code>len</code>, which calls the  item's <code>__len__</code> method internally. If that fails, the keyword tries to call the item's possible <code>length</code> and <code>size</code> methods directly. The final attempt is trying to get the value of the item's <code>length</code> attribute. If all these attempts are unsuccessful, the keyword fails.</p> <p>Examples: | ${length} = | Get Length    | Hello, world! |        | | Should Be Equal As Integers | ${length}     | 13     | | @{list} =   | Create List   | Hello,        | world! | | ${length} = | Get Length    | ${list}       |        | | Should Be Equal As Integers | ${length}     | 2      |</p> <p>See also <code>Length Should Be</code>, <code>Should Be Empty</code> and <code>Should Not Be Empty</code>.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def get_length(self, item):\n    \"\"\"Returns and logs the length of the given item as an integer.\n\n    The item can be anything that has a length, for example, a string,\n    a list, or a mapping. The keyword first tries to get the length with\n    the Python function ``len``, which calls the  item's ``__len__`` method\n    internally. If that fails, the keyword tries to call the item's\n    possible ``length`` and ``size`` methods directly. The final attempt is\n    trying to get the value of the item's ``length`` attribute. If all\n    these attempts are unsuccessful, the keyword fails.\n\n    Examples:\n    | ${length} = | Get Length    | Hello, world! |        |\n    | Should Be Equal As Integers | ${length}     | 13     |\n    | @{list} =   | Create List   | Hello,        | world! |\n    | ${length} = | Get Length    | ${list}       |        |\n    | Should Be Equal As Integers | ${length}     | 2      |\n\n    See also `Length Should Be`, `Should Be Empty` and `Should Not Be\n    Empty`.\n    \"\"\"\n    length = self._get_length(item)\n    self.log(f'Length is {length}.')\n    return length\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.length_should_be","title":"length_should_be","text":"<pre><code>length_should_be(item, length, msg=None)\n</code></pre> <p>Verifies that the length of the given item is correct.</p> <p>The length of the item is got using the <code>Get Length</code> keyword. The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def length_should_be(self, item, length, msg=None):\n    \"\"\"Verifies that the length of the given item is correct.\n\n    The length of the item is got using the `Get Length` keyword. The\n    default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    length = self._convert_to_integer(length)\n    actual = self.get_length(item)\n    if actual != length:\n        raise AssertionError(msg or f\"Length of '{item}' should be {length} \"\n                                    f\"but is {actual}.\")\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_be_empty","title":"should_be_empty","text":"<pre><code>should_be_empty(item, msg=None)\n</code></pre> <p>Verifies that the given item is empty.</p> <p>The length of the item is got using the <code>Get Length</code> keyword. The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_be_empty(self, item, msg=None):\n    \"\"\"Verifies that the given item is empty.\n\n    The length of the item is got using the `Get Length` keyword. The\n    default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    if self.get_length(item) &gt; 0:\n        raise AssertionError(msg or f\"'{item}' should be empty.\")\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.BuiltIn.should_not_be_empty","title":"should_not_be_empty","text":"<pre><code>should_not_be_empty(item, msg=None)\n</code></pre> <p>Verifies that the given item is not empty.</p> <p>The length of the item is got using the <code>Get Length</code> keyword. The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def should_not_be_empty(self, item, msg=None):\n    \"\"\"Verifies that the given item is not empty.\n\n    The length of the item is got using the `Get Length` keyword. The\n    default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    if self.get_length(item) == 0:\n        raise AssertionError(msg or f\"'{item}' should not be empty.\")\n</code></pre>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.RobotNotRunningError","title":"RobotNotRunningError","text":"<p>               Bases: <code>AttributeError</code></p> <p>Used when something cannot be done because Robot is not running.</p> <p>Based on AttributeError to be backwards compatible with RF &lt; 2.8.5. May later be based directly on Exception, so new code should except this exception explicitly.</p>"},{"location":"api/robot/libraries/BuiltIn/#robot.libraries.BuiltIn.register_run_keyword","title":"register_run_keyword","text":"<pre><code>register_run_keyword(\n    library,\n    keyword,\n    args_to_process=0,\n    deprecation_warning=True,\n)\n</code></pre> <p>Tell Robot Framework that this keyword runs other keywords internally.</p> <p>NOTE: This API will change in the future. For more information see #2190.</p> <p>:param library: Name of the library the keyword belongs to. :param keyword: Name of the keyword itself. :param args_to_process: How many arguments to process normally before     passing them to the keyword. Other arguments are not touched at all. :param deprecation_warning: Set to ``False```to avoid the warning.</p> <p>Registered keywords are handled specially by Robot so that:</p> <ul> <li>Their arguments are not resolved normally (use <code>args_to_process</code>   to control that). This basically means not replacing variables or   handling escapes.</li> <li>They are not stopped by timeouts.</li> <li>If there are conflicts with keyword names, these keywords have   lower precedence than other keywords.</li> </ul> <p>Main use cases are:</p> <ul> <li>Library keyword is using <code>BuiltIn.run_keyword</code> internally to execute other   keywords. Registering the caller as a \"run keyword variant\" avoids variables   and escapes in arguments being resolved multiple times. All arguments passed   to <code>run_keyword</code> can and should be left unresolved.</li> <li>Keyword has some need to not resolve variables in arguments. This way   variable values are not logged anywhere by Robot automatically.</li> </ul> <p>As mentioned above, this API will likely be reimplemented in the future or there could be new API for library keywords to execute other keywords. External libraries can nevertheless use this API if they really need it and are aware of the possible breaking changes in the future.</p> <p>Examples::</p> <pre><code>from robot.libraries.BuiltIn import BuiltIn, register_run_keyword\n\ndef my_run_keyword(name, *args):\n    # do something\n    return BuiltIn().run_keyword(name, *args)\n\nregister_run_keyword(__name__, 'My Run Keyword')\n\n-------------\n\nfrom robot.libraries.BuiltIn import BuiltIn, register_run_keyword\n\nclass MyLibrary:\n    def my_run_keyword_if(self, expression, name, *args):\n        # Do something\n        if self._is_true(expression):\n            return BuiltIn().run_keyword(name, *args)\n\n# Process one argument normally to get `expression` resolved.\nregister_run_keyword('MyLibrary', 'my_run_keyword_if', args_to_process=1)\n</code></pre> Source code in <code>src/robot/libraries/BuiltIn.py</code> <pre><code>def register_run_keyword(library, keyword, args_to_process=0, deprecation_warning=True):\n    \"\"\"Tell Robot Framework that this keyword runs other keywords internally.\n\n    *NOTE:* This API will change in the future. For more information see\n    https://github.com/robotframework/robotframework/issues/2190.\n\n    :param library: Name of the library the keyword belongs to.\n    :param keyword: Name of the keyword itself.\n    :param args_to_process: How many arguments to process normally before\n        passing them to the keyword. Other arguments are not touched at all.\n    :param deprecation_warning: Set to ``False```to avoid the warning.\n\n    Registered keywords are handled specially by Robot so that:\n\n    - Their arguments are not resolved normally (use ``args_to_process``\n      to control that). This basically means not replacing variables or\n      handling escapes.\n    - They are not stopped by timeouts.\n    - If there are conflicts with keyword names, these keywords have\n      *lower* precedence than other keywords.\n\n    Main use cases are:\n\n    - Library keyword is using `BuiltIn.run_keyword` internally to execute other\n      keywords. Registering the caller as a \"run keyword variant\" avoids variables\n      and escapes in arguments being resolved multiple times. All arguments passed\n      to `run_keyword` can and should be left unresolved.\n    - Keyword has some need to not resolve variables in arguments. This way\n      variable values are not logged anywhere by Robot automatically.\n\n    As mentioned above, this API will likely be reimplemented in the future\n    or there could be new API for library keywords to execute other keywords.\n    External libraries can nevertheless use this API if they really need it and\n    are aware of the possible breaking changes in the future.\n\n    Examples::\n\n        from robot.libraries.BuiltIn import BuiltIn, register_run_keyword\n\n        def my_run_keyword(name, *args):\n            # do something\n            return BuiltIn().run_keyword(name, *args)\n\n        register_run_keyword(__name__, 'My Run Keyword')\n\n        -------------\n\n        from robot.libraries.BuiltIn import BuiltIn, register_run_keyword\n\n        class MyLibrary:\n            def my_run_keyword_if(self, expression, name, *args):\n                # Do something\n                if self._is_true(expression):\n                    return BuiltIn().run_keyword(name, *args)\n\n        # Process one argument normally to get `expression` resolved.\n        register_run_keyword('MyLibrary', 'my_run_keyword_if', args_to_process=1)\n    \"\"\"\n    RUN_KW_REGISTER.register_run_keyword(library, keyword, args_to_process,\n                                         deprecation_warning)\n</code></pre>"},{"location":"api/robot/libraries/Collections/","title":"robot.libraries.Collections","text":""},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections","title":"robot.libraries.Collections","text":""},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections","title":"Collections","text":"<p>               Bases: <code>_List</code>, <code>_Dictionary</code></p> <p>A library providing keywords for handling lists and dictionaries.</p> <p><code>Collections</code> is Robot Framework's standard library that provides a set of keywords for handling Python lists and dictionaries. This library has keywords, for example, for modifying and getting values from lists and dictionaries (e.g. <code>Append To List</code>, <code>Get From Dictionary</code>) and for verifying their contents (e.g. <code>Lists Should Be Equal</code>, <code>Dictionary Should Contain Value</code>).</p> <p>== Table of contents ==</p> <p>%TOC%</p> <p>= Related keywords in BuiltIn =</p> <p>Following keywords in the BuiltIn library can also be used with lists and dictionaries:</p> <p>| = Keyword Name =             | = Applicable With = | | <code>Create List</code>                | lists | | <code>Create Dictionary</code>          | dicts | | <code>Get Length</code>                 | both  | | <code>Length Should Be</code>           | both  | | <code>Should Be Empty</code>            | both  | | <code>Should Not Be Empty</code>        | both  | | <code>Should Contain</code>             | both  | | <code>Should Not Contain</code>         | both  | | <code>Should Contain X Times</code>     | lists | | <code>Should Not Contain X Times</code> | lists | | <code>Get Count</code>                  | lists |</p> <p>= Using with list-like and dictionary-like objects =</p> <p>List keywords that do not alter the given list can also be used with tuples, and to some extent also with other iterables. <code>Convert To List</code> can be used to convert tuples and other iterables to Python <code>list</code> objects.</p> <p>Similarly, dictionary keywords can, for most parts, be used with other mappings. <code>Convert To Dictionary</code> can be used if real Python <code>dict</code> objects are needed.</p> <p>= Ignore case =</p> <p>Various keywords support ignoring case in comparisons by using the optional <code>ignore_case</code> argument. Case-insensitivity can be enabled by using <code>ignore_case=True</code> (see <code>Boolean arguments</code>) and it works recursively. With dictionaries, it is also possible to use special values <code>keys</code> and <code>values</code> to normalize only keys or values, respectively. These options themselves are case-insensitive and also singular forms <code>key</code> and <code>value</code> are supported.</p> <p>If a dictionary contains keys that normalize to the same value, e.g. <code>{'a': 1, 'A': 2}</code>, normalizing keys causes an error.</p> <p>Examples: | <code>Lists Should Be Equal</code>        | ${list1} | ${list2} | ignore_case=True   | | <code>Dictionaries Should Be Equal</code> | ${dict1} | ${dict2} | ignore_case=values |</p> <p>Notice that some keywords accept also an older <code>case_insensitive</code> argument in addition to <code>ignore_case</code>. The latter is new in Robot Framework 7.0 and should be used unless there is a need to support older versions. The old argument is considered deprecated and will eventually be removed.</p> <p>= Boolean arguments =</p> <p>Some keywords accept arguments that are handled as Boolean values true or false. If such an argument is given as a string, it is considered false if it is an empty string or equal to <code>FALSE</code>, <code>NONE</code>, <code>NO</code>, <code>OFF</code> or <code>0</code>, case-insensitively. Keywords verifying something that allow dropping actual and expected values from the possible error message also consider string <code>no values</code> to be false. Other strings are considered true regardless their value, and other argument types are tested using the same [http://docs.python.org/library/stdtypes.html#truth|rules as in Python].</p> <p>| <code>Should Contain Match</code> | ${list} | ${pattern} | ignore_case=True  | | <code>Should Contain Match</code> | ${list} | ${pattern} | ignore_case=False | | <code>Lists Should Be Equal</code> | ${list1} | ${list2} | Custom error | no values |</p> <p>= Data in examples =</p> <p>List related keywords use variables in format <code>${Lx}</code> in their examples. They mean lists with as many alphabetic characters as specified by <code>x</code>. For example, <code>${L1}</code> means <code>['a']</code> and <code>${L3}</code> means <code>['a', 'b', 'c']</code>.</p> <p>Dictionary keywords use similar <code>${Dx}</code> variables. For example, <code>${D1}</code> means <code>{'a': 1}</code> and <code>${D3}</code> means <code>{'a': 1, 'b': 2, 'c': 3}</code>.</p>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.convert_to_dictionary","title":"convert_to_dictionary","text":"<pre><code>convert_to_dictionary(item)\n</code></pre> <p>Converts the given <code>item</code> to a Python <code>dict</code> type.</p> <p>Mainly useful for converting other mappings to normal dictionaries. This includes converting Robot Framework's own <code>DotDict</code> instances that it uses if variables are created using the <code>&amp;{var}</code> syntax.</p> <p>Use <code>Create Dictionary</code> from the BuiltIn library for constructing new dictionaries.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def convert_to_dictionary(self, item):\n    \"\"\"Converts the given ``item`` to a Python ``dict`` type.\n\n    Mainly useful for converting other mappings to normal dictionaries.\n    This includes converting Robot Framework's own ``DotDict`` instances\n    that it uses if variables are created using the ``&amp;{var}`` syntax.\n\n    Use `Create Dictionary` from the BuiltIn library for constructing new\n    dictionaries.\n    \"\"\"\n    return dict(item)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.set_to_dictionary","title":"set_to_dictionary","text":"<pre><code>set_to_dictionary(dictionary, *key_value_pairs, **items)\n</code></pre> <p>Adds the given <code>key_value_pairs</code> and/or <code>items</code> to the <code>dictionary</code>.</p> <p>If given items already exist in the dictionary, their values are updated.</p> <p>It is easiest to specify items using the <code>name=value</code> syntax: | Set To Dictionary | ${D1} | key=value | second=${2} | =&gt; | ${D1} = {'a': 1, 'key': 'value', 'second': 2}</p> <p>A limitation of the above syntax is that keys must be strings. That can be avoided by passing keys and values as separate arguments: | Set To Dictionary | ${D1} | key | value | ${2} | value 2 | =&gt; | ${D1} = {'a': 1, 'key': 'value', 2: 'value 2'}</p> <p>Starting from Robot Framework 6.1, it is also possible to use the native item assignment syntax. This is equivalent to the above: | ${D1}[key] =  | Set Variable | value | | ${D1}[${2}] = | Set Variable | value 2 |</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def set_to_dictionary(self, dictionary, *key_value_pairs, **items):\n    \"\"\"Adds the given ``key_value_pairs`` and/or ``items`` to the ``dictionary``.\n\n    If given items already exist in the dictionary, their values are updated.\n\n    It is easiest to specify items using the ``name=value`` syntax:\n    | Set To Dictionary | ${D1} | key=value | second=${2} |\n    =&gt;\n    | ${D1} = {'a': 1, 'key': 'value', 'second': 2}\n\n    A limitation of the above syntax is that keys must be strings.\n    That can be avoided by passing keys and values as separate arguments:\n    | Set To Dictionary | ${D1} | key | value | ${2} | value 2 |\n    =&gt;\n    | ${D1} = {'a': 1, 'key': 'value', 2: 'value 2'}\n\n    Starting from Robot Framework 6.1, it is also possible to use the native\n    item assignment syntax. This is equivalent to the above:\n    | ${D1}[key] =  | Set Variable | value |\n    | ${D1}[${2}] = | Set Variable | value 2 |\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    if len(key_value_pairs) % 2 != 0:\n        raise ValueError(\"Adding data to a dictionary failed. There \"\n                         \"should be even number of key-value-pairs.\")\n    for i in range(0, len(key_value_pairs), 2):\n        dictionary[key_value_pairs[i]] = key_value_pairs[i+1]\n    dictionary.update(items)\n    return dictionary\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.remove_from_dictionary","title":"remove_from_dictionary","text":"<pre><code>remove_from_dictionary(dictionary, *keys)\n</code></pre> <p>Removes the given <code>keys</code> from the <code>dictionary</code>.</p> <p>If the given <code>key</code> cannot be found from the <code>dictionary</code>, it is ignored.</p> <p>Example: | Remove From Dictionary | ${D3} | b | x | y | =&gt; | ${D3} = {'a': 1, 'c': 3}</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def remove_from_dictionary(self, dictionary, *keys):\n    \"\"\"Removes the given ``keys`` from the ``dictionary``.\n\n    If the given ``key`` cannot be found from the ``dictionary``, it\n    is ignored.\n\n    Example:\n    | Remove From Dictionary | ${D3} | b | x | y |\n    =&gt;\n    | ${D3} = {'a': 1, 'c': 3}\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    for key in keys:\n        if key in dictionary:\n            value = dictionary.pop(key)\n            logger.info(f\"Removed item with key '{key}' and value '{value}'.\")\n        else:\n            logger.info(f\"Key '{key}' not found.\")\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.pop_from_dictionary","title":"pop_from_dictionary","text":"<pre><code>pop_from_dictionary(dictionary, key, default=NOT_SET)\n</code></pre> <p>Pops the given <code>key</code> from the <code>dictionary</code> and returns its value.</p> <p>By default the keyword fails if the given <code>key</code> cannot be found from the <code>dictionary</code>. If optional <code>default</code> value is given, it will be returned instead of failing.</p> <p>Example: | ${val}= | Pop From Dictionary | ${D3} | b | =&gt; | ${val} = 2 | ${D3} = {'a': 1, 'c': 3}</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def pop_from_dictionary(self, dictionary, key, default=NOT_SET):\n    \"\"\"Pops the given ``key`` from the ``dictionary`` and returns its value.\n\n    By default the keyword fails if the given ``key`` cannot be found from\n    the ``dictionary``. If optional ``default`` value is given, it will be\n    returned instead of failing.\n\n    Example:\n    | ${val}= | Pop From Dictionary | ${D3} | b |\n    =&gt;\n    | ${val} = 2\n    | ${D3} = {'a': 1, 'c': 3}\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    if default is NOT_SET:\n        self.dictionary_should_contain_key(dictionary, key)\n        return dictionary.pop(key)\n    return dictionary.pop(key, default)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.keep_in_dictionary","title":"keep_in_dictionary","text":"<pre><code>keep_in_dictionary(dictionary, *keys)\n</code></pre> <p>Keeps the given <code>keys</code> in the <code>dictionary</code> and removes all other.</p> <p>If the given <code>key</code> cannot be found from the <code>dictionary</code>, it is ignored.</p> <p>Example: | Keep In Dictionary | ${D5} | b | x | d | =&gt; | ${D5} = {'b': 2, 'd': 4}</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def keep_in_dictionary(self, dictionary, *keys):\n    \"\"\"Keeps the given ``keys`` in the ``dictionary`` and removes all other.\n\n    If the given ``key`` cannot be found from the ``dictionary``, it\n    is ignored.\n\n    Example:\n    | Keep In Dictionary | ${D5} | b | x | d |\n    =&gt;\n    | ${D5} = {'b': 2, 'd': 4}\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    remove_keys = [k for k in dictionary if k not in keys]\n    self.remove_from_dictionary(dictionary, *remove_keys)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.copy_dictionary","title":"copy_dictionary","text":"<pre><code>copy_dictionary(dictionary, deepcopy=False)\n</code></pre> <p>Returns a copy of the given dictionary.</p> <p>By default, returns a new dictionary with same items as in the original. Set the <code>deepcopy</code> argument to a true value if also items should be copied.</p> <p>The given dictionary is never altered by this keyword.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def copy_dictionary(self, dictionary, deepcopy=False):\n    \"\"\"Returns a copy of the given dictionary.\n\n    By default, returns a new dictionary with same items as in the original.\n    Set the ``deepcopy`` argument to a true value if also items should\n    be copied.\n\n    The given dictionary is never altered by this keyword.\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    if deepcopy:\n        return copy.deepcopy(dictionary)\n    return dictionary.copy()\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.get_dictionary_keys","title":"get_dictionary_keys","text":"<pre><code>get_dictionary_keys(dictionary, sort_keys=True)\n</code></pre> <p>Returns keys of the given <code>dictionary</code> as a list.</p> <p>By default, keys are returned in sorted order (assuming they are sortable), but they can be returned in the original order by giving <code>sort_keys</code> a false value.</p> <p>The given <code>dictionary</code> is never altered by this keyword.</p> <p>Example: | ${sorted} =   | Get Dictionary Keys | ${D3} | | ${unsorted} = | Get Dictionary Keys | ${D3} | sort_keys=False |</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def get_dictionary_keys(self, dictionary, sort_keys=True):\n    \"\"\"Returns keys of the given ``dictionary`` as a list.\n\n    By default, keys are returned in sorted order (assuming they are\n    sortable), but they can be returned in the original order by giving\n    ``sort_keys`` a false value.\n\n    The given ``dictionary`` is never altered by this keyword.\n\n    Example:\n    | ${sorted} =   | Get Dictionary Keys | ${D3} |\n    | ${unsorted} = | Get Dictionary Keys | ${D3} | sort_keys=False |\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    if sort_keys:\n        try:\n            return sorted(dictionary)\n        except TypeError:\n            pass\n    return list(dictionary)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.get_dictionary_values","title":"get_dictionary_values","text":"<pre><code>get_dictionary_values(dictionary, sort_keys=True)\n</code></pre> <p>Returns values of the given <code>dictionary</code> as a list.</p> <p>Uses <code>Get Dictionary Keys</code> to get keys and then returns corresponding values. By default, keys are sorted and values returned in that order, but this can be changed by giving <code>sort_keys</code> a false value.</p> <p>The given <code>dictionary</code> is never altered by this keyword.</p> <p>Example: | ${sorted} =   | Get Dictionary Values | ${D3} | | ${unsorted} = | Get Dictionary Values | ${D3} | sort_keys=False |</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def get_dictionary_values(self, dictionary, sort_keys=True):\n    \"\"\"Returns values of the given ``dictionary`` as a list.\n\n    Uses `Get Dictionary Keys` to get keys and then returns corresponding\n    values. By default, keys are sorted and values returned in that order,\n    but this can be changed by giving ``sort_keys`` a false value.\n\n    The given ``dictionary`` is never altered by this keyword.\n\n    Example:\n    | ${sorted} =   | Get Dictionary Values | ${D3} |\n    | ${unsorted} = | Get Dictionary Values | ${D3} | sort_keys=False |\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    keys = self.get_dictionary_keys(dictionary, sort_keys=sort_keys)\n    return [dictionary[k] for k in keys]\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.get_dictionary_items","title":"get_dictionary_items","text":"<pre><code>get_dictionary_items(dictionary, sort_keys=True)\n</code></pre> <p>Returns items of the given <code>dictionary</code> as a list.</p> <p>Uses <code>Get Dictionary Keys</code> to get keys and then returns corresponding items. By default, keys are sorted and items returned in that order, but this can be changed by giving <code>sort_keys</code> a false value.</p> <p>Items are returned as a flat list so that first item is a key, second item is a corresponding value, third item is the second key, and so on.</p> <p>The given <code>dictionary</code> is never altered by this keyword.</p> <p>Example: | ${sorted} =   | Get Dictionary Items | ${D3} | | ${unsorted} = | Get Dictionary Items | ${D3} | sort_keys=False |</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def get_dictionary_items(self, dictionary, sort_keys=True):\n    \"\"\"Returns items of the given ``dictionary`` as a list.\n\n    Uses `Get Dictionary Keys` to get keys and then returns corresponding\n    items. By default, keys are sorted and items returned in that order,\n    but this can be changed by giving ``sort_keys`` a false value.\n\n    Items are returned as a flat list so that first item is a key,\n    second item is a corresponding value, third item is the second key,\n    and so on.\n\n    The given ``dictionary`` is never altered by this keyword.\n\n    Example:\n    | ${sorted} =   | Get Dictionary Items | ${D3} |\n    | ${unsorted} = | Get Dictionary Items | ${D3} | sort_keys=False |\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    keys = self.get_dictionary_keys(dictionary, sort_keys=sort_keys)\n    return [i for key in keys for i in (key, dictionary[key])]\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.get_from_dictionary","title":"get_from_dictionary","text":"<pre><code>get_from_dictionary(dictionary, key, default=NOT_SET)\n</code></pre> <p>Returns a value from the given <code>dictionary</code> based on the given <code>key</code>.</p> <p>If the given <code>key</code> cannot be found from the <code>dictionary</code>, this keyword fails. If optional <code>default</code> value is given, it will be returned instead of failing.</p> <p>The given dictionary is never altered by this keyword.</p> <p>Example: | ${value} = | Get From Dictionary | ${D3} | b | =&gt; | ${value} = 2</p> <p>Support for <code>default</code> is new in Robot Framework 6.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def get_from_dictionary(self, dictionary, key, default=NOT_SET):\n    \"\"\"Returns a value from the given ``dictionary`` based on the given ``key``.\n\n    If the given ``key`` cannot be found from the ``dictionary``, this\n    keyword fails. If optional ``default`` value is given, it will be\n    returned instead of failing.\n\n    The given dictionary is never altered by this keyword.\n\n    Example:\n    | ${value} = | Get From Dictionary | ${D3} | b |\n    =&gt;\n    | ${value} = 2\n\n    Support for ``default`` is new in Robot Framework 6.0.\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    try:\n        return dictionary[key]\n    except KeyError:\n        if default is not NOT_SET:\n            return default\n        raise RuntimeError(f\"Dictionary does not contain key '{key}'.\")\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.dictionary_should_contain_key","title":"dictionary_should_contain_key","text":"<pre><code>dictionary_should_contain_key(\n    dictionary, key, msg=None, ignore_case=False\n)\n</code></pre> <p>Fails if <code>key</code> is not found from <code>dictionary</code>.</p> <p>Use the <code>msg</code> argument to override the default error message.</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def dictionary_should_contain_key(self, dictionary, key, msg=None,\n                                  ignore_case=False):\n    \"\"\"Fails if ``key`` is not found from ``dictionary``.\n\n    Use the ``msg`` argument to override the default error message.\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    norm = Normalizer(ignore_case)\n    _verify_condition(\n        norm.normalize_key(key) in norm.normalize(dictionary),\n        f\"Dictionary does not contain key '{key}'.\", msg\n    )\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.dictionary_should_not_contain_key","title":"dictionary_should_not_contain_key","text":"<pre><code>dictionary_should_not_contain_key(\n    dictionary, key, msg=None, ignore_case=False\n)\n</code></pre> <p>Fails if <code>key</code> is found from <code>dictionary</code>.</p> <p>Use the <code>msg</code> argument to override the default error message.</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def dictionary_should_not_contain_key(self, dictionary, key, msg=None,\n                                      ignore_case=False):\n    \"\"\"Fails if ``key`` is found from ``dictionary``.\n\n    Use the ``msg`` argument to override the default error message.\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    norm = Normalizer(ignore_case)\n    _verify_condition(\n        norm.normalize_key(key) not in norm.normalize(dictionary),\n        f\"Dictionary contains key '{key}'.\", msg\n    )\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.dictionary_should_contain_item","title":"dictionary_should_contain_item","text":"<pre><code>dictionary_should_contain_item(\n    dictionary, key, value, msg=None, ignore_case=False\n)\n</code></pre> <p>An item of <code>key</code> / <code>value</code> must be found in a <code>dictionary</code>.</p> <p>Use the <code>msg</code> argument to override the default error message.</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def dictionary_should_contain_item(self, dictionary, key, value, msg=None,\n                                   ignore_case=False):\n    \"\"\"An item of ``key`` / ``value`` must be found in a ``dictionary``.\n\n    Use the ``msg`` argument to override the default error message.\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    self.dictionary_should_contain_key(dictionary, key, msg, ignore_case)\n    norm = Normalizer(ignore_case)\n    assert_equal(\n        norm.normalize(dictionary)[norm.normalize_key(key)],\n        norm.normalize_value(value),\n        msg or f\"Value of dictionary key '{key}' does not match\", values=not msg\n    )\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.dictionary_should_contain_value","title":"dictionary_should_contain_value","text":"<pre><code>dictionary_should_contain_value(\n    dictionary, value, msg=None, ignore_case=False\n)\n</code></pre> <p>Fails if <code>value</code> is not found from <code>dictionary</code>.</p> <p>Use the <code>msg</code> argument to override the default error message.</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def dictionary_should_contain_value(self, dictionary, value, msg=None,\n                                    ignore_case=False):\n    \"\"\"Fails if ``value`` is not found from ``dictionary``.\n\n    Use the ``msg`` argument to override the default error message.\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    norm = Normalizer(ignore_case)\n    _verify_condition(\n        norm.normalize_value(value) in norm.normalize(dictionary).values(),\n        f\"Dictionary does not contain value '{value}'.\", msg\n    )\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.dictionary_should_not_contain_value","title":"dictionary_should_not_contain_value","text":"<pre><code>dictionary_should_not_contain_value(\n    dictionary, value, msg=None, ignore_case=False\n)\n</code></pre> <p>Fails if <code>value</code> is found from <code>dictionary</code>.</p> <p>Use the <code>msg</code> argument to override the default error message.</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def dictionary_should_not_contain_value(self, dictionary, value, msg=None,\n                                        ignore_case=False):\n    \"\"\"Fails if ``value`` is found from ``dictionary``.\n\n    Use the ``msg`` argument to override the default error message.\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    norm = Normalizer(ignore_case)\n    _verify_condition(\n        norm.normalize_value(value) not in norm.normalize(dictionary).values(),\n        f\"Dictionary contains value '{value}'.\", msg\n    )\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.dictionaries_should_be_equal","title":"dictionaries_should_be_equal","text":"<pre><code>dictionaries_should_be_equal(\n    dict1,\n    dict2,\n    msg=None,\n    values=True,\n    ignore_keys=None,\n    ignore_case=False,\n)\n</code></pre> <p>Fails if the given dictionaries are not equal.</p> <p>First the equality of dictionaries' keys is checked and after that all the key value pairs. If there are differences between the values, those are listed in the error message. The types of the dictionaries do not need to be same.</p> <p><code>ignore_keys</code> can be used to provide a list of keys to ignore in the comparison. It can be an actual list or a Python list literal. This option is new in Robot Framework 6.1. It works recursively with nested dictionaries starting from Robot Framework 7.0.</p> <p>Examples: | Dictionaries Should Be Equal | ${dict} | ${expected} | | Dictionaries Should Be Equal | ${dict} | ${expected} | ignore_keys=${ignored} | | Dictionaries Should Be Equal | ${dict} | ${expected} | ignore_keys=['key1', 'key2'] |</p> <p>See <code>Lists Should Be Equal</code> for more information about configuring the error message with <code>msg</code> and <code>values</code> arguments.</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def dictionaries_should_be_equal(self, dict1, dict2, msg=None, values=True,\n                                 ignore_keys=None, ignore_case=False):\n    \"\"\"Fails if the given dictionaries are not equal.\n\n    First the equality of dictionaries' keys is checked and after that all\n    the key value pairs. If there are differences between the values, those\n    are listed in the error message. The types of the dictionaries do not\n    need to be same.\n\n    ``ignore_keys`` can be used to provide a list of keys to ignore in the\n    comparison. It can be an actual list or a Python list literal. This\n    option is new in Robot Framework 6.1. It works recursively with nested\n    dictionaries starting from Robot Framework 7.0.\n\n    Examples:\n    | Dictionaries Should Be Equal | ${dict} | ${expected} |\n    | Dictionaries Should Be Equal | ${dict} | ${expected} | ignore_keys=${ignored} |\n    | Dictionaries Should Be Equal | ${dict} | ${expected} | ignore_keys=['key1', 'key2'] |\n\n    See `Lists Should Be Equal` for more information about configuring\n    the error message with ``msg`` and ``values`` arguments.\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_dictionary(dict1, dict2)\n    normalizer = Normalizer(ignore_case, ignore_keys=ignore_keys)\n    dict1 = normalizer.normalize(dict1)\n    dict2 = normalizer.normalize(dict2)\n    self._should_have_same_keys(dict1, dict2, msg, values)\n    self._should_have_same_values(dict1, dict2, msg, values)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.dictionary_should_contain_sub_dictionary","title":"dictionary_should_contain_sub_dictionary","text":"<pre><code>dictionary_should_contain_sub_dictionary(\n    dict1, dict2, msg=None, values=True, ignore_case=False\n)\n</code></pre> <p>Fails unless all items in <code>dict2</code> are found from <code>dict1</code>.</p> <p>See <code>Lists Should Be Equal</code> for more information about configuring the error message with <code>msg</code> and <code>values</code> arguments.</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def dictionary_should_contain_sub_dictionary(self, dict1, dict2, msg=None,\n                                             values=True, ignore_case=False):\n    \"\"\"Fails unless all items in ``dict2`` are found from ``dict1``.\n\n    See `Lists Should Be Equal` for more information about configuring\n    the error message with ``msg`` and ``values`` arguments.\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_dictionary(dict1, dict2)\n    normalizer = Normalizer(ignore_case)\n    dict1 = normalizer.normalize(dict1)\n    dict2 = normalizer.normalize(dict2)\n    self._should_have_same_keys(dict1, dict2, msg, values, validate_both=False)\n    self._should_have_same_values(dict1, dict2, msg, values)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.log_dictionary","title":"log_dictionary","text":"<pre><code>log_dictionary(dictionary, level='INFO')\n</code></pre> <p>Logs the size and contents of the <code>dictionary</code> using given <code>level</code>.</p> <p>Valid levels are TRACE, DEBUG, INFO (default), and WARN.</p> <p>If you only want to log the size, use keyword <code>Get Length</code> from the BuiltIn library.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def log_dictionary(self, dictionary, level='INFO'):\n    \"\"\"Logs the size and contents of the ``dictionary`` using given ``level``.\n\n    Valid levels are TRACE, DEBUG, INFO (default), and WARN.\n\n    If you only want to log the size, use keyword `Get Length` from\n    the BuiltIn library.\n    \"\"\"\n    self._validate_dictionary(dictionary)\n    logger.write('\\n'.join(self._log_dictionary(dictionary)), level)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.convert_to_list","title":"convert_to_list","text":"<pre><code>convert_to_list(item)\n</code></pre> <p>Converts the given <code>item</code> to a Python <code>list</code> type.</p> <p>Mainly useful for converting tuples and other iterable to lists. Use <code>Create List</code> from the BuiltIn library for constructing new lists.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def convert_to_list(self, item):\n    \"\"\"Converts the given ``item`` to a Python ``list`` type.\n\n    Mainly useful for converting tuples and other iterable to lists.\n    Use `Create List` from the BuiltIn library for constructing new lists.\n    \"\"\"\n    return list(item)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.append_to_list","title":"append_to_list","text":"<pre><code>append_to_list(list_, *values)\n</code></pre> <p>Adds <code>values</code> to the end of <code>list</code>.</p> <p>Example: | Append To List | ${L1} | xxx |   |   | | Append To List | ${L2} | x   | y | z | =&gt; | ${L1} = ['a', 'xxx'] | ${L2} = ['a', 'b', 'x', 'y', 'z']</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def append_to_list(self, list_, *values):\n    \"\"\"Adds ``values`` to the end of ``list``.\n\n    Example:\n    | Append To List | ${L1} | xxx |   |   |\n    | Append To List | ${L2} | x   | y | z |\n    =&gt;\n    | ${L1} = ['a', 'xxx']\n    | ${L2} = ['a', 'b', 'x', 'y', 'z']\n    \"\"\"\n    self._validate_list(list_)\n    for value in values:\n        list_.append(value)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.insert_into_list","title":"insert_into_list","text":"<pre><code>insert_into_list(list_, index, value)\n</code></pre> <p>Inserts <code>value</code> into <code>list</code> to the position specified with <code>index</code>.</p> <p>Index <code>0</code> adds the value into the first position, <code>1</code> to the second, and so on. Inserting from right works with negative indices so that <code>-1</code> is the second last position, <code>-2</code> third last, and so on. Use <code>Append To List</code> to add items to the end of the list.</p> <p>If the absolute value of the index is greater than the length of the list, the value is added at the end (positive index) or the beginning (negative index). An index can be given either as an integer or a string that can be converted to an integer.</p> <p>Example: | Insert Into List | ${L1} | 0     | xxx | | Insert Into List | ${L2} | ${-1} | xxx | =&gt; | ${L1} = ['xxx', 'a'] | ${L2} = ['a', 'xxx', 'b']</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def insert_into_list(self, list_, index, value):\n    \"\"\"Inserts ``value`` into ``list`` to the position specified with ``index``.\n\n    Index ``0`` adds the value into the first position, ``1`` to the second,\n    and so on. Inserting from right works with negative indices so that\n    ``-1`` is the second last position, ``-2`` third last, and so on. Use\n    `Append To List` to add items to the end of the list.\n\n    If the absolute value of the index is greater than\n    the length of the list, the value is added at the end\n    (positive index) or the beginning (negative index). An index\n    can be given either as an integer or a string that can be\n    converted to an integer.\n\n    Example:\n    | Insert Into List | ${L1} | 0     | xxx |\n    | Insert Into List | ${L2} | ${-1} | xxx |\n    =&gt;\n    | ${L1} = ['xxx', 'a']\n    | ${L2} = ['a', 'xxx', 'b']\n    \"\"\"\n    self._validate_list(list_)\n    list_.insert(self._index_to_int(index), value)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.combine_lists","title":"combine_lists","text":"<pre><code>combine_lists(*lists)\n</code></pre> <p>Combines the given <code>lists</code> together and returns the result.</p> <p>The given lists are not altered by this keyword.</p> <p>Example: | ${x} = | Combine Lists | ${L1} | ${L2} |       | | ${y} = | Combine Lists | ${L1} | ${L2} | ${L1} | =&gt; | ${x} = ['a', 'a', 'b'] | ${y} = ['a', 'a', 'b', 'a'] | ${L1} and ${L2} are not changed.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def combine_lists(self, *lists):\n    \"\"\"Combines the given ``lists`` together and returns the result.\n\n    The given lists are not altered by this keyword.\n\n    Example:\n    | ${x} = | Combine Lists | ${L1} | ${L2} |       |\n    | ${y} = | Combine Lists | ${L1} | ${L2} | ${L1} |\n    =&gt;\n    | ${x} = ['a', 'a', 'b']\n    | ${y} = ['a', 'a', 'b', 'a']\n    | ${L1} and ${L2} are not changed.\n    \"\"\"\n    self._validate_lists(*lists)\n    return list(chain.from_iterable(lists))\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.set_list_value","title":"set_list_value","text":"<pre><code>set_list_value(list_, index, value)\n</code></pre> <p>Sets the value of <code>list</code> specified by <code>index</code> to the given <code>value</code>.</p> <p>Index <code>0</code> means the first position, <code>1</code> the second and so on. Similarly, <code>-1</code> is the last position, <code>-2</code> second last, and so on. Using an index that does not exist on the list causes an error. The index can be either an integer or a string that can be converted to an integer.</p> <p>Example: | Set List Value | ${L3} | 1  | xxx | | Set List Value | ${L3} | -1 | yyy | =&gt; | ${L3} = ['a', 'xxx', 'yyy']</p> <p>Starting from Robot Framework 6.1, it is also possible to use the native item assignment syntax. This is equivalent to the above: | ${L3}[1] =  | Set Variable | xxx | | ${L3}[-1] = | Set Variable | yyy |</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def set_list_value(self, list_, index, value):\n    \"\"\"Sets the value of ``list`` specified by ``index`` to the given ``value``.\n\n    Index ``0`` means the first position, ``1`` the second and so on.\n    Similarly, ``-1`` is the last position, ``-2`` second last, and so on.\n    Using an index that does not exist on the list causes an error.\n    The index can be either an integer or a string that can be converted to\n    an integer.\n\n    Example:\n    | Set List Value | ${L3} | 1  | xxx |\n    | Set List Value | ${L3} | -1 | yyy |\n    =&gt;\n    | ${L3} = ['a', 'xxx', 'yyy']\n\n    Starting from Robot Framework 6.1, it is also possible to use the native\n    item assignment syntax. This is equivalent to the above:\n    | ${L3}[1] =  | Set Variable | xxx |\n    | ${L3}[-1] = | Set Variable | yyy |\n    \"\"\"\n    self._validate_list(list_)\n    try:\n        list_[self._index_to_int(index)] = value\n    except IndexError:\n        self._index_error(list_, index)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.remove_values_from_list","title":"remove_values_from_list","text":"<pre><code>remove_values_from_list(list_, *values)\n</code></pre> <p>Removes all occurrences of given <code>values</code> from <code>list</code>.</p> <p>It is not an error if a value does not exist in the list at all.</p> <p>Example: | Remove Values From List | ${L4} | a | c | e | f | =&gt; | ${L4} = ['b', 'd']</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def remove_values_from_list(self, list_, *values):\n    \"\"\"Removes all occurrences of given ``values`` from ``list``.\n\n    It is not an error if a value does not exist in the list at all.\n\n    Example:\n    | Remove Values From List | ${L4} | a | c | e | f |\n    =&gt;\n    | ${L4} = ['b', 'd']\n    \"\"\"\n    self._validate_list(list_)\n    for value in values:\n        while value in list_:\n            list_.remove(value)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.remove_from_list","title":"remove_from_list","text":"<pre><code>remove_from_list(list_, index)\n</code></pre> <p>Removes and returns the value specified with an <code>index</code> from <code>list</code>.</p> <p>Index <code>0</code> means the first position, <code>1</code> the second and so on. Similarly, <code>-1</code> is the last position, <code>-2</code> the second last, and so on. Using an index that does not exist on the list causes an error. The index can be either an integer or a string that can be converted to an integer.</p> <p>Example: | ${x} = | Remove From List | ${L2} | 0 | =&gt; | ${x} = 'a' | ${L2} = ['b']</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def remove_from_list(self, list_, index):\n    \"\"\"Removes and returns the value specified with an ``index`` from ``list``.\n\n    Index ``0`` means the first position, ``1`` the second and so on.\n    Similarly, ``-1`` is the last position, ``-2`` the second last, and so on.\n    Using an index that does not exist on the list causes an error.\n    The index can be either an integer or a string that can be converted\n    to an integer.\n\n    Example:\n    | ${x} = | Remove From List | ${L2} | 0 |\n    =&gt;\n    | ${x} = 'a'\n    | ${L2} = ['b']\n    \"\"\"\n    self._validate_list(list_)\n    try:\n        return list_.pop(self._index_to_int(index))\n    except IndexError:\n        self._index_error(list_, index)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.remove_duplicates","title":"remove_duplicates","text":"<pre><code>remove_duplicates(list_)\n</code></pre> <p>Returns a list without duplicates based on the given <code>list</code>.</p> <p>Creates and returns a new list that contains all items in the given list so that one item can appear only once. Order of the items in the new list is the same as in the original except for missing duplicates. Number of the removed duplicates is logged.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def remove_duplicates(self, list_):\n    \"\"\"Returns a list without duplicates based on the given ``list``.\n\n    Creates and returns a new list that contains all items in the given\n    list so that one item can appear only once. Order of the items in\n    the new list is the same as in the original except for missing\n    duplicates. Number of the removed duplicates is logged.\n    \"\"\"\n    self._validate_list(list_)\n    ret = []\n    for item in list_:\n        if item not in ret:\n            ret.append(item)\n    removed = len(list_) - len(ret)\n    logger.info(f'{removed} duplicate{s(removed)} removed.')\n    return ret\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.get_from_list","title":"get_from_list","text":"<pre><code>get_from_list(list_, index)\n</code></pre> <p>Returns the value specified with an <code>index</code> from <code>list</code>.</p> <p>The given list is never altered by this keyword.</p> <p>Index <code>0</code> means the first position, <code>1</code> the second, and so on. Similarly, <code>-1</code> is the last position, <code>-2</code> the second last, and so on. Using an index that does not exist on the list causes an error. The index can be either an integer or a string that can be converted to an integer.</p> <p>Examples (including Python equivalents in comments): | ${x} = | Get From List | ${L5} | 0  | # L5[0]  | | ${y} = | Get From List | ${L5} | -2 | # L5[-2] | =&gt; | ${x} = 'a' | ${y} = 'd' | ${L5} is not changed</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def get_from_list(self, list_, index):\n    \"\"\"Returns the value specified with an ``index`` from ``list``.\n\n    The given list is never altered by this keyword.\n\n    Index ``0`` means the first position, ``1`` the second, and so on.\n    Similarly, ``-1`` is the last position, ``-2`` the second last, and so on.\n    Using an index that does not exist on the list causes an error.\n    The index can be either an integer or a string that can be converted\n    to an integer.\n\n    Examples (including Python equivalents in comments):\n    | ${x} = | Get From List | ${L5} | 0  | # L5[0]  |\n    | ${y} = | Get From List | ${L5} | -2 | # L5[-2] |\n    =&gt;\n    | ${x} = 'a'\n    | ${y} = 'd'\n    | ${L5} is not changed\n    \"\"\"\n    self._validate_list(list_)\n    try:\n        return list_[self._index_to_int(index)]\n    except IndexError:\n        self._index_error(list_, index)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.get_slice_from_list","title":"get_slice_from_list","text":"<pre><code>get_slice_from_list(list_, start=0, end=None)\n</code></pre> <p>Returns a slice of the given list between <code>start</code> and <code>end</code> indexes.</p> <p>The given list is never altered by this keyword.</p> <p>If both <code>start</code> and <code>end</code> are given, a sublist containing values from <code>start</code> to <code>end</code> is returned. This is the same as <code>list[start:end]</code> in Python. To get all items from the beginning, use 0 as the start value, and to get all items until and including the end, use <code>None</code> (default) as the end value.</p> <p>Using <code>start</code> or <code>end</code> not found on the list is the same as using the largest (or smallest) available index.</p> <p>Examples (incl. Python equivalents in comments): | ${x} = | Get Slice From List | ${L5} | 2      | 4 | # L5[2:4]    | | ${y} = | Get Slice From List | ${L5} | 1      |   | # L5[1:None] | | ${z} = | Get Slice From List | ${L5} | end=-2 |   | # L5[0:-2]   | =&gt; | ${x} = ['c', 'd'] | ${y} = ['b', 'c', 'd', 'e'] | ${z} = ['a', 'b', 'c'] | ${L5} is not changed</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def get_slice_from_list(self, list_, start=0, end=None):\n    \"\"\"Returns a slice of the given list between ``start`` and ``end`` indexes.\n\n    The given list is never altered by this keyword.\n\n    If both ``start`` and ``end`` are given, a sublist containing values\n    from ``start`` to ``end`` is returned. This is the same as\n    ``list[start:end]`` in Python. To get all items from the beginning,\n    use 0 as the start value, and to get all items until and including\n    the end, use ``None`` (default) as the end value.\n\n    Using ``start`` or ``end`` not found on the list is the same as using\n    the largest (or smallest) available index.\n\n    Examples (incl. Python equivalents in comments):\n    | ${x} = | Get Slice From List | ${L5} | 2      | 4 | # L5[2:4]    |\n    | ${y} = | Get Slice From List | ${L5} | 1      |   | # L5[1:None] |\n    | ${z} = | Get Slice From List | ${L5} | end=-2 |   | # L5[0:-2]   |\n    =&gt;\n    | ${x} = ['c', 'd']\n    | ${y} = ['b', 'c', 'd', 'e']\n    | ${z} = ['a', 'b', 'c']\n    | ${L5} is not changed\n    \"\"\"\n    self._validate_list(list_)\n    start = self._index_to_int(start, True)\n    if end is not None:\n        end = self._index_to_int(end)\n    return list_[start:end]\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.count_values_in_list","title":"count_values_in_list","text":"<pre><code>count_values_in_list(list_, value, start=0, end=None)\n</code></pre> <p>Returns the number of occurrences of the given <code>value</code> in <code>list</code>.</p> <p>The search can be narrowed to the selected sublist by the <code>start</code> and <code>end</code> indexes having the same semantics as with <code>Get Slice From List</code> keyword. The given list is never altered by this keyword.</p> <p>Example: | ${x} = | Count Values In List | ${L3} | b | =&gt; | ${x} = 1 | ${L3} is not changed</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def count_values_in_list(self, list_, value, start=0, end=None):\n    \"\"\"Returns the number of occurrences of the given ``value`` in ``list``.\n\n    The search can be narrowed to the selected sublist by the ``start`` and\n    ``end`` indexes having the same semantics as with `Get Slice From List`\n    keyword. The given list is never altered by this keyword.\n\n    Example:\n    | ${x} = | Count Values In List | ${L3} | b |\n    =&gt;\n    | ${x} = 1\n    | ${L3} is not changed\n    \"\"\"\n    self._validate_list(list_)\n    return self.get_slice_from_list(list_, start, end).count(value)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.get_index_from_list","title":"get_index_from_list","text":"<pre><code>get_index_from_list(list_, value, start=0, end=None)\n</code></pre> <p>Returns the index of the first occurrence of the <code>value</code> on the list.</p> <p>The search can be narrowed to the selected sublist by the <code>start</code> and <code>end</code> indexes having the same semantics as with <code>Get Slice From List</code> keyword. In case the value is not found, -1 is returned. The given list is never altered by this keyword.</p> <p>Example: | ${x} = | Get Index From List | ${L5} | d | =&gt; | ${x} = 3 | ${L5} is not changed</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def get_index_from_list(self, list_, value, start=0, end=None):\n    \"\"\"Returns the index of the first occurrence of the ``value`` on the list.\n\n    The search can be narrowed to the selected sublist by the ``start`` and\n    ``end`` indexes having the same semantics as with `Get Slice From List`\n    keyword. In case the value is not found, -1 is returned. The given list\n    is never altered by this keyword.\n\n    Example:\n    | ${x} = | Get Index From List | ${L5} | d |\n    =&gt;\n    | ${x} = 3\n    | ${L5} is not changed\n    \"\"\"\n    self._validate_list(list_)\n    start = self._index_to_int(start, empty_to_zero=True)\n    list_ = self.get_slice_from_list(list_, start, end)\n    try:\n        return start + list_.index(value)\n    except ValueError:\n        return -1\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.copy_list","title":"copy_list","text":"<pre><code>copy_list(list_, deepcopy=False)\n</code></pre> <p>Returns a copy of the given list.</p> <p>By default, returns a new list with same items as in the original. Set the <code>deepcopy</code> argument to a true value if also items should be copied.</p> <p>The given list is never altered by this keyword.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def copy_list(self, list_, deepcopy=False):\n    \"\"\"Returns a copy of the given list.\n\n    By default, returns a new list with same items as in the original.\n    Set the ``deepcopy`` argument to a true value if also items should\n    be copied.\n\n    The given list is never altered by this keyword.\n    \"\"\"\n    self._validate_list(list_)\n    if deepcopy:\n        return copy.deepcopy(list_)\n    return list_[:]\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.reverse_list","title":"reverse_list","text":"<pre><code>reverse_list(list_)\n</code></pre> <p>Reverses the given list in place.</p> <p>Note that the given list is changed and nothing is returned. Use <code>Copy List</code> first, if you need to keep also the original order.</p> <p>| Reverse List | ${L3} | =&gt; | ${L3} = ['c', 'b', 'a']</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def reverse_list(self, list_):\n    \"\"\"Reverses the given list in place.\n\n    Note that the given list is changed and nothing is returned. Use\n    `Copy List` first, if you need to keep also the original order.\n\n    | Reverse List | ${L3} |\n    =&gt;\n    | ${L3} = ['c', 'b', 'a']\n    \"\"\"\n    self._validate_list(list_)\n    list_.reverse()\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.sort_list","title":"sort_list","text":"<pre><code>sort_list(list_)\n</code></pre> <p>Sorts the given list in place.</p> <p>Sorting fails if items in the list are not comparable with each others. For example, sorting a list containing strings and numbers is not possible.</p> <p>Note that the given list is changed and nothing is returned. Use <code>Copy List</code> first, if you need to preserve the list also in the original order.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def sort_list(self, list_):\n    \"\"\"Sorts the given list in place.\n\n    Sorting fails if items in the list are not comparable with each others.\n    For example, sorting a list containing strings and numbers is not possible.\n\n    Note that the given list is changed and nothing is returned. Use\n    `Copy List` first, if you need to preserve the list also in the original\n    order.\n    \"\"\"\n    self._validate_list(list_)\n    list_.sort()\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.list_should_contain_value","title":"list_should_contain_value","text":"<pre><code>list_should_contain_value(\n    list_, value, msg=None, ignore_case=False\n)\n</code></pre> <p>Fails if the <code>value</code> is not found from <code>list</code>.</p> <p>Use the <code>msg</code> argument to override the default error message.</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def list_should_contain_value(self, list_, value, msg=None, ignore_case=False):\n    \"\"\"Fails if the ``value`` is not found from ``list``.\n\n    Use the ``msg`` argument to override the default error message.\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_list(list_)\n    normalize = Normalizer(ignore_case).normalize\n    _verify_condition(normalize(value) in normalize(list_),\n                      f\"{seq2str2(list_)} does not contain value '{value}'.\", msg)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.list_should_not_contain_value","title":"list_should_not_contain_value","text":"<pre><code>list_should_not_contain_value(\n    list_, value, msg=None, ignore_case=False\n)\n</code></pre> <p>Fails if the <code>value</code> is found from <code>list</code>.</p> <p>Use the <code>msg</code> argument to override the default error message.</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def list_should_not_contain_value(self, list_, value, msg=None, ignore_case=False):\n    \"\"\"Fails if the ``value`` is found from ``list``.\n\n    Use the ``msg`` argument to override the default error message.\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_list(list_)\n    normalize = Normalizer(ignore_case).normalize\n    _verify_condition(normalize(value) not in normalize(list_),\n                      f\"{seq2str2(list_)} contains value '{value}'.\", msg)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.list_should_not_contain_duplicates","title":"list_should_not_contain_duplicates","text":"<pre><code>list_should_not_contain_duplicates(\n    list_, msg=None, ignore_case=False\n)\n</code></pre> <p>Fails if any element in the <code>list</code> is found from it more than once.</p> <p>The default error message lists all the elements that were found from the <code>list</code> multiple times, but it can be overridden by giving a custom <code>msg</code>. All multiple times found items and their counts are also logged.</p> <p>This keyword works with all iterables that can be converted to a list. The original iterable is never altered.</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def list_should_not_contain_duplicates(self, list_, msg=None, ignore_case=False):\n    \"\"\"Fails if any element in the ``list`` is found from it more than once.\n\n    The default error message lists all the elements that were found\n    from the ``list`` multiple times, but it can be overridden by giving\n    a custom ``msg``. All multiple times found items and their counts are\n    also logged.\n\n    This keyword works with all iterables that can be converted to a list.\n    The original iterable is never altered.\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_list(list_)\n    dupes = []\n    list_ = Normalizer(ignore_case).normalize(list_)\n    for item in list_:\n        if item not in dupes:\n            count = list_.count(item)\n            if count &gt; 1:\n                logger.info(f\"'{item}' found {count} times.\")\n                dupes.append(item)\n    if dupes:\n        raise AssertionError(msg or f'{seq2str(dupes)} found multiple times.')\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.lists_should_be_equal","title":"lists_should_be_equal","text":"<pre><code>lists_should_be_equal(\n    list1,\n    list2,\n    msg=None,\n    values=True,\n    names=None,\n    ignore_order=False,\n    ignore_case=False,\n)\n</code></pre> <p>Fails if given lists are unequal.</p> <p>The keyword first verifies that the lists have equal lengths, and then it checks are all their values equal. Possible differences between the values are listed in the default error message like <code>Index 4: ABC != Abc</code>. The types of the lists do not need to be the same. For example, Python tuple and list with same content are considered equal.</p> <p>The error message can be configured using <code>msg</code> and <code>values</code> arguments: - If <code>msg</code> is not given, the default error message is used. - If <code>msg</code> is given and <code>values</code> gets a value considered true   (see <code>Boolean arguments</code>), the error message starts with the given   <code>msg</code> followed by a newline and the default message. - If <code>msg</code> is given and <code>values</code>  is not given a true value,   the error message is just the given <code>msg</code>.</p> <p>The optional <code>names</code> argument can be used for naming the indices shown in the default error message. It can either be a list of names matching the indices in the lists or a dictionary where keys are indices that need to be named. It is not necessary to name all indices. When using a dictionary, keys can be either integers or strings that can be converted to integers.</p> <p>Examples: | ${names} = | Create List | First Name | Family Name | Email | | Lists Should Be Equal | ${people1} | ${people2} | names=${names} | | ${names} = | Create Dictionary | 0=First Name | 2=Email | | Lists Should Be Equal | ${people1} | ${people2} | names=${names} |</p> <p>If the items in index 2 would differ in the above examples, the error message would contain a row like <code>Index 2 (email): name@foo.com != name@bar.com</code>.</p> <p>The optional <code>ignore_order</code> argument can be used to ignore the order of the elements in the lists. Using it requires items to be sortable. This option works recursively with nested lists starting from Robot Framework 7.0.</p> <p>Example: | ${list1} = | Create List | apple | cherry | banana | | ${list2} = | Create List | cherry | banana | apple | | Lists Should Be Equal | ${list1} | ${list2} | ignore_order=True |</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def lists_should_be_equal(self, list1, list2, msg=None, values=True,\n                          names=None, ignore_order=False, ignore_case=False):\n    \"\"\"Fails if given lists are unequal.\n\n    The keyword first verifies that the lists have equal lengths, and then\n    it checks are all their values equal. Possible differences between the\n    values are listed in the default error message like ``Index 4: ABC !=\n    Abc``. The types of the lists do not need to be the same. For example,\n    Python tuple and list with same content are considered equal.\n\n    The error message can be configured using ``msg`` and ``values``\n    arguments:\n    - If ``msg`` is not given, the default error message is used.\n    - If ``msg`` is given and ``values`` gets a value considered true\n      (see `Boolean arguments`), the error message starts with the given\n      ``msg`` followed by a newline and the default message.\n    - If ``msg`` is given and ``values``  is not given a true value,\n      the error message is just the given ``msg``.\n\n    The optional ``names`` argument can be used for naming the indices\n    shown in the default error message. It can either be a list of names\n    matching the indices in the lists or a dictionary where keys are\n    indices that need to be named. It is not necessary to name all indices.\n    When using a dictionary, keys can be either integers\n    or strings that can be converted to integers.\n\n    Examples:\n    | ${names} = | Create List | First Name | Family Name | Email |\n    | Lists Should Be Equal | ${people1} | ${people2} | names=${names} |\n    | ${names} = | Create Dictionary | 0=First Name | 2=Email |\n    | Lists Should Be Equal | ${people1} | ${people2} | names=${names} |\n\n    If the items in index 2 would differ in the above examples, the error\n    message would contain a row like ``Index 2 (email): name@foo.com !=\n    name@bar.com``.\n\n    The optional ``ignore_order`` argument can be used to ignore the order\n    of the elements in the lists. Using it requires items to be sortable.\n    This option works recursively with nested lists starting from Robot\n    Framework 7.0.\n\n    Example:\n    | ${list1} = | Create List | apple | cherry | banana |\n    | ${list2} = | Create List | cherry | banana | apple |\n    | Lists Should Be Equal | ${list1} | ${list2} | ignore_order=True |\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_lists(list1, list2)\n    len1 = len(list1)\n    len2 = len(list2)\n    _verify_condition(len1 == len2,\n                      f'Lengths are different: {len1} != {len2}',\n                      msg, values)\n    names = self._get_list_index_name_mapping(names, len1)\n    normalize = Normalizer(ignore_case, ignore_order).normalize\n    diffs = '\\n'.join(self._yield_list_diffs(normalize(list1), normalize(list2),\n                                             names))\n    _verify_condition(not diffs,\n                      f'Lists are different:\\n{diffs}',\n                      msg, values)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.list_should_contain_sub_list","title":"list_should_contain_sub_list","text":"<pre><code>list_should_contain_sub_list(\n    list1, list2, msg=None, values=True, ignore_case=False\n)\n</code></pre> <p>Fails if not all elements in <code>list2</code> are found in <code>list1</code>.</p> <p>The order of values and the number of values are not taken into account.</p> <p>See <code>Lists Should Be Equal</code> for more information about configuring the error message with <code>msg</code> and <code>values</code> arguments.</p> <p>The <code>ignore_case</code> argument can be used to make comparison case-insensitive. See the <code>Ignore case</code> section for more details. This option is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def list_should_contain_sub_list(self, list1, list2, msg=None, values=True,\n                                 ignore_case=False):\n    \"\"\"Fails if not all elements in ``list2`` are found in ``list1``.\n\n    The order of values and the number of values are not taken into\n    account.\n\n    See `Lists Should Be Equal` for more information about configuring\n    the error message with ``msg`` and ``values`` arguments.\n\n    The ``ignore_case`` argument can be used to make comparison case-insensitive.\n    See the `Ignore case` section for more details. This option is new in\n    Robot Framework 7.0.\n    \"\"\"\n    self._validate_lists(list1, list2)\n    normalize = Normalizer(ignore_case).normalize\n    list1 = normalize(list1)\n    list2 = normalize(list2)\n    diffs = [item for item in list2 if item not in list1]\n    _verify_condition(not diffs, f'Following values are missing: {seq2str(diffs)}',\n                      msg, values)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.log_list","title":"log_list","text":"<pre><code>log_list(list_, level='INFO')\n</code></pre> <p>Logs the length and contents of the <code>list</code> using given <code>level</code>.</p> <p>Valid levels are TRACE, DEBUG, INFO (default), and WARN.</p> <p>If you only want to the length, use keyword <code>Get Length</code> from the BuiltIn library.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def log_list(self, list_, level='INFO'):\n    \"\"\"Logs the length and contents of the ``list`` using given ``level``.\n\n    Valid levels are TRACE, DEBUG, INFO (default), and WARN.\n\n    If you only want to the length, use keyword `Get Length` from\n    the BuiltIn library.\n    \"\"\"\n    self._validate_list(list_)\n    logger.write('\\n'.join(self._log_list(list_)), level)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.should_contain_match","title":"should_contain_match","text":"<pre><code>should_contain_match(\n    list,\n    pattern,\n    msg=None,\n    case_insensitive: bool | None = None,\n    whitespace_insensitive: bool | None = None,\n    ignore_case: bool = False,\n    ignore_whitespace: bool = False,\n)\n</code></pre> <p>Fails if <code>pattern</code> is not found in <code>list</code>.</p> <p>By default, pattern matching is similar to matching files in a shell and is case-sensitive and whitespace-sensitive. In the pattern syntax, <code>*</code> matches to anything and <code>?</code> matches to any single character. You can also prepend <code>glob=</code> to your pattern to explicitly use this pattern matching behavior.</p> <p>If you prepend <code>regexp=</code> to your pattern, your pattern will be used according to the Python [http://docs.python.org/library/re.html|re module] regular expression syntax. Notice that the backslash character often used with regular expressions is an escape character in Robot Framework data and needs to be escaped with another backslash like <code>regexp=\\\\d{6}</code>. See <code>BuiltIn.Should Match Regexp</code> for more details.</p> <p>Matching is case-sensitive by default, but that can be changed by giving the <code>ignore_case</code> argument a true value (see <code>Boolean arguments</code>). This argument is new in Robot Framework 7.0, but with earlier versions it is possible to use <code>case_insensitive</code> for the same purpose.</p> <p>It is possible to ignore all whitespace by giving the <code>ignore_whitespace</code> argument a true value. This argument is new in Robot Framework 7.0 as well, and with earlier versions it is possible to use <code>whitespace_insensitive</code>.</p> <p>Notice that both <code>case_insensitive</code> and <code>whitespace_insensitive</code> are considered deprecated. They will eventually be removed.</p> <p>Non-string values in lists are ignored when matching patterns.</p> <p>Use the <code>msg</code> argument to override the default error message.</p> <p>Examples: | Should Contain Match | ${list} | a              | | | # Match strings beginning with 'a'. | | Should Contain Match | ${list} | regexp=a.      | | | # Same as the above but with regexp. | | Should Contain Match | ${list} | regexp=\\d{6} | | | # Match strings containing six digits. | | Should Contain Match | ${list} | a  | ignore_case=True       | | # Match strings beginning with 'a' or 'A'. | | Should Contain Match | ${list} | ab | ignore_whitespace=yes  | | # Match strings beginning with 'ab' with possible whitespace ignored. | | Should Contain Match | ${list} | ab* | ignore_whitespace=true | ignore_case=true | # Same as the above but also ignore case. |</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def should_contain_match(self, list, pattern, msg=None,\n                         case_insensitive: 'bool|None' = None,\n                         whitespace_insensitive: 'bool|None' = None,\n                         ignore_case: bool = False,\n                         ignore_whitespace: bool = False):\n    \"\"\"Fails if ``pattern`` is not found in ``list``.\n\n    By default, pattern matching is similar to matching files in a shell\n    and is case-sensitive and whitespace-sensitive. In the pattern syntax,\n    ``*`` matches to anything and ``?`` matches to any single character. You\n    can also prepend ``glob=`` to your pattern to explicitly use this pattern\n    matching behavior.\n\n    If you prepend ``regexp=`` to your pattern, your pattern will be used\n    according to the Python\n    [http://docs.python.org/library/re.html|re module] regular expression\n    syntax. Notice that the backslash character often used with regular\n    expressions is an escape character in Robot Framework data and needs\n    to be escaped with another backslash like ``regexp=\\\\\\\\d{6}``. See\n    `BuiltIn.Should Match Regexp` for more details.\n\n    Matching is case-sensitive by default, but that can be changed by giving\n    the ``ignore_case`` argument a true value (see `Boolean arguments`).\n    This argument is new in Robot Framework 7.0, but with earlier versions\n    it is possible to use ``case_insensitive`` for the same purpose.\n\n    It is possible to ignore all whitespace by giving the ``ignore_whitespace``\n    argument a true value. This argument is new in Robot Framework 7.0 as well,\n    and with earlier versions it is possible to use ``whitespace_insensitive``.\n\n    Notice that both ``case_insensitive`` and ``whitespace_insensitive``\n    are considered deprecated. They will eventually be removed.\n\n    Non-string values in lists are ignored when matching patterns.\n\n    Use the ``msg`` argument to override the default error message.\n\n    Examples:\n    | Should Contain Match | ${list} | a*              | | | # Match strings beginning with 'a'. |\n    | Should Contain Match | ${list} | regexp=a.*      | | | # Same as the above but with regexp. |\n    | Should Contain Match | ${list} | regexp=\\\\\\\\d{6} | | | # Match strings containing six digits. |\n    | Should Contain Match | ${list} | a*  | ignore_case=True       | | # Match strings beginning with 'a' or 'A'. |\n    | Should Contain Match | ${list} | ab* | ignore_whitespace=yes  | | # Match strings beginning with 'ab' with possible whitespace ignored. |\n    | Should Contain Match | ${list} | ab* | ignore_whitespace=true | ignore_case=true | # Same as the above but also ignore case. |\n    \"\"\"\n    _List._validate_list(self, list)\n    matches = self._get_matches(list, pattern, case_insensitive,\n                                whitespace_insensitive, ignore_case,\n                                ignore_whitespace)\n    default = f\"{seq2str2(list)} does not contain match for pattern '{pattern}'.\"\n    _verify_condition(matches, default, msg)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.should_not_contain_match","title":"should_not_contain_match","text":"<pre><code>should_not_contain_match(\n    list,\n    pattern,\n    msg=None,\n    case_insensitive: bool | None = None,\n    whitespace_insensitive: bool | None = None,\n    ignore_case: bool = False,\n    ignore_whitespace: bool = False,\n)\n</code></pre> <p>Fails if <code>pattern</code> is found in <code>list</code>.</p> <p>Exact opposite of <code>Should Contain Match</code> keyword. See that keyword for information about arguments and usage in general.</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def should_not_contain_match(self, list, pattern, msg=None,\n                             case_insensitive: 'bool|None' = None,\n                             whitespace_insensitive: 'bool|None' = None,\n                             ignore_case: bool = False,\n                             ignore_whitespace: bool = False):\n    \"\"\"Fails if ``pattern`` is found in ``list``.\n\n    Exact opposite of `Should Contain Match` keyword. See that keyword\n    for information about arguments and usage in general.\n    \"\"\"\n    _List._validate_list(self, list)\n    matches = self._get_matches(list, pattern, case_insensitive,\n                                whitespace_insensitive, ignore_case,\n                                ignore_whitespace)\n    default = f\"{seq2str2(list)} contains match for pattern '{pattern}'.\"\n    _verify_condition(not matches, default, msg)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.get_matches","title":"get_matches","text":"<pre><code>get_matches(\n    list,\n    pattern,\n    case_insensitive: bool | None = None,\n    whitespace_insensitive: bool | None = None,\n    ignore_case: bool = False,\n    ignore_whitespace: bool = False,\n)\n</code></pre> <p>Returns a list of matches to <code>pattern</code> in <code>list</code>.</p> <p>For more information on <code>pattern</code>, <code>case_insensitive/ignore_case</code>, and <code>whitespace_insensitive/ignore_whitespace</code>, see <code>Should Contain Match</code>.</p> <p>Examples: | ${matches}= | Get Matches | ${list} | a | # ${matches} will contain any string beginning with 'a' | | ${matches}= | Get Matches | ${list} | regexp=a. | # ${matches} will contain any string beginning with 'a' (regexp version) | | ${matches}= | Get Matches | ${list} | a* | ignore_case=True | # ${matches} will contain any string beginning with 'a' or 'A' |</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def get_matches(self, list, pattern,\n                case_insensitive: 'bool|None' = None,\n                whitespace_insensitive: 'bool|None' = None,\n                ignore_case: bool = False,\n                ignore_whitespace: bool = False):\n    \"\"\"Returns a list of matches to ``pattern`` in ``list``.\n\n    For more information on ``pattern``, ``case_insensitive/ignore_case``, and\n    ``whitespace_insensitive/ignore_whitespace``, see `Should Contain Match`.\n\n    Examples:\n    | ${matches}= | Get Matches | ${list} | a* | # ${matches} will contain any string beginning with 'a' |\n    | ${matches}= | Get Matches | ${list} | regexp=a.* | # ${matches} will contain any string beginning with 'a' (regexp version) |\n    | ${matches}= | Get Matches | ${list} | a* | ignore_case=True | # ${matches} will contain any string beginning with 'a' or 'A' |\n    \"\"\"\n    _List._validate_list(self, list)\n    return self._get_matches(list, pattern, case_insensitive,\n                             whitespace_insensitive, ignore_case,\n                             ignore_whitespace)\n</code></pre>"},{"location":"api/robot/libraries/Collections/#robot.libraries.Collections.Collections.get_match_count","title":"get_match_count","text":"<pre><code>get_match_count(\n    list,\n    pattern,\n    case_insensitive: bool | None = None,\n    whitespace_insensitive: bool | None = None,\n    ignore_case: bool = False,\n    ignore_whitespace: bool = False,\n)\n</code></pre> <p>Returns the count of matches to <code>pattern</code> in <code>list</code>.</p> <p>For more information on <code>pattern</code>, <code>case_insensitive/ignore_case</code>, and <code>whitespace_insensitive/ignore_whitespace</code>, see <code>Should Contain Match</code>.</p> <p>Examples: | ${count}= | Get Match Count | ${list} | a | # ${count} will be the count of strings beginning with 'a' | | ${count}= | Get Match Count | ${list} | regexp=a. | # ${matches} will be the count of strings beginning with 'a' (regexp version) | | ${count}= | Get Match Count | ${list} | a* | case_insensitive=${True} | # ${matches} will be the count of strings beginning with 'a' or 'A' |</p> Source code in <code>src/robot/libraries/Collections.py</code> <pre><code>def get_match_count(self, list, pattern,\n                    case_insensitive: 'bool|None' = None,\n                    whitespace_insensitive: 'bool|None' = None,\n                    ignore_case: bool = False,\n                    ignore_whitespace: bool = False):\n    \"\"\"Returns the count of matches to ``pattern`` in ``list``.\n\n    For more information on ``pattern``, ``case_insensitive/ignore_case``, and\n    ``whitespace_insensitive/ignore_whitespace``, see `Should Contain Match`.\n\n    Examples:\n    | ${count}= | Get Match Count | ${list} | a* | # ${count} will be the count of strings beginning with 'a' |\n    | ${count}= | Get Match Count | ${list} | regexp=a.* | # ${matches} will be the count of strings beginning with 'a' (regexp version) |\n    | ${count}= | Get Match Count | ${list} | a* | case_insensitive=${True} | # ${matches} will be the count of strings beginning with 'a' or 'A' |\n    \"\"\"\n    _List._validate_list(self, list)\n    return len(self.get_matches(list, pattern, case_insensitive,\n                                whitespace_insensitive, ignore_case,\n                                ignore_whitespace))\n</code></pre>"},{"location":"api/robot/libraries/DateTime/","title":"robot.libraries.DateTime","text":""},{"location":"api/robot/libraries/DateTime/#robot.libraries.DateTime","title":"robot.libraries.DateTime","text":"<p>A library for handling date and time values.</p> <p><code>DateTime</code> is a Robot Framework standard library that supports creating and converting date and time values (e.g. <code>Get Current Date</code>, <code>Convert Time</code>), as well as doing simple calculations with them (e.g. <code>Subtract Time From Date</code>, <code>Add Time To Time</code>). It supports dates and times in various formats, and can also be used by other libraries programmatically.</p> <p>== Table of contents ==</p> <p>%TOC%</p> <p>= Terminology =</p> <p>In the context of this library, <code>date</code> and <code>time</code> generally have the following meanings:</p> <ul> <li><code>date</code>: An entity with both date and time components but without any    time zone information. For example, <code>2014-06-11 10:07:42</code>.</li> <li><code>time</code>: A time interval. For example, <code>1 hour 20 minutes</code> or <code>01:20:00</code>.</li> </ul> <p>This terminology differs from what Python's standard [http://docs.python.org/library/datetime.html|datetime] module uses. Basically its [http://docs.python.org/library/datetime.html#datetime-objects|datetime] and [http://docs.python.org/library/datetime.html#timedelta-objects|timedelta] objects match <code>date</code> and <code>time</code> as defined by this library.</p> <p>= Date formats =</p> <p>Dates can be given to and received from keywords in <code>timestamp</code>, <code>custom timestamp</code>, <code>Python datetime</code> and <code>epoch time</code> formats. These formats are discussed thoroughly in subsequent sections.</p> <p>Input format is determined automatically based on the given date except when using custom timestamps, in which case it needs to be given using <code>date_format</code> argument. Default result format is timestamp, but it can be overridden using <code>result_format</code> argument.</p> <p>== Timestamp ==</p> <p>If a date is given as a string, it is always considered to be a timestamp. If no custom formatting is given using <code>date_format</code> argument, the timestamp is expected to be in [http://en.wikipedia.org/wiki/ISO_8601|ISO 8601] like format <code>YYYY-MM-DD hh:mm:ss.mil</code>, where any non-digit character can be used as a separator or separators can be omitted altogether. Additionally, only the date part is mandatory, all possibly missing time components are considered to be zeros.</p> <p>Dates can also be returned in the same <code>YYYY-MM-DD hh:mm:ss.mil</code> format by using <code>timestamp</code> value with <code>result_format</code> argument. This is also the default format that keywords returning dates use. Milliseconds can be excluded using <code>exclude_millis</code> as explained in <code>Millisecond handling</code> section.</p> <p>Examples: | ${date1} =      | Convert Date | 2014-06-11 10:07:42.000 | | ${date2} =      | Convert Date | 20140611 100742         | result_format=timestamp | | Should Be Equal | ${date1}     | ${date2}                | | ${date} =       | Convert Date | 20140612 12:57          | exclude_millis=yes | | Should Be Equal | ${date}      | 2014-06-12 12:57:00     |</p> <p>== Custom timestamp ==</p> <p>It is possible to use custom timestamps in both input and output. The custom format is same as accepted by Python's [http://docs.python.org/library/datetime.html#strftime-strptime-behavior| datetime.strptime] function. For example, the default timestamp discussed in the previous section would match <code>%Y-%m-%d %H:%M:%S.%f</code>.</p> <p>When using a custom timestamp in input, it must be specified using <code>date_format</code> argument. The actual input value must be a string that matches the specified format exactly. When using a custom timestamp in output, it must be given using <code>result_format</code> argument.</p> <p>Examples: | ${date} =       | Convert Date | 28.05.2014 12:05        | date_format=%d.%m.%Y %H:%M | | Should Be Equal | ${date}      | 2014-05-28 12:05:00.000 | | ${date} =       | Convert Date | ${date}                 | result_format=%d.%m.%Y | | Should Be Equal | ${date}      | 28.05.2014              |</p> <p>== Python datetime ==</p> <p>Python's standard [https://docs.python.org/library/datetime.html#datetime.datetime|datetime] objects can be used both in input and output. In input, they are recognized automatically, and in output it is possible to get them by using the <code>datetime</code> value with the <code>result_format</code> argument.</p> <p>One nice benefit with datetime objects is that they have different time components available as attributes that can be easily accessed using the extended variable syntax.</p> <p>Examples: | ${datetime} = | Convert Date | 2014-06-11 10:07:42.123 | datetime | | Should Be Equal As Integers | ${datetime.year}        | 2014   | | Should Be Equal As Integers | ${datetime.month}       | 6      | | Should Be Equal As Integers | ${datetime.day}         | 11     | | Should Be Equal As Integers | ${datetime.hour}        | 10     | | Should Be Equal As Integers | ${datetime.minute}      | 7      | | Should Be Equal As Integers | ${datetime.second}      | 42     | | Should Be Equal As Integers | ${datetime.microsecond} | 123000 |</p> <p>== Python date ==</p> <p>Python's standard [https://docs.python.org/library/datetime.html#datetime.date|date] objects are automatically recognized in input starting from Robot Framework 7.0. They are not supported in output, but <code>datetime</code> objects can be converted to <code>date</code> objects if needed:</p> <p>| ${datetime} = | Convert Date | 2023-12-18 11:10:42 | datetime | | Log | ${datetime.date()} | # The time part is ignored. |</p> <p>== Epoch time ==</p> <p>Epoch time is the time in seconds since the [http://en.wikipedia.org/wiki/Unix_time|UNIX epoch] i.e. 00:00:00.000 (UTC) January 1, 1970. To give a date as an epoch time, it must be given as a number (integer or float), not as a string. To return a date as an epoch time, it is possible to use <code>epoch</code> value with <code>result_format</code> argument. Epoch times are returned as floating point numbers.</p> <p>Notice that epoch times are independent on time zones and thus same around the world at a certain time. For example, epoch times returned by <code>Get Current Date</code> are not affected by the <code>time_zone</code> argument. What local time a certain epoch time matches then depends on the time zone.</p> <p>Following examples demonstrate using epoch times. They are tested in Finland, and due to the reasons explained above they would fail on other time zones.</p> <p>| ${date} =       | Convert Date | ${1000000000}           | | Should Be Equal | ${date}      | 2001-09-09 04:46:40.000 | | ${date} =       | Convert Date | 2014-06-12 13:27:59.279 | epoch | | Should Be Equal | ${date}      | ${1402568879.279}       |</p> <p>== Earliest supported date ==</p> <p>The earliest date that is supported depends on the date format and to some extent on the platform:</p> <ul> <li>Timestamps support year 1900 and above.</li> <li>Python datetime objects support year 1 and above.</li> <li>Epoch time supports 1970 and above on Windows.</li> <li>On other platforms epoch time supports 1900 and above or even earlier.</li> </ul> <p>= Time formats =</p> <p>Similarly as dates, times can be given to and received from keywords in various different formats. Supported formats are <code>number</code>, <code>time string</code> (verbose and compact), <code>timer string</code> and <code>Python timedelta</code>.</p> <p>Input format for time is always determined automatically based on the input. Result format is number by default, but it can be customised using <code>result_format</code> argument.</p> <p>== Number ==</p> <p>Time given as a number is interpreted to be seconds. It can be given either as an integer or a float, or it can be a string that can be converted to a number.</p> <p>To return a time as a number, <code>result_format</code> argument must have value <code>number</code>, which is also the default. Returned number is always a float.</p> <p>Examples: | ${time} =       | Convert Time | 3.14    | | Should Be Equal | ${time}      | ${3.14} | | ${time} =       | Convert Time | ${time} | result_format=number | | Should Be Equal | ${time}      | ${3.14} |</p> <p>== Time string ==</p> <p>Time strings are strings in format like <code>1 minute 42 seconds</code> or <code>1min 42s</code>. The basic idea of this format is having first a number and then a text specifying what time that number represents. Numbers can be either integers or floating point numbers, the whole format is case and space insensitive, and it is possible to add a minus prefix to specify negative times. The available time specifiers are:</p> <ul> <li><code>weeks</code>, <code>week</code>, <code>w</code> (new in RF 7.1)</li> <li><code>days</code>, <code>day</code>, <code>d</code></li> <li><code>hours</code>, <code>hour</code>, <code>h</code></li> <li><code>minutes</code>, <code>minute</code>, <code>mins</code>, <code>min</code>, <code>m</code></li> <li><code>seconds</code>, <code>second</code>, <code>secs</code>, <code>sec</code>, <code>s</code></li> <li><code>milliseconds</code>, <code>millisecond</code>, <code>millis</code>, <code>ms</code></li> <li><code>microseconds</code>, <code>microsecond</code>, <code>us</code>, <code>\u03bcs</code> (new in RF 6.0)</li> <li><code>nanoseconds</code>, <code>nanosecond</code>, <code>ns</code> (new in RF 6.0)</li> </ul> <p>When returning a time string, it is possible to select between <code>verbose</code> and <code>compact</code> representations using <code>result_format</code> argument. The verbose format uses long specifiers <code>week</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code> and <code>millisecond</code>, and adds <code>s</code> at the end when needed. The compact format uses shorter specifiers <code>w</code>, <code>d</code>, <code>h</code>, <code>min</code>, <code>s</code> and <code>ms</code>, and even drops the space between the number and the specifier.</p> <p>Examples: | ${time} =       | Convert Time | 1 minute 42 seconds | | Should Be Equal | ${time}      | ${102}              | | ${time} =       | Convert Time | 4200                | verbose | | Should Be Equal | ${time}      | 1 hour 10 minutes   | | ${time} =       | Convert Time | - 1.5 hours         | compact | | Should Be Equal | ${time}      | - 1h 30min          |</p> <p>== Timer string ==</p> <p>Timer string is a string given in timer like format <code>hh:mm:ss.mil</code>. In this format both hour and millisecond parts are optional, leading and trailing zeros can be left out when they are not meaningful, and negative times can be represented by adding a minus prefix.</p> <p>To return a time as timer string, <code>result_format</code> argument must be given value <code>timer</code>. Timer strings are by default returned in full <code>hh:mm:ss.mil</code> format, but milliseconds can be excluded using <code>exclude_millis</code> as explained in <code>Millisecond handling</code> section.</p> <p>Examples: | ${time} =       | Convert Time | 01:42        | | Should Be Equal | ${time}      | ${102}       | | ${time} =       | Convert Time | 01:10:00.123 | | Should Be Equal | ${time}      | ${4200.123}  | | ${time} =       | Convert Time | 102          | timer | | Should Be Equal | ${time}      | 00:01:42.000 | | ${time} =       | Convert Time | -101.567     | timer | exclude_millis=yes | | Should Be Equal | ${time}      | -00:01:42    |</p> <p>== Python timedelta ==</p> <p>Python's standard [http://docs.python.org/library/datetime.html#datetime.timedelta|timedelta] objects are also supported both in input and in output. In input they are recognized automatically, and in output it is possible to receive them by giving <code>timedelta</code> value to <code>result_format</code> argument.</p> <p>Examples: | ${timedelta} =  | Convert Time                 | 01:10:02.123 | timedelta | | Should Be Equal | ${timedelta.total_seconds()} | ${4202.123}  |</p> <p>= Millisecond handling =</p> <p>This library handles dates and times internally using the precision of the given input. With <code>timestamp</code>, <code>time string</code>, and <code>timer string</code> result formats seconds are, however, rounded to millisecond accuracy. Milliseconds may also be included even if there would be none.</p> <p>All keywords returning dates or times have an option to leave milliseconds out by giving a true value to <code>exclude_millis</code> argument. If the argument is given as a string, it is considered true unless it is empty or case-insensitively equal to <code>false</code>, <code>none</code> or <code>no</code>. Other argument types are tested using same [http://docs.python.org/library/stdtypes.html#truth|rules as in Python].</p> <p>When milliseconds are excluded, seconds in returned dates and times are rounded to the nearest full second. With <code>timestamp</code> and <code>timer string</code> result formats, milliseconds will also be removed from the returned string altogether.</p> <p>Examples: | ${date} =       | Convert Date | 2014-06-11 10:07:42     | | Should Be Equal | ${date}      | 2014-06-11 10:07:42.000 | | ${date} =       | Convert Date | 2014-06-11 10:07:42.500 | exclude_millis=yes | | Should Be Equal | ${date}      | 2014-06-11 10:07:43     | | ${dt} =         | Convert Date | 2014-06-11 10:07:42.500 | datetime | exclude_millis=yes | | Should Be Equal | ${dt.second} | ${43}        | | Should Be Equal | ${dt.microsecond} | ${0}    | | ${time} =       | Convert Time | 102          | timer | exclude_millis=false | | Should Be Equal | ${time}      | 00:01:42.000 |       | | ${time} =       | Convert Time | 102.567      | timer | exclude_millis=true | | Should Be Equal | ${time}      | 00:01:43     |       |</p> <p>= Programmatic usage =</p> <p>In addition to be used as normal library, this library is intended to provide a stable API for other libraries to use if they want to support same date and time formats as this library. All the provided keywords are available as functions that can be easily imported:</p> from robot.libraries.DateTime import convert_time def example_keyword(timeout): seconds = convert_time(timeout) # ... <p>Additionally, helper classes <code>Date</code> and <code>Time</code> can be used directly:</p> from robot.libraries.DateTime import Date, Time def example_keyword(date, interval): date = Date(date).convert('datetime') interval = Time(interval).convert('number') # ..."},{"location":"api/robot/libraries/DateTime/#robot.libraries.DateTime.get_current_date","title":"get_current_date","text":"<pre><code>get_current_date(\n    time_zone=\"local\",\n    increment=0,\n    result_format=\"timestamp\",\n    exclude_millis=False,\n)\n</code></pre> <p>Returns current local or UTC time with an optional increment.</p> <ul> <li><code>time_zone:</code>      Get the current time on this time zone. Currently only                       <code>local</code> (default) and <code>UTC</code> are supported.                       Has no effect if date is returned as an <code>epoch time</code>.</li> <li><code>increment:</code>      Optional time increment to add to the returned date in                       one of the supported <code>time formats</code>. Can be negative.</li> <li><code>result_format:</code>  Format of the returned date (see <code>date formats</code>).</li> <li><code>exclude_millis:</code> When set to any true value, rounds and drops                       milliseconds as explained in <code>millisecond handling</code>.</li> </ul> <p>Examples: | ${date} =       | Get Current Date | | Should Be Equal | ${date}          | 2014-06-12 20:00:58.946 | | ${date} =       | Get Current Date | UTC                     | | Should Be Equal | ${date}          | 2014-06-12 17:00:58.946 | | ${date} =       | Get Current Date | increment=02:30:00      | | Should Be Equal | ${date}          | 2014-06-12 22:30:58.946 | | ${date} =       | Get Current Date | UTC                     | - 5 hours | | Should Be Equal | ${date}          | 2014-06-12 12:00:58.946 | | ${date} =       | Get Current Date | result_format=datetime  | | Should Be Equal | ${date.year}     | ${2014}                 | | Should Be Equal | ${date.month}    | ${6}                    |</p> Source code in <code>src/robot/libraries/DateTime.py</code> <pre><code>def get_current_date(time_zone='local', increment=0, result_format='timestamp',\n                     exclude_millis=False):\n    \"\"\"Returns current local or UTC time with an optional increment.\n\n    Arguments:\n    - ``time_zone:``      Get the current time on this time zone. Currently only\n                          ``local`` (default) and ``UTC`` are supported.\n                          Has no effect if date is returned as an `epoch time`.\n    - ``increment:``      Optional time increment to add to the returned date in\n                          one of the supported `time formats`. Can be negative.\n    - ``result_format:``  Format of the returned date (see `date formats`).\n    - ``exclude_millis:`` When set to any true value, rounds and drops\n                          milliseconds as explained in `millisecond handling`.\n\n    Examples:\n    | ${date} =       | Get Current Date |\n    | Should Be Equal | ${date}          | 2014-06-12 20:00:58.946 |\n    | ${date} =       | Get Current Date | UTC                     |\n    | Should Be Equal | ${date}          | 2014-06-12 17:00:58.946 |\n    | ${date} =       | Get Current Date | increment=02:30:00      |\n    | Should Be Equal | ${date}          | 2014-06-12 22:30:58.946 |\n    | ${date} =       | Get Current Date | UTC                     | - 5 hours |\n    | Should Be Equal | ${date}          | 2014-06-12 12:00:58.946 |\n    | ${date} =       | Get Current Date | result_format=datetime  |\n    | Should Be Equal | ${date.year}     | ${2014}                 |\n    | Should Be Equal | ${date.month}    | ${6}                    |\n    \"\"\"\n    if time_zone.upper() == 'LOCAL' or result_format.upper() == 'EPOCH':\n        dt = datetime.datetime.now()\n    elif time_zone.upper() == 'UTC':\n        if sys.version_info &gt;= (3, 12):\n            # `utcnow()` was deprecated in Python 3.12. We only support \"naive\"\n            # datetime objects and thus need to remove timezone information here.\n            dt = datetime.datetime.now(datetime.UTC).replace(tzinfo=None)\n        else:\n            dt = datetime.datetime.utcnow()\n    else:\n        raise ValueError(f\"Unsupported timezone '{time_zone}'.\")\n    date = Date(dt) + Time(increment)\n    return date.convert(result_format, millis=not exclude_millis)\n</code></pre>"},{"location":"api/robot/libraries/DateTime/#robot.libraries.DateTime.convert_date","title":"convert_date","text":"<pre><code>convert_date(\n    date,\n    result_format=\"timestamp\",\n    exclude_millis=False,\n    date_format=None,\n)\n</code></pre> <p>Converts between supported <code>date formats</code>.</p> <p>Arguments: - <code>date:</code>           Date in one of the supported <code>date formats</code>. - <code>result_format:</code>  Format of the returned date. - <code>exclude_millis:</code> When set to any true value, rounds and drops                       milliseconds as explained in <code>millisecond handling</code>. - <code>date_format:</code>    Specifies possible <code>custom timestamp</code> format.</p> <p>Examples: | ${date} =       | Convert Date | 20140528 12:05:03.111   | | Should Be Equal | ${date}      | 2014-05-28 12:05:03.111 | | ${date} =       | Convert Date | ${date}                 | epoch | | Should Be Equal | ${date}      | ${1401267903.111}       | | ${date} =       | Convert Date | 5.28.2014 12:05         | exclude_millis=yes | date_format=%m.%d.%Y %H:%M | | Should Be Equal | ${date}      | 2014-05-28 12:05:00     |</p> Source code in <code>src/robot/libraries/DateTime.py</code> <pre><code>def convert_date(date, result_format='timestamp', exclude_millis=False,\n                 date_format=None):\n    \"\"\"Converts between supported `date formats`.\n\n    Arguments:\n    - ``date:``           Date in one of the supported `date formats`.\n    - ``result_format:``  Format of the returned date.\n    - ``exclude_millis:`` When set to any true value, rounds and drops\n                          milliseconds as explained in `millisecond handling`.\n    - ``date_format:``    Specifies possible `custom timestamp` format.\n\n    Examples:\n    | ${date} =       | Convert Date | 20140528 12:05:03.111   |\n    | Should Be Equal | ${date}      | 2014-05-28 12:05:03.111 |\n    | ${date} =       | Convert Date | ${date}                 | epoch |\n    | Should Be Equal | ${date}      | ${1401267903.111}       |\n    | ${date} =       | Convert Date | 5.28.2014 12:05         | exclude_millis=yes | date_format=%m.%d.%Y %H:%M |\n    | Should Be Equal | ${date}      | 2014-05-28 12:05:00     |\n    \"\"\"\n    return Date(date, date_format).convert(result_format, millis=not exclude_millis)\n</code></pre>"},{"location":"api/robot/libraries/DateTime/#robot.libraries.DateTime.convert_time","title":"convert_time","text":"<pre><code>convert_time(\n    time, result_format=\"number\", exclude_millis=False\n)\n</code></pre> <p>Converts between supported <code>time formats</code>.</p> <p>Arguments: - <code>time:</code>           Time in one of the supported <code>time formats</code>. - <code>result_format:</code>  Format of the returned time. - <code>exclude_millis:</code> When set to any true value, rounds and drops                       milliseconds as explained in <code>millisecond handling</code>.</p> <p>Examples: | ${time} =       | Convert Time  | 10 seconds        | | Should Be Equal | ${time}       | ${10}             | | ${time} =       | Convert Time  | 1:00:01           | verbose | | Should Be Equal | ${time}       | 1 hour 1 second   | | ${time} =       | Convert Time  | ${3661.5} | timer | exclude_milles=yes | | Should Be Equal | ${time}       | 01:01:02          |</p> Source code in <code>src/robot/libraries/DateTime.py</code> <pre><code>def convert_time(time, result_format='number', exclude_millis=False):\n    \"\"\"Converts between supported `time formats`.\n\n    Arguments:\n    - ``time:``           Time in one of the supported `time formats`.\n    - ``result_format:``  Format of the returned time.\n    - ``exclude_millis:`` When set to any true value, rounds and drops\n                          milliseconds as explained in `millisecond handling`.\n\n    Examples:\n    | ${time} =       | Convert Time  | 10 seconds        |\n    | Should Be Equal | ${time}       | ${10}             |\n    | ${time} =       | Convert Time  | 1:00:01           | verbose |\n    | Should Be Equal | ${time}       | 1 hour 1 second   |\n    | ${time} =       | Convert Time  | ${3661.5} | timer | exclude_milles=yes |\n    | Should Be Equal | ${time}       | 01:01:02          |\n    \"\"\"\n    return Time(time).convert(result_format, millis=not exclude_millis)\n</code></pre>"},{"location":"api/robot/libraries/DateTime/#robot.libraries.DateTime.subtract_date_from_date","title":"subtract_date_from_date","text":"<pre><code>subtract_date_from_date(\n    date1,\n    date2,\n    result_format=\"number\",\n    exclude_millis=False,\n    date1_format=None,\n    date2_format=None,\n)\n</code></pre> <p>Subtracts date from another date and returns time between.</p> <ul> <li><code>date1:</code>          Date to subtract another date from in one of the                       supported <code>date formats</code>.</li> <li><code>date2:</code>          Date that is subtracted in one of the supported                       <code>date formats</code>.</li> <li><code>result_format:</code>  Format of the returned time (see <code>time formats</code>).</li> <li><code>exclude_millis:</code> When set to any true value, rounds and drops                       milliseconds as explained in <code>millisecond handling</code>.</li> <li><code>date1_format:</code>   Possible <code>custom timestamp</code> format of <code>date1</code>.</li> <li><code>date2_format:</code>   Possible <code>custom timestamp</code> format of <code>date2</code>.</li> </ul> <p>Examples: | ${time} =       | Subtract Date From Date | 2014-05-28 12:05:52     | 2014-05-28 12:05:10 | | Should Be Equal | ${time}                 | ${42}                   | | ${time} =       | Subtract Date From Date | 2014-05-28 12:05:52     | 2014-05-27 12:05:10 | verbose | | Should Be Equal | ${time}                 | 1 day 42 seconds        |</p> Source code in <code>src/robot/libraries/DateTime.py</code> <pre><code>def subtract_date_from_date(date1, date2, result_format='number',\n                            exclude_millis=False, date1_format=None,\n                            date2_format=None):\n    \"\"\"Subtracts date from another date and returns time between.\n\n    Arguments:\n    - ``date1:``          Date to subtract another date from in one of the\n                          supported `date formats`.\n    - ``date2:``          Date that is subtracted in one of the supported\n                          `date formats`.\n    - ``result_format:``  Format of the returned time (see `time formats`).\n    - ``exclude_millis:`` When set to any true value, rounds and drops\n                          milliseconds as explained in `millisecond handling`.\n    - ``date1_format:``   Possible `custom timestamp` format of ``date1``.\n    - ``date2_format:``   Possible `custom timestamp` format of ``date2``.\n\n     Examples:\n    | ${time} =       | Subtract Date From Date | 2014-05-28 12:05:52     | 2014-05-28 12:05:10 |\n    | Should Be Equal | ${time}                 | ${42}                   |\n    | ${time} =       | Subtract Date From Date | 2014-05-28 12:05:52     | 2014-05-27 12:05:10 | verbose |\n    | Should Be Equal | ${time}                 | 1 day 42 seconds        |\n    \"\"\"\n    time = Date(date1, date1_format) - Date(date2, date2_format)\n    return time.convert(result_format, millis=not exclude_millis)\n</code></pre>"},{"location":"api/robot/libraries/DateTime/#robot.libraries.DateTime.add_time_to_date","title":"add_time_to_date","text":"<pre><code>add_time_to_date(\n    date,\n    time,\n    result_format=\"timestamp\",\n    exclude_millis=False,\n    date_format=None,\n)\n</code></pre> <p>Adds time to date and returns the resulting date.</p> <ul> <li><code>date:</code>           Date to add time to in one of the supported                       <code>date formats</code>.</li> <li><code>time:</code>           Time that is added in one of the supported                       <code>time formats</code>.</li> <li><code>result_format:</code>  Format of the returned date.</li> <li><code>exclude_millis:</code> When set to any true value, rounds and drops                       milliseconds as explained in <code>millisecond handling</code>.</li> <li><code>date_format:</code>    Possible <code>custom timestamp</code> format of <code>date</code>.</li> </ul> <p>Examples: | ${date} =       | Add Time To Date | 2014-05-28 12:05:03.111 | 7 days       | | Should Be Equal | ${date}          | 2014-06-04 12:05:03.111 |              | | ${date} =       | Add Time To Date | 2014-05-28 12:05:03.111 | 01:02:03:004 | | Should Be Equal | ${date}          | 2014-05-28 13:07:06.115 |</p> Source code in <code>src/robot/libraries/DateTime.py</code> <pre><code>def add_time_to_date(date, time, result_format='timestamp',\n                     exclude_millis=False, date_format=None):\n    \"\"\"Adds time to date and returns the resulting date.\n\n    Arguments:\n    - ``date:``           Date to add time to in one of the supported\n                          `date formats`.\n    - ``time:``           Time that is added in one of the supported\n                          `time formats`.\n    - ``result_format:``  Format of the returned date.\n    - ``exclude_millis:`` When set to any true value, rounds and drops\n                          milliseconds as explained in `millisecond handling`.\n    - ``date_format:``    Possible `custom timestamp` format of ``date``.\n\n    Examples:\n    | ${date} =       | Add Time To Date | 2014-05-28 12:05:03.111 | 7 days       |\n    | Should Be Equal | ${date}          | 2014-06-04 12:05:03.111 |              |\n    | ${date} =       | Add Time To Date | 2014-05-28 12:05:03.111 | 01:02:03:004 |\n    | Should Be Equal | ${date}          | 2014-05-28 13:07:06.115 |\n    \"\"\"\n    date = Date(date, date_format) + Time(time)\n    return date.convert(result_format, millis=not exclude_millis)\n</code></pre>"},{"location":"api/robot/libraries/DateTime/#robot.libraries.DateTime.subtract_time_from_date","title":"subtract_time_from_date","text":"<pre><code>subtract_time_from_date(\n    date,\n    time,\n    result_format=\"timestamp\",\n    exclude_millis=False,\n    date_format=None,\n)\n</code></pre> <p>Subtracts time from date and returns the resulting date.</p> <ul> <li><code>date:</code>           Date to subtract time from in one of the supported                       <code>date formats</code>.</li> <li><code>time:</code>           Time that is subtracted in one of the supported                      <code>time formats</code>.</li> <li><code>result_format:</code>  Format of the returned date.</li> <li><code>exclude_millis:</code> When set to any true value, rounds and drops                       milliseconds as explained in <code>millisecond handling</code>.</li> <li><code>date_format:</code>    Possible <code>custom timestamp</code> format of <code>date</code>.</li> </ul> <p>Examples: | ${date} =       | Subtract Time From Date | 2014-06-04 12:05:03.111 | 7 days | | Should Be Equal | ${date}                 | 2014-05-28 12:05:03.111 | | ${date} =       | Subtract Time From Date | 2014-05-28 13:07:06.115 | 01:02:03:004 | | Should Be Equal | ${date}                 | 2014-05-28 12:05:03.111 |</p> Source code in <code>src/robot/libraries/DateTime.py</code> <pre><code>def subtract_time_from_date(date, time, result_format='timestamp',\n                            exclude_millis=False, date_format=None):\n    \"\"\"Subtracts time from date and returns the resulting date.\n\n    Arguments:\n    - ``date:``           Date to subtract time from in one of the supported\n                          `date formats`.\n    - ``time:``           Time that is subtracted in one of the supported\n                         `time formats`.\n    - ``result_format:``  Format of the returned date.\n    - ``exclude_millis:`` When set to any true value, rounds and drops\n                          milliseconds as explained in `millisecond handling`.\n    - ``date_format:``    Possible `custom timestamp` format of ``date``.\n\n    Examples:\n    | ${date} =       | Subtract Time From Date | 2014-06-04 12:05:03.111 | 7 days |\n    | Should Be Equal | ${date}                 | 2014-05-28 12:05:03.111 |\n    | ${date} =       | Subtract Time From Date | 2014-05-28 13:07:06.115 | 01:02:03:004 |\n    | Should Be Equal | ${date}                 | 2014-05-28 12:05:03.111 |\n    \"\"\"\n    date = Date(date, date_format) - Time(time)\n    return date.convert(result_format, millis=not exclude_millis)\n</code></pre>"},{"location":"api/robot/libraries/DateTime/#robot.libraries.DateTime.add_time_to_time","title":"add_time_to_time","text":"<pre><code>add_time_to_time(\n    time1,\n    time2,\n    result_format=\"number\",\n    exclude_millis=False,\n)\n</code></pre> <p>Adds time to another time and returns the resulting time.</p> <p>Arguments: - <code>time1:</code>          First time in one of the supported <code>time formats</code>. - <code>time2:</code>          Second time in one of the supported <code>time formats</code>. - <code>result_format:</code>  Format of the returned time. - <code>exclude_millis:</code> When set to any true value, rounds and drops                       milliseconds as explained in <code>millisecond handling</code>.</p> <p>Examples: | ${time} =       | Add Time To Time | 1 minute          | 42       | | Should Be Equal | ${time}          | ${102}            | | ${time} =       | Add Time To Time | 3 hours 5 minutes | 01:02:03 | timer | exclude_millis=yes | | Should Be Equal | ${time}          | 04:07:03          |</p> Source code in <code>src/robot/libraries/DateTime.py</code> <pre><code>def add_time_to_time(time1, time2, result_format='number',\n                     exclude_millis=False):\n    \"\"\"Adds time to another time and returns the resulting time.\n\n    Arguments:\n    - ``time1:``          First time in one of the supported `time formats`.\n    - ``time2:``          Second time in one of the supported `time formats`.\n    - ``result_format:``  Format of the returned time.\n    - ``exclude_millis:`` When set to any true value, rounds and drops\n                          milliseconds as explained in `millisecond handling`.\n\n    Examples:\n    | ${time} =       | Add Time To Time | 1 minute          | 42       |\n    | Should Be Equal | ${time}          | ${102}            |\n    | ${time} =       | Add Time To Time | 3 hours 5 minutes | 01:02:03 | timer | exclude_millis=yes |\n    | Should Be Equal | ${time}          | 04:07:03          |\n    \"\"\"\n    time = Time(time1) + Time(time2)\n    return time.convert(result_format, millis=not exclude_millis)\n</code></pre>"},{"location":"api/robot/libraries/DateTime/#robot.libraries.DateTime.subtract_time_from_time","title":"subtract_time_from_time","text":"<pre><code>subtract_time_from_time(\n    time1,\n    time2,\n    result_format=\"number\",\n    exclude_millis=False,\n)\n</code></pre> <p>Subtracts time from another time and returns the resulting time.</p> <ul> <li><code>time1:</code>          Time to subtract another time from in one of                       the supported <code>time formats</code>.</li> <li><code>time2:</code>          Time to subtract in one of the supported <code>time formats</code>.</li> <li><code>result_format:</code>  Format of the returned time.</li> <li><code>exclude_millis:</code> When set to any true value, rounds and drops                       milliseconds as explained in <code>millisecond handling</code>.</li> </ul> <p>Examples: | ${time} =       | Subtract Time From Time | 00:02:30 | 100      | | Should Be Equal | ${time}                 | ${50}    | | ${time} =       | Subtract Time From Time | ${time}  | 1 minute | compact | | Should Be Equal | ${time}                 | - 10s    |</p> Source code in <code>src/robot/libraries/DateTime.py</code> <pre><code>def subtract_time_from_time(time1, time2, result_format='number',\n                            exclude_millis=False):\n    \"\"\"Subtracts time from another time and returns the resulting time.\n\n    Arguments:\n    - ``time1:``          Time to subtract another time from in one of\n                          the supported `time formats`.\n    - ``time2:``          Time to subtract in one of the supported `time formats`.\n    - ``result_format:``  Format of the returned time.\n    - ``exclude_millis:`` When set to any true value, rounds and drops\n                          milliseconds as explained in `millisecond handling`.\n\n    Examples:\n    | ${time} =       | Subtract Time From Time | 00:02:30 | 100      |\n    | Should Be Equal | ${time}                 | ${50}    |\n    | ${time} =       | Subtract Time From Time | ${time}  | 1 minute | compact |\n    | Should Be Equal | ${time}                 | - 10s    |\n    \"\"\"\n    time = Time(time1) - Time(time2)\n    return time.convert(result_format, millis=not exclude_millis)\n</code></pre>"},{"location":"api/robot/libraries/Dialogs/","title":"robot.libraries.Dialogs","text":""},{"location":"api/robot/libraries/Dialogs/#robot.libraries.Dialogs","title":"robot.libraries.Dialogs","text":"<p>A library providing dialogs for interacting with users.</p> <p><code>Dialogs</code> is Robot Framework's standard library that provides means for pausing the test or task execution and getting input from users.</p> <p>Long lines in the provided messages are wrapped automatically. If you want to wrap lines manually, you can add newlines using the <code>\\n</code> character sequence.</p> <p>The library has a known limitation that it cannot be used with timeouts.</p>"},{"location":"api/robot/libraries/Dialogs/#robot.libraries.Dialogs.pause_execution","title":"pause_execution","text":"<pre><code>pause_execution(\n    message=\"Execution paused. Press OK to continue.\",\n)\n</code></pre> <p>Pauses execution until user clicks <code>Ok</code> button.</p> <p><code>message</code> is the message shown in the dialog.</p> Source code in <code>src/robot/libraries/Dialogs.py</code> <pre><code>def pause_execution(message='Execution paused. Press OK to continue.'):\n    \"\"\"Pauses execution until user clicks ``Ok`` button.\n\n    ``message`` is the message shown in the dialog.\n    \"\"\"\n    MessageDialog(message).show()\n</code></pre>"},{"location":"api/robot/libraries/Dialogs/#robot.libraries.Dialogs.execute_manual_step","title":"execute_manual_step","text":"<pre><code>execute_manual_step(message, default_error='')\n</code></pre> <p>Pauses execution until user sets the keyword status.</p> <p>User can press either <code>PASS</code> or <code>FAIL</code> button. In the latter case execution fails and an additional dialog is opened for defining the error message.</p> <p><code>message</code> is the instruction shown in the initial dialog and <code>default_error</code> is the default value shown in the possible error message dialog.</p> Source code in <code>src/robot/libraries/Dialogs.py</code> <pre><code>def execute_manual_step(message, default_error=''):\n    \"\"\"Pauses execution until user sets the keyword status.\n\n    User can press either ``PASS`` or ``FAIL`` button. In the latter case execution\n    fails and an additional dialog is opened for defining the error message.\n\n    ``message`` is the instruction shown in the initial dialog and\n    ``default_error`` is the default value shown in the possible error message\n    dialog.\n    \"\"\"\n    if not _validate_user_input(PassFailDialog(message)):\n        msg = get_value_from_user('Give error message:', default_error)\n        raise AssertionError(msg)\n</code></pre>"},{"location":"api/robot/libraries/Dialogs/#robot.libraries.Dialogs.get_value_from_user","title":"get_value_from_user","text":"<pre><code>get_value_from_user(\n    message, default_value=\"\", hidden=False\n)\n</code></pre> <p>Pauses execution and asks user to input a value.</p> <p>Value typed by the user, or the possible default value, is returned. Returning an empty value is fine, but pressing <code>Cancel</code> fails the keyword.</p> <p><code>message</code> is the instruction shown in the dialog and <code>default_value</code> is the possible default value shown in the input field.</p> <p>If <code>hidden</code> is given a true value, the value typed by the user is hidden. <code>hidden</code> is considered true if it is a non-empty string not equal to <code>false</code>, <code>none</code> or <code>no</code>, case-insensitively. If it is not a string, its truth value is got directly using same [http://docs.python.org/library/stdtypes.html#truth|rules as in Python].</p> <p>Example: | ${username} = | Get Value From User | Input user name | default    | | ${password} = | Get Value From User | Input password  | hidden=yes |</p> Source code in <code>src/robot/libraries/Dialogs.py</code> <pre><code>def get_value_from_user(message, default_value='', hidden=False):\n    \"\"\"Pauses execution and asks user to input a value.\n\n    Value typed by the user, or the possible default value, is returned.\n    Returning an empty value is fine, but pressing ``Cancel`` fails the keyword.\n\n    ``message`` is the instruction shown in the dialog and ``default_value`` is\n    the possible default value shown in the input field.\n\n    If ``hidden`` is given a true value, the value typed by the user is hidden.\n    ``hidden`` is considered true if it is a non-empty string not equal to\n    ``false``, ``none`` or ``no``, case-insensitively. If it is not a string,\n    its truth value is got directly using same\n    [http://docs.python.org/library/stdtypes.html#truth|rules as in Python].\n\n    Example:\n    | ${username} = | Get Value From User | Input user name | default    |\n    | ${password} = | Get Value From User | Input password  | hidden=yes |\n    \"\"\"\n    return _validate_user_input(InputDialog(message, default_value,\n                                            is_truthy(hidden)))\n</code></pre>"},{"location":"api/robot/libraries/Dialogs/#robot.libraries.Dialogs.get_selection_from_user","title":"get_selection_from_user","text":"<pre><code>get_selection_from_user(message, *values, default=None)\n</code></pre> <p>Pauses execution and asks user to select a value.</p> <p>The selected value is returned. Pressing <code>Cancel</code> fails the keyword.</p> <p><code>message</code> is the instruction shown in the dialog, <code>values</code> are the options given to the user and <code>default</code> is the optional default value.</p> <p>The default value can either be one of the specified values or the index of the value starting from <code>1</code>. For example, <code>default=user1</code> and <code>default=1</code> in the examples below have the exact same effect.</p> <p>Example: | ${user} = | Get Selection From User | Select user | user1 | user2 | admin | | ${user} = | Get Selection From User | Select user | user1 | user2 | admin | default=user1 | | ${user} = | Get Selection From User | Select user | user1 | user2 | admin | default=1 |</p> <p><code>default</code> is new in Robot Framework 7.1.</p> Source code in <code>src/robot/libraries/Dialogs.py</code> <pre><code>def get_selection_from_user(message, *values, default=None):\n    \"\"\"Pauses execution and asks user to select a value.\n\n    The selected value is returned. Pressing ``Cancel`` fails the keyword.\n\n    ``message`` is the instruction shown in the dialog, ``values`` are\n    the options given to the user and ``default`` is the optional default value.\n\n    The default value can either be one of the specified values or the index of\n    the value starting from ``1``. For example, ``default=user1`` and ``default=1``\n    in the examples below have the exact same effect.\n\n    Example:\n    | ${user} = | Get Selection From User | Select user | user1 | user2 | admin |\n    | ${user} = | Get Selection From User | Select user | user1 | user2 | admin | default=user1 |\n    | ${user} = | Get Selection From User | Select user | user1 | user2 | admin | default=1 |\n\n    ``default`` is new in Robot Framework 7.1.\n    \"\"\"\n    return _validate_user_input(SelectionDialog(message, values, default))\n</code></pre>"},{"location":"api/robot/libraries/Dialogs/#robot.libraries.Dialogs.get_selections_from_user","title":"get_selections_from_user","text":"<pre><code>get_selections_from_user(message, *values)\n</code></pre> <p>Pauses execution and asks user to select multiple values.</p> <p>The selected values are returned as a list. Selecting no values is OK and in that case the returned list is empty. Pressing <code>Cancel</code> fails the keyword.</p> <p><code>message</code> is the instruction shown in the dialog and <code>values</code> are the options given to the user.</p> <p>Example: | ${users} = | Get Selections From User | Select users | user1 | user2 | admin |</p> Source code in <code>src/robot/libraries/Dialogs.py</code> <pre><code>def get_selections_from_user(message, *values):\n    \"\"\"Pauses execution and asks user to select multiple values.\n\n    The selected values are returned as a list. Selecting no values is OK\n    and in that case the returned list is empty. Pressing ``Cancel`` fails\n    the keyword.\n\n    ``message`` is the instruction shown in the dialog and ``values`` are\n    the options given to the user.\n\n    Example:\n    | ${users} = | Get Selections From User | Select users | user1 | user2 | admin |\n    \"\"\"\n    return _validate_user_input(MultipleSelectionDialog(message, values))\n</code></pre>"},{"location":"api/robot/libraries/Easter/","title":"robot.libraries.Easter","text":""},{"location":"api/robot/libraries/Easter/#robot.libraries.Easter","title":"robot.libraries.Easter","text":""},{"location":"api/robot/libraries/OperatingSystem/","title":"robot.libraries.OperatingSystem","text":""},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem","title":"robot.libraries.OperatingSystem","text":""},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem","title":"OperatingSystem","text":"<p>A library providing keywords for operating system related tasks.</p> <p><code>OperatingSystem</code> is Robot Framework's standard library that enables various operating system related tasks to be performed in the system where Robot Framework is running. It can, among other things, execute commands (e.g. <code>Run</code>), create and remove files and directories (e.g. <code>Create File</code>, <code>Remove Directory</code>), check whether files or directories exists or contain something (e.g. <code>File Should Exist</code>, <code>Directory Should Be Empty</code>) and manipulate environment variables (e.g. <code>Set Environment Variable</code>).</p> <p>== Table of contents ==</p> <p>%TOC%</p> <p>= Path separators =</p> <p>Because Robot Framework uses the backslash (<code>\\</code>) as an escape character in its data, using a literal backslash requires duplicating it like in <code>c:\\\\path\\\\file.txt</code>. That can be inconvenient especially with longer Windows paths, and thus all keywords expecting paths as arguments convert forward slashes to backslashes automatically on Windows. This also means that paths like <code>${CURDIR}/path/file.txt</code> are operating system independent.</p> <p>Notice that the automatic path separator conversion does not work if the path is only a part of an argument like with the <code>Run</code> keyword. In these cases the built-in variable <code>${/}</code> that contains <code>\\</code> or <code>/</code>, depending on the operating system, can be used instead.</p> <p>= Pattern matching =</p> <p>Many keywords accept arguments as either glob or regular expression patterns.</p> <p>== Glob patterns ==</p> <p>Some keywords, for example <code>List Directory</code>, support so called [http://en.wikipedia.org/wiki/Glob_(programming)|glob patterns] where:</p> <p>| <code>*</code>        | matches any string, even an empty string                | | <code>?</code>        | matches any single character                            | | <code>[chars]</code>  | matches one character in the bracket                    | | <code>[!chars]</code> | matches one character not in the bracket                | | <code>[a-z]</code>    | matches one character from the range in the bracket     | | <code>[!a-z]</code>   | matches one character not from the range in the bracket |</p> <p>Unless otherwise noted, matching is case-insensitive on case-insensitive operating systems such as Windows.</p> <p>== Regular expressions ==</p> <p>Some keywords, for example <code>Grep File</code>, support [http://en.wikipedia.org/wiki/Regular_expression|regular expressions] that are more powerful but also more complicated that glob patterns. The regular expression support is implemented using Python's [http://docs.python.org/library/re.html|re module] and its documentation should be consulted for more information about the syntax.</p> <p>Because the backslash character (<code>\\</code>) is an escape character in Robot Framework data, possible backslash characters in regular expressions need to be escaped with another backslash like <code>\\\\d\\\\w+</code>. Strings that may contain special characters but should be handled as literal strings, can be escaped with the <code>Regexp Escape</code> keyword from the BuiltIn library.</p> <p>= Tilde expansion =</p> <p>Paths beginning with <code>~</code> or <code>~username</code> are expanded to the current or specified user's home directory, respectively. The resulting path is operating system dependent, but typically e.g. <code>~/robot</code> is expanded to <code>C:\\Users\\&lt;user&gt;\\robot</code> on Windows and <code>/home/&lt;user&gt;/robot</code> on Unixes.</p> <p>= pathlib.Path support =</p> <p>Starting from Robot Framework 6.0, arguments representing paths can be given as [https://docs.python.org/3/library/pathlib.html|pathlib.Path] instances in addition to strings.</p> <p>All keywords returning paths return them as strings. This may change in the future so that the return value type matches the argument type.</p> <p>= Boolean arguments =</p> <p>Some keywords accept arguments that are handled as Boolean values true or false. If such an argument is given as a string, it is considered false if it is an empty string or equal to <code>FALSE</code>, <code>NONE</code>, <code>NO</code>, <code>OFF</code> or <code>0</code>, case-insensitively. Other strings are considered true regardless their value, and other argument types are tested using the same [http://docs.python.org/library/stdtypes.html#truth|rules as in Python].</p> <p>True examples: | <code>Remove Directory</code> | ${path} | recursive=True    | # Strings are generally true.    | | <code>Remove Directory</code> | ${path} | recursive=yes     | # Same as the above.             | | <code>Remove Directory</code> | ${path} | recursive=${TRUE} | # Python <code>True</code> is true.       | | <code>Remove Directory</code> | ${path} | recursive=${42}   | # Numbers other than 0 are true. |</p> <p>False examples: | <code>Remove Directory</code> | ${path} | recursive=False    | # String <code>false</code> is false.   | | <code>Remove Directory</code> | ${path} | recursive=no       | # Also string <code>no</code> is false. | | <code>Remove Directory</code> | ${path} | recursive=${EMPTY} | # Empty string is false.       | | <code>Remove Directory</code> | ${path} | recursive=${FALSE} | # Python <code>False</code> is false.   |</p> <p>= Example =</p> <p>| * Settings  | Library         OperatingSystem | |  Variables  | ${PATH}         ${CURDIR}/example.txt | |  Test Cases *** | Example |     <code>Create File</code>          ${PATH}    Some text |     <code>File Should Exist</code>    ${PATH} |     <code>Copy File</code>            ${PATH}    ~/file.txt</p>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.run","title":"run","text":"<pre><code>run(command)\n</code></pre> <p>Runs the given command in the system and returns the output.</p> <p>The execution status of the command is not checked by this keyword, and it must be done separately based on the returned output. If the execution return code is needed, either <code>Run And Return RC</code> or <code>Run And Return RC And Output</code> can be used.</p> <p>The standard error stream is automatically redirected to the standard output stream by adding <code>2&gt;&amp;1</code> after the executed command. This automatic redirection is done only when the executed command does not contain additional output redirections. You can thus freely forward the standard error somewhere else, for example, like <code>my_command 2&gt;stderr.txt</code>.</p> <p>The returned output contains everything written into the standard output or error streams by the command (unless either of them is redirected explicitly). Many commands add an extra newline (<code>\\n</code>) after the output to make it easier to read in the console. To ease processing the returned output, this possible trailing newline is stripped by this keyword.</p> <p>Examples: | ${output} =        | Run       | ls -lhF /tmp | | Log                | ${output} | | ${result} =        | Run       | ${CURDIR}${/}tester.py arg1 arg2 | | Should Not Contain | ${result} | FAIL | | ${stdout} =        | Run       | /opt/script.sh 2&gt;/tmp/stderr.txt | | Should Be Equal    | ${stdout} | TEST PASSED | | File Should Be Empty | /tmp/stderr.txt |</p> <p>TIP: <code>Run Process</code> keyword provided by the [http://robotframework.org/robotframework/latest/libraries/Process.html| Process library] supports better process configuration and is generally recommended as a replacement for this keyword.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def run(self, command):\n    \"\"\"Runs the given command in the system and returns the output.\n\n    The execution status of the command *is not checked* by this\n    keyword, and it must be done separately based on the returned\n    output. If the execution return code is needed, either `Run\n    And Return RC` or `Run And Return RC And Output` can be used.\n\n    The standard error stream is automatically redirected to the standard\n    output stream by adding ``2&gt;&amp;1`` after the executed command. This\n    automatic redirection is done only when the executed command does not\n    contain additional output redirections. You can thus freely forward\n    the standard error somewhere else, for example, like\n    ``my_command 2&gt;stderr.txt``.\n\n    The returned output contains everything written into the standard\n    output or error streams by the command (unless either of them\n    is redirected explicitly). Many commands add an extra newline\n    (``\\\\n``) after the output to make it easier to read in the\n    console. To ease processing the returned output, this possible\n    trailing newline is stripped by this keyword.\n\n    Examples:\n    | ${output} =        | Run       | ls -lhF /tmp |\n    | Log                | ${output} |\n    | ${result} =        | Run       | ${CURDIR}${/}tester.py arg1 arg2 |\n    | Should Not Contain | ${result} | FAIL |\n    | ${stdout} =        | Run       | /opt/script.sh 2&gt;/tmp/stderr.txt |\n    | Should Be Equal    | ${stdout} | TEST PASSED |\n    | File Should Be Empty | /tmp/stderr.txt |\n\n    *TIP:* `Run Process` keyword provided by the\n    [http://robotframework.org/robotframework/latest/libraries/Process.html|\n    Process library] supports better process configuration and is generally\n    recommended as a replacement for this keyword.\n    \"\"\"\n    return self._run(command)[1]\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.run_and_return_rc","title":"run_and_return_rc","text":"<pre><code>run_and_return_rc(command)\n</code></pre> <p>Runs the given command in the system and returns the return code.</p> <p>The return code (RC) is returned as a positive integer in range from 0 to 255 as returned by the executed command. On some operating systems (notable Windows) original return codes can be something else, but this keyword always maps them to the 0-255 range. Since the RC is an integer, it must be checked e.g. with the keyword <code>Should Be Equal As Integers</code> instead of <code>Should Be Equal</code> (both are built-in keywords).</p> <p>Examples: | ${rc} = | Run and Return RC | ${CURDIR}${/}script.py arg | | Should Be Equal As Integers | ${rc} | 0 | | ${rc} = | Run and Return RC | /path/to/example.rb arg1 arg2 | | Should Be True | 0 &lt; ${rc} &lt; 42 |</p> <p>See <code>Run</code> and <code>Run And Return RC And Output</code> if you need to get the output of the executed command.</p> <p>TIP: <code>Run Process</code> keyword provided by the [http://robotframework.org/robotframework/latest/libraries/Process.html| Process library] supports better process configuration and is generally recommended as a replacement for this keyword.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def run_and_return_rc(self, command):\n    \"\"\"Runs the given command in the system and returns the return code.\n\n    The return code (RC) is returned as a positive integer in\n    range from 0 to 255 as returned by the executed command. On\n    some operating systems (notable Windows) original return codes\n    can be something else, but this keyword always maps them to\n    the 0-255 range. Since the RC is an integer, it must be\n    checked e.g. with the keyword `Should Be Equal As Integers`\n    instead of `Should Be Equal` (both are built-in keywords).\n\n    Examples:\n    | ${rc} = | Run and Return RC | ${CURDIR}${/}script.py arg |\n    | Should Be Equal As Integers | ${rc} | 0 |\n    | ${rc} = | Run and Return RC | /path/to/example.rb arg1 arg2 |\n    | Should Be True | 0 &lt; ${rc} &lt; 42 |\n\n    See `Run` and `Run And Return RC And Output` if you need to get the\n    output of the executed command.\n\n    *TIP:* `Run Process` keyword provided by the\n    [http://robotframework.org/robotframework/latest/libraries/Process.html|\n    Process library] supports better process configuration and is generally\n    recommended as a replacement for this keyword.\n    \"\"\"\n    return self._run(command)[0]\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.run_and_return_rc_and_output","title":"run_and_return_rc_and_output","text":"<pre><code>run_and_return_rc_and_output(command)\n</code></pre> <p>Runs the given command in the system and returns the RC and output.</p> <p>The return code (RC) is returned similarly as with <code>Run And Return RC</code> and the output similarly as with <code>Run</code>.</p> <p>Examples: | ${rc} | ${output} =  | Run and Return RC and Output | ${CURDIR}${/}mytool | | Should Be Equal As Integers | ${rc}    | 0    | | Should Not Contain   | ${output}       | FAIL | | ${rc} | ${stdout} =  | Run and Return RC and Output | /opt/script.sh 2&gt;/tmp/stderr.txt | | Should Be True       | ${rc} &gt; 42      | | Should Be Equal      | ${stdout}       | TEST PASSED | | File Should Be Empty | /tmp/stderr.txt |</p> <p>TIP: <code>Run Process</code> keyword provided by the [http://robotframework.org/robotframework/latest/libraries/Process.html| Process library] supports better process configuration and is generally recommended as a replacement for this keyword.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def run_and_return_rc_and_output(self, command):\n    \"\"\"Runs the given command in the system and returns the RC and output.\n\n    The return code (RC) is returned similarly as with `Run And Return RC`\n    and the output similarly as with `Run`.\n\n    Examples:\n    | ${rc} | ${output} =  | Run and Return RC and Output | ${CURDIR}${/}mytool |\n    | Should Be Equal As Integers | ${rc}    | 0    |\n    | Should Not Contain   | ${output}       | FAIL |\n    | ${rc} | ${stdout} =  | Run and Return RC and Output | /opt/script.sh 2&gt;/tmp/stderr.txt |\n    | Should Be True       | ${rc} &gt; 42      |\n    | Should Be Equal      | ${stdout}       | TEST PASSED |\n    | File Should Be Empty | /tmp/stderr.txt |\n\n    *TIP:* `Run Process` keyword provided by the\n    [http://robotframework.org/robotframework/latest/libraries/Process.html|\n    Process library] supports better process configuration and is generally\n    recommended as a replacement for this keyword.\n    \"\"\"\n    return self._run(command)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.get_file","title":"get_file","text":"<pre><code>get_file(path, encoding='UTF-8', encoding_errors='strict')\n</code></pre> <p>Returns the contents of a specified file.</p> <p>This keyword reads the specified file and returns the contents. Line breaks in content are converted to platform independent form. See also <code>Get Binary File</code>.</p> <p><code>encoding</code> defines the encoding of the file. The default value is <code>UTF-8</code>, which means that UTF-8 and ASCII encoded files are read correctly. In addition to the encodings supported by the underlying Python implementation, the following special encoding values can be used:</p> <ul> <li><code>SYSTEM</code>: Use the default system encoding.</li> <li><code>CONSOLE</code>: Use the console encoding. Outside Windows this is same   as the system encoding.</li> </ul> <p><code>encoding_errors</code> argument controls what to do if decoding some bytes fails. All values accepted by <code>decode</code> method in Python are valid, but in practice the following values are most useful:</p> <ul> <li><code>strict</code>: Fail if characters cannot be decoded (default).</li> <li><code>ignore</code>: Ignore characters that cannot be decoded.</li> <li><code>replace</code>: Replace characters that cannot be decoded with   a replacement character.</li> </ul> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def get_file(self, path, encoding='UTF-8', encoding_errors='strict'):\n    \"\"\"Returns the contents of a specified file.\n\n    This keyword reads the specified file and returns the contents.\n    Line breaks in content are converted to platform independent form.\n    See also `Get Binary File`.\n\n    ``encoding`` defines the encoding of the file. The default value is\n    ``UTF-8``, which means that UTF-8 and ASCII encoded files are read\n    correctly. In addition to the encodings supported by the underlying\n    Python implementation, the following special encoding values can be\n    used:\n\n    - ``SYSTEM``: Use the default system encoding.\n    - ``CONSOLE``: Use the console encoding. Outside Windows this is same\n      as the system encoding.\n\n    ``encoding_errors`` argument controls what to do if decoding some bytes\n    fails. All values accepted by ``decode`` method in Python are valid, but\n    in practice the following values are most useful:\n\n    - ``strict``: Fail if characters cannot be decoded (default).\n    - ``ignore``: Ignore characters that cannot be decoded.\n    - ``replace``: Replace characters that cannot be decoded with\n      a replacement character.\n    \"\"\"\n    path = self._absnorm(path)\n    self._link(\"Getting file '%s'.\", path)\n    encoding = self._map_encoding(encoding)\n    # Using `newline=None` (default) and not converting `\\r\\n` -&gt; `\\n`\n    # ourselves would be better but some of our own acceptance tests\n    # depend on these semantics. Best solution would probably be making\n    # `newline` configurable.\n    # FIXME: Make `newline` configurable or at least submit an issue about that.\n    with open(path, encoding=encoding, errors=encoding_errors, newline='') as f:\n        return f.read().replace('\\r\\n', '\\n')\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.get_binary_file","title":"get_binary_file","text":"<pre><code>get_binary_file(path)\n</code></pre> <p>Returns the contents of a specified file.</p> <p>This keyword reads the specified file and returns the contents as is. See also <code>Get File</code>.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def get_binary_file(self, path):\n    \"\"\"Returns the contents of a specified file.\n\n    This keyword reads the specified file and returns the contents as is.\n    See also `Get File`.\n    \"\"\"\n    path = self._absnorm(path)\n    self._link(\"Getting file '%s'.\", path)\n    with open(path, 'rb') as f:\n        return f.read()\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.grep_file","title":"grep_file","text":"<pre><code>grep_file(\n    path,\n    pattern,\n    encoding=\"UTF-8\",\n    encoding_errors=\"strict\",\n    regexp=False,\n)\n</code></pre> <p>Returns the lines of the specified file that match the <code>pattern</code>.</p> <p>This keyword reads a file from the file system using the defined <code>path</code>, <code>encoding</code> and <code>encoding_errors</code> similarly as <code>Get File</code>. A difference is that only the lines that match the given <code>pattern</code> are returned. Lines are returned as a single string concatenated back together with newlines and the number of matched lines is automatically logged. Possible trailing newline is never returned.</p> <p>A line matches if it contains the <code>pattern</code> anywhere in it i.e. it does not need to match the pattern fully. There are two supported pattern types:</p> <ul> <li>By default the pattern is considered a glob pattern where, for example,   <code>*</code> and <code>?</code> can be used as wildcards.</li> <li>If the <code>regexp</code> argument is given a true value, the pattern is   considered to be a regular expression. These patterns are more   powerful but also more complicated than glob patterns. They often use   the backslash character and it needs to be escaped in Robot Framework   date like <code>\\\\</code>.</li> </ul> <p>For more information about glob and regular expression syntax, see the <code>Pattern matching</code> section. With this keyword matching is always case-sensitive.</p> <p>Examples: | ${errors} = | Grep File | /var/log/myapp.log | ERROR | | ${ret} = | Grep File | ${CURDIR}/file.txt | [Ww]ildc??d exple | | ${ret} = | Grep File | ${CURDIR}/file.txt | [Ww]ildc\\w+d ex.ple | regexp=True |</p> <p>Special encoding values <code>SYSTEM</code> and <code>CONSOLE</code> that <code>Get File</code> supports are supported by this keyword only with Robot Framework 4.0 and newer.</p> <p>Support for regular expressions is new in Robot Framework 5.0.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def grep_file(self, path, pattern, encoding='UTF-8', encoding_errors='strict',\n              regexp=False):\n    r\"\"\"Returns the lines of the specified file that match the ``pattern``.\n\n    This keyword reads a file from the file system using the defined\n    ``path``, ``encoding`` and ``encoding_errors`` similarly as `Get File`.\n    A difference is that only the lines that match the given ``pattern`` are\n    returned. Lines are returned as a single string concatenated back together\n    with newlines and the number of matched lines is automatically logged.\n    Possible trailing newline is never returned.\n\n    A line matches if it contains the ``pattern`` anywhere in it i.e. it does\n    not need to match the pattern fully. There are two supported pattern types:\n\n    - By default the pattern is considered a _glob_ pattern where, for example,\n      ``*`` and ``?`` can be used as wildcards.\n    - If the ``regexp`` argument is given a true value, the pattern is\n      considered to be a _regular expression_. These patterns are more\n      powerful but also more complicated than glob patterns. They often use\n      the backslash character and it needs to be escaped in Robot Framework\n      date like `\\\\`.\n\n    For more information about glob and regular expression syntax, see\n    the `Pattern matching` section. With this keyword matching is always\n    case-sensitive.\n\n    Examples:\n    | ${errors} = | Grep File | /var/log/myapp.log | ERROR |\n    | ${ret} = | Grep File | ${CURDIR}/file.txt | [Ww]ildc??d ex*ple |\n    | ${ret} = | Grep File | ${CURDIR}/file.txt | [Ww]ildc\\\\w+d ex.*ple | regexp=True |\n\n    Special encoding values ``SYSTEM`` and ``CONSOLE`` that `Get File` supports\n    are supported by this keyword only with Robot Framework 4.0 and newer.\n\n    Support for regular expressions is new in Robot Framework 5.0.\n    \"\"\"\n    path = self._absnorm(path)\n    if not regexp:\n        pattern = fnmatch.translate(f'{pattern}*')\n    reobj = re.compile(pattern)\n    encoding = self._map_encoding(encoding)\n    lines = []\n    total_lines = 0\n    self._link(\"Reading file '%s'.\", path)\n    with open(path, encoding=encoding, errors=encoding_errors) as file:\n        for line in file:\n            total_lines += 1\n            line = line.rstrip('\\r\\n')\n            if reobj.search(line):\n                lines.append(line)\n        self._info('%d out of %d lines matched' % (len(lines), total_lines))\n        return '\\n'.join(lines)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.log_file","title":"log_file","text":"<pre><code>log_file(path, encoding='UTF-8', encoding_errors='strict')\n</code></pre> <p>Wrapper for <code>Get File</code> that also logs the returned file.</p> <p>The file is logged with the INFO level. If you want something else, just use <code>Get File</code> and the built-in keyword <code>Log</code> with the desired level.</p> <p>See <code>Get File</code> for more information about <code>encoding</code> and <code>encoding_errors</code> arguments.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def log_file(self, path, encoding='UTF-8', encoding_errors='strict'):\n    \"\"\"Wrapper for `Get File` that also logs the returned file.\n\n    The file is logged with the INFO level. If you want something else,\n    just use `Get File` and the built-in keyword `Log` with the desired\n    level.\n\n    See `Get File` for more information about ``encoding`` and\n    ``encoding_errors`` arguments.\n    \"\"\"\n    content = self.get_file(path, encoding, encoding_errors)\n    self._info(content)\n    return content\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.should_exist","title":"should_exist","text":"<pre><code>should_exist(path, msg=None)\n</code></pre> <p>Fails unless the given path (file or directory) exists.</p> <p>The path can be given as an exact path or as a glob pattern. See the <code>Glob patterns</code> section for details about the supported syntax.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def should_exist(self, path, msg=None):\n    \"\"\"Fails unless the given path (file or directory) exists.\n\n    The path can be given as an exact path or as a glob pattern.\n    See the `Glob patterns` section for details about the supported syntax.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    path = self._absnorm(path)\n    if not self._glob(path):\n        self._fail(msg, \"Path '%s' does not exist.\" % path)\n    self._link(\"Path '%s' exists.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.should_not_exist","title":"should_not_exist","text":"<pre><code>should_not_exist(path, msg=None)\n</code></pre> <p>Fails if the given path (file or directory) exists.</p> <p>The path can be given as an exact path or as a glob pattern. See the <code>Glob patterns</code> section for details about the supported syntax.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def should_not_exist(self, path, msg=None):\n    \"\"\"Fails if the given path (file or directory) exists.\n\n    The path can be given as an exact path or as a glob pattern.\n    See the `Glob patterns` section for details about the supported syntax.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    path = self._absnorm(path)\n    matches = self._glob(path)\n    if matches:\n        self._fail(msg, self._get_matches_error('Path', path, matches))\n    self._link(\"Path '%s' does not exist.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.file_should_exist","title":"file_should_exist","text":"<pre><code>file_should_exist(path, msg=None)\n</code></pre> <p>Fails unless the given <code>path</code> points to an existing file.</p> <p>The path can be given as an exact path or as a glob pattern. See the <code>Glob patterns</code> section for details about the supported syntax.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def file_should_exist(self, path, msg=None):\n    \"\"\"Fails unless the given ``path`` points to an existing file.\n\n    The path can be given as an exact path or as a glob pattern.\n    See the `Glob patterns` section for details about the supported syntax.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    path = self._absnorm(path)\n    matches = [p for p in self._glob(path) if os.path.isfile(p)]\n    if not matches:\n        self._fail(msg, \"File '%s' does not exist.\" % path)\n    self._link(\"File '%s' exists.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.file_should_not_exist","title":"file_should_not_exist","text":"<pre><code>file_should_not_exist(path, msg=None)\n</code></pre> <p>Fails if the given path points to an existing file.</p> <p>The path can be given as an exact path or as a glob pattern. See the <code>Glob patterns</code> section for details about the supported syntax.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def file_should_not_exist(self, path, msg=None):\n    \"\"\"Fails if the given path points to an existing file.\n\n    The path can be given as an exact path or as a glob pattern.\n    See the `Glob patterns` section for details about the supported syntax.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    path = self._absnorm(path)\n    matches = [p for p in self._glob(path) if os.path.isfile(p)]\n    if matches:\n        self._fail(msg, self._get_matches_error('File', path, matches))\n    self._link(\"File '%s' does not exist.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.directory_should_exist","title":"directory_should_exist","text":"<pre><code>directory_should_exist(path, msg=None)\n</code></pre> <p>Fails unless the given path points to an existing directory.</p> <p>The path can be given as an exact path or as a glob pattern. See the <code>Glob patterns</code> section for details about the supported syntax.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def directory_should_exist(self, path, msg=None):\n    \"\"\"Fails unless the given path points to an existing directory.\n\n    The path can be given as an exact path or as a glob pattern.\n    See the `Glob patterns` section for details about the supported syntax.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    path = self._absnorm(path)\n    matches = [p for p in self._glob(path) if os.path.isdir(p)]\n    if not matches:\n        self._fail(msg, \"Directory '%s' does not exist.\" % path)\n    self._link(\"Directory '%s' exists.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.directory_should_not_exist","title":"directory_should_not_exist","text":"<pre><code>directory_should_not_exist(path, msg=None)\n</code></pre> <p>Fails if the given path points to an existing file.</p> <p>The path can be given as an exact path or as a glob pattern. See the <code>Glob patterns</code> section for details about the supported syntax.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def directory_should_not_exist(self, path, msg=None):\n    \"\"\"Fails if the given path points to an existing file.\n\n    The path can be given as an exact path or as a glob pattern.\n    See the `Glob patterns` section for details about the supported syntax.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    path = self._absnorm(path)\n    matches = [p for p in self._glob(path) if os.path.isdir(p)]\n    if matches:\n        self._fail(msg, self._get_matches_error('Directory', path, matches))\n    self._link(\"Directory '%s' does not exist.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.wait_until_removed","title":"wait_until_removed","text":"<pre><code>wait_until_removed(path, timeout='1 minute')\n</code></pre> <p>Waits until the given file or directory is removed.</p> <p>The path can be given as an exact path or as a glob pattern. See the <code>Glob patterns</code> section for details about the supported syntax. If the path is a pattern, the keyword waits until all matching items are removed.</p> <p>The optional <code>timeout</code> can be used to control the maximum time of waiting. The timeout is given as a timeout string, e.g. in a format <code>15 seconds</code>, <code>1min 10s</code> or just <code>10</code>. The time string format is described in an appendix of Robot Framework User Guide.</p> <p>If the timeout is negative, the keyword is never timed-out. The keyword returns immediately, if the path does not exist in the first place.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def wait_until_removed(self, path, timeout='1 minute'):\n    \"\"\"Waits until the given file or directory is removed.\n\n    The path can be given as an exact path or as a glob pattern.\n    See the `Glob patterns` section for details about the supported syntax.\n    If the path is a pattern, the keyword waits until all matching\n    items are removed.\n\n    The optional ``timeout`` can be used to control the maximum time of\n    waiting. The timeout is given as a timeout string, e.g. in a format\n    ``15 seconds``, ``1min 10s`` or just ``10``. The time string format is\n    described in an appendix of Robot Framework User Guide.\n\n    If the timeout is negative, the keyword is never timed-out. The keyword\n    returns immediately, if the path does not exist in the first place.\n    \"\"\"\n    path = self._absnorm(path)\n    timeout = timestr_to_secs(timeout)\n    maxtime = time.time() + timeout\n    while self._glob(path):\n        if timeout &gt;= 0 and time.time() &gt; maxtime:\n            self._fail(\"'%s' was not removed in %s.\"\n                       % (path, secs_to_timestr(timeout)))\n        time.sleep(0.1)\n    self._link(\"'%s' was removed.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.wait_until_created","title":"wait_until_created","text":"<pre><code>wait_until_created(path, timeout='1 minute')\n</code></pre> <p>Waits until the given file or directory is created.</p> <p>The path can be given as an exact path or as a glob pattern. See the <code>Glob patterns</code> section for details about the supported syntax. If the path is a pattern, the keyword returns when an item matching it is created.</p> <p>The optional <code>timeout</code> can be used to control the maximum time of waiting. The timeout is given as a timeout string, e.g. in a format <code>15 seconds</code>, <code>1min 10s</code> or just <code>10</code>. The time string format is described in an appendix of Robot Framework User Guide.</p> <p>If the timeout is negative, the keyword is never timed-out. The keyword returns immediately, if the path already exists.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def wait_until_created(self, path, timeout='1 minute'):\n    \"\"\"Waits until the given file or directory is created.\n\n    The path can be given as an exact path or as a glob pattern.\n    See the `Glob patterns` section for details about the supported syntax.\n    If the path is a pattern, the keyword returns when an item matching\n    it is created.\n\n    The optional ``timeout`` can be used to control the maximum time of\n    waiting. The timeout is given as a timeout string, e.g. in a format\n    ``15 seconds``, ``1min 10s`` or just ``10``. The time string format is\n    described in an appendix of Robot Framework User Guide.\n\n    If the timeout is negative, the keyword is never timed-out. The keyword\n    returns immediately, if the path already exists.\n    \"\"\"\n    path = self._absnorm(path)\n    timeout = timestr_to_secs(timeout)\n    maxtime = time.time() + timeout\n    while not self._glob(path):\n        if timeout &gt;= 0 and time.time() &gt; maxtime:\n            self._fail(\"'%s' was not created in %s.\"\n                       % (path, secs_to_timestr(timeout)))\n        time.sleep(0.1)\n    self._link(\"'%s' was created.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.directory_should_be_empty","title":"directory_should_be_empty","text":"<pre><code>directory_should_be_empty(path, msg=None)\n</code></pre> <p>Fails unless the specified directory is empty.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def directory_should_be_empty(self, path, msg=None):\n    \"\"\"Fails unless the specified directory is empty.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    path = self._absnorm(path)\n    items = self._list_dir(path)\n    if items:\n        self._fail(msg, \"Directory '%s' is not empty. Contents: %s.\"\n                        % (path, seq2str(items, lastsep=', ')))\n    self._link(\"Directory '%s' is empty.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.directory_should_not_be_empty","title":"directory_should_not_be_empty","text":"<pre><code>directory_should_not_be_empty(path, msg=None)\n</code></pre> <p>Fails if the specified directory is empty.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def directory_should_not_be_empty(self, path, msg=None):\n    \"\"\"Fails if the specified directory is empty.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    path = self._absnorm(path)\n    items = self._list_dir(path)\n    if not items:\n        self._fail(msg, \"Directory '%s' is empty.\" % path)\n    self._link(\"Directory '%%s' contains %d item%s.\"\n               % (len(items), plural_or_not(items)), path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.file_should_be_empty","title":"file_should_be_empty","text":"<pre><code>file_should_be_empty(path, msg=None)\n</code></pre> <p>Fails unless the specified file is empty.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def file_should_be_empty(self, path, msg=None):\n    \"\"\"Fails unless the specified file is empty.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    path = self._absnorm(path)\n    if not os.path.isfile(path):\n        self._error(\"File '%s' does not exist.\" % path)\n    size = os.stat(path).st_size\n    if size &gt; 0:\n        self._fail(msg,\n                   \"File '%s' is not empty. Size: %d bytes.\" % (path, size))\n    self._link(\"File '%s' is empty.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.file_should_not_be_empty","title":"file_should_not_be_empty","text":"<pre><code>file_should_not_be_empty(path, msg=None)\n</code></pre> <p>Fails if the specified file is empty.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def file_should_not_be_empty(self, path, msg=None):\n    \"\"\"Fails if the specified file is empty.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    path = self._absnorm(path)\n    if not os.path.isfile(path):\n        self._error(\"File '%s' does not exist.\" % path)\n    size = os.stat(path).st_size\n    if size == 0:\n        self._fail(msg, \"File '%s' is empty.\" % path)\n    self._link(\"File '%%s' contains %d bytes.\" % size, path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.create_file","title":"create_file","text":"<pre><code>create_file(path, content='', encoding='UTF-8')\n</code></pre> <p>Creates a file with the given content and encoding.</p> <p>If the directory where the file is created does not exist, it is automatically created along with possible missing intermediate directories. Possible existing file is overwritten.</p> <p>On Windows newline characters (<code>\\n</code>) in content are automatically converted to Windows native newline sequence (<code>\\r\\n</code>).</p> <p>See <code>Get File</code> for more information about possible <code>encoding</code> values, including special values <code>SYSTEM</code> and <code>CONSOLE</code>.</p> <p>Examples: | Create File | ${dir}/example.txt | Hello, world!       |         | | Create File | ${path}            | Hyv\\xe4 esimerkki  | Latin-1 | | Create File | /tmp/foo.txt       | 3\\nlines\\nhere\\n | SYSTEM  |</p> <p>Use <code>Append To File</code> if you want to append to an existing file and <code>Create Binary File</code> if you need to write bytes without encoding. <code>File Should Not Exist</code> can be used to avoid overwriting existing files.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def create_file(self, path, content='', encoding='UTF-8'):\n    \"\"\"Creates a file with the given content and encoding.\n\n    If the directory where the file is created does not exist, it is\n    automatically created along with possible missing intermediate\n    directories. Possible existing file is overwritten.\n\n    On Windows newline characters (``\\\\n``) in content are automatically\n    converted to Windows native newline sequence (``\\\\r\\\\n``).\n\n    See `Get File` for more information about possible ``encoding`` values,\n    including special values ``SYSTEM`` and ``CONSOLE``.\n\n    Examples:\n    | Create File | ${dir}/example.txt | Hello, world!       |         |\n    | Create File | ${path}            | Hyv\\\\xe4 esimerkki  | Latin-1 |\n    | Create File | /tmp/foo.txt       | 3\\\\nlines\\\\nhere\\\\n | SYSTEM  |\n\n    Use `Append To File` if you want to append to an existing file\n    and `Create Binary File` if you need to write bytes without encoding.\n    `File Should Not Exist` can be used to avoid overwriting existing\n    files.\n    \"\"\"\n    path = self._write_to_file(path, content, encoding)\n    self._link(\"Created file '%s'.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.create_binary_file","title":"create_binary_file","text":"<pre><code>create_binary_file(path, content)\n</code></pre> <p>Creates a binary file with the given content.</p> <p>If content is given as a Unicode string, it is first converted to bytes character by character. All characters with ordinal below 256 can be used and are converted to bytes with same values. Using characters with higher ordinal is an error.</p> <p>Byte strings, and possible other types, are written to the file as is.</p> <p>If the directory for the file does not exist, it is created, along with missing intermediate directories.</p> <p>Examples: | Create Binary File | ${dir}/example.png | ${image content} | | Create Binary File | ${path}            | \\x01\\x00\\xe4\\x00 |</p> <p>Use <code>Create File</code> if you want to create a text file using a certain encoding. <code>File Should Not Exist</code> can be used to avoid overwriting existing files.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def create_binary_file(self, path, content):\n    r\"\"\"Creates a binary file with the given content.\n\n    If content is given as a Unicode string, it is first converted to bytes\n    character by character. All characters with ordinal below 256 can be\n    used and are converted to bytes with same values. Using characters\n    with higher ordinal is an error.\n\n    Byte strings, and possible other types, are written to the file as is.\n\n    If the directory for the file does not exist, it is created, along\n    with missing intermediate directories.\n\n    Examples:\n    | Create Binary File | ${dir}/example.png | ${image content} |\n    | Create Binary File | ${path}            | \\x01\\x00\\xe4\\x00 |\n\n    Use `Create File` if you want to create a text file using a certain\n    encoding. `File Should Not Exist` can be used to avoid overwriting\n    existing files.\n    \"\"\"\n    if is_string(content):\n        content = bytes(ord(c) for c in content)\n    path = self._write_to_file(path, content, mode='wb')\n    self._link(\"Created binary file '%s'.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.append_to_file","title":"append_to_file","text":"<pre><code>append_to_file(path, content, encoding='UTF-8')\n</code></pre> <p>Appends the given content to the specified file.</p> <p>If the file exists, the given text is written to its end. If the file does not exist, it is created.</p> <p>Other than not overwriting possible existing files, this keyword works exactly like <code>Create File</code>. See its documentation for more details about the usage.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def append_to_file(self, path, content, encoding='UTF-8'):\n    \"\"\"Appends the given content to the specified file.\n\n    If the file exists, the given text is written to its end. If the file\n    does not exist, it is created.\n\n    Other than not overwriting possible existing files, this keyword works\n    exactly like `Create File`. See its documentation for more details\n    about the usage.\n    \"\"\"\n    path = self._write_to_file(path, content, encoding, mode='a')\n    self._link(\"Appended to file '%s'.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.remove_file","title":"remove_file","text":"<pre><code>remove_file(path)\n</code></pre> <p>Removes a file with the given path.</p> <p>Passes if the file does not exist, but fails if the path does not point to a regular file (e.g. it points to a directory).</p> <p>The path can be given as an exact path or as a glob pattern. See the <code>Glob patterns</code> section for details about the supported syntax. If the path is a pattern, all files matching it are removed.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def remove_file(self, path):\n    \"\"\"Removes a file with the given path.\n\n    Passes if the file does not exist, but fails if the path does\n    not point to a regular file (e.g. it points to a directory).\n\n    The path can be given as an exact path or as a glob pattern.\n    See the `Glob patterns` section for details about the supported syntax.\n    If the path is a pattern, all files matching it are removed.\n    \"\"\"\n    path = self._absnorm(path)\n    matches = self._glob(path)\n    if not matches:\n        self._link(\"File '%s' does not exist.\", path)\n    for match in matches:\n        if not os.path.isfile(match):\n            self._error(\"Path '%s' is not a file.\" % match)\n        os.remove(match)\n        self._link(\"Removed file '%s'.\", match)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.remove_files","title":"remove_files","text":"<pre><code>remove_files(*paths)\n</code></pre> <p>Uses <code>Remove File</code> to remove multiple files one-by-one.</p> <p>Example: | Remove Files | ${TEMPDIR}${/}foo.txt | ${TEMPDIR}${/}bar.txt | ${TEMPDIR}${/}zap.txt |</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def remove_files(self, *paths):\n    \"\"\"Uses `Remove File` to remove multiple files one-by-one.\n\n    Example:\n    | Remove Files | ${TEMPDIR}${/}foo.txt | ${TEMPDIR}${/}bar.txt | ${TEMPDIR}${/}zap.txt |\n    \"\"\"\n    for path in paths:\n        self.remove_file(path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.empty_directory","title":"empty_directory","text":"<pre><code>empty_directory(path)\n</code></pre> <p>Deletes all the content from the given directory.</p> <p>Deletes both files and sub-directories, but the specified directory itself if not removed. Use <code>Remove Directory</code> if you want to remove the whole directory.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def empty_directory(self, path):\n    \"\"\"Deletes all the content from the given directory.\n\n    Deletes both files and sub-directories, but the specified directory\n    itself if not removed. Use `Remove Directory` if you want to remove\n    the whole directory.\n    \"\"\"\n    path = self._absnorm(path)\n    for item in self._list_dir(path, absolute=True):\n        if os.path.isdir(item):\n            shutil.rmtree(item)\n        else:\n            os.remove(item)\n    self._link(\"Emptied directory '%s'.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.create_directory","title":"create_directory","text":"<pre><code>create_directory(path)\n</code></pre> <p>Creates the specified directory.</p> <p>Also possible intermediate directories are created. Passes if the directory already exists, but fails if the path exists and is not a directory.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def create_directory(self, path):\n    \"\"\"Creates the specified directory.\n\n    Also possible intermediate directories are created. Passes if the\n    directory already exists, but fails if the path exists and is not\n    a directory.\n    \"\"\"\n    path = self._absnorm(path)\n    if os.path.isdir(path):\n        self._link(\"Directory '%s' already exists.\", path )\n    elif os.path.exists(path):\n        self._error(\"Path '%s' is not a directory.\" % path)\n    else:\n        os.makedirs(path)\n        self._link(\"Created directory '%s'.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.remove_directory","title":"remove_directory","text":"<pre><code>remove_directory(path, recursive=False)\n</code></pre> <p>Removes the directory pointed to by the given <code>path</code>.</p> <p>If the second argument <code>recursive</code> is given a true value (see <code>Boolean arguments</code>), the directory is removed recursively. Otherwise removing fails if the directory is not empty.</p> <p>If the directory pointed to by the <code>path</code> does not exist, the keyword passes, but it fails, if the <code>path</code> points to a file.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def remove_directory(self, path, recursive=False):\n    \"\"\"Removes the directory pointed to by the given ``path``.\n\n    If the second argument ``recursive`` is given a true value (see\n    `Boolean arguments`), the directory is removed recursively. Otherwise\n    removing fails if the directory is not empty.\n\n    If the directory pointed to by the ``path`` does not exist, the keyword\n    passes, but it fails, if the ``path`` points to a file.\n    \"\"\"\n    path = self._absnorm(path)\n    if not os.path.exists(path):\n        self._link(\"Directory '%s' does not exist.\", path)\n    elif not os.path.isdir(path):\n        self._error(\"Path '%s' is not a directory.\" % path)\n    else:\n        if is_truthy(recursive):\n            shutil.rmtree(path)\n        else:\n            self.directory_should_be_empty(\n                path, \"Directory '%s' is not empty.\" % path)\n            os.rmdir(path)\n        self._link(\"Removed directory '%s'.\", path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.copy_file","title":"copy_file","text":"<pre><code>copy_file(source, destination)\n</code></pre> <p>Copies the source file into the destination.</p> <p>Source must be a path to an existing file or a glob pattern (see <code>Glob patterns</code>) that matches exactly one file. How the destination is interpreted is explained below.</p> <p>1) If the destination is an existing file, the source file is copied over it.</p> <p>2) If the destination is an existing directory, the source file is copied into it. A possible file with the same name as the source is overwritten.</p> <p>3) If the destination does not exist and it ends with a path separator (<code>/</code> or <code>\\</code>), it is considered a directory. That directory is created and a source file copied into it. Possible missing intermediate directories are also created.</p> <p>4) If the destination does not exist and it does not end with a path separator, it is considered a file. If the path to the file does not exist, it is created.</p> <p>The resulting destination path is returned.</p> <p>See also <code>Copy Files</code>, <code>Move File</code>, and <code>Move Files</code>.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def copy_file(self, source, destination):\n    r\"\"\"Copies the source file into the destination.\n\n    Source must be a path to an existing file or a glob pattern (see\n    `Glob patterns`) that matches exactly one file. How the\n    destination is interpreted is explained below.\n\n    1) If the destination is an existing file, the source file is copied\n    over it.\n\n    2) If the destination is an existing directory, the source file is\n    copied into it. A possible file with the same name as the source is\n    overwritten.\n\n    3) If the destination does not exist and it ends with a path\n    separator (``/`` or ``\\``), it is considered a directory. That\n    directory is created and a source file copied into it.\n    Possible missing intermediate directories are also created.\n\n    4) If the destination does not exist and it does not end with a path\n    separator, it is considered a file. If the path to the file does not\n    exist, it is created.\n\n    The resulting destination path is returned.\n\n    See also `Copy Files`, `Move File`, and `Move Files`.\n    \"\"\"\n    source, destination = \\\n        self._prepare_copy_and_move_file(source, destination)\n    if not self._are_source_and_destination_same_file(source, destination):\n        source, destination = self._atomic_copy(source, destination)\n        self._link(\"Copied file from '%s' to '%s'.\", source, destination)\n    return destination\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.move_file","title":"move_file","text":"<pre><code>move_file(source, destination)\n</code></pre> <p>Moves the source file into the destination.</p> <p>Arguments have exactly same semantics as with <code>Copy File</code> keyword. Destination file path is returned.</p> <p>If the source and destination are on the same filesystem, rename operation is used. Otherwise file is copied to the destination filesystem and then removed from the original filesystem.</p> <p>See also <code>Move Files</code>, <code>Copy File</code>, and <code>Copy Files</code>.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def move_file(self, source, destination):\n    \"\"\"Moves the source file into the destination.\n\n    Arguments have exactly same semantics as with `Copy File` keyword.\n    Destination file path is returned.\n\n    If the source and destination are on the same filesystem, rename\n    operation is used. Otherwise file is copied to the destination\n    filesystem and then removed from the original filesystem.\n\n    See also `Move Files`, `Copy File`, and `Copy Files`.\n    \"\"\"\n    source, destination = \\\n        self._prepare_copy_and_move_file(source, destination)\n    if not self._are_source_and_destination_same_file(destination, source):\n        shutil.move(source, destination)\n        self._link(\"Moved file from '%s' to '%s'.\", source, destination)\n    return destination\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.copy_files","title":"copy_files","text":"<pre><code>copy_files(*sources_and_destination)\n</code></pre> <p>Copies specified files to the target directory.</p> <p>Source files can be given as exact paths and as glob patterns (see <code>Glob patterns</code>). At least one source must be given, but it is not an error if it is a pattern that does not match anything.</p> <p>Last argument must be the destination directory. If the destination does not exist, it will be created.</p> <p>Examples: | Copy Files | ${dir}/file1.txt  | ${dir}/file2.txt | ${dir2} | | Copy Files | ${dir}/file-*.txt | ${dir2}          |         |</p> <p>See also <code>Copy File</code>, <code>Move File</code>, and <code>Move Files</code>.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def copy_files(self, *sources_and_destination):\n    \"\"\"Copies specified files to the target directory.\n\n    Source files can be given as exact paths and as glob patterns (see\n    `Glob patterns`). At least one source must be given, but it is\n    not an error if it is a pattern that does not match anything.\n\n    Last argument must be the destination directory. If the destination\n    does not exist, it will be created.\n\n    Examples:\n    | Copy Files | ${dir}/file1.txt  | ${dir}/file2.txt | ${dir2} |\n    | Copy Files | ${dir}/file-*.txt | ${dir2}          |         |\n\n    See also `Copy File`, `Move File`, and `Move Files`.\n    \"\"\"\n    sources, destination \\\n        = self._prepare_copy_and_move_files(sources_and_destination)\n    for source in sources:\n        self.copy_file(source, destination)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.move_files","title":"move_files","text":"<pre><code>move_files(*sources_and_destination)\n</code></pre> <p>Moves specified files to the target directory.</p> <p>Arguments have exactly same semantics as with <code>Copy Files</code> keyword.</p> <p>See also <code>Move File</code>, <code>Copy File</code>, and <code>Copy Files</code>.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def move_files(self, *sources_and_destination):\n    \"\"\"Moves specified files to the target directory.\n\n    Arguments have exactly same semantics as with `Copy Files` keyword.\n\n    See also `Move File`, `Copy File`, and `Copy Files`.\n    \"\"\"\n    sources, destination \\\n        = self._prepare_copy_and_move_files(sources_and_destination)\n    for source in sources:\n        self.move_file(source, destination)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.copy_directory","title":"copy_directory","text":"<pre><code>copy_directory(source, destination)\n</code></pre> <p>Copies the source directory into the destination.</p> <p>If the destination exists, the source is copied under it. Otherwise the destination directory and the possible missing intermediate directories are created.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def copy_directory(self, source, destination):\n    \"\"\"Copies the source directory into the destination.\n\n    If the destination exists, the source is copied under it. Otherwise\n    the destination directory and the possible missing intermediate\n    directories are created.\n    \"\"\"\n    source, destination = self._prepare_copy_and_move_directory(source, destination)\n    shutil.copytree(source, destination)\n    self._link(\"Copied directory from '%s' to '%s'.\", source, destination)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.move_directory","title":"move_directory","text":"<pre><code>move_directory(source, destination)\n</code></pre> <p>Moves the source directory into a destination.</p> <p>Uses <code>Copy Directory</code> keyword internally, and <code>source</code> and <code>destination</code> arguments have exactly same semantics as with that keyword.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def move_directory(self, source, destination):\n    \"\"\"Moves the source directory into a destination.\n\n    Uses `Copy Directory` keyword internally, and ``source`` and\n    ``destination`` arguments have exactly same semantics as with\n    that keyword.\n    \"\"\"\n    source, destination \\\n        = self._prepare_copy_and_move_directory(source, destination)\n    shutil.move(source, destination)\n    self._link(\"Moved directory from '%s' to '%s'.\", source, destination)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.get_environment_variable","title":"get_environment_variable","text":"<pre><code>get_environment_variable(name, default=None)\n</code></pre> <p>Returns the value of an environment variable with the given name.</p> <p>If no environment variable is found, returns possible default value. If no default value is given, the keyword fails.</p> <p>Returned variables are automatically decoded to Unicode using the system encoding.</p> <p>Note that you can also access environment variables directly using the variable syntax <code>%{ENV_VAR_NAME}</code>.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>@keyword(types=None)\ndef get_environment_variable(self, name, default=None):\n    \"\"\"Returns the value of an environment variable with the given name.\n\n    If no environment variable is found, returns possible default value.\n    If no default value is given, the keyword fails.\n\n    Returned variables are automatically decoded to Unicode using\n    the system encoding.\n\n    Note that you can also access environment variables directly using\n    the variable syntax ``%{ENV_VAR_NAME}``.\n    \"\"\"\n    value = get_env_var(name, default)\n    if value is None:\n        self._error(\"Environment variable '%s' does not exist.\" % name)\n    return value\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.set_environment_variable","title":"set_environment_variable","text":"<pre><code>set_environment_variable(name, value)\n</code></pre> <p>Sets an environment variable to a specified value.</p> <p>Values are converted to strings automatically. Set variables are automatically encoded using the system encoding.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def set_environment_variable(self, name, value):\n    \"\"\"Sets an environment variable to a specified value.\n\n    Values are converted to strings automatically. Set variables are\n    automatically encoded using the system encoding.\n    \"\"\"\n    set_env_var(name, value)\n    self._info(\"Environment variable '%s' set to value '%s'.\"\n               % (name, value))\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.append_to_environment_variable","title":"append_to_environment_variable","text":"<pre><code>append_to_environment_variable(name, *values, **config)\n</code></pre> <p>Appends given <code>values</code> to environment variable <code>name</code>.</p> <p>If the environment variable already exists, values are added after it, and otherwise a new environment variable is created.</p> <p>Values are, by default, joined together using the operating system path separator (<code>;</code> on Windows, <code>:</code> elsewhere). This can be changed by giving a separator after the values like <code>separator=value</code>. No other configuration parameters are accepted.</p> <p>Examples (assuming <code>NAME</code> and <code>NAME2</code> do not exist initially): | Append To Environment Variable | NAME     | first  |       | | Should Be Equal                | %{NAME}  | first  |       | | Append To Environment Variable | NAME     | second | third | | Should Be Equal                | %{NAME}  | first${:}second${:}third | | Append To Environment Variable | NAME2    | first  | separator=-     | | Should Be Equal                | %{NAME2} | first  |                 | | Append To Environment Variable | NAME2    | second | separator=-     | | Should Be Equal                | %{NAME2} | first-second             |</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def append_to_environment_variable(self, name, *values, **config):\n    \"\"\"Appends given ``values`` to environment variable ``name``.\n\n    If the environment variable already exists, values are added after it,\n    and otherwise a new environment variable is created.\n\n    Values are, by default, joined together using the operating system\n    path separator (``;`` on Windows, ``:`` elsewhere). This can be changed\n    by giving a separator after the values like ``separator=value``. No\n    other configuration parameters are accepted.\n\n    Examples (assuming ``NAME`` and ``NAME2`` do not exist initially):\n    | Append To Environment Variable | NAME     | first  |       |\n    | Should Be Equal                | %{NAME}  | first  |       |\n    | Append To Environment Variable | NAME     | second | third |\n    | Should Be Equal                | %{NAME}  | first${:}second${:}third |\n    | Append To Environment Variable | NAME2    | first  | separator=-     |\n    | Should Be Equal                | %{NAME2} | first  |                 |\n    | Append To Environment Variable | NAME2    | second | separator=-     |\n    | Should Be Equal                | %{NAME2} | first-second             |\n    \"\"\"\n    sentinel = object()\n    initial = self.get_environment_variable(name, sentinel)\n    if initial is not sentinel:\n        values = (initial,) + values\n    separator = config.pop('separator', os.pathsep)\n    if config:\n        config = ['='.join(i) for i in sorted(config.items())]\n        self._error('Configuration %s not accepted.'\n                    % seq2str(config, lastsep=' or '))\n    self.set_environment_variable(name, separator.join(values))\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.remove_environment_variable","title":"remove_environment_variable","text":"<pre><code>remove_environment_variable(*names)\n</code></pre> <p>Deletes the specified environment variable.</p> <p>Does nothing if the environment variable is not set.</p> <p>It is possible to remove multiple variables by passing them to this keyword as separate arguments.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def remove_environment_variable(self, *names):\n    \"\"\"Deletes the specified environment variable.\n\n    Does nothing if the environment variable is not set.\n\n    It is possible to remove multiple variables by passing them to this\n    keyword as separate arguments.\n    \"\"\"\n    for name in names:\n        value = del_env_var(name)\n        if value:\n            self._info(\"Environment variable '%s' deleted.\" % name)\n        else:\n            self._info(\"Environment variable '%s' does not exist.\" % name)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.environment_variable_should_be_set","title":"environment_variable_should_be_set","text":"<pre><code>environment_variable_should_be_set(name, msg=None)\n</code></pre> <p>Fails if the specified environment variable is not set.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def environment_variable_should_be_set(self, name, msg=None):\n    \"\"\"Fails if the specified environment variable is not set.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    value = get_env_var(name)\n    if not value:\n        self._fail(msg, \"Environment variable '%s' is not set.\" % name)\n    self._info(\"Environment variable '%s' is set to '%s'.\" % (name, value))\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.environment_variable_should_not_be_set","title":"environment_variable_should_not_be_set","text":"<pre><code>environment_variable_should_not_be_set(name, msg=None)\n</code></pre> <p>Fails if the specified environment variable is set.</p> <p>The default error message can be overridden with the <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def environment_variable_should_not_be_set(self, name, msg=None):\n    \"\"\"Fails if the specified environment variable is set.\n\n    The default error message can be overridden with the ``msg`` argument.\n    \"\"\"\n    value = get_env_var(name)\n    if value:\n        self._fail(msg, \"Environment variable '%s' is set to '%s'.\"\n                        % (name, value))\n    self._info(\"Environment variable '%s' is not set.\" % name)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.get_environment_variables","title":"get_environment_variables","text":"<pre><code>get_environment_variables()\n</code></pre> <p>Returns currently available environment variables as a dictionary.</p> <p>Both keys and values are decoded to Unicode using the system encoding. Altering the returned dictionary has no effect on the actual environment variables.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def get_environment_variables(self):\n    \"\"\"Returns currently available environment variables as a dictionary.\n\n    Both keys and values are decoded to Unicode using the system encoding.\n    Altering the returned dictionary has no effect on the actual environment\n    variables.\n    \"\"\"\n    return get_env_vars()\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.log_environment_variables","title":"log_environment_variables","text":"<pre><code>log_environment_variables(level='INFO')\n</code></pre> <p>Logs all environment variables using the given log level.</p> <p>Environment variables are also returned the same way as with <code>Get Environment Variables</code> keyword.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def log_environment_variables(self, level='INFO'):\n    \"\"\"Logs all environment variables using the given log level.\n\n    Environment variables are also returned the same way as with\n    `Get Environment Variables` keyword.\n    \"\"\"\n    variables = get_env_vars()\n    for name in sorted(variables, key=lambda item: item.lower()):\n        self._log('%s = %s' % (name, variables[name]), level)\n    return variables\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.join_path","title":"join_path","text":"<pre><code>join_path(base, *parts)\n</code></pre> <p>Joins the given path part(s) to the given base path.</p> <p>The path separator (<code>/</code> or <code>\\</code>) is inserted when needed and the possible absolute paths handled as expected. The resulted path is also normalized.</p> <p>Examples: | ${path} = | Join Path | my        | path  | | ${p2} =   | Join Path | my/       | path/ | | ${p3} =   | Join Path | my        | path  | my | file.txt | | ${p4} =   | Join Path | my        | /path | | ${p5} =   | Join Path | /my/path/ | ..    | path2 | =&gt; - ${path} = 'my/path' - ${p2} = 'my/path' - ${p3} = 'my/path/my/file.txt' - ${p4} = '/path' - ${p5} = '/my/path2'</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def join_path(self, base, *parts):\n    \"\"\"Joins the given path part(s) to the given base path.\n\n    The path separator (``/`` or ``\\\\``) is inserted when needed and\n    the possible absolute paths handled as expected. The resulted\n    path is also normalized.\n\n    Examples:\n    | ${path} = | Join Path | my        | path  |\n    | ${p2} =   | Join Path | my/       | path/ |\n    | ${p3} =   | Join Path | my        | path  | my | file.txt |\n    | ${p4} =   | Join Path | my        | /path |\n    | ${p5} =   | Join Path | /my/path/ | ..    | path2 |\n    =&gt;\n    - ${path} = 'my/path'\n    - ${p2} = 'my/path'\n    - ${p3} = 'my/path/my/file.txt'\n    - ${p4} = '/path'\n    - ${p5} = '/my/path2'\n    \"\"\"\n    parts = [str(p) if isinstance(p, pathlib.Path) else p.replace('/', os.sep)\n             for p in (base,) + parts]\n    return self.normalize_path(os.path.join(*parts))\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.join_paths","title":"join_paths","text":"<pre><code>join_paths(base, *paths)\n</code></pre> <p>Joins given paths with base and returns resulted paths.</p> <p>See <code>Join Path</code> for more information.</p> <p>Examples: | @{p1} = | Join Paths | base     | example       | other |          | | @{p2} = | Join Paths | /my/base | /example      | other |          | | @{p3} = | Join Paths | my/base  | example/path/ | other | one/more | =&gt; - @{p1} = ['base/example', 'base/other'] - @{p2} = ['/example', '/my/base/other'] - @{p3} = ['my/base/example/path', 'my/base/other', 'my/base/one/more']</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def join_paths(self, base, *paths):\n    \"\"\"Joins given paths with base and returns resulted paths.\n\n    See `Join Path` for more information.\n\n    Examples:\n    | @{p1} = | Join Paths | base     | example       | other |          |\n    | @{p2} = | Join Paths | /my/base | /example      | other |          |\n    | @{p3} = | Join Paths | my/base  | example/path/ | other | one/more |\n    =&gt;\n    - @{p1} = ['base/example', 'base/other']\n    - @{p2} = ['/example', '/my/base/other']\n    - @{p3} = ['my/base/example/path', 'my/base/other', 'my/base/one/more']\n    \"\"\"\n    return [self.join_path(base, path) for path in paths]\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.normalize_path","title":"normalize_path","text":"<pre><code>normalize_path(path, case_normalize=False)\n</code></pre> <p>Normalizes the given path.</p> <ul> <li>Collapses redundant separators and up-level references.</li> <li>Converts <code>/</code> to <code>\\</code> on Windows.</li> <li>Replaces initial <code>~</code> or <code>~user</code> by that user's home directory.</li> <li>If <code>case_normalize</code> is given a true value (see <code>Boolean arguments</code>)   on Windows, converts the path to all lowercase.</li> <li>Converts <code>pathlib.Path</code> instances to <code>str</code>.</li> </ul> <p>Examples: | ${path1} = | Normalize Path | abc/           | | ${path2} = | Normalize Path | abc/../def     | | ${path3} = | Normalize Path | abc/./def//ghi | | ${path4} = | Normalize Path | ~robot/stuff   | =&gt; - ${path1} = 'abc' - ${path2} = 'def' - ${path3} = 'abc/def/ghi' - ${path4} = '/home/robot/stuff'</p> <p>On Windows result would use <code>\\</code> instead of <code>/</code> and home directory would be different.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def normalize_path(self, path, case_normalize=False):\n    \"\"\"Normalizes the given path.\n\n    - Collapses redundant separators and up-level references.\n    - Converts ``/`` to ``\\\\`` on Windows.\n    - Replaces initial ``~`` or ``~user`` by that user's home directory.\n    - If ``case_normalize`` is given a true value (see `Boolean arguments`)\n      on Windows, converts the path to all lowercase.\n    - Converts ``pathlib.Path`` instances to ``str``.\n\n    Examples:\n    | ${path1} = | Normalize Path | abc/           |\n    | ${path2} = | Normalize Path | abc/../def     |\n    | ${path3} = | Normalize Path | abc/./def//ghi |\n    | ${path4} = | Normalize Path | ~robot/stuff   |\n    =&gt;\n    - ${path1} = 'abc'\n    - ${path2} = 'def'\n    - ${path3} = 'abc/def/ghi'\n    - ${path4} = '/home/robot/stuff'\n\n    On Windows result would use ``\\\\`` instead of ``/`` and home directory\n    would be different.\n    \"\"\"\n    if isinstance(path, pathlib.Path):\n        path = str(path)\n    else:\n        path = path.replace('/', os.sep)\n    path = os.path.normpath(os.path.expanduser(path))\n    # os.path.normcase doesn't normalize on OSX which also, by default,\n    # has case-insensitive file system. Our robot.utils.normpath would\n    # do that, but it's not certain would that, or other things that the\n    # utility do, desirable.\n    if case_normalize:\n        path = os.path.normcase(path)\n    return path or '.'\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.split_path","title":"split_path","text":"<pre><code>split_path(path)\n</code></pre> <p>Splits the given path from the last path separator (<code>/</code> or <code>\\</code>).</p> <p>The given path is first normalized (e.g. a possible trailing path separator is removed, special directories <code>..</code> and <code>.</code> removed). The parts that are split are returned as separate components.</p> <p>Examples: | ${path1} | ${dir} =  | Split Path | abc/def         | | ${path2} | ${file} = | Split Path | abc/def/ghi.txt | | ${path3} | ${d2}  =  | Split Path | abc/../def/ghi/ | =&gt; - ${path1} = 'abc' &amp; ${dir} = 'def' - ${path2} = 'abc/def' &amp; ${file} = 'ghi.txt' - ${path3} = 'def' &amp; ${d2} = 'ghi'</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def split_path(self, path):\n    \"\"\"Splits the given path from the last path separator (``/`` or ``\\\\``).\n\n    The given path is first normalized (e.g. a possible trailing\n    path separator is removed, special directories ``..`` and ``.``\n    removed). The parts that are split are returned as separate\n    components.\n\n    Examples:\n    | ${path1} | ${dir} =  | Split Path | abc/def         |\n    | ${path2} | ${file} = | Split Path | abc/def/ghi.txt |\n    | ${path3} | ${d2}  =  | Split Path | abc/../def/ghi/ |\n    =&gt;\n    - ${path1} = 'abc' &amp; ${dir} = 'def'\n    - ${path2} = 'abc/def' &amp; ${file} = 'ghi.txt'\n    - ${path3} = 'def' &amp; ${d2} = 'ghi'\n    \"\"\"\n    return os.path.split(self.normalize_path(path))\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.split_extension","title":"split_extension","text":"<pre><code>split_extension(path)\n</code></pre> <p>Splits the extension from the given path.</p> <p>The given path is first normalized (e.g. possible trailing path separators removed, special directories <code>..</code> and <code>.</code> removed). The base path and extension are returned as separate components so that the dot used as an extension separator is removed. If the path contains no extension, an empty string is returned for it. Possible leading and trailing dots in the file name are never considered to be extension separators.</p> <p>Examples: | ${path} | ${ext} = | Split Extension | file.extension    | | ${p2}   | ${e2} =  | Split Extension | path/file.ext     | | ${p3}   | ${e3} =  | Split Extension | path/file         | | ${p4}   | ${e4} =  | Split Extension | p1/../p2/file.ext | | ${p5}   | ${e5} =  | Split Extension | path/.file.ext    | | ${p6}   | ${e6} =  | Split Extension | path/.file        | =&gt; - ${path} = 'file' &amp; ${ext} = 'extension' - ${p2} = 'path/file' &amp; ${e2} = 'ext' - ${p3} = 'path/file' &amp; ${e3} = '' - ${p4} = 'p2/file' &amp; ${e4} = 'ext' - ${p5} = 'path/.file' &amp; ${e5} = 'ext' - ${p6} = 'path/.file' &amp; ${e6} = ''</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def split_extension(self, path):\n    \"\"\"Splits the extension from the given path.\n\n    The given path is first normalized (e.g. possible trailing\n    path separators removed, special directories ``..`` and ``.``\n    removed). The base path and extension are returned as separate\n    components so that the dot used as an extension separator is\n    removed. If the path contains no extension, an empty string is\n    returned for it. Possible leading and trailing dots in the file\n    name are never considered to be extension separators.\n\n    Examples:\n    | ${path} | ${ext} = | Split Extension | file.extension    |\n    | ${p2}   | ${e2} =  | Split Extension | path/file.ext     |\n    | ${p3}   | ${e3} =  | Split Extension | path/file         |\n    | ${p4}   | ${e4} =  | Split Extension | p1/../p2/file.ext |\n    | ${p5}   | ${e5} =  | Split Extension | path/.file.ext    |\n    | ${p6}   | ${e6} =  | Split Extension | path/.file        |\n    =&gt;\n    - ${path} = 'file' &amp; ${ext} = 'extension'\n    - ${p2} = 'path/file' &amp; ${e2} = 'ext'\n    - ${p3} = 'path/file' &amp; ${e3} = ''\n    - ${p4} = 'p2/file' &amp; ${e4} = 'ext'\n    - ${p5} = 'path/.file' &amp; ${e5} = 'ext'\n    - ${p6} = 'path/.file' &amp; ${e6} = ''\n    \"\"\"\n    path = self.normalize_path(path)\n    basename = os.path.basename(path)\n    if basename.startswith('.' * basename.count('.')):\n        return path, ''\n    if path.endswith('.'):\n        path2 = path.rstrip('.')\n        trailing_dots = '.' * (len(path) - len(path2))\n        path = path2\n    else:\n        trailing_dots = ''\n    basepath, extension = os.path.splitext(path)\n    if extension.startswith('.'):\n        extension = extension[1:]\n    if extension:\n        extension += trailing_dots\n    else:\n        basepath += trailing_dots\n    return basepath, extension\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.get_modified_time","title":"get_modified_time","text":"<pre><code>get_modified_time(path, format='timestamp')\n</code></pre> <p>Returns the last modification time of a file or directory.</p> <p>How time is returned is determined based on the given <code>format</code> string as follows. Note that all checks are case-insensitive. Returned time is also automatically logged.</p> <p>1) If <code>format</code> contains the word <code>epoch</code>, the time is returned    in seconds after the UNIX epoch. The return value is always    an integer.</p> <p>2) If <code>format</code> contains any of the words <code>year</code>, <code>month</code>,    <code>day</code>, <code>hour</code>, <code>min</code> or <code>sec</code>, only the selected parts are    returned. The order of the returned parts is always the one    in the previous sentence and the order of the words in    <code>format</code> is not significant. The parts are returned as    zero-padded strings (e.g. May -&gt; <code>05</code>).</p> <p>3) Otherwise, and by default, the time is returned as a    timestamp string in the format <code>2006-02-24 15:08:31</code>.</p> <p>Examples (when the modified time of <code>${CURDIR}</code> is 2006-03-29 15:06:21): | ${time} = | Get Modified Time | ${CURDIR} | | ${secs} = | Get Modified Time | ${CURDIR} | epoch | | ${year} = | Get Modified Time | ${CURDIR} | return year | | ${y} | ${d} = | Get Modified Time | ${CURDIR} | year,day | | @{time} = | Get Modified Time | ${CURDIR} | year,month,day,hour,min,sec | =&gt; - ${time} = '2006-03-29 15:06:21' - ${secs} = 1143637581 - ${year} = '2006' - ${y} = '2006' &amp; ${d} = '29' - @{time} = ['2006', '03', '29', '15', '06', '21']</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def get_modified_time(self, path, format='timestamp'):\n    \"\"\"Returns the last modification time of a file or directory.\n\n    How time is returned is determined based on the given ``format``\n    string as follows. Note that all checks are case-insensitive.\n    Returned time is also automatically logged.\n\n    1) If ``format`` contains the word ``epoch``, the time is returned\n       in seconds after the UNIX epoch. The return value is always\n       an integer.\n\n    2) If ``format`` contains any of the words ``year``, ``month``,\n       ``day``, ``hour``, ``min`` or ``sec``, only the selected parts are\n       returned. The order of the returned parts is always the one\n       in the previous sentence and the order of the words in\n       ``format`` is not significant. The parts are returned as\n       zero-padded strings (e.g. May -&gt; ``05``).\n\n    3) Otherwise, and by default, the time is returned as a\n       timestamp string in the format ``2006-02-24 15:08:31``.\n\n    Examples (when the modified time of ``${CURDIR}`` is\n    2006-03-29 15:06:21):\n    | ${time} = | Get Modified Time | ${CURDIR} |\n    | ${secs} = | Get Modified Time | ${CURDIR} | epoch |\n    | ${year} = | Get Modified Time | ${CURDIR} | return year |\n    | ${y} | ${d} = | Get Modified Time | ${CURDIR} | year,day |\n    | @{time} = | Get Modified Time | ${CURDIR} | year,month,day,hour,min,sec |\n    =&gt;\n    - ${time} = '2006-03-29 15:06:21'\n    - ${secs} = 1143637581\n    - ${year} = '2006'\n    - ${y} = '2006' &amp; ${d} = '29'\n    - @{time} = ['2006', '03', '29', '15', '06', '21']\n    \"\"\"\n    path = self._absnorm(path)\n    if not os.path.exists(path):\n        self._error(\"Path '%s' does not exist.\" % path)\n    mtime = get_time(format, os.stat(path).st_mtime)\n    self._link(\"Last modified time of '%%s' is %s.\" % mtime, path)\n    return mtime\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.set_modified_time","title":"set_modified_time","text":"<pre><code>set_modified_time(path, mtime)\n</code></pre> <p>Sets the file modification and access times.</p> <p>Changes the modification and access times of the given file to the value determined by <code>mtime</code>. The time can be given in different formats described below. Note that all checks involving strings are case-insensitive. Modified time can only be set to regular files.</p> <p>1) If <code>mtime</code> is a number, or a string that can be converted    to a number, it is interpreted as seconds since the UNIX    epoch (1970-01-01 00:00:00 UTC). This documentation was    originally written about 1177654467 seconds after the epoch.</p> <p>2) If <code>mtime</code> is a timestamp, that time will be used. Valid    timestamp formats are <code>YYYY-MM-DD hh:mm:ss</code> and    <code>YYYYMMDD hhmmss</code>.</p> <p>3) If <code>mtime</code> is equal to <code>NOW</code>, the current local time is used.</p> <p>4) If <code>mtime</code> is equal to <code>UTC</code>, the current time in    [http://en.wikipedia.org/wiki/Coordinated_Universal_Time|UTC]    is used.</p> <p>5) If <code>mtime</code> is in the format like <code>NOW - 1 day</code> or <code>UTC + 1    hour 30 min</code>, the current local/UTC time plus/minus the time    specified with the time string is used. The time string format    is described in an appendix of Robot Framework User Guide.</p> <p>Examples: | Set Modified Time | /path/file | 1177654467         | # Time given as epoch seconds | | Set Modified Time | /path/file | 2007-04-27 9:14:27 | # Time given as a timestamp   | | Set Modified Time | /path/file | NOW                | # The local time of execution | | Set Modified Time | /path/file | NOW - 1 day        | # 1 day subtracted from the local time | | Set Modified Time | /path/file | UTC + 1h 2min 3s   | # 1h 2min 3s added to the UTC time |</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def set_modified_time(self, path, mtime):\n    \"\"\"Sets the file modification and access times.\n\n    Changes the modification and access times of the given file to\n    the value determined by ``mtime``. The time can be given in\n    different formats described below. Note that all checks\n    involving strings are case-insensitive. Modified time can only\n    be set to regular files.\n\n    1) If ``mtime`` is a number, or a string that can be converted\n       to a number, it is interpreted as seconds since the UNIX\n       epoch (1970-01-01 00:00:00 UTC). This documentation was\n       originally written about 1177654467 seconds after the epoch.\n\n    2) If ``mtime`` is a timestamp, that time will be used. Valid\n       timestamp formats are ``YYYY-MM-DD hh:mm:ss`` and\n       ``YYYYMMDD hhmmss``.\n\n    3) If ``mtime`` is equal to ``NOW``, the current local time is used.\n\n    4) If ``mtime`` is equal to ``UTC``, the current time in\n       [http://en.wikipedia.org/wiki/Coordinated_Universal_Time|UTC]\n       is used.\n\n    5) If ``mtime`` is in the format like ``NOW - 1 day`` or ``UTC + 1\n       hour 30 min``, the current local/UTC time plus/minus the time\n       specified with the time string is used. The time string format\n       is described in an appendix of Robot Framework User Guide.\n\n    Examples:\n    | Set Modified Time | /path/file | 1177654467         | # Time given as epoch seconds |\n    | Set Modified Time | /path/file | 2007-04-27 9:14:27 | # Time given as a timestamp   |\n    | Set Modified Time | /path/file | NOW                | # The local time of execution |\n    | Set Modified Time | /path/file | NOW - 1 day        | # 1 day subtracted from the local time |\n    | Set Modified Time | /path/file | UTC + 1h 2min 3s   | # 1h 2min 3s added to the UTC time |\n    \"\"\"\n    mtime = parse_time(mtime)\n    path = self._absnorm(path)\n    if not os.path.exists(path):\n        self._error(\"File '%s' does not exist.\" % path)\n    if not os.path.isfile(path):\n        self._error(\"Path '%s' is not a regular file.\" % path)\n    os.utime(path, (mtime, mtime))\n    time.sleep(0.1)    # Give OS some time to really set these times.\n    tstamp = datetime.fromtimestamp(mtime).isoformat(' ', timespec='seconds')\n    self._link(\"Set modified time of '%%s' to %s.\" % tstamp, path)\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.get_file_size","title":"get_file_size","text":"<pre><code>get_file_size(path)\n</code></pre> <p>Returns and logs file size as an integer in bytes.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def get_file_size(self, path):\n    \"\"\"Returns and logs file size as an integer in bytes.\"\"\"\n    path = self._absnorm(path)\n    if not os.path.isfile(path):\n        self._error(\"File '%s' does not exist.\" % path)\n    size = os.stat(path).st_size\n    plural = plural_or_not(size)\n    self._link(\"Size of file '%%s' is %d byte%s.\" % (size, plural), path)\n    return size\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.list_directory","title":"list_directory","text":"<pre><code>list_directory(path, pattern=None, absolute=False)\n</code></pre> <p>Returns and logs items in a directory, optionally filtered with <code>pattern</code>.</p> <p>File and directory names are returned in case-sensitive alphabetical order, e.g. <code>['A Name', 'Second', 'a lower case name', 'one more']</code>. Implicit directories <code>.</code> and <code>..</code> are not returned. The returned items are automatically logged.</p> <p>File and directory names are returned relative to the given path (e.g. <code>'file.txt'</code>) by default. If you want them be returned in absolute format (e.g. <code>'/home/robot/file.txt'</code>), give the <code>absolute</code> argument a true value (see <code>Boolean arguments</code>).</p> <p>If <code>pattern</code> is given, only items matching it are returned. The pattern is considered to be a glob pattern and the full syntax is explained in the <code>Glob patterns</code> section. With this keyword matching is always case-sensitive.</p> <p>Examples (using also other <code>List Directory</code> variants): | @{items} = | List Directory           | ${TEMPDIR} | | @{files} = | List Files In Directory  | /tmp | *.txt | absolute | | ${count} = | Count Files In Directory | ${CURDIR} | ??? |</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def list_directory(self, path, pattern=None, absolute=False):\n    \"\"\"Returns and logs items in a directory, optionally filtered with ``pattern``.\n\n    File and directory names are returned in case-sensitive alphabetical\n    order, e.g. ``['A Name', 'Second', 'a lower case name', 'one more']``.\n    Implicit directories ``.`` and ``..`` are not returned. The returned\n    items are automatically logged.\n\n    File and directory names are returned relative to the given path\n    (e.g. ``'file.txt'``) by default. If you want them be returned in\n    absolute format (e.g. ``'/home/robot/file.txt'``), give the ``absolute``\n    argument a true value (see `Boolean arguments`).\n\n    If ``pattern`` is given, only items matching it are returned. The pattern\n    is considered to be a _glob pattern_ and the full syntax is explained in\n    the `Glob patterns` section. With this keyword matching is always\n    case-sensitive.\n\n    Examples (using also other `List Directory` variants):\n    | @{items} = | List Directory           | ${TEMPDIR} |\n    | @{files} = | List Files In Directory  | /tmp | *.txt | absolute |\n    | ${count} = | Count Files In Directory | ${CURDIR} | ??? |\n    \"\"\"\n    items = self._list_dir(path, pattern, absolute)\n    self._info('%d item%s:\\n%s' % (len(items), plural_or_not(items),\n                                   '\\n'.join(items)))\n    return items\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.list_files_in_directory","title":"list_files_in_directory","text":"<pre><code>list_files_in_directory(path, pattern=None, absolute=False)\n</code></pre> <p>Wrapper for <code>List Directory</code> that returns only files.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def list_files_in_directory(self, path, pattern=None, absolute=False):\n    \"\"\"Wrapper for `List Directory` that returns only files.\"\"\"\n    files = self._list_files_in_dir(path, pattern, absolute)\n    self._info('%d file%s:\\n%s' % (len(files), plural_or_not(files),\n                                   '\\n'.join(files)))\n    return files\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.list_directories_in_directory","title":"list_directories_in_directory","text":"<pre><code>list_directories_in_directory(\n    path, pattern=None, absolute=False\n)\n</code></pre> <p>Wrapper for <code>List Directory</code> that returns only directories.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def list_directories_in_directory(self, path, pattern=None, absolute=False):\n    \"\"\"Wrapper for `List Directory` that returns only directories.\"\"\"\n    dirs = self._list_dirs_in_dir(path, pattern, absolute)\n    self._info('%d director%s:\\n%s' % (len(dirs),\n                                       'y' if len(dirs) == 1 else 'ies',\n                                       '\\n'.join(dirs)))\n    return dirs\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.count_items_in_directory","title":"count_items_in_directory","text":"<pre><code>count_items_in_directory(path, pattern=None)\n</code></pre> <p>Returns and logs the number of all items in the given directory.</p> <p>The argument <code>pattern</code> has the same semantics as with <code>List Directory</code> keyword. The count is returned as an integer, so it must be checked e.g. with the built-in keyword <code>Should Be Equal As Integers</code>.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def count_items_in_directory(self, path, pattern=None):\n    \"\"\"Returns and logs the number of all items in the given directory.\n\n    The argument ``pattern`` has the same semantics as with `List Directory`\n    keyword. The count is returned as an integer, so it must be checked e.g.\n    with the built-in keyword `Should Be Equal As Integers`.\n    \"\"\"\n    count = len(self._list_dir(path, pattern))\n    self._info(\"%s item%s.\" % (count, plural_or_not(count)))\n    return count\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.count_files_in_directory","title":"count_files_in_directory","text":"<pre><code>count_files_in_directory(path, pattern=None)\n</code></pre> <p>Wrapper for <code>Count Items In Directory</code> returning only file count.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def count_files_in_directory(self, path, pattern=None):\n    \"\"\"Wrapper for `Count Items In Directory` returning only file count.\"\"\"\n    count = len(self._list_files_in_dir(path, pattern))\n    self._info(\"%s file%s.\" % (count, plural_or_not(count)))\n    return count\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.count_directories_in_directory","title":"count_directories_in_directory","text":"<pre><code>count_directories_in_directory(path, pattern=None)\n</code></pre> <p>Wrapper for <code>Count Items In Directory</code> returning only directory count.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def count_directories_in_directory(self, path, pattern=None):\n    \"\"\"Wrapper for `Count Items In Directory` returning only directory count.\"\"\"\n    count = len(self._list_dirs_in_dir(path, pattern))\n    self._info(\"%s director%s.\" % (count, 'y' if count == 1 else 'ies'))\n    return count\n</code></pre>"},{"location":"api/robot/libraries/OperatingSystem/#robot.libraries.OperatingSystem.OperatingSystem.touch","title":"touch","text":"<pre><code>touch(path)\n</code></pre> <p>Emulates the UNIX touch command.</p> <p>Creates a file, if it does not exist. Otherwise changes its access and modification times to the current time.</p> <p>Fails if used with the directories or the parent directory of the given file does not exist.</p> Source code in <code>src/robot/libraries/OperatingSystem.py</code> <pre><code>def touch(self, path):\n    \"\"\"Emulates the UNIX touch command.\n\n    Creates a file, if it does not exist. Otherwise changes its access and\n    modification times to the current time.\n\n    Fails if used with the directories or the parent directory of the given\n    file does not exist.\n    \"\"\"\n    path = self._absnorm(path)\n    if os.path.isdir(path):\n        self._error(\"Cannot touch '%s' because it is a directory.\" % path)\n    if not os.path.exists(os.path.dirname(path)):\n        self._error(\"Cannot touch '%s' because its parent directory does \"\n                    \"not exist.\" % path)\n    if os.path.exists(path):\n        mtime = round(time.time())\n        os.utime(path, (mtime, mtime))\n        self._link(\"Touched existing file '%s'.\", path)\n    else:\n        open(path, 'w', encoding='ASCII').close()\n        self._link(\"Touched new file '%s'.\", path)\n</code></pre>"},{"location":"api/robot/libraries/Process/","title":"robot.libraries.Process","text":""},{"location":"api/robot/libraries/Process/#robot.libraries.Process","title":"robot.libraries.Process","text":""},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process","title":"Process","text":"<pre><code>Process()\n</code></pre> <p>Robot Framework library for running processes.</p> <p>This library utilizes Python's [http://docs.python.org/library/subprocess.html|subprocess] module and its [http://docs.python.org/library/subprocess.html#popen-constructor|Popen] class.</p> <p>The library has following main usages:</p> <ul> <li>Running processes in system and waiting for their completion using   <code>Run Process</code> keyword.</li> <li>Starting processes on background using <code>Start Process</code>.</li> <li>Waiting started process to complete using <code>Wait For Process</code> or   stopping them with <code>Terminate Process</code> or <code>Terminate All Processes</code>.</li> </ul> <p>== Table of contents ==</p> <p>%TOC%</p> <p>= Specifying command and arguments =</p> <p>Both <code>Run Process</code> and <code>Start Process</code> accept the command to execute and all arguments passed to the command as separate arguments. This makes usage convenient and also allows these keywords to automatically escape possible spaces and other special characters in commands and arguments. Notice that if a command accepts options that themselves accept values, these options and their values must be given as separate arguments.</p> <p>When <code>running processes in shell</code>, it is also possible to give the whole command to execute as a single string. The command can then contain multiple commands to be run together. When using this approach, the caller is responsible on escaping.</p> <p>Examples: | <code>Run Process</code> | ${tools}${/}prog.py | argument | second arg with spaces | | <code>Run Process</code> | java | -jar | ${jars}${/}example.jar | --option | value | | <code>Run Process</code> | prog.py \"one arg\" &amp;&amp; tool.sh | shell=yes | cwd=${tools} |</p> <p>Possible non-string arguments are converted to strings automatically.</p> <p>= Process configuration =</p> <p><code>Run Process</code> and <code>Start Process</code> keywords can be configured using optional <code>**configuration</code> keyword arguments. Configuration arguments must be given after other arguments passed to these keywords and must use syntax like <code>name=value</code>. Available configuration arguments are listed below and discussed further in sections afterward.</p> <p>|  = Name =  |                  = Explanation =                      | | shell      | Specifies whether to run the command in shell or not. | | cwd        | Specifies the working directory.                      | | env        | Specifies environment variables given to the process. | | env: | Overrides the named environment variable(s) only.     | | stdout     | Path of a file where to write standard output.        | | stderr     | Path of a file where to write standard error.         | | stdin      | Configure process standard input. New in RF 4.1.2.    | | output_encoding | Encoding to use when reading command outputs.    | | alias      | Alias given to the process.                           | <p>Note that because <code>**configuration</code> is passed using <code>name=value</code> syntax, possible equal signs in other arguments passed to <code>Run Process</code> and <code>Start Process</code> must be escaped with a backslash like <code>name\\=value</code>. See <code>Run Process</code> for an example.</p> <p>== Running processes in shell ==</p> <p>The <code>shell</code> argument specifies whether to run the process in a shell or not. By default, shell is not used, which means that shell specific commands, like <code>copy</code> and <code>dir</code> on Windows, are not available. You can, however, run shell scripts and batch files without using a shell.</p> <p>Giving the <code>shell</code> argument any non-false value, such as <code>shell=True</code>, changes the program to be executed in a shell. It allows using the shell capabilities, but can also make the process invocation operating system dependent. Having a shell between the actually started process and this library can also interfere communication with the process such as stopping it and reading its outputs. Because of these problems, it is recommended to use the shell only when absolutely necessary.</p> <p>When using a shell it is possible to give the whole command to execute as a single string. See <code>Specifying command and arguments</code> section for examples and more details in general.</p> <p>== Current working directory ==</p> <p>By default, the child process will be executed in the same directory as the parent process, the process running Robot Framework, is executed. This can be changed by giving an alternative location using the <code>cwd</code> argument. Forward slashes in the given path are automatically converted to backslashes on Windows.</p> <p><code>Standard output and error streams</code>, when redirected to files, are also relative to the current working directory possibly set using the <code>cwd</code> argument.</p> <p>Example: | <code>Run Process</code> | prog.exe | cwd=${ROOT}/directory | stdout=stdout.txt |</p> <p>== Environment variables ==</p> <p>The child process will get a copy of the parent process's environment variables by default. The <code>env</code> argument can be used to give the child a custom environment as a Python dictionary. If there is a need to specify only certain environment variable, it is possible to use the <code>env:&lt;name&gt;=&lt;value&gt;</code> format to set or override only that named variables. It is also possible to use these two approaches together.</p> <p>Examples: | <code>Run Process</code> | program | env=${environ} | | <code>Run Process</code> | program | env:http_proxy=10.144.1.10:8080 | env:PATH=%{PATH}${:}${PROGDIR} | | <code>Run Process</code> | program | env=${environ} | env:EXTRA=value |</p> <p>== Standard output and error streams ==</p> <p>By default, processes are run so that their standard output and standard error streams are kept in the memory. This works fine normally, but if there is a lot of output, the output buffers may get full and the program can hang.</p> <p>To avoid the above-mentioned problems, it is possible to use <code>stdout</code> and <code>stderr</code> arguments to specify files on the file system where to redirect the outputs. This can also be useful if other processes or other keywords need to read or manipulate the outputs somehow.</p> <p>Given <code>stdout</code> and <code>stderr</code> paths are relative to the <code>current working directory</code>. Forward slashes in the given paths are automatically converted to backslashes on Windows.</p> <p>As a special feature, it is possible to redirect the standard error to the standard output by using <code>stderr=STDOUT</code>.</p> <p>Regardless are outputs redirected to files or not, they are accessible through the <code>result object</code> returned when the process ends. Commands are expected to write outputs using the console encoding, but <code>output encoding</code> can be configured using the <code>output_encoding</code> argument if needed.</p> <p>If you are not interested in outputs at all, you can explicitly ignore them by using a special value <code>DEVNULL</code> both with <code>stdout</code> and <code>stderr</code>. For example, <code>stdout=DEVNULL</code> is the same as redirecting output on console with <code>&gt; /dev/null</code> on UNIX-like operating systems or <code>&gt; NUL</code> on Windows. This way the process will not hang even if there would be a lot of output, but naturally output is not available after execution either.</p> <p>Examples: | ${result} = | <code>Run Process</code> | program | stdout=${TEMPDIR}/stdout.txt | stderr=${TEMPDIR}/stderr.txt | | <code>Log Many</code>  | stdout: ${result.stdout} | stderr: ${result.stderr} | | ${result} = | <code>Run Process</code> | program | stderr=STDOUT | | <code>Log</code>       | all output: ${result.stdout} | | ${result} = | <code>Run Process</code> | program | stdout=DEVNULL | stderr=DEVNULL |</p> <p>Note that the created output files are not automatically removed after the test run. The user is responsible to remove them if needed.</p> <p>== Standard input stream ==</p> <p>The <code>stdin</code> argument makes it possible to pass information to the standard input stream of the started process. How its value is interpreted is explained in the table below.</p> <p>| = Value =        | = Explanation = | | String <code>NONE</code>  | Inherit stdin from the parent process. This is the default. | | String <code>PIPE</code>  | Make stdin a pipe that can be written to. | | Path to a file   | Open the specified file and use it as the stdin. | | Any other string | Create a temporary file with the text as its content and use it as the stdin. | | Any non-string value | Used as-is. Could be a file descriptor, stdout of another process, etc. |</p> <p>Values <code>PIPE</code> and <code>NONE</code> are case-insensitive and internally mapped to <code>subprocess.PIPE</code> and <code>None</code>, respectively, when calling [https://docs.python.org/3/library/subprocess.html#subprocess.Popen|subprocess.Popen].</p> <p>Examples: | <code>Run Process</code> | command | stdin=PIPE | | <code>Run Process</code> | command | stdin=${CURDIR}/stdin.txt | | <code>Run Process</code> | command | stdin=Stdin as text. |</p> <p>The support to configure <code>stdin</code> is new in Robot Framework 4.1.2. Its default value used to be <code>PIPE</code> until Robot Framework 7.0.</p> <p>== Output encoding ==</p> <p>Executed commands are, by default, expected to write outputs to the <code>standard output and error streams</code> using the encoding used by the system console. If the command uses some other encoding, that can be configured using the <code>output_encoding</code> argument. This is especially useful on Windows where the console uses a different encoding than rest of the system, and many commands use the general system encoding instead of the console encoding.</p> <p>The value used with the <code>output_encoding</code> argument must be a valid encoding and must match the encoding actually used by the command. As a convenience, it is possible to use strings <code>CONSOLE</code> and <code>SYSTEM</code> to specify that the console or system encoding is used, respectively. If produced outputs use different encoding then configured, values got through the <code>result object</code> will be invalid.</p> <p>Examples: | <code>Start Process</code> | program | output_encoding=UTF-8 | | <code>Run Process</code>   | program | stdout=${path} | output_encoding=SYSTEM |</p> <p>== Alias ==</p> <p>A custom name given to the process that can be used when selecting the <code>active process</code>.</p> <p>Examples: | <code>Start Process</code> | program | alias=example | | <code>Run Process</code>   | python  | -c | print('hello') | alias=hello |</p> <p>= Active process =</p> <p>The library keeps record which of the started processes is currently active. By default it is the latest process started with <code>Start Process</code>, but <code>Switch Process</code> can be used to activate a different process. Using <code>Run Process</code> does not affect the active process.</p> <p>The keywords that operate on started processes will use the active process by default, but it is possible to explicitly select a different process using the <code>handle</code> argument. The handle can be an <code>alias</code> explicitly given to <code>Start Process</code> or the process object returned by it.</p> <p>= Result object =</p> <p><code>Run Process</code>, <code>Wait For Process</code> and <code>Terminate Process</code> keywords return a result object that contains information about the process execution as its attributes. The same result object, or some of its attributes, can also be get using <code>Get Process Result</code> keyword. Attributes available in the object are documented in the table below.</p> <p>| = Attribute = |             = Explanation =               | | rc            | Return code of the process as an integer. | | stdout        | Contents of the standard output stream.   | | stderr        | Contents of the standard error stream.    | | stdout_path   | Path where stdout was redirected or <code>None</code> if not redirected. | | stderr_path   | Path where stderr was redirected or <code>None</code> if not redirected. |</p> <p>Example: | ${result} =            | <code>Run Process</code>         | program               | | <code>Should Be Equal As Integers</code> | ${result.rc}   | 0                     | | <code>Should Match</code>         | ${result.stdout}      | Some t?xt*            | | <code>Should Be Empty</code>      | ${result.stderr}      |                       | | ${stdout} =            | <code>Get File</code>            | ${result.stdout_path} | | <code>Should Be Equal</code>      | ${stdout}             | ${result.stdout}      | | <code>File Should Be Empty</code> | ${result.stderr_path} |                       |</p> <p>= Boolean arguments =</p> <p>Some keywords accept arguments that are handled as Boolean values true or false. If such an argument is given as a string, it is considered false if it is an empty string or equal to <code>FALSE</code>, <code>NONE</code>, <code>NO</code>, <code>OFF</code> or <code>0</code>, case-insensitively. Other strings are considered true regardless their value, and other argument types are tested using the same [http://docs.python.org/library/stdtypes.html#truth|rules as in Python].</p> <p>True examples: | <code>Terminate Process</code> | kill=True     | # Strings are generally true.    | | <code>Terminate Process</code> | kill=yes      | # Same as the above.             | | <code>Terminate Process</code> | kill=${TRUE}  | # Python <code>True</code> is true.       | | <code>Terminate Process</code> | kill=${42}    | # Numbers other than 0 are true. |</p> <p>False examples: | <code>Terminate Process</code> | kill=False    | # String <code>false</code> is false.   | | <code>Terminate Process</code> | kill=no       | # Also string <code>no</code> is false. | | <code>Terminate Process</code> | kill=${EMPTY} | # Empty string is false.       | | <code>Terminate Process</code> | kill=${FALSE} | # Python <code>False</code> is false.   |</p> <p>= Example =</p> <p>| * Settings  | Library           Process | Suite Teardown    <code>Terminate All Processes</code>    kill=True | |  Test Cases *** | Example |     <code>Start Process</code>    program    arg1    arg2    alias=First |     ${handle} =    <code>Start Process</code>    command.sh arg | command2.sh    shell=True    cwd=/path |     ${result} =    <code>Run Process</code>    ${CURDIR}/script.py |     <code>Should Not Contain</code>    ${result.stdout}    FAIL |     <code>Terminate Process</code>    ${handle} |     ${result} =    <code>Wait For Process</code>    First |     <code>Should Be Equal As Integers</code>    ${result.rc}    0</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def __init__(self):\n    self._processes = ConnectionCache('No active process.')\n    self._results = {}\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.run_process","title":"run_process","text":"<pre><code>run_process(command, *arguments, **configuration)\n</code></pre> <p>Runs a process and waits for it to complete.</p> <p><code>command</code> and <code>*arguments</code> specify the command to execute and arguments passed to it. See <code>Specifying command and arguments</code> for more details.</p> <p><code>**configuration</code> contains additional configuration related to starting processes and waiting for them to finish. See <code>Process configuration</code> for more details about configuration related to starting processes. Configuration related to waiting for processes consists of <code>timeout</code> and <code>on_timeout</code> arguments that have same semantics as with <code>Wait For Process</code> keyword. By default, there is no timeout, and if timeout is defined the default action on timeout is <code>terminate</code>.</p> <p>Process outputs are, by default, written into in-memory buffers. If there is a lot of output, these buffers may get full causing the process to hang. To avoid that, process outputs can be redirected using the <code>stdout</code> and <code>stderr</code> configuration parameters. For more information see the <code>Standard output and error streams</code> section.</p> <p>Returns a <code>result object</code> containing information about the execution.</p> <p>Note that possible equal signs in <code>*arguments</code> must be escaped with a backslash (e.g. <code>name\\=value</code>) to avoid them to be passed in as <code>**configuration</code>.</p> <p>Examples: | ${result} = | Run Process | python | -c | print('Hello, world!') | | Should Be Equal | ${result.stdout} | Hello, world! | | ${result} = | Run Process | ${command} | stdout=${CURDIR}/stdout.txt | stderr=STDOUT | | ${result} = | Run Process | ${command} | timeout=1min | on_timeout=continue | | ${result} = | Run Process | java -Dname\\=value Example | shell=True | cwd=${EXAMPLE} |</p> <p>This keyword does not change the <code>active process</code>.</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def run_process(self, command, *arguments, **configuration):\n    \"\"\"Runs a process and waits for it to complete.\n\n    ``command`` and ``*arguments`` specify the command to execute and\n    arguments passed to it. See `Specifying command and arguments` for\n    more details.\n\n    ``**configuration`` contains additional configuration related to\n    starting processes and waiting for them to finish. See `Process\n    configuration` for more details about configuration related to starting\n    processes. Configuration related to waiting for processes consists of\n    ``timeout`` and ``on_timeout`` arguments that have same semantics as\n    with `Wait For Process` keyword. By default, there is no timeout, and\n    if timeout is defined the default action on timeout is ``terminate``.\n\n    Process outputs are, by default, written into in-memory buffers.\n    If there is a lot of output, these buffers may get full causing\n    the process to hang. To avoid that, process outputs can be redirected\n    using the ``stdout`` and ``stderr`` configuration parameters. For more\n    information see the `Standard output and error streams` section.\n\n    Returns a `result object` containing information about the execution.\n\n    Note that possible equal signs in ``*arguments`` must be escaped\n    with a backslash (e.g. ``name\\\\=value``) to avoid them to be passed in\n    as ``**configuration``.\n\n    Examples:\n    | ${result} = | Run Process | python | -c | print('Hello, world!') |\n    | Should Be Equal | ${result.stdout} | Hello, world! |\n    | ${result} = | Run Process | ${command} | stdout=${CURDIR}/stdout.txt | stderr=STDOUT |\n    | ${result} = | Run Process | ${command} | timeout=1min | on_timeout=continue |\n    | ${result} = | Run Process | java -Dname\\\\=value Example | shell=True | cwd=${EXAMPLE} |\n\n    This keyword does not change the `active process`.\n    \"\"\"\n    current = self._processes.current\n    timeout = configuration.pop('timeout', None)\n    on_timeout = configuration.pop('on_timeout', 'terminate')\n    try:\n        handle = self.start_process(command, *arguments, **configuration)\n        return self.wait_for_process(handle, timeout, on_timeout)\n    finally:\n        self._processes.current = current\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.start_process","title":"start_process","text":"<pre><code>start_process(command, *arguments, **configuration)\n</code></pre> <p>Starts a new process on background.</p> <p>See <code>Specifying command and arguments</code> and <code>Process configuration</code> for more information about the arguments, and <code>Run Process</code> keyword for related examples. This includes information about redirecting process outputs to avoid process handing due to output buffers getting full.</p> <p>Makes the started process new <code>active process</code>. Returns the created [https://docs.python.org/3/library/subprocess.html#popen-constructor | subprocess.Popen] object which can be used later to activate this process. <code>Popen</code> attributes like <code>pid</code> can also be accessed directly.</p> <p>Processes are started so that they create a new process group. This allows terminating and sending signals to possible child processes.</p> <p>Examples:</p> <p>Start process and wait for it to end later using an alias: | <code>Start Process</code> | ${command} | alias=example | | # Other keywords | | ${result} = | <code>Wait For Process</code> | example |</p> <p>Use returned <code>Popen</code> object: | ${process} = | <code>Start Process</code> | ${command} | | <code>Log</code> | PID: ${process.pid} | | # Other keywords | | ${result} = | <code>Terminate Process</code> | ${process} |</p> <p>Use started process in a pipeline with another process: | ${process} = | <code>Start Process</code> | python | -c | print('Hello, world!') | | ${result} = | <code>Run Process</code> | python | -c | import sys; print(sys.stdin.read().upper().strip()) | stdin=${process.stdout} | | <code>Wait For Process</code> | ${process} | | <code>Should Be Equal</code> | ${result.stdout} | HELLO, WORLD! |</p> <p>Returning a <code>subprocess.Popen</code> object is new in Robot Framework 5.0. Earlier versions returned a generic handle and getting the process object required using <code>Get Process Object</code> separately.</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def start_process(self, command, *arguments, **configuration):\n    \"\"\"Starts a new process on background.\n\n    See `Specifying command and arguments` and `Process configuration`\n    for more information about the arguments, and `Run Process` keyword\n    for related examples. This includes information about redirecting\n    process outputs to avoid process handing due to output buffers getting\n    full.\n\n    Makes the started process new `active process`. Returns the created\n    [https://docs.python.org/3/library/subprocess.html#popen-constructor |\n    subprocess.Popen] object which can be used later to activate this\n    process. ``Popen`` attributes like ``pid`` can also be accessed directly.\n\n    Processes are started so that they create a new process group. This\n    allows terminating and sending signals to possible child processes.\n\n    Examples:\n\n    Start process and wait for it to end later using an alias:\n    | `Start Process` | ${command} | alias=example |\n    | # Other keywords |\n    | ${result} = | `Wait For Process` | example |\n\n    Use returned ``Popen`` object:\n    | ${process} = | `Start Process` | ${command} |\n    | `Log` | PID: ${process.pid} |\n    | # Other keywords |\n    | ${result} = | `Terminate Process` | ${process} |\n\n    Use started process in a pipeline with another process:\n    | ${process} = | `Start Process` | python | -c | print('Hello, world!') |\n    | ${result} = | `Run Process` | python | -c | import sys; print(sys.stdin.read().upper().strip()) | stdin=${process.stdout} |\n    | `Wait For Process` | ${process} |\n    | `Should Be Equal` | ${result.stdout} | HELLO, WORLD! |\n\n    Returning a ``subprocess.Popen`` object is new in Robot Framework 5.0.\n    Earlier versions returned a generic handle and getting the process object\n    required using `Get Process Object` separately.\n    \"\"\"\n    conf = ProcessConfiguration(**configuration)\n    command = conf.get_command(command, list(arguments))\n    self._log_start(command, conf)\n    process = subprocess.Popen(command, **conf.popen_config)\n    self._results[process] = ExecutionResult(process, **conf.result_config)\n    self._processes.register(process, alias=conf.alias)\n    return self._processes.current\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.is_process_running","title":"is_process_running","text":"<pre><code>is_process_running(handle=None)\n</code></pre> <p>Checks is the process running or not.</p> <p>If <code>handle</code> is not given, uses the current <code>active process</code>.</p> <p>Returns <code>True</code> if the process is still running and <code>False</code> otherwise.</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def is_process_running(self, handle=None):\n    \"\"\"Checks is the process running or not.\n\n    If ``handle`` is not given, uses the current `active process`.\n\n    Returns ``True`` if the process is still running and ``False`` otherwise.\n    \"\"\"\n    return self._processes[handle].poll() is None\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.process_should_be_running","title":"process_should_be_running","text":"<pre><code>process_should_be_running(\n    handle=None, error_message=\"Process is not running.\"\n)\n</code></pre> <p>Verifies that the process is running.</p> <p>If <code>handle</code> is not given, uses the current <code>active process</code>.</p> <p>Fails if the process has stopped.</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def process_should_be_running(self, handle=None,\n                              error_message='Process is not running.'):\n    \"\"\"Verifies that the process is running.\n\n    If ``handle`` is not given, uses the current `active process`.\n\n    Fails if the process has stopped.\n    \"\"\"\n    if not self.is_process_running(handle):\n        raise AssertionError(error_message)\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.process_should_be_stopped","title":"process_should_be_stopped","text":"<pre><code>process_should_be_stopped(\n    handle=None, error_message=\"Process is running.\"\n)\n</code></pre> <p>Verifies that the process is not running.</p> <p>If <code>handle</code> is not given, uses the current <code>active process</code>.</p> <p>Fails if the process is still running.</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def process_should_be_stopped(self, handle=None,\n                              error_message='Process is running.'):\n    \"\"\"Verifies that the process is not running.\n\n    If ``handle`` is not given, uses the current `active process`.\n\n    Fails if the process is still running.\n    \"\"\"\n    if self.is_process_running(handle):\n        raise AssertionError(error_message)\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.wait_for_process","title":"wait_for_process","text":"<pre><code>wait_for_process(\n    handle=None, timeout=None, on_timeout=\"continue\"\n)\n</code></pre> <p>Waits for the process to complete or to reach the given timeout.</p> <p>The process to wait for must have been started earlier with <code>Start Process</code>. If <code>handle</code> is not given, uses the current <code>active process</code>.</p> <p><code>timeout</code> defines the maximum time to wait for the process. It can be given in [http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#time-format| various time formats] supported by Robot Framework, for example, <code>42</code>, <code>42 s</code>, or <code>1 minute 30 seconds</code>. The timeout is ignored if it is Python <code>None</code> (default), string <code>NONE</code> (case-insensitively), zero, or negative.</p> <p><code>on_timeout</code> defines what to do if the timeout occurs. Possible values and corresponding actions are explained in the table below. Notice that reaching the timeout never fails the test.</p> <p>| = Value = |               = Action =               | | continue  | The process is left running (default). | | terminate | The process is gracefully terminated.  | | kill      | The process is forcefully stopped.     |</p> <p>See <code>Terminate Process</code> keyword for more details how processes are terminated and killed.</p> <p>If the process ends before the timeout or it is terminated or killed, this keyword returns a <code>result object</code> containing information about the execution. If the process is left running, Python <code>None</code> is returned instead.</p> <p>Examples: | # Process ends cleanly      |                  |                  | | ${result} =                 | Wait For Process | example          | | Process Should Be Stopped   | example          |                  | | Should Be Equal As Integers | ${result.rc}     | 0                | | # Process does not end      |                  |                  | | ${result} =                 | Wait For Process | timeout=42 secs  | | Process Should Be Running   |                  |                  | | Should Be Equal             | ${result}        | ${NONE}          | | # Kill non-ending process   |                  |                  | | ${result} =                 | Wait For Process | timeout=1min 30s | on_timeout=kill | | Process Should Be Stopped   |                  |                  | | Should Be Equal As Integers | ${result.rc}     | -9               |</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def wait_for_process(self, handle=None, timeout=None, on_timeout='continue'):\n    \"\"\"Waits for the process to complete or to reach the given timeout.\n\n    The process to wait for must have been started earlier with\n    `Start Process`. If ``handle`` is not given, uses the current\n    `active process`.\n\n    ``timeout`` defines the maximum time to wait for the process. It can be\n    given in\n    [http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#time-format|\n    various time formats] supported by Robot Framework, for example, ``42``,\n    ``42 s``, or ``1 minute 30 seconds``. The timeout is ignored if it is\n    Python ``None`` (default), string ``NONE`` (case-insensitively), zero,\n    or negative.\n\n    ``on_timeout`` defines what to do if the timeout occurs. Possible values\n    and corresponding actions are explained in the table below. Notice\n    that reaching the timeout never fails the test.\n\n    | = Value = |               = Action =               |\n    | continue  | The process is left running (default). |\n    | terminate | The process is gracefully terminated.  |\n    | kill      | The process is forcefully stopped.     |\n\n    See `Terminate Process` keyword for more details how processes are\n    terminated and killed.\n\n    If the process ends before the timeout or it is terminated or killed,\n    this keyword returns a `result object` containing information about\n    the execution. If the process is left running, Python ``None`` is\n    returned instead.\n\n    Examples:\n    | # Process ends cleanly      |                  |                  |\n    | ${result} =                 | Wait For Process | example          |\n    | Process Should Be Stopped   | example          |                  |\n    | Should Be Equal As Integers | ${result.rc}     | 0                |\n    | # Process does not end      |                  |                  |\n    | ${result} =                 | Wait For Process | timeout=42 secs  |\n    | Process Should Be Running   |                  |                  |\n    | Should Be Equal             | ${result}        | ${NONE}          |\n    | # Kill non-ending process   |                  |                  |\n    | ${result} =                 | Wait For Process | timeout=1min 30s | on_timeout=kill |\n    | Process Should Be Stopped   |                  |                  |\n    | Should Be Equal As Integers | ${result.rc}     | -9               |\n    \"\"\"\n    process = self._processes[handle]\n    logger.info('Waiting for process to complete.')\n    timeout = self._get_timeout(timeout)\n    if timeout &gt; 0:\n        if not self._process_is_stopped(process, timeout):\n            logger.info(f'Process did not complete in {secs_to_timestr(timeout)}.')\n            return self._manage_process_timeout(handle, on_timeout.lower())\n    return self._wait(process)\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.terminate_process","title":"terminate_process","text":"<pre><code>terminate_process(handle=None, kill=False)\n</code></pre> <p>Stops the process gracefully or forcefully.</p> <p>If <code>handle</code> is not given, uses the current <code>active process</code>.</p> <p>By default first tries to stop the process gracefully. If the process does not stop in 30 seconds, or <code>kill</code> argument is given a true value, (see <code>Boolean arguments</code>) kills the process forcefully. Stops also all the child processes of the originally started process.</p> <p>Waits for the process to stop after terminating it. Returns a <code>result object</code> containing information about the execution similarly as <code>Wait For Process</code>.</p> <p>On Unix-like machines graceful termination is done using <code>TERM (15)</code> signal and killing using <code>KILL (9)</code>. Use <code>Send Signal To Process</code> instead if you just want to send either of these signals without waiting for the process to stop.</p> <p>On Windows graceful termination is done using <code>CTRL_BREAK_EVENT</code> event and killing using Win32 API function <code>TerminateProcess()</code>.</p> <p>Examples: | ${result} =                 | Terminate Process |     | | Should Be Equal As Integers | ${result.rc}      | -15 | # On Unixes | | Terminate Process           | myproc            | kill=true |</p> <p>Limitations: - On Windows forceful kill only stops the main process, not possible   child processes.</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def terminate_process(self, handle=None, kill=False):\n    \"\"\"Stops the process gracefully or forcefully.\n\n    If ``handle`` is not given, uses the current `active process`.\n\n    By default first tries to stop the process gracefully. If the process\n    does not stop in 30 seconds, or ``kill`` argument is given a true value,\n    (see `Boolean arguments`) kills the process forcefully. Stops also all\n    the child processes of the originally started process.\n\n    Waits for the process to stop after terminating it. Returns a `result\n    object` containing information about the execution similarly as `Wait\n    For Process`.\n\n    On Unix-like machines graceful termination is done using ``TERM (15)``\n    signal and killing using ``KILL (9)``. Use `Send Signal To Process`\n    instead if you just want to send either of these signals without\n    waiting for the process to stop.\n\n    On Windows graceful termination is done using ``CTRL_BREAK_EVENT``\n    event and killing using Win32 API function ``TerminateProcess()``.\n\n    Examples:\n    | ${result} =                 | Terminate Process |     |\n    | Should Be Equal As Integers | ${result.rc}      | -15 | # On Unixes |\n    | Terminate Process           | myproc            | kill=true |\n\n    Limitations:\n    - On Windows forceful kill only stops the main process, not possible\n      child processes.\n    \"\"\"\n    process = self._processes[handle]\n    if not hasattr(process, 'terminate'):\n        raise RuntimeError('Terminating processes is not supported '\n                           'by this Python version.')\n    terminator = self._kill if is_truthy(kill) else self._terminate\n    try:\n        terminator(process)\n    except OSError:\n        if not self._process_is_stopped(process, self.KILL_TIMEOUT):\n            raise\n        logger.debug('Ignored OSError because process was stopped.')\n    return self._wait(process)\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.terminate_all_processes","title":"terminate_all_processes","text":"<pre><code>terminate_all_processes(kill=False)\n</code></pre> <p>Terminates all still running processes started by this library.</p> <p>This keyword can be used in suite teardown or elsewhere to make sure that all processes are stopped,</p> <p>By default tries to terminate processes gracefully, but can be configured to forcefully kill them immediately. See <code>Terminate Process</code> that this keyword uses internally for more details.</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def terminate_all_processes(self, kill=False):\n    \"\"\"Terminates all still running processes started by this library.\n\n    This keyword can be used in suite teardown or elsewhere to make\n    sure that all processes are stopped,\n\n    By default tries to terminate processes gracefully, but can be\n    configured to forcefully kill them immediately. See `Terminate Process`\n    that this keyword uses internally for more details.\n    \"\"\"\n    for handle in range(1, len(self._processes) + 1):\n        if self.is_process_running(handle):\n            self.terminate_process(handle, kill=kill)\n    self.__init__()\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.send_signal_to_process","title":"send_signal_to_process","text":"<pre><code>send_signal_to_process(signal, handle=None, group=False)\n</code></pre> <p>Sends the given <code>signal</code> to the specified process.</p> <p>If <code>handle</code> is not given, uses the current <code>active process</code>.</p> <p>Signal can be specified either as an integer as a signal name. In the latter case it is possible to give the name both with or without <code>SIG</code> prefix, but names are case-sensitive. For example, all the examples below send signal <code>INT (2)</code>:</p> <p>| Send Signal To Process | 2      |        | # Send to active process | | Send Signal To Process | INT    |        |                          | | Send Signal To Process | SIGINT | myproc | # Send to named process  |</p> <p>This keyword is only supported on Unix-like machines, not on Windows. What signals are supported depends on the system. For a list of existing signals on your system, see the Unix man pages related to signal handling (typically <code>man signal</code> or <code>man 7 signal</code>).</p> <p>By default sends the signal only to the parent process, not to possible child processes started by it. Notice that when <code>running processes in shell</code>, the shell is the parent process and it depends on the system does the shell propagate the signal to the actual started process.</p> <p>To send the signal to the whole process group, <code>group</code> argument can be set to any true value (see <code>Boolean arguments</code>).</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def send_signal_to_process(self, signal, handle=None, group=False):\n    \"\"\"Sends the given ``signal`` to the specified process.\n\n    If ``handle`` is not given, uses the current `active process`.\n\n    Signal can be specified either as an integer as a signal name. In the\n    latter case it is possible to give the name both with or without ``SIG``\n    prefix, but names are case-sensitive. For example, all the examples\n    below send signal ``INT (2)``:\n\n    | Send Signal To Process | 2      |        | # Send to active process |\n    | Send Signal To Process | INT    |        |                          |\n    | Send Signal To Process | SIGINT | myproc | # Send to named process  |\n\n    This keyword is only supported on Unix-like machines, not on Windows.\n    What signals are supported depends on the system. For a list of\n    existing signals on your system, see the Unix man pages related to\n    signal handling (typically ``man signal`` or ``man 7 signal``).\n\n    By default sends the signal only to the parent process, not to possible\n    child processes started by it. Notice that when `running processes in\n    shell`, the shell is the parent process and it depends on the system\n    does the shell propagate the signal to the actual started process.\n\n    To send the signal to the whole process group, ``group`` argument can\n    be set to any true value (see `Boolean arguments`).\n    \"\"\"\n    if os.sep == '\\\\':\n        raise RuntimeError('This keyword does not work on Windows.')\n    process = self._processes[handle]\n    signum = self._get_signal_number(signal)\n    logger.info(f'Sending signal {signal} ({signum}).')\n    if is_truthy(group) and hasattr(os, 'killpg'):\n        os.killpg(process.pid, signum)\n    elif hasattr(process, 'send_signal'):\n        process.send_signal(signum)\n    else:\n        raise RuntimeError('Sending signals is not supported '\n                           'by this Python version.')\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.get_process_id","title":"get_process_id","text":"<pre><code>get_process_id(handle=None)\n</code></pre> <p>Returns the process ID (pid) of the process as an integer.</p> <p>If <code>handle</code> is not given, uses the current <code>active process</code>.</p> <p>Starting from Robot Framework 5.0, it is also possible to directly access the <code>pid</code> attribute of the <code>subprocess.Popen</code> object returned by <code>Start Process</code> like <code>${process.pid}</code>.</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def get_process_id(self, handle=None):\n    \"\"\"Returns the process ID (pid) of the process as an integer.\n\n    If ``handle`` is not given, uses the current `active process`.\n\n    Starting from Robot Framework 5.0, it is also possible to directly access\n    the ``pid`` attribute of the ``subprocess.Popen`` object returned by\n    `Start Process` like ``${process.pid}``.\n    \"\"\"\n    return self._processes[handle].pid\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.get_process_object","title":"get_process_object","text":"<pre><code>get_process_object(handle=None)\n</code></pre> <p>Return the underlying <code>subprocess.Popen</code> object.</p> <p>If <code>handle</code> is not given, uses the current <code>active process</code>.</p> <p>Starting from Robot Framework 5.0, <code>Start Process</code> returns the created <code>subprocess.Popen</code> object, not a generic handle, making this keyword mostly redundant.</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def get_process_object(self, handle=None):\n    \"\"\"Return the underlying ``subprocess.Popen`` object.\n\n    If ``handle`` is not given, uses the current `active process`.\n\n    Starting from Robot Framework 5.0, `Start Process` returns the created\n    ``subprocess.Popen`` object, not a generic handle, making this keyword\n    mostly redundant.\n    \"\"\"\n    return self._processes[handle]\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.get_process_result","title":"get_process_result","text":"<pre><code>get_process_result(\n    handle=None,\n    rc=False,\n    stdout=False,\n    stderr=False,\n    stdout_path=False,\n    stderr_path=False,\n)\n</code></pre> <p>Returns the specified <code>result object</code> or some of its attributes.</p> <p>The given <code>handle</code> specifies the process whose results should be returned. If no <code>handle</code> is given, results of the current <code>active process</code> are returned. In either case, the process must have been finishes before this keyword can be used. In practice this means that processes started with <code>Start Process</code> must be finished either with <code>Wait For Process</code> or <code>Terminate Process</code> before using this keyword.</p> <p>If no other arguments than the optional <code>handle</code> are given, a whole <code>result object</code> is returned. If one or more of the other arguments are given any true value, only the specified attributes of the <code>result object</code> are returned. These attributes are always returned in the same order as arguments are specified in the keyword signature. See <code>Boolean arguments</code> section for more details about true and false values.</p> <p>Examples: | Run Process           | python             | -c            | print('Hello, world!') | alias=myproc | | # Get result object   |                    |               | | ${result} =           | Get Process Result | myproc        | | Should Be Equal       | ${result.rc}       | ${0}          | | Should Be Equal       | ${result.stdout}   | Hello, world! | | Should Be Empty       | ${result.stderr}   |               | | # Get one attribute   |                    |               | | ${stdout} =           | Get Process Result | myproc        | stdout=true | | Should Be Equal       | ${stdout}          | Hello, world! | | # Multiple attributes |                    |               | | ${stdout}             | ${stderr} =        | Get Process Result |  myproc | stdout=yes | stderr=yes | | Should Be Equal       | ${stdout}          | Hello, world! | | Should Be Empty       | ${stderr}          |               |</p> <p>Although getting results of a previously executed process can be handy in general, the main use case for this keyword is returning results over the remote library interface. The remote interface does not support returning the whole result object, but individual attributes can be returned without problems.</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def get_process_result(self, handle=None, rc=False, stdout=False,\n                       stderr=False, stdout_path=False, stderr_path=False):\n    \"\"\"Returns the specified `result object` or some of its attributes.\n\n    The given ``handle`` specifies the process whose results should be\n    returned. If no ``handle`` is given, results of the current `active\n    process` are returned. In either case, the process must have been\n    finishes before this keyword can be used. In practice this means\n    that processes started with `Start Process` must be finished either\n    with `Wait For Process` or `Terminate Process` before using this\n    keyword.\n\n    If no other arguments than the optional ``handle`` are given, a whole\n    `result object` is returned. If one or more of the other arguments\n    are given any true value, only the specified attributes of the\n    `result object` are returned. These attributes are always returned\n    in the same order as arguments are specified in the keyword signature.\n    See `Boolean arguments` section for more details about true and false\n    values.\n\n    Examples:\n    | Run Process           | python             | -c            | print('Hello, world!') | alias=myproc |\n    | # Get result object   |                    |               |\n    | ${result} =           | Get Process Result | myproc        |\n    | Should Be Equal       | ${result.rc}       | ${0}          |\n    | Should Be Equal       | ${result.stdout}   | Hello, world! |\n    | Should Be Empty       | ${result.stderr}   |               |\n    | # Get one attribute   |                    |               |\n    | ${stdout} =           | Get Process Result | myproc        | stdout=true |\n    | Should Be Equal       | ${stdout}          | Hello, world! |\n    | # Multiple attributes |                    |               |\n    | ${stdout}             | ${stderr} =        | Get Process Result |  myproc | stdout=yes | stderr=yes |\n    | Should Be Equal       | ${stdout}          | Hello, world! |\n    | Should Be Empty       | ${stderr}          |               |\n\n    Although getting results of a previously executed process can be handy\n    in general, the main use case for this keyword is returning results\n    over the remote library interface. The remote interface does not\n    support returning the whole result object, but individual attributes\n    can be returned without problems.\n    \"\"\"\n    result = self._results[self._processes[handle]]\n    if result.rc is None:\n        raise RuntimeError('Getting results of unfinished processes '\n                           'is not supported.')\n    attributes = self._get_result_attributes(result, rc, stdout, stderr,\n                                             stdout_path, stderr_path)\n    if not attributes:\n        return result\n    elif len(attributes) == 1:\n        return attributes[0]\n    return attributes\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.switch_process","title":"switch_process","text":"<pre><code>switch_process(handle)\n</code></pre> <p>Makes the specified process the current <code>active process</code>.</p> <p>The handle can be an identifier returned by <code>Start Process</code> or the <code>alias</code> given to it explicitly.</p> <p>Example: | Start Process  | prog1    | alias=process1 | | Start Process  | prog2    | alias=process2 | | # currently active process is process2 | | Switch Process | process1 | | # now active process is process1 |</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def switch_process(self, handle):\n    \"\"\"Makes the specified process the current `active process`.\n\n    The handle can be an identifier returned by `Start Process` or\n    the ``alias`` given to it explicitly.\n\n    Example:\n    | Start Process  | prog1    | alias=process1 |\n    | Start Process  | prog2    | alias=process2 |\n    | # currently active process is process2 |\n    | Switch Process | process1 |\n    | # now active process is process1 |\n    \"\"\"\n    self._processes.switch(handle)\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.split_command_line","title":"split_command_line","text":"<pre><code>split_command_line(args, escaping=False)\n</code></pre> <p>Splits command line string into a list of arguments.</p> <p>String is split from spaces, but argument surrounded in quotes may contain spaces in them.</p> <p>If <code>escaping</code> is given a true value, then backslash is treated as an escape character. It can escape unquoted spaces, quotes inside quotes, and so on, but it also requires using doubling backslashes in Windows paths and elsewhere.</p> <p>Examples: | @{cmd} = | Split Command Line | --option \"value with spaces\" | | Should Be True | $cmd == ['--option', 'value with spaces'] |</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def split_command_line(self, args, escaping=False):\n    \"\"\"Splits command line string into a list of arguments.\n\n    String is split from spaces, but argument surrounded in quotes may\n    contain spaces in them.\n\n    If ``escaping`` is given a true value, then backslash is treated as\n    an escape character. It can escape unquoted spaces, quotes inside\n    quotes, and so on, but it also requires using doubling backslashes\n    in Windows paths and elsewhere.\n\n    Examples:\n    | @{cmd} = | Split Command Line | --option \"value with spaces\" |\n    | Should Be True | $cmd == ['--option', 'value with spaces'] |\n    \"\"\"\n    return cmdline2list(args, escaping=escaping)\n</code></pre>"},{"location":"api/robot/libraries/Process/#robot.libraries.Process.Process.join_command_line","title":"join_command_line","text":"<pre><code>join_command_line(*args)\n</code></pre> <p>Joins arguments into one command line string.</p> <p>In resulting command line string arguments are delimited with a space, arguments containing spaces are surrounded with quotes, and possible quotes are escaped with a backslash.</p> <p>If this keyword is given only one argument and that is a list-like object, then the values of that list are joined instead.</p> <p>Example: | ${cmd} = | Join Command Line | --option | value with spaces | | Should Be Equal | ${cmd} | --option \"value with spaces\" |</p> Source code in <code>src/robot/libraries/Process.py</code> <pre><code>def join_command_line(self, *args):\n    \"\"\"Joins arguments into one command line string.\n\n    In resulting command line string arguments are delimited with a space,\n    arguments containing spaces are surrounded with quotes, and possible\n    quotes are escaped with a backslash.\n\n    If this keyword is given only one argument and that is a list-like\n    object, then the values of that list are joined instead.\n\n    Example:\n    | ${cmd} = | Join Command Line | --option | value with spaces |\n    | Should Be Equal | ${cmd} | --option \"value with spaces\" |\n    \"\"\"\n    if len(args) == 1 and is_list_like(args[0]):\n        args = args[0]\n    return subprocess.list2cmdline(str(a) for a in args)\n</code></pre>"},{"location":"api/robot/libraries/Remote/","title":"robot.libraries.Remote","text":""},{"location":"api/robot/libraries/Remote/#robot.libraries.Remote","title":"robot.libraries.Remote","text":""},{"location":"api/robot/libraries/Remote/#robot.libraries.Remote.Remote","title":"Remote","text":"<pre><code>Remote(uri='http://127.0.0.1:8270', timeout=None)\n</code></pre> <p>Connects to a remote server at <code>uri</code>.</p> <p>Optional <code>timeout</code> can be used to specify a timeout to wait when initially connecting to the server and if a connection accidentally closes. Timeout can be given as seconds (e.g. <code>60</code>) or using Robot Framework time format (e.g. <code>60s</code>, <code>2 minutes 10 seconds</code>).</p> <p>The default timeout is typically several minutes, but it depends on the operating system and its configuration. Notice that setting a timeout that is shorter than keyword execution time will interrupt the keyword.</p> Source code in <code>src/robot/libraries/Remote.py</code> <pre><code>def __init__(self, uri='http://127.0.0.1:8270', timeout=None):\n    \"\"\"Connects to a remote server at ``uri``.\n\n    Optional ``timeout`` can be used to specify a timeout to wait when\n    initially connecting to the server and if a connection accidentally\n    closes. Timeout can be given as seconds (e.g. ``60``) or using\n    Robot Framework time format (e.g. ``60s``, ``2 minutes 10 seconds``).\n\n    The default timeout is typically several minutes, but it depends on\n    the operating system and its configuration. Notice that setting\n    a timeout that is shorter than keyword execution time will interrupt\n    the keyword.\n    \"\"\"\n    if '://' not in uri:\n        uri = 'http://' + uri\n    if timeout:\n        timeout = timestr_to_secs(timeout)\n    self._uri = uri\n    self._client = XmlRpcRemoteClient(uri, timeout)\n    self._lib_info = None\n    self._lib_info_initialized = False\n</code></pre>"},{"location":"api/robot/libraries/Screenshot/","title":"robot.libraries.Screenshot","text":""},{"location":"api/robot/libraries/Screenshot/#robot.libraries.Screenshot","title":"robot.libraries.Screenshot","text":""},{"location":"api/robot/libraries/Screenshot/#robot.libraries.Screenshot.Screenshot","title":"Screenshot","text":"<pre><code>Screenshot(\n    screenshot_directory=None, screenshot_module=None\n)\n</code></pre> <p>Library for taking screenshots on the machine where tests are executed.</p> <p>Taking the actual screenshot requires a suitable tool or module that may need to be installed separately. Taking screenshots also requires tests to be run with a physical or virtual display.</p> <p>== Table of contents ==</p> <p>%TOC%</p> <p>= Supported screenshot taking tools and modules =</p> <p>How screenshots are taken depends on the operating system. On OSX screenshots are taken using the built-in <code>screencapture</code> utility. On other operating systems you need to have one of the following tools or Python modules installed. You can specify the tool/module to use when <code>importing</code> the library. If no tool or module is specified, the first one found will be used.</p> <ul> <li>wxPython :: http://wxpython.org :: Generic Python GUI toolkit.</li> <li>PyGTK :: http://pygtk.org :: This module is available by default on most   Linux distributions.</li> <li>Pillow :: http://python-pillow.github.io ::   Only works on Windows. Also the original PIL package is supported.</li> <li>Scrot :: http://en.wikipedia.org/wiki/Scrot :: Not used on Windows.   Install with <code>apt-get install scrot</code> or similar.</li> </ul> <p>= Where screenshots are saved =</p> <p>By default screenshots are saved into the same directory where the Robot Framework log file is written. If no log is created, screenshots are saved into the directory where the XML output file is written.</p> <p>It is possible to specify a custom location for screenshots using <code>screenshot_directory</code> argument when <code>importing</code> the library and using <code>Set Screenshot Directory</code> keyword during execution. It is also possible to save screenshots using an absolute path.</p> <p>= ScreenCapLibrary =</p> <p>[mihaiparvu/ScreenCapLibrary|ScreenCapLibrary] is an external Robot Framework library that can be used as an alternative, which additionally provides support for multiple formats, adjusting the quality, using GIFs and video capturing.</p> <p>Configure where screenshots are saved.</p> <p>If <code>screenshot_directory</code> is not given, screenshots are saved into same directory as the log file. The directory can also be set using <code>Set Screenshot Directory</code> keyword.</p> <p><code>screenshot_module</code> specifies the module or tool to use when using this library outside OSX. Possible values are <code>wxPython</code>, <code>PyGTK</code>, <code>PIL</code> and <code>scrot</code>, case-insensitively. If no value is given, the first module/tool found is used in that order.</p> <p>Examples: | =Setting= |  =Value=   |  =Value=   | | Library   | Screenshot |            | | Library   | Screenshot | ${TEMPDIR} | | Library   | Screenshot | screenshot_module=PyGTK |</p> Source code in <code>src/robot/libraries/Screenshot.py</code> <pre><code>def __init__(self, screenshot_directory=None, screenshot_module=None):\n    \"\"\"Configure where screenshots are saved.\n\n    If ``screenshot_directory`` is not given, screenshots are saved into\n    same directory as the log file. The directory can also be set using\n    `Set Screenshot Directory` keyword.\n\n    ``screenshot_module`` specifies the module or tool to use when using\n    this library outside OSX. Possible values are ``wxPython``,\n    ``PyGTK``, ``PIL`` and ``scrot``, case-insensitively. If no value is\n    given, the first module/tool found is used in that order.\n\n    Examples:\n    | =Setting= |  =Value=   |  =Value=   |\n    | Library   | Screenshot |            |\n    | Library   | Screenshot | ${TEMPDIR} |\n    | Library   | Screenshot | screenshot_module=PyGTK |\n    \"\"\"\n    self._given_screenshot_dir = self._norm_path(screenshot_directory)\n    self._screenshot_taker = ScreenshotTaker(screenshot_module)\n</code></pre>"},{"location":"api/robot/libraries/Screenshot/#robot.libraries.Screenshot.Screenshot.set_screenshot_directory","title":"set_screenshot_directory","text":"<pre><code>set_screenshot_directory(path)\n</code></pre> <p>Sets the directory where screenshots are saved.</p> <p>It is possible to use <code>/</code> as a path separator in all operating systems. Path to the old directory is returned.</p> <p>The directory can also be set in <code>importing</code>.</p> Source code in <code>src/robot/libraries/Screenshot.py</code> <pre><code>def set_screenshot_directory(self, path):\n    \"\"\"Sets the directory where screenshots are saved.\n\n    It is possible to use ``/`` as a path separator in all operating\n    systems. Path to the old directory is returned.\n\n    The directory can also be set in `importing`.\n    \"\"\"\n    path = self._norm_path(path)\n    if not os.path.isdir(path):\n        raise RuntimeError(\"Directory '%s' does not exist.\" % path)\n    old = self._screenshot_dir\n    self._given_screenshot_dir = path\n    return old\n</code></pre>"},{"location":"api/robot/libraries/Screenshot/#robot.libraries.Screenshot.Screenshot.take_screenshot","title":"take_screenshot","text":"<pre><code>take_screenshot(name='screenshot', width='800px')\n</code></pre> <p>Takes a screenshot in JPEG format and embeds it into the log file.</p> <p>Name of the file where the screenshot is stored is derived from the given <code>name</code>. If the <code>name</code> ends with extension <code>.jpg</code> or <code>.jpeg</code>, the screenshot will be stored with that exact name. Otherwise a unique name is created by adding an underscore, a running index and an extension to the <code>name</code>.</p> <p>The name will be interpreted to be relative to the directory where the log file is written. It is also possible to use absolute paths. Using <code>/</code> as a path separator works in all operating systems.</p> <p><code>width</code> specifies the size of the screenshot in the log file.</p> <p>Examples: (LOGDIR is determined automatically by the library) | Take Screenshot |                  |     | # LOGDIR/screenshot_1.jpg (index automatically incremented) | | Take Screenshot | mypic            |     | # LOGDIR/mypic_1.jpg (index automatically incremented) | | Take Screenshot | ${TEMPDIR}/mypic |     | # /tmp/mypic_1.jpg (index automatically incremented) | | Take Screenshot | pic.jpg          |     | # LOGDIR/pic.jpg (always uses this file) | | Take Screenshot | images/login.jpg | 80% | # Specify both name and width. | | Take Screenshot | width=550px      |     | # Specify only width. |</p> <p>The path where the screenshot is saved is returned.</p> Source code in <code>src/robot/libraries/Screenshot.py</code> <pre><code>def take_screenshot(self, name=\"screenshot\", width=\"800px\"):\n    \"\"\"Takes a screenshot in JPEG format and embeds it into the log file.\n\n    Name of the file where the screenshot is stored is derived from the\n    given ``name``. If the ``name`` ends with extension ``.jpg`` or\n    ``.jpeg``, the screenshot will be stored with that exact name.\n    Otherwise a unique name is created by adding an underscore, a running\n    index and an extension to the ``name``.\n\n    The name will be interpreted to be relative to the directory where\n    the log file is written. It is also possible to use absolute paths.\n    Using ``/`` as a path separator works in all operating systems.\n\n    ``width`` specifies the size of the screenshot in the log file.\n\n    Examples: (LOGDIR is determined automatically by the library)\n    | Take Screenshot |                  |     | # LOGDIR/screenshot_1.jpg (index automatically incremented) |\n    | Take Screenshot | mypic            |     | # LOGDIR/mypic_1.jpg (index automatically incremented) |\n    | Take Screenshot | ${TEMPDIR}/mypic |     | # /tmp/mypic_1.jpg (index automatically incremented) |\n    | Take Screenshot | pic.jpg          |     | # LOGDIR/pic.jpg (always uses this file) |\n    | Take Screenshot | images/login.jpg | 80% | # Specify both name and width. |\n    | Take Screenshot | width=550px      |     | # Specify only width. |\n\n    The path where the screenshot is saved is returned.\n    \"\"\"\n    path = self._save_screenshot(name)\n    self._embed_screenshot(path, width)\n    return path\n</code></pre>"},{"location":"api/robot/libraries/Screenshot/#robot.libraries.Screenshot.Screenshot.take_screenshot_without_embedding","title":"take_screenshot_without_embedding","text":"<pre><code>take_screenshot_without_embedding(name='screenshot')\n</code></pre> <p>Takes a screenshot and links it from the log file.</p> <p>This keyword is otherwise identical to <code>Take Screenshot</code> but the saved screenshot is not embedded into the log file. The screenshot is linked so it is nevertheless easily available.</p> Source code in <code>src/robot/libraries/Screenshot.py</code> <pre><code>def take_screenshot_without_embedding(self, name=\"screenshot\"):\n    \"\"\"Takes a screenshot and links it from the log file.\n\n    This keyword is otherwise identical to `Take Screenshot` but the saved\n    screenshot is not embedded into the log file. The screenshot is linked\n    so it is nevertheless easily available.\n    \"\"\"\n    path = self._save_screenshot(name)\n    self._link_screenshot(path)\n    return path\n</code></pre>"},{"location":"api/robot/libraries/String/","title":"robot.libraries.String","text":""},{"location":"api/robot/libraries/String/#robot.libraries.String","title":"robot.libraries.String","text":""},{"location":"api/robot/libraries/String/#robot.libraries.String.String","title":"String","text":"<p>A library for string manipulation and verification.</p> <p><code>String</code> is Robot Framework's standard library for manipulating strings (e.g. <code>Replace String Using Regexp</code>, <code>Split To Lines</code>) and verifying their contents (e.g. <code>Should Be String</code>).</p> <p>Following keywords from <code>BuiltIn</code> library can also be used with strings:</p> <ul> <li><code>Catenate</code></li> <li><code>Get Length</code></li> <li><code>Length Should Be</code></li> <li><code>Should (Not) Be Empty</code></li> <li><code>Should (Not) Be Equal (As Strings/Integers/Numbers)</code></li> <li><code>Should (Not) Match (Regexp)</code></li> <li><code>Should (Not) Contain</code></li> <li><code>Should (Not) Start With</code></li> <li><code>Should (Not) End With</code></li> <li><code>Convert To String</code></li> <li><code>Convert To Bytes</code></li> </ul>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.convert_to_lower_case","title":"convert_to_lower_case","text":"<pre><code>convert_to_lower_case(string)\n</code></pre> <p>Converts string to lower case.</p> <p>Uses Python's standard [https://docs.python.org/library/stdtypes.html#str.lower|lower()] method.</p> <p>Examples: | ${str1} = | Convert To Lower Case | ABC | | ${str2} = | Convert To Lower Case | 1A2c3D | | Should Be Equal | ${str1} | abc | | Should Be Equal | ${str2} | 1a2c3d |</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def convert_to_lower_case(self, string):\n    \"\"\"Converts string to lower case.\n\n    Uses Python's standard\n    [https://docs.python.org/library/stdtypes.html#str.lower|lower()]\n    method.\n\n    Examples:\n    | ${str1} = | Convert To Lower Case | ABC |\n    | ${str2} = | Convert To Lower Case | 1A2c3D |\n    | Should Be Equal | ${str1} | abc |\n    | Should Be Equal | ${str2} | 1a2c3d |\n    \"\"\"\n    return string.lower()\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.convert_to_upper_case","title":"convert_to_upper_case","text":"<pre><code>convert_to_upper_case(string)\n</code></pre> <p>Converts string to upper case.</p> <p>Uses Python's standard [https://docs.python.org/library/stdtypes.html#str.upper|upper()] method.</p> <p>Examples: | ${str1} = | Convert To Upper Case | abc | | ${str2} = | Convert To Upper Case | 1a2C3d | | Should Be Equal | ${str1} | ABC | | Should Be Equal | ${str2} | 1A2C3D |</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def convert_to_upper_case(self, string):\n    \"\"\"Converts string to upper case.\n\n    Uses Python's standard\n    [https://docs.python.org/library/stdtypes.html#str.upper|upper()]\n    method.\n\n    Examples:\n    | ${str1} = | Convert To Upper Case | abc |\n    | ${str2} = | Convert To Upper Case | 1a2C3d |\n    | Should Be Equal | ${str1} | ABC |\n    | Should Be Equal | ${str2} | 1A2C3D |\n    \"\"\"\n    return string.upper()\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.convert_to_title_case","title":"convert_to_title_case","text":"<pre><code>convert_to_title_case(string, exclude=None)\n</code></pre> <p>Converts string to title case.</p> <p>Uses the following algorithm:</p> <ul> <li>Split the string to words from whitespace characters (spaces,   newlines, etc.).</li> <li>Exclude words that are not all lower case. This preserves,   for example, \"OK\" and \"iPhone\".</li> <li>Exclude also words listed in the optional <code>exclude</code> argument.</li> <li>Title case the first alphabetical character of each word that has   not been excluded.</li> <li>Join all words together so that original whitespace is preserved.</li> </ul> <p>Explicitly excluded words can be given as a list or as a string with words separated by a comma and an optional space. Excluded words are actually considered to be regular expression patterns, so it is possible to use something like \"example[.!?]?\" to match the word \"example\" on it own and also if followed by \".\", \"!\" or \"?\". See <code>BuiltIn.Should Match Regexp</code> for more information about Python regular expression syntax in general and how to use it in Robot Framework data in particular.</p> <p>Examples: | ${str1} = | Convert To Title Case | hello, world!     | | ${str2} = | Convert To Title Case | it's an OK iPhone | exclude=a, an, the | | ${str3} = | Convert To Title Case | distance is 1 km. | exclude=is, km.? | | Should Be Equal | ${str1} | Hello, World! | | Should Be Equal | ${str2} | It's an OK iPhone | | Should Be Equal | ${str3} | Distance is 1 km. |</p> <p>The reason this keyword does not use Python's standard [https://docs.python.org/library/stdtypes.html#str.title|title()] method is that it can yield undesired results, for example, if strings contain upper case letters or special characters like apostrophes. It would, for example, convert \"it's an OK iPhone\" to \"It'S An Ok Iphone\".</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>@keyword(types=None)\ndef convert_to_title_case(self, string, exclude=None):\n    \"\"\"Converts string to title case.\n\n    Uses the following algorithm:\n\n    - Split the string to words from whitespace characters (spaces,\n      newlines, etc.).\n    - Exclude words that are not all lower case. This preserves,\n      for example, \"OK\" and \"iPhone\".\n    - Exclude also words listed in the optional ``exclude`` argument.\n    - Title case the first alphabetical character of each word that has\n      not been excluded.\n    - Join all words together so that original whitespace is preserved.\n\n    Explicitly excluded words can be given as a list or as a string with\n    words separated by a comma and an optional space. Excluded words are\n    actually considered to be regular expression patterns, so it is\n    possible to use something like \"example[.!?]?\" to match the word\n    \"example\" on it own and also if followed by \".\", \"!\" or \"?\".\n    See `BuiltIn.Should Match Regexp` for more information about Python\n    regular expression syntax in general and how to use it in Robot\n    Framework data in particular.\n\n    Examples:\n    | ${str1} = | Convert To Title Case | hello, world!     |\n    | ${str2} = | Convert To Title Case | it's an OK iPhone | exclude=a, an, the |\n    | ${str3} = | Convert To Title Case | distance is 1 km. | exclude=is, km.? |\n    | Should Be Equal | ${str1} | Hello, World! |\n    | Should Be Equal | ${str2} | It's an OK iPhone |\n    | Should Be Equal | ${str3} | Distance is 1 km. |\n\n    The reason this keyword does not use Python's standard\n    [https://docs.python.org/library/stdtypes.html#str.title|title()]\n    method is that it can yield undesired results, for example, if\n    strings contain upper case letters or special characters like\n    apostrophes. It would, for example, convert \"it's an OK iPhone\"\n    to \"It'S An Ok Iphone\".\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError('This keyword works only with strings.')\n    if isinstance(exclude, str):\n        exclude = [e.strip() for e in exclude.split(',')]\n    elif not exclude:\n        exclude = []\n    exclude = [re.compile('^%s$' % e) for e in exclude]\n\n    def title(word):\n        if any(e.match(word) for e in exclude) or not word.islower():\n            return word\n        for index, char in enumerate(word):\n            if char.isalpha():\n                return word[:index] + word[index].title() + word[index+1:]\n        return word\n\n    tokens = re.split(r'(\\s+)', string, flags=re.UNICODE)\n    return ''.join(title(token) for token in tokens)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.encode_string_to_bytes","title":"encode_string_to_bytes","text":"<pre><code>encode_string_to_bytes(string, encoding, errors='strict')\n</code></pre> <p>Encodes the given <code>string</code> to bytes using the given <code>encoding</code>.</p> <p><code>errors</code> argument controls what to do if encoding some characters fails. All values accepted by <code>encode</code> method in Python are valid, but in practice the following values are most useful:</p> <ul> <li><code>strict</code>: fail if characters cannot be encoded (default)</li> <li><code>ignore</code>: ignore characters that cannot be encoded</li> <li><code>replace</code>: replace characters that cannot be encoded with   a replacement character</li> </ul> <p>Examples: | ${bytes} = | Encode String To Bytes | ${string} | UTF-8 | | ${bytes} = | Encode String To Bytes | ${string} | ASCII | errors=ignore |</p> <p>Use <code>Convert To Bytes</code> in <code>BuiltIn</code> if you want to create bytes based on character or integer sequences. Use <code>Decode Bytes To String</code> if you need to convert bytes to strings and <code>Convert To String</code> in <code>BuiltIn</code> if you need to convert arbitrary objects to strings.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def encode_string_to_bytes(self, string, encoding, errors='strict'):\n    \"\"\"Encodes the given ``string`` to bytes using the given ``encoding``.\n\n    ``errors`` argument controls what to do if encoding some characters fails.\n    All values accepted by ``encode`` method in Python are valid, but in\n    practice the following values are most useful:\n\n    - ``strict``: fail if characters cannot be encoded (default)\n    - ``ignore``: ignore characters that cannot be encoded\n    - ``replace``: replace characters that cannot be encoded with\n      a replacement character\n\n    Examples:\n    | ${bytes} = | Encode String To Bytes | ${string} | UTF-8 |\n    | ${bytes} = | Encode String To Bytes | ${string} | ASCII | errors=ignore |\n\n    Use `Convert To Bytes` in ``BuiltIn`` if you want to create bytes based\n    on character or integer sequences. Use `Decode Bytes To String` if you\n    need to convert bytes to strings and `Convert To String`\n    in ``BuiltIn`` if you need to convert arbitrary objects to strings.\n    \"\"\"\n    return bytes(string.encode(encoding, errors))\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.decode_bytes_to_string","title":"decode_bytes_to_string","text":"<pre><code>decode_bytes_to_string(bytes, encoding, errors='strict')\n</code></pre> <p>Decodes the given <code>bytes</code> to a string using the given <code>encoding</code>.</p> <p><code>errors</code> argument controls what to do if decoding some bytes fails. All values accepted by <code>decode</code> method in Python are valid, but in practice the following values are most useful:</p> <ul> <li><code>strict</code>: fail if characters cannot be decoded (default)</li> <li><code>ignore</code>: ignore characters that cannot be decoded</li> <li><code>replace</code>: replace characters that cannot be decoded with   a replacement character</li> </ul> <p>Examples: | ${string} = | Decode Bytes To String | ${bytes} | UTF-8 | | ${string} = | Decode Bytes To String | ${bytes} | ASCII | errors=ignore |</p> <p>Use <code>Encode String To Bytes</code> if you need to convert strings to bytes, and <code>Convert To String</code> in <code>BuiltIn</code> if you need to convert arbitrary objects to strings.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def decode_bytes_to_string(self, bytes, encoding, errors='strict'):\n    \"\"\"Decodes the given ``bytes`` to a string using the given ``encoding``.\n\n    ``errors`` argument controls what to do if decoding some bytes fails.\n    All values accepted by ``decode`` method in Python are valid, but in\n    practice the following values are most useful:\n\n    - ``strict``: fail if characters cannot be decoded (default)\n    - ``ignore``: ignore characters that cannot be decoded\n    - ``replace``: replace characters that cannot be decoded with\n      a replacement character\n\n    Examples:\n    | ${string} = | Decode Bytes To String | ${bytes} | UTF-8 |\n    | ${string} = | Decode Bytes To String | ${bytes} | ASCII | errors=ignore |\n\n    Use `Encode String To Bytes` if you need to convert strings to bytes,\n    and `Convert To String` in ``BuiltIn`` if you need to\n    convert arbitrary objects to strings.\n    \"\"\"\n    if isinstance(bytes, str):\n        raise TypeError('Cannot decode strings.')\n    return bytes.decode(encoding, errors)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.format_string","title":"format_string","text":"<pre><code>format_string(template, /, *positional, **named)\n</code></pre> <p>Formats a <code>template</code> using the given <code>positional</code> and <code>named</code> arguments.</p> <p>The template can be either be a string or an absolute path to an existing file. In the latter case the file is read and its contents are used as the template. If the template file contains non-ASCII characters, it must be encoded using UTF-8.</p> <p>The template is formatted using Python's [https://docs.python.org/library/string.html#format-string-syntax|format string syntax]. Placeholders are marked using <code>{}</code> with possible field name and format specification inside. Literal curly braces can be inserted by doubling them like <code>{{</code> and <code>}}</code>.</p> <p>Examples: | ${to} = | Format String | To: {} &lt;{}&gt;                    | ${user}      | ${email} | | ${to} = | Format String | To: {name} &lt;{email}&gt;           | name=${name} | email=${email} | | ${to} = | Format String | To: {user.name} &lt;{user.email}&gt; | user=${user} | | ${xx} = | Format String | {:*^30}                        | centered     | | ${yy} = | Format String | {0:{width}{base}}              | ${42}        | base=X | width=10 | | ${zz} = | Format String | ${CURDIR}/template.txt         | positional   | named=value |</p> <p>Prior to Robot Framework 7.1, possible equal signs in the template string must be escaped with a backslash like <code>`x\\={}</code>.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def format_string(self, template, /, *positional, **named):\n    \"\"\"Formats a ``template`` using the given ``positional`` and ``named`` arguments.\n\n    The template can be either be a string or an absolute path to\n    an existing file. In the latter case the file is read and its contents\n    are used as the template. If the template file contains non-ASCII\n    characters, it must be encoded using UTF-8.\n\n    The template is formatted using Python's\n    [https://docs.python.org/library/string.html#format-string-syntax|format\n    string syntax]. Placeholders are marked using ``{}`` with possible\n    field name and format specification inside. Literal curly braces\n    can be inserted by doubling them like `{{` and `}}`.\n\n    Examples:\n    | ${to} = | Format String | To: {} &lt;{}&gt;                    | ${user}      | ${email} |\n    | ${to} = | Format String | To: {name} &lt;{email}&gt;           | name=${name} | email=${email} |\n    | ${to} = | Format String | To: {user.name} &lt;{user.email}&gt; | user=${user} |\n    | ${xx} = | Format String | {:*^30}                        | centered     |\n    | ${yy} = | Format String | {0:{width}{base}}              | ${42}        | base=X | width=10 |\n    | ${zz} = | Format String | ${CURDIR}/template.txt         | positional   | named=value |\n\n    Prior to Robot Framework 7.1, possible equal signs in the template string must\n    be escaped with a backslash like ``x\\\\={}`.\n    \"\"\"\n    if os.path.isabs(template) and os.path.isfile(template):\n        template = template.replace('/', os.sep)\n        logger.info(f'Reading template from file '\n                    f'&lt;a href=\"{template}\"&gt;{template}&lt;/a&gt;.', html=True)\n        with FileReader(template) as reader:\n            template = reader.read()\n    return template.format(*positional, **named)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.get_line_count","title":"get_line_count","text":"<pre><code>get_line_count(string)\n</code></pre> <p>Returns and logs the number of lines in the given string.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def get_line_count(self, string):\n    \"\"\"Returns and logs the number of lines in the given string.\"\"\"\n    count = len(string.splitlines())\n    logger.info(f'{count} lines.')\n    return count\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.split_to_lines","title":"split_to_lines","text":"<pre><code>split_to_lines(string, start=0, end=None)\n</code></pre> <p>Splits the given string to lines.</p> <p>It is possible to get only a selection of lines from <code>start</code> to <code>end</code> so that <code>start</code> index is inclusive and <code>end</code> is exclusive. Line numbering starts from 0, and it is possible to use negative indices to refer to lines from the end.</p> <p>Lines are returned without the newlines. The number of returned lines is automatically logged.</p> <p>Examples: | @{lines} =        | Split To Lines | ${manylines} |    |    | | @{ignore first} = | Split To Lines | ${manylines} | 1  |    | | @{ignore last} =  | Split To Lines | ${manylines} |    | -1 | | @{5th to 10th} =  | Split To Lines | ${manylines} | 4  | 10 | | @{first two} =    | Split To Lines | ${manylines} |    | 1  | | @{last two} =     | Split To Lines | ${manylines} | -2 |    |</p> <p>Use <code>Get Line</code> if you only need to get a single line.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def split_to_lines(self, string, start=0, end=None):\n    \"\"\"Splits the given string to lines.\n\n    It is possible to get only a selection of lines from ``start``\n    to ``end`` so that ``start`` index is inclusive and ``end`` is\n    exclusive. Line numbering starts from 0, and it is possible to\n    use negative indices to refer to lines from the end.\n\n    Lines are returned without the newlines. The number of\n    returned lines is automatically logged.\n\n    Examples:\n    | @{lines} =        | Split To Lines | ${manylines} |    |    |\n    | @{ignore first} = | Split To Lines | ${manylines} | 1  |    |\n    | @{ignore last} =  | Split To Lines | ${manylines} |    | -1 |\n    | @{5th to 10th} =  | Split To Lines | ${manylines} | 4  | 10 |\n    | @{first two} =    | Split To Lines | ${manylines} |    | 1  |\n    | @{last two} =     | Split To Lines | ${manylines} | -2 |    |\n\n    Use `Get Line` if you only need to get a single line.\n    \"\"\"\n    start = self._convert_to_index(start, 'start')\n    end = self._convert_to_index(end, 'end')\n    lines = string.splitlines()[start:end]\n    logger.info('%d lines returned' % len(lines))\n    return lines\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.get_line","title":"get_line","text":"<pre><code>get_line(string, line_number)\n</code></pre> <p>Returns the specified line from the given <code>string</code>.</p> <p>Line numbering starts from 0, and it is possible to use negative indices to refer to lines from the end. The line is returned without the newline character.</p> <p>Examples: | ${first} =    | Get Line | ${string} | 0  | | ${2nd last} = | Get Line | ${string} | -2 |</p> <p>Use <code>Split To Lines</code> if all lines are needed.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def get_line(self, string, line_number):\n    \"\"\"Returns the specified line from the given ``string``.\n\n    Line numbering starts from 0, and it is possible to use\n    negative indices to refer to lines from the end. The line is\n    returned without the newline character.\n\n    Examples:\n    | ${first} =    | Get Line | ${string} | 0  |\n    | ${2nd last} = | Get Line | ${string} | -2 |\n\n    Use `Split To Lines` if all lines are needed.\n    \"\"\"\n    line_number = self._convert_to_integer(line_number, 'line_number')\n    return string.splitlines()[line_number]\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.get_lines_containing_string","title":"get_lines_containing_string","text":"<pre><code>get_lines_containing_string(\n    string: str,\n    pattern: str,\n    case_insensitive: bool | None = None,\n    ignore_case: bool = False,\n)\n</code></pre> <p>Returns lines of the given <code>string</code> that contain the <code>pattern</code>.</p> <p>The <code>pattern</code> is always considered to be a normal string, not a glob or regexp pattern. A line matches if the <code>pattern</code> is found anywhere on it.</p> <p>The match is case-sensitive by default, but that can be changed by giving <code>ignore_case</code> a true value. This option is new in Robot Framework 7.0, but with older versions it is possible to use the nowadays deprecated <code>case_insensitive</code> argument.</p> <p>Lines are returned as a string with lines joined together with a newline. Possible trailing newline is never returned. The number of matching lines is automatically logged.</p> <p>Examples: | ${lines} = | Get Lines Containing String | ${result} | An example | | ${ret} =   | Get Lines Containing String | ${ret} | FAIL | ignore_case=True |</p> <p>See <code>Get Lines Matching Pattern</code> and <code>Get Lines Matching Regexp</code> if you need more complex pattern matching.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def get_lines_containing_string(self, string: str, pattern: str,\n                                case_insensitive: 'bool|None' = None,\n                                ignore_case: bool = False):\n    \"\"\"Returns lines of the given ``string`` that contain the ``pattern``.\n\n    The ``pattern`` is always considered to be a normal string, not a glob\n    or regexp pattern. A line matches if the ``pattern`` is found anywhere\n    on it.\n\n    The match is case-sensitive by default, but that can be changed by\n    giving ``ignore_case`` a true value. This option is new in Robot\n    Framework 7.0, but with older versions it is possible to use the\n    nowadays deprecated ``case_insensitive`` argument.\n\n    Lines are returned as a string with lines joined together with\n    a newline. Possible trailing newline is never returned. The number\n    of matching lines is automatically logged.\n\n    Examples:\n    | ${lines} = | Get Lines Containing String | ${result} | An example |\n    | ${ret} =   | Get Lines Containing String | ${ret} | FAIL | ignore_case=True |\n\n    See `Get Lines Matching Pattern` and `Get Lines Matching Regexp`\n    if you need more complex pattern matching.\n    \"\"\"\n    if case_insensitive is not None:\n        ignore_case = case_insensitive\n    if ignore_case:\n        pattern = pattern.casefold()\n        contains = lambda line: pattern in line.casefold()\n    else:\n        contains = lambda line: pattern in line\n    return self._get_matching_lines(string, contains)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.get_lines_matching_pattern","title":"get_lines_matching_pattern","text":"<pre><code>get_lines_matching_pattern(\n    string: str,\n    pattern: str,\n    case_insensitive: bool | None = None,\n    ignore_case: bool = False,\n)\n</code></pre> <p>Returns lines of the given <code>string</code> that match the <code>pattern</code>.</p> <p>The <code>pattern</code> is a glob pattern where: | <code>*</code>        | matches everything | | <code>?</code>        | matches any single character | | <code>[chars]</code>  | matches any character inside square brackets (e.g. <code>[abc]</code> matches either <code>a</code>, <code>b</code> or <code>c</code>) | | <code>[!chars]</code> | matches any character not inside square brackets |</p> <p>A line matches only if it matches the <code>pattern</code> fully.</p> <p>The match is case-sensitive by default, but that can be changed by giving <code>ignore_case</code> a true value. This option is new in Robot Framework 7.0, but with older versions it is possible to use the nowadays deprecated <code>case_insensitive</code> argument.</p> <p>Lines are returned as a string with lines joined together with a newline. Possible trailing newline is never returned. The number of matching lines is automatically logged.</p> <p>Examples: | ${lines} = | Get Lines Matching Pattern | ${result} | Wild???? example | | ${ret} = | Get Lines Matching Pattern | ${ret} | FAIL: * | ignore_case=True |</p> <p>See <code>Get Lines Matching Regexp</code> if you need more complex patterns and <code>Get Lines Containing String</code> if searching literal strings is enough.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def get_lines_matching_pattern(self, string: str, pattern: str,\n                               case_insensitive: 'bool|None' = None,\n                               ignore_case: bool = False):\n    \"\"\"Returns lines of the given ``string`` that match the ``pattern``.\n\n    The ``pattern`` is a _glob pattern_ where:\n    | ``*``        | matches everything |\n    | ``?``        | matches any single character |\n    | ``[chars]``  | matches any character inside square brackets (e.g. ``[abc]`` matches either ``a``, ``b`` or ``c``) |\n    | ``[!chars]`` | matches any character not inside square brackets |\n\n    A line matches only if it matches the ``pattern`` fully.\n\n    The match is case-sensitive by default, but that can be changed by\n    giving ``ignore_case`` a true value. This option is new in Robot\n    Framework 7.0, but with older versions it is possible to use the\n    nowadays deprecated ``case_insensitive`` argument.\n\n    Lines are returned as a string with lines joined together with\n    a newline. Possible trailing newline is never returned. The number\n    of matching lines is automatically logged.\n\n    Examples:\n    | ${lines} = | Get Lines Matching Pattern | ${result} | Wild???? example |\n    | ${ret} = | Get Lines Matching Pattern | ${ret} | FAIL: * | ignore_case=True |\n\n    See `Get Lines Matching Regexp` if you need more complex\n    patterns and `Get Lines Containing String` if searching\n    literal strings is enough.\n    \"\"\"\n    if case_insensitive is not None:\n        ignore_case = case_insensitive\n    if ignore_case:\n        pattern = pattern.casefold()\n        matches = lambda line: fnmatchcase(line.casefold(), pattern)\n    else:\n        matches = lambda line: fnmatchcase(line, pattern)\n    return self._get_matching_lines(string, matches)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.get_lines_matching_regexp","title":"get_lines_matching_regexp","text":"<pre><code>get_lines_matching_regexp(\n    string, pattern, partial_match=False, flags=None\n)\n</code></pre> <p>Returns lines of the given <code>string</code> that match the regexp <code>pattern</code>.</p> <p>See <code>BuiltIn.Should Match Regexp</code> for more information about Python regular expression syntax in general and how to use it in Robot Framework data in particular.</p> <p>Lines match only if they match the pattern fully by default, but partial matching can be enabled by giving the <code>partial_match</code> argument a true value.</p> <p>If the pattern is empty, it matches only empty lines by default. When partial matching is enabled, empty pattern matches all lines.</p> <p>Possible flags altering how the expression is parsed (e.g. <code>re.IGNORECASE</code>, <code>re.VERBOSE</code>) can be given using the <code>flags</code> argument (e.g. <code>flags=IGNORECASE | VERBOSE</code>) or embedded to the pattern (e.g. <code>(?ix)pattern</code>).</p> <p>Lines are returned as one string concatenated back together with newlines. Possible trailing newline is never returned. The number of matching lines is automatically logged.</p> <p>Examples: | ${lines} = | Get Lines Matching Regexp | ${result} | Reg\\w{3} example | | ${lines} = | Get Lines Matching Regexp | ${result} | Reg\\w{3} example | partial_match=true | | ${ret} =   | Get Lines Matching Regexp | ${ret}    | (?i)FAIL: . | | ${ret} =   | Get Lines Matching Regexp | ${ret}    | FAIL: . | flags=IGNORECASE |</p> <p>See <code>Get Lines Matching Pattern</code> and <code>Get Lines Containing String</code> if you do not need the full regular expression powers (and complexity).</p> <p>The <code>flags</code> argument is new in Robot Framework 6.0.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def get_lines_matching_regexp(self, string, pattern, partial_match=False, flags=None):\n    \"\"\"Returns lines of the given ``string`` that match the regexp ``pattern``.\n\n    See `BuiltIn.Should Match Regexp` for more information about\n    Python regular expression syntax in general and how to use it\n    in Robot Framework data in particular.\n\n    Lines match only if they match the pattern fully by default, but\n    partial matching can be enabled by giving the ``partial_match``\n    argument a true value.\n\n    If the pattern is empty, it matches only empty lines by default.\n    When partial matching is enabled, empty pattern matches all lines.\n\n    Possible flags altering how the expression is parsed (e.g. ``re.IGNORECASE``,\n    ``re.VERBOSE``) can be given using the ``flags`` argument (e.g.\n    ``flags=IGNORECASE | VERBOSE``) or embedded to the pattern (e.g.\n    ``(?ix)pattern``).\n\n    Lines are returned as one string concatenated back together with\n    newlines. Possible trailing newline is never returned. The\n    number of matching lines is automatically logged.\n\n    Examples:\n    | ${lines} = | Get Lines Matching Regexp | ${result} | Reg\\\\\\\\w{3} example |\n    | ${lines} = | Get Lines Matching Regexp | ${result} | Reg\\\\\\\\w{3} example | partial_match=true |\n    | ${ret} =   | Get Lines Matching Regexp | ${ret}    | (?i)FAIL: .* |\n    | ${ret} =   | Get Lines Matching Regexp | ${ret}    | FAIL: .* | flags=IGNORECASE |\n\n    See `Get Lines Matching Pattern` and `Get Lines Containing String` if you\n    do not need the full regular expression powers (and complexity).\n\n    The ``flags`` argument is new in Robot Framework 6.0.\n    \"\"\"\n    regexp = re.compile(pattern, flags=parse_re_flags(flags))\n    match = regexp.search if partial_match else regexp.fullmatch\n    return self._get_matching_lines(string, match)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.get_regexp_matches","title":"get_regexp_matches","text":"<pre><code>get_regexp_matches(string, pattern, *groups, flags=None)\n</code></pre> <p>Returns a list of all non-overlapping matches in the given string.</p> <p><code>string</code> is the string to find matches from and <code>pattern</code> is the regular expression. See <code>BuiltIn.Should Match Regexp</code> for more information about Python regular expression syntax in general and how to use it in Robot Framework data in particular.</p> <p>If no groups are used, the returned list contains full matches. If one group is used, the list contains only contents of that group. If multiple groups are used, the list contains tuples that contain individual group contents. All groups can be given as indexes (starting from 1) and named groups also as names.</p> <p>Possible flags altering how the expression is parsed (e.g. <code>re.IGNORECASE</code>, <code>re.MULTILINE</code>) can be given using the <code>flags</code> argument (e.g. <code>flags=IGNORECASE | MULTILINE</code>) or embedded to the pattern (e.g. <code>(?im)pattern</code>).</p> <p>Examples: | ${no match} =    | Get Regexp Matches | the string | xxx     | | ${matches} =     | Get Regexp Matches | the string | t..     | | ${matches} =     | Get Regexp Matches | the string | T..     | flags=IGNORECASE | | ${one group} =   | Get Regexp Matches | the string | t(..)   | 1 | | ${named group} = | Get Regexp Matches | the string | t(?P..) | name | | ${two groups} =  | Get Regexp Matches | the string | t(.)(.) | 1 | 2 | =&gt; | ${no match} = [] | ${matches} = ['the', 'tri'] | ${one group} = ['he', 'ri'] | ${named group} = ['he', 'ri'] | ${two groups} = [('h', 'e'), ('r', 'i')] <p>The <code>flags</code> argument is new in Robot Framework 6.0.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def get_regexp_matches(self, string, pattern, *groups, flags=None):\n    \"\"\"Returns a list of all non-overlapping matches in the given string.\n\n    ``string`` is the string to find matches from and ``pattern`` is the\n    regular expression. See `BuiltIn.Should Match Regexp` for more\n    information about Python regular expression syntax in general and how\n    to use it in Robot Framework data in particular.\n\n    If no groups are used, the returned list contains full matches. If one\n    group is used, the list contains only contents of that group. If\n    multiple groups are used, the list contains tuples that contain\n    individual group contents. All groups can be given as indexes (starting\n    from 1) and named groups also as names.\n\n    Possible flags altering how the expression is parsed (e.g. ``re.IGNORECASE``,\n    ``re.MULTILINE``) can be given using the ``flags`` argument (e.g.\n    ``flags=IGNORECASE | MULTILINE``) or embedded to the pattern (e.g.\n    ``(?im)pattern``).\n\n    Examples:\n    | ${no match} =    | Get Regexp Matches | the string | xxx     |\n    | ${matches} =     | Get Regexp Matches | the string | t..     |\n    | ${matches} =     | Get Regexp Matches | the string | T..     | flags=IGNORECASE |\n    | ${one group} =   | Get Regexp Matches | the string | t(..)   | 1 |\n    | ${named group} = | Get Regexp Matches | the string | t(?P&lt;name&gt;..) | name |\n    | ${two groups} =  | Get Regexp Matches | the string | t(.)(.) | 1 | 2 |\n    =&gt;\n    | ${no match} = []\n    | ${matches} = ['the', 'tri']\n    | ${one group} = ['he', 'ri']\n    | ${named group} = ['he', 'ri']\n    | ${two groups} = [('h', 'e'), ('r', 'i')]\n\n    The ``flags`` argument is new in Robot Framework 6.0.\n    \"\"\"\n    regexp = re.compile(pattern, flags=parse_re_flags(flags))\n    groups = [self._parse_group(g) for g in groups]\n    return [m.group(*groups) for m in regexp.finditer(string)]\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.replace_string","title":"replace_string","text":"<pre><code>replace_string(string, search_for, replace_with, count=-1)\n</code></pre> <p>Replaces <code>search_for</code> in the given <code>string</code> with <code>replace_with</code>.</p> <p><code>search_for</code> is used as a literal string. See <code>Replace String Using Regexp</code> if more powerful pattern matching is needed. If you need to just remove a string see <code>Remove String</code>.</p> <p>If the optional argument <code>count</code> is given, only that many occurrences from left are replaced. Negative <code>count</code> means that all occurrences are replaced (default behaviour) and zero means that nothing is done.</p> <p>A modified version of the string is returned and the original string is not altered.</p> <p>Examples: | ${str} =        | Replace String | Hello, world!  | world | tellus   | | Should Be Equal | ${str}         | Hello, tellus! |       |          | | ${str} =        | Replace String | Hello, world!  | l     | ${EMPTY} | count=1 | | Should Be Equal | ${str}         | Helo, world!   |       |          |</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def replace_string(self, string, search_for, replace_with, count=-1):\n    \"\"\"Replaces ``search_for`` in the given ``string`` with ``replace_with``.\n\n    ``search_for`` is used as a literal string. See `Replace String\n    Using Regexp` if more powerful pattern matching is needed.\n    If you need to just remove a string see `Remove String`.\n\n    If the optional argument ``count`` is given, only that many\n    occurrences from left are replaced. Negative ``count`` means\n    that all occurrences are replaced (default behaviour) and zero\n    means that nothing is done.\n\n    A modified version of the string is returned and the original\n    string is not altered.\n\n    Examples:\n    | ${str} =        | Replace String | Hello, world!  | world | tellus   |\n    | Should Be Equal | ${str}         | Hello, tellus! |       |          |\n    | ${str} =        | Replace String | Hello, world!  | l     | ${EMPTY} | count=1 |\n    | Should Be Equal | ${str}         | Helo, world!   |       |          |\n    \"\"\"\n    count = self._convert_to_integer(count, 'count')\n    return string.replace(search_for, replace_with, count)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.replace_string_using_regexp","title":"replace_string_using_regexp","text":"<pre><code>replace_string_using_regexp(\n    string, pattern, replace_with, count=-1, flags=None\n)\n</code></pre> <p>Replaces <code>pattern</code> in the given <code>string</code> with <code>replace_with</code>.</p> <p>This keyword is otherwise identical to <code>Replace String</code>, but the <code>pattern</code> to search for is considered to be a regular expression.  See <code>BuiltIn.Should Match Regexp</code> for more information about Python regular expression syntax in general and how to use it in Robot Framework data in particular.</p> <p>Possible flags altering how the expression is parsed (e.g. <code>re.IGNORECASE</code>, <code>re.MULTILINE</code>) can be given using the <code>flags</code> argument (e.g. <code>flags=IGNORECASE | MULTILINE</code>) or embedded to the pattern (e.g. <code>(?im)pattern</code>).</p> <p>If you need to just remove a string see <code>Remove String Using Regexp</code>.</p> <p>Examples: | ${str} = | Replace String Using Regexp | ${str} | 20\\d\\d-\\d\\d-\\d\\d |  | | ${str} = | Replace String Using Regexp | ${str} | (Hello|Hi) | ${EMPTY} | count=1 | <p>The <code>flags</code> argument is new in Robot Framework 6.0.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def replace_string_using_regexp(self, string, pattern, replace_with, count=-1, flags=None):\n    \"\"\"Replaces ``pattern`` in the given ``string`` with ``replace_with``.\n\n    This keyword is otherwise identical to `Replace String`, but\n    the ``pattern`` to search for is considered to be a regular\n    expression.  See `BuiltIn.Should Match Regexp` for more\n    information about Python regular expression syntax in general\n    and how to use it in Robot Framework data in particular.\n\n    Possible flags altering how the expression is parsed (e.g. ``re.IGNORECASE``,\n    ``re.MULTILINE``) can be given using the ``flags`` argument (e.g.\n    ``flags=IGNORECASE | MULTILINE``) or embedded to the pattern (e.g.\n    ``(?im)pattern``).\n\n    If you need to just remove a string see `Remove String Using Regexp`.\n\n    Examples:\n    | ${str} = | Replace String Using Regexp | ${str} | 20\\\\\\\\d\\\\\\\\d-\\\\\\\\d\\\\\\\\d-\\\\\\\\d\\\\\\\\d | &lt;DATE&gt; |\n    | ${str} = | Replace String Using Regexp | ${str} | (Hello|Hi) | ${EMPTY} | count=1 |\n\n    The ``flags`` argument is new in Robot Framework 6.0.\n    \"\"\"\n    count = self._convert_to_integer(count, 'count')\n    # re.sub handles 0 and negative counts differently than string.replace\n    if count == 0:\n        return string\n    return re.sub(pattern, replace_with, string, max(count, 0), flags=parse_re_flags(flags))\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.remove_string","title":"remove_string","text":"<pre><code>remove_string(string, *removables)\n</code></pre> <p>Removes all <code>removables</code> from the given <code>string</code>.</p> <p><code>removables</code> are used as literal strings. Each removable will be matched to a temporary string from which preceding removables have been already removed. See second example below.</p> <p>Use <code>Remove String Using Regexp</code> if more powerful pattern matching is needed. If only a certain number of matches should be removed, <code>Replace String</code> or <code>Replace String Using Regexp</code> can be used.</p> <p>A modified version of the string is returned and the original string is not altered.</p> <p>Examples: | ${str} =        | Remove String | Robot Framework | work   | | Should Be Equal | ${str}        | Robot Frame     | | ${str} =        | Remove String | Robot Framework | o | bt | | Should Be Equal | ${str}        | R Framewrk      |</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def remove_string(self, string, *removables):\n    \"\"\"Removes all ``removables`` from the given ``string``.\n\n    ``removables`` are used as literal strings. Each removable will be\n    matched to a temporary string from which preceding removables have\n    been already removed. See second example below.\n\n    Use `Remove String Using Regexp` if more powerful pattern matching is\n    needed. If only a certain number of matches should be removed,\n    `Replace String` or `Replace String Using Regexp` can be used.\n\n    A modified version of the string is returned and the original\n    string is not altered.\n\n    Examples:\n    | ${str} =        | Remove String | Robot Framework | work   |\n    | Should Be Equal | ${str}        | Robot Frame     |\n    | ${str} =        | Remove String | Robot Framework | o | bt |\n    | Should Be Equal | ${str}        | R Framewrk      |\n    \"\"\"\n    for removable in removables:\n        string = self.replace_string(string, removable, '')\n    return string\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.remove_string_using_regexp","title":"remove_string_using_regexp","text":"<pre><code>remove_string_using_regexp(string, *patterns, flags=None)\n</code></pre> <p>Removes <code>patterns</code> from the given <code>string</code>.</p> <p>This keyword is otherwise identical to <code>Remove String</code>, but the <code>patterns</code> to search for are considered to be a regular expression. See <code>Replace String Using Regexp</code> for more information about the regular expression syntax. That keyword can also be used if there is a need to remove only a certain number of occurrences.</p> <p>Possible flags altering how the expression is parsed (e.g. <code>re.IGNORECASE</code>, <code>re.MULTILINE</code>) can be given using the <code>flags</code> argument (e.g. <code>flags=IGNORECASE | MULTILINE</code>) or embedded to the pattern (e.g. <code>(?im)pattern</code>).</p> <p>The <code>flags</code> argument is new in Robot Framework 6.0.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def remove_string_using_regexp(self, string, *patterns, flags=None):\n    \"\"\"Removes ``patterns`` from the given ``string``.\n\n    This keyword is otherwise identical to `Remove String`, but\n    the ``patterns`` to search for are considered to be a regular\n    expression. See `Replace String Using Regexp` for more information\n    about the regular expression syntax. That keyword can also be\n    used if there is a need to remove only a certain number of\n    occurrences.\n\n    Possible flags altering how the expression is parsed (e.g. ``re.IGNORECASE``,\n    ``re.MULTILINE``) can be given using the ``flags`` argument (e.g.\n    ``flags=IGNORECASE | MULTILINE``) or embedded to the pattern (e.g.\n    ``(?im)pattern``).\n\n    The ``flags`` argument is new in Robot Framework 6.0.\n    \"\"\"\n    for pattern in patterns:\n        string = self.replace_string_using_regexp(string, pattern, '', flags=flags)\n    return string\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.split_string","title":"split_string","text":"<pre><code>split_string(string, separator=None, max_split=-1)\n</code></pre> <p>Splits the <code>string</code> using <code>separator</code> as a delimiter string.</p> <p>If a <code>separator</code> is not given, any whitespace string is a separator. In that case also possible consecutive whitespace as well as leading and trailing whitespace is ignored.</p> <p>Split words are returned as a list. If the optional <code>max_split</code> is given, at most <code>max_split</code> splits are done, and the returned list will have maximum <code>max_split + 1</code> elements.</p> <p>Examples: | @{words} =         | Split String | ${string} | | @{words} =         | Split String | ${string} | ,${SPACE} | | ${pre} | ${post} = | Split String | ${string} | ::    | 1 |</p> <p>See <code>Split String From Right</code> if you want to start splitting from right, and <code>Fetch From Left</code> and <code>Fetch From Right</code> if you only want to get first/last part of the string.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>@keyword(types=None)\ndef split_string(self, string, separator=None, max_split=-1):\n    \"\"\"Splits the ``string`` using ``separator`` as a delimiter string.\n\n    If a ``separator`` is not given, any whitespace string is a\n    separator. In that case also possible consecutive whitespace\n    as well as leading and trailing whitespace is ignored.\n\n    Split words are returned as a list. If the optional\n    ``max_split`` is given, at most ``max_split`` splits are done, and\n    the returned list will have maximum ``max_split + 1`` elements.\n\n    Examples:\n    | @{words} =         | Split String | ${string} |\n    | @{words} =         | Split String | ${string} | ,${SPACE} |\n    | ${pre} | ${post} = | Split String | ${string} | ::    | 1 |\n\n    See `Split String From Right` if you want to start splitting\n    from right, and `Fetch From Left` and `Fetch From Right` if\n    you only want to get first/last part of the string.\n    \"\"\"\n    if separator == '':\n        separator = None\n    max_split = self._convert_to_integer(max_split, 'max_split')\n    return string.split(separator, max_split)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.split_string_from_right","title":"split_string_from_right","text":"<pre><code>split_string_from_right(\n    string, separator=None, max_split=-1\n)\n</code></pre> <p>Splits the <code>string</code> using <code>separator</code> starting from right.</p> <p>Same as <code>Split String</code>, but splitting is started from right. This has an effect only when <code>max_split</code> is given.</p> <p>Examples: | ${first} | ${rest} = | Split String            | ${string} | - | 1 | | ${rest}  | ${last} = | Split String From Right | ${string} | - | 1 |</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>@keyword(types=None)\ndef split_string_from_right(self, string, separator=None, max_split=-1):\n    \"\"\"Splits the ``string`` using ``separator`` starting from right.\n\n    Same as `Split String`, but splitting is started from right. This has\n    an effect only when ``max_split`` is given.\n\n    Examples:\n    | ${first} | ${rest} = | Split String            | ${string} | - | 1 |\n    | ${rest}  | ${last} = | Split String From Right | ${string} | - | 1 |\n    \"\"\"\n    if separator == '':\n        separator = None\n    max_split = self._convert_to_integer(max_split, 'max_split')\n    return string.rsplit(separator, max_split)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.split_string_to_characters","title":"split_string_to_characters","text":"<pre><code>split_string_to_characters(string)\n</code></pre> <p>Splits the given <code>string</code> to characters.</p> <p>Example: | @{characters} = | Split String To Characters | ${string} |</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def split_string_to_characters(self, string):\n    \"\"\"Splits the given ``string`` to characters.\n\n    Example:\n    | @{characters} = | Split String To Characters | ${string} |\n    \"\"\"\n    return list(string)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.fetch_from_left","title":"fetch_from_left","text":"<pre><code>fetch_from_left(string, marker)\n</code></pre> <p>Returns contents of the <code>string</code> before the first occurrence of <code>marker</code>.</p> <p>If the <code>marker</code> is not found, whole string is returned.</p> <p>See also <code>Fetch From Right</code>, <code>Split String</code> and <code>Split String From Right</code>.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def fetch_from_left(self, string, marker):\n    \"\"\"Returns contents of the ``string`` before the first occurrence of ``marker``.\n\n    If the ``marker`` is not found, whole string is returned.\n\n    See also `Fetch From Right`, `Split String` and `Split String\n    From Right`.\n    \"\"\"\n    return string.split(marker)[0]\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.fetch_from_right","title":"fetch_from_right","text":"<pre><code>fetch_from_right(string, marker)\n</code></pre> <p>Returns contents of the <code>string</code> after the last occurrence of <code>marker</code>.</p> <p>If the <code>marker</code> is not found, whole string is returned.</p> <p>See also <code>Fetch From Left</code>, <code>Split String</code> and <code>Split String From Right</code>.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def fetch_from_right(self, string, marker):\n    \"\"\"Returns contents of the ``string`` after the last occurrence of ``marker``.\n\n    If the ``marker`` is not found, whole string is returned.\n\n    See also `Fetch From Left`, `Split String` and `Split String\n    From Right`.\n    \"\"\"\n    return string.split(marker)[-1]\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.generate_random_string","title":"generate_random_string","text":"<pre><code>generate_random_string(\n    length=8, chars=\"[LETTERS][NUMBERS]\"\n)\n</code></pre> <p>Generates a string with a desired <code>length</code> from the given <code>chars</code>.</p> <p><code>length</code> can be given as a number, a string representation of a number, or as a range of numbers, such as <code>5-10</code>. When a range of values is given the range will be selected by random within the range.</p> <p>The population sequence <code>chars</code> contains the characters to use when generating the random string. It can contain any characters, and it is possible to use special markers explained in the table below:</p> <p>|  = Marker =   |               = Explanation =                   | | <code>[LOWER]</code>   | Lowercase ASCII characters from <code>a</code> to <code>z</code>. | | <code>[UPPER]</code>   | Uppercase ASCII characters from <code>A</code> to <code>Z</code>. | | <code>[LETTERS]</code> | Lowercase and uppercase ASCII characters.       | | <code>[NUMBERS]</code> | Numbers from 0 to 9.                            |</p> <p>Examples: | ${ret} = | Generate Random String | | ${low} = | Generate Random String | 12 | [LOWER]         | | ${bin} = | Generate Random String | 8  | 01              | | ${hex} = | Generate Random String | 4  | [NUMBERS]abcdef | | ${rnd} = | Generate Random String | 5-10 | # Generates a string 5 to 10 characters long |</p> <p>Giving <code>length</code> as a range of values is new in Robot Framework 5.0.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def generate_random_string(self, length=8, chars='[LETTERS][NUMBERS]'):\n    \"\"\"Generates a string with a desired ``length`` from the given ``chars``.\n\n    ``length`` can be given as a number, a string representation of a number,\n    or as a range of numbers, such as ``5-10``. When a range of values is given\n    the range will be selected by random within the range.\n\n    The population sequence ``chars`` contains the characters to use\n    when generating the random string. It can contain any\n    characters, and it is possible to use special markers\n    explained in the table below:\n\n    |  = Marker =   |               = Explanation =                   |\n    | ``[LOWER]``   | Lowercase ASCII characters from ``a`` to ``z``. |\n    | ``[UPPER]``   | Uppercase ASCII characters from ``A`` to ``Z``. |\n    | ``[LETTERS]`` | Lowercase and uppercase ASCII characters.       |\n    | ``[NUMBERS]`` | Numbers from 0 to 9.                            |\n\n    Examples:\n    | ${ret} = | Generate Random String |\n    | ${low} = | Generate Random String | 12 | [LOWER]         |\n    | ${bin} = | Generate Random String | 8  | 01              |\n    | ${hex} = | Generate Random String | 4  | [NUMBERS]abcdef |\n    | ${rnd} = | Generate Random String | 5-10 | # Generates a string 5 to 10 characters long |\n\n    Giving ``length`` as a range of values is new in Robot Framework 5.0.\n    \"\"\"\n    if length == '':\n        length = 8\n    if isinstance(length, str) and re.match(r'^\\d+-\\d+$', length):\n        min_length, max_length = length.split('-')\n        length = randint(self._convert_to_integer(min_length, \"length\"),\n                         self._convert_to_integer(max_length, \"length\"))\n    else:\n        length = self._convert_to_integer(length, 'length')\n    for name, value in [('[LOWER]', ascii_lowercase),\n                        ('[UPPER]', ascii_uppercase),\n                        ('[LETTERS]', ascii_lowercase + ascii_uppercase),\n                        ('[NUMBERS]', digits)]:\n        chars = chars.replace(name, value)\n    maxi = len(chars) - 1\n    return ''.join(chars[randint(0, maxi)] for _ in range(length))\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.get_substring","title":"get_substring","text":"<pre><code>get_substring(string, start, end=None)\n</code></pre> <p>Returns a substring from <code>start</code> index to <code>end</code> index.</p> <p>The <code>start</code> index is inclusive and <code>end</code> is exclusive. Indexing starts from 0, and it is possible to use negative indices to refer to characters from the end.</p> <p>Examples: | ${ignore first} = | Get Substring | ${string} | 1  |    | | ${ignore last} =  | Get Substring | ${string} | 0  | -1 | | ${5th to 10th} =  | Get Substring | ${string} | 4  | 10 | | ${first two} =    | Get Substring | ${string} | 0  | 1  | | ${last two} =     | Get Substring | ${string} | -2 |    |</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def get_substring(self, string, start, end=None):\n    \"\"\"Returns a substring from ``start`` index to ``end`` index.\n\n    The ``start`` index is inclusive and ``end`` is exclusive.\n    Indexing starts from 0, and it is possible to use\n    negative indices to refer to characters from the end.\n\n    Examples:\n    | ${ignore first} = | Get Substring | ${string} | 1  |    |\n    | ${ignore last} =  | Get Substring | ${string} | 0  | -1 |\n    | ${5th to 10th} =  | Get Substring | ${string} | 4  | 10 |\n    | ${first two} =    | Get Substring | ${string} | 0  | 1  |\n    | ${last two} =     | Get Substring | ${string} | -2 |    |\n    \"\"\"\n    start = self._convert_to_index(start, 'start')\n    end = self._convert_to_index(end, 'end')\n    return string[start:end]\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.strip_string","title":"strip_string","text":"<pre><code>strip_string(string, mode='both', characters=None)\n</code></pre> <p>Remove leading and/or trailing whitespaces from the given string.</p> <p><code>mode</code> is either <code>left</code> to remove leading characters, <code>right</code> to remove trailing characters, <code>both</code> (default) to remove the characters from both sides of the string or <code>none</code> to return the unmodified string.</p> <p>If the optional <code>characters</code> is given, it must be a string and the characters in the string will be stripped in the string. Please note, that this is not a substring to be removed but a list of characters, see the example below.</p> <p>Examples: | ${stripped}=  | Strip String | ${SPACE}Hello${SPACE} | | | Should Be Equal | ${stripped} | Hello | | | ${stripped}=  | Strip String | ${SPACE}Hello${SPACE} | mode=left | | Should Be Equal | ${stripped} | Hello${SPACE} | | | ${stripped}=  | Strip String | aabaHelloeee | characters=abe | | Should Be Equal | ${stripped} | Hello | |</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>@keyword(types=None)\ndef strip_string(self, string, mode='both', characters=None):\n    \"\"\"Remove leading and/or trailing whitespaces from the given string.\n\n    ``mode`` is either ``left`` to remove leading characters, ``right`` to\n    remove trailing characters, ``both`` (default) to remove the\n    characters from both sides of the string or ``none`` to return the\n    unmodified string.\n\n    If the optional ``characters`` is given, it must be a string and the\n    characters in the string will be stripped in the string. Please note,\n    that this is not a substring to be removed but a list of characters,\n    see the example below.\n\n    Examples:\n    | ${stripped}=  | Strip String | ${SPACE}Hello${SPACE} | |\n    | Should Be Equal | ${stripped} | Hello | |\n    | ${stripped}=  | Strip String | ${SPACE}Hello${SPACE} | mode=left |\n    | Should Be Equal | ${stripped} | Hello${SPACE} | |\n    | ${stripped}=  | Strip String | aabaHelloeee | characters=abe |\n    | Should Be Equal | ${stripped} | Hello | |\n    \"\"\"\n    try:\n        method = {'BOTH': string.strip,\n                  'LEFT': string.lstrip,\n                  'RIGHT': string.rstrip,\n                  'NONE': lambda characters: string}[mode.upper()]\n    except KeyError:\n        raise ValueError(\"Invalid mode '%s'.\" % mode)\n    return method(characters)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.should_be_string","title":"should_be_string","text":"<pre><code>should_be_string(item, msg=None)\n</code></pre> <p>Fails if the given <code>item</code> is not a string.</p> <p>The default error message can be overridden with the optional <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def should_be_string(self, item, msg=None):\n    \"\"\"Fails if the given ``item`` is not a string.\n\n    The default error message can be overridden with the optional ``msg`` argument.\n    \"\"\"\n    if not isinstance(item, str):\n        raise AssertionError(msg or f\"{item!r} is {type_name(item)}, not a string.\")\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.should_not_be_string","title":"should_not_be_string","text":"<pre><code>should_not_be_string(item, msg=None)\n</code></pre> <p>Fails if the given <code>item</code> is a string.</p> <p>The default error message can be overridden with the optional <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def should_not_be_string(self, item, msg=None):\n    \"\"\"Fails if the given ``item`` is a string.\n\n    The default error message can be overridden with the optional ``msg`` argument.\n    \"\"\"\n    if isinstance(item, str):\n        raise AssertionError(msg or f\"{item!r} is a string.\")\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.should_be_unicode_string","title":"should_be_unicode_string","text":"<pre><code>should_be_unicode_string(item, msg=None)\n</code></pre> <p>Fails if the given <code>item</code> is not a Unicode string.</p> <p>On Python 3 this keyword behaves exactly the same way <code>Should Be String</code>. That keyword should be used instead and this keyword will be deprecated.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def should_be_unicode_string(self, item, msg=None):\n    \"\"\"Fails if the given ``item`` is not a Unicode string.\n\n    On Python 3 this keyword behaves exactly the same way `Should Be String`.\n    That keyword should be used instead and this keyword will be deprecated.\n    \"\"\"\n    self.should_be_string(item, msg)\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.should_be_byte_string","title":"should_be_byte_string","text":"<pre><code>should_be_byte_string(item, msg=None)\n</code></pre> <p>Fails if the given <code>item</code> is not a byte string.</p> <p>Use <code>Should Be String</code> if you want to verify the <code>item</code> is a string.</p> <p>The default error message can be overridden with the optional <code>msg</code> argument.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def should_be_byte_string(self, item, msg=None):\n    \"\"\"Fails if the given ``item`` is not a byte string.\n\n    Use `Should Be String` if you want to verify the ``item`` is a string.\n\n    The default error message can be overridden with the optional ``msg`` argument.\n    \"\"\"\n    if not isinstance(item, bytes):\n        raise AssertionError(msg or f\"{item!r} is not a byte string.\")\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.should_be_lower_case","title":"should_be_lower_case","text":"<pre><code>should_be_lower_case(string, msg=None)\n</code></pre> <p>Fails if the given <code>string</code> is not in lower case.</p> <p>For example, <code>'string'</code> and <code>'with specials!'</code> would pass, and <code>'String'</code>, <code>''</code> and <code>' '</code> would fail.</p> <p>The default error message can be overridden with the optional <code>msg</code> argument.</p> <p>See also <code>Should Be Upper Case</code> and <code>Should Be Title Case</code>.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def should_be_lower_case(self, string, msg=None):\n    \"\"\"Fails if the given ``string`` is not in lower case.\n\n    For example, ``'string'`` and ``'with specials!'`` would pass, and\n    ``'String'``, ``''`` and ``' '`` would fail.\n\n    The default error message can be overridden with the optional\n    ``msg`` argument.\n\n    See also `Should Be Upper Case` and `Should Be Title Case`.\n    \"\"\"\n    if not string.islower():\n        raise AssertionError(msg or f\"{string!r} is not lower case.\")\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.should_be_upper_case","title":"should_be_upper_case","text":"<pre><code>should_be_upper_case(string, msg=None)\n</code></pre> <p>Fails if the given <code>string</code> is not in upper case.</p> <p>For example, <code>'STRING'</code> and <code>'WITH SPECIALS!'</code> would pass, and <code>'String'</code>, <code>''</code> and <code>' '</code> would fail.</p> <p>The default error message can be overridden with the optional <code>msg</code> argument.</p> <p>See also <code>Should Be Title Case</code> and <code>Should Be Lower Case</code>.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>def should_be_upper_case(self, string, msg=None):\n    \"\"\"Fails if the given ``string`` is not in upper case.\n\n    For example, ``'STRING'`` and ``'WITH SPECIALS!'`` would pass, and\n    ``'String'``, ``''`` and ``' '`` would fail.\n\n    The default error message can be overridden with the optional\n    ``msg`` argument.\n\n    See also `Should Be Title Case` and `Should Be Lower Case`.\n    \"\"\"\n    if not string.isupper():\n        raise AssertionError(msg or f\"{string!r} is not upper case.\")\n</code></pre>"},{"location":"api/robot/libraries/String/#robot.libraries.String.String.should_be_title_case","title":"should_be_title_case","text":"<pre><code>should_be_title_case(string, msg=None, exclude=None)\n</code></pre> <p>Fails if given <code>string</code> is not title.</p> <p><code>string</code> is a title cased string if there is at least one upper case letter in each word.</p> <p>For example, <code>'This Is Title'</code> and <code>'OK, Give Me My iPhone'</code> would pass. <code>'all words lower'</code> and <code>'Word In lower'</code> would fail.</p> <p>This logic changed in Robot Framework 4.0 to be compatible with <code>Convert to Title Case</code>. See <code>Convert to Title Case</code> for title case algorithm and reasoning.</p> <p>The default error message can be overridden with the optional <code>msg</code> argument.</p> <p>Words can be explicitly excluded with the optional <code>exclude</code> argument.</p> <p>Explicitly excluded words can be given as a list or as a string with words separated by a comma and an optional space. Excluded words are actually considered to be regular expression patterns, so it is possible to use something like \"example[.!?]?\" to match the word \"example\" on it own and also if followed by \".\", \"!\" or \"?\". See <code>BuiltIn.Should Match Regexp</code> for more information about Python regular expression syntax in general and how to use it in Robot Framework data in particular.</p> <p>See also <code>Should Be Upper Case</code> and <code>Should Be Lower Case</code>.</p> Source code in <code>src/robot/libraries/String.py</code> <pre><code>@keyword(types=None)\ndef should_be_title_case(self, string, msg=None, exclude=None):\n    \"\"\"Fails if given ``string`` is not title.\n\n    ``string`` is a title cased string if there is at least one upper case\n    letter in each word.\n\n    For example, ``'This Is Title'`` and ``'OK, Give Me My iPhone'``\n    would pass. ``'all words lower'`` and ``'Word In lower'`` would fail.\n\n    This logic changed in Robot Framework 4.0 to be compatible with\n    `Convert to Title Case`. See `Convert to Title Case` for title case\n    algorithm and reasoning.\n\n    The default error message can be overridden with the optional\n    ``msg`` argument.\n\n    Words can be explicitly excluded with the optional ``exclude`` argument.\n\n    Explicitly excluded words can be given as a list or as a string with\n    words separated by a comma and an optional space. Excluded words are\n    actually considered to be regular expression patterns, so it is\n    possible to use something like \"example[.!?]?\" to match the word\n    \"example\" on it own and also if followed by \".\", \"!\" or \"?\".\n    See `BuiltIn.Should Match Regexp` for more information about Python\n    regular expression syntax in general and how to use it in Robot\n    Framework data in particular.\n\n    See also `Should Be Upper Case` and `Should Be Lower Case`.\n    \"\"\"\n    if string != self.convert_to_title_case(string, exclude):\n        raise AssertionError(msg or f\"{string!r} is not title case.\")\n</code></pre>"},{"location":"api/robot/libraries/Telnet/","title":"robot.libraries.Telnet","text":""},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet","title":"robot.libraries.Telnet","text":""},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.Telnet","title":"Telnet","text":"<pre><code>Telnet(\n    timeout=\"3 seconds\",\n    newline=\"CRLF\",\n    prompt=None,\n    prompt_is_regexp=False,\n    encoding=\"UTF-8\",\n    encoding_errors=\"ignore\",\n    default_log_level=\"INFO\",\n    window_size=None,\n    environ_user=None,\n    terminal_emulation=False,\n    terminal_type=None,\n    telnetlib_log_level=\"TRACE\",\n    connection_timeout=None,\n)\n</code></pre> <p>A library providing communication over Telnet connections.</p> <p><code>Telnet</code> is Robot Framework's standard library that makes it possible to connect to Telnet servers and execute commands on the opened connections.</p> <p>== Table of contents ==</p> <p>%TOC%</p> <p>= Connections =</p> <p>The first step of using <code>Telnet</code> is opening a connection with <code>Open Connection</code> keyword. Typically the next step is logging in with <code>Login</code> keyword, and in the end the opened connection can be closed with <code>Close Connection</code>.</p> <p>It is possible to open multiple connections and switch the active one using <code>Switch Connection</code>. <code>Close All Connections</code> can be used to close all the connections, which is especially useful in suite teardowns to guarantee that all connections are always closed.</p> <p>= Writing and reading =</p> <p>After opening a connection and possibly logging in, commands can be executed or text written to the connection for other reasons using <code>Write</code> and <code>Write Bare</code> keywords. The main difference between these two is that the former adds a [#Configuration|configurable newline] after the text automatically.</p> <p>After writing something to the connection, the resulting output can be read using <code>Read</code>, <code>Read Until</code>, <code>Read Until Regexp</code>, and <code>Read Until Prompt</code> keywords. Which one to use depends on the context, but the latest one is often the most convenient.</p> <p>As a convenience when running a command, it is possible to use <code>Execute Command</code> that simply uses <code>Write</code> and <code>Read Until Prompt</code> internally. <code>Write Until Expected Output</code> is useful if you need to wait until writing something produces a desired output.</p> <p>Written and read text is automatically encoded/decoded using a [#Configuration|configured encoding].</p> <p>The ANSI escape codes, like cursor movement and color codes, are normally returned as part of the read operation. If an escape code occurs in middle of a search pattern it may also prevent finding the searched string. <code>Terminal emulation</code> can be used to process these escape codes as they would be if a real terminal would be in use.</p> <p>= Configuration =</p> <p>Many aspects related the connections can be easily configured either globally or per connection basis. Global configuration is done when [#Importing|library is imported], and these values can be overridden per connection by <code>Open Connection</code> or with setting specific keywords <code>Set Timeout</code>, <code>Set Newline</code>, <code>Set Prompt</code>, <code>Set Encoding</code>, <code>Set Default Log Level</code> and <code>Set Telnetlib Log Level</code>.</p> <p>Values of <code>environ_user</code>, <code>window_size</code>, <code>terminal_emulation</code>, and <code>terminal_type</code> can not be changed after opening the connection.</p> <p>== Timeout ==</p> <p>Timeout defines how long is the maximum time to wait when reading output. It is used internally by <code>Read Until</code>, <code>Read Until Regexp</code>, <code>Read Until Prompt</code>, and <code>Login</code> keywords. The default value is 3 seconds.</p> <p>== Connection Timeout ==</p> <p>Connection Timeout defines how long is the maximum time to wait when opening the telnet connection. It is used internally by <code>Open Connection</code>. The default value is the system global default timeout.</p> <p>== Newline ==</p> <p>Newline defines which line separator <code>Write</code> keyword should use. The default value is <code>CRLF</code> that is typically used by Telnet connections.</p> <p>Newline can be given either in escaped format using <code>\\n</code> and <code>\\r</code> or with special <code>LF</code> and <code>CR</code> syntax.</p> <p>Examples: | <code>Set Newline</code> | \\n  | | <code>Set Newline</code> | CRLF |</p> <p>== Prompt ==</p> <p>Often the easiest way to read the output of a command is reading all the output until the next prompt with <code>Read Until Prompt</code>. It also makes it easier, and faster, to verify did <code>Login</code> succeed.</p> <p>Prompt can be specified either as a normal string or a regular expression. The latter is especially useful if the prompt changes as a result of the executed commands. Prompt can be set to be a regular expression by giving <code>prompt_is_regexp</code> argument a true value (see <code>Boolean arguments</code>).</p> <p>Examples: | <code>Open Connection</code> | lolcathost | prompt=$              | | <code>Set Prompt</code>      | (&gt; |# )    | prompt_is_regexp=true |</p> <p>== Encoding ==</p> <p>To ease handling text containing non-ASCII characters, all written text is encoded and read text decoded by default. The default encoding is UTF-8 that works also with ASCII. Encoding can be disabled by using a special encoding value <code>NONE</code>. This is mainly useful if you need to get the bytes received from the connection as-is.</p> <p>Notice that when writing to the connection, only Unicode strings are encoded using the defined encoding. Byte strings are expected to be already encoded correctly. Notice also that normal text in data is passed to the library as Unicode and you need to use variables to use bytes.</p> <p>It is also possible to configure the error handler to use if encoding or decoding characters fails. Accepted values are the same that encode/decode functions in Python strings accept. In practice the following values are the most useful:</p> <ul> <li><code>ignore</code>: ignore characters that cannot be encoded (default)</li> <li><code>strict</code>: fail if characters cannot be encoded</li> <li><code>replace</code>: replace characters that cannot be encoded with a replacement   character</li> </ul> <p>Examples: | <code>Open Connection</code> | lolcathost | encoding=Latin1 | encoding_errors=strict | | <code>Set Encoding</code> | ISO-8859-15 | | <code>Set Encoding</code> | errors=ignore |</p> <p>== Default log level ==</p> <p>Default log level specifies the log level keywords use for <code>logging</code> unless they are given an explicit log level. The default value is <code>INFO</code>, and changing it, for example, to <code>DEBUG</code> can be a good idea if there is lot of unnecessary output that makes log files big.</p> <p>== Terminal type ==</p> <p>By default the Telnet library does not negotiate any specific terminal type with the server. If a specific terminal type, for example <code>vt100</code>, is desired, the terminal type can be configured in <code>importing</code> and with <code>Open Connection</code>.</p> <p>== Window size ==</p> <p>Window size for negotiation with the server can be configured when <code>importing</code> the library and with <code>Open Connection</code>.</p> <p>== USER environment variable ==</p> <p>Telnet protocol allows the <code>USER</code> environment variable to be sent when connecting to the server. On some servers it may happen that there is no login prompt, and on those cases this configuration option will allow still to define the desired username. The option <code>environ_user</code> can be used in <code>importing</code> and with <code>Open Connection</code>.</p> <p>= Terminal emulation =</p> <p>Telnet library supports terminal emulation with [http://pyte.readthedocs.io|Pyte]. Terminal emulation will process the output in a virtual screen. This means that ANSI escape codes, like cursor movements, and also control characters, like carriage returns and backspaces, have the same effect on the result as they would have on a normal terminal screen. For example the sequence <code>acdc\\x1b[3Dbba</code> will result in output <code>abba</code>.</p> <p>Terminal emulation is taken into use by giving <code>terminal_emulation</code> argument a true value (see <code>Boolean arguments</code>) either in the library initialization or with <code>Open Connection</code>.</p> <p>As Pyte approximates vt-style terminal, you may also want to set the terminal type as <code>vt100</code>. We also recommend that you increase the window size, as the terminal emulation will break all lines that are longer than the window row length.</p> <p>When terminal emulation is used, the <code>newline</code> and <code>encoding</code> can not be changed anymore after opening the connection.</p> <p>Examples: | <code>Open Connection</code> | lolcathost | terminal_emulation=True | terminal_type=vt100 | window_size=400x100 |</p> <p>As a prerequisite for using terminal emulation, you need to have Pyte installed. Due to backwards incompatible changes in Pyte, different Robot Framework versions support different Pyte versions:</p> <ul> <li>Pyte 0.6 and newer are supported by Robot Framework 3.0.3.   Latest Pyte version can be installed (or upgraded) with   <code>pip install --upgrade pyte</code>.</li> <li>Pyte 0.5.2 and older are supported by Robot Framework 3.0.2 and earlier.   Pyte 0.5.2 can be installed with <code>pip install pyte==0.5.2</code>.</li> </ul> <p>= Logging =</p> <p>All keywords that read something log the output. These keywords take the log level to use as an optional argument, and if no log level is specified they use the [#Configuration|configured] default value.</p> <p>The valid log levels to use are <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code> (default), and <code>WARN</code>. Levels below <code>INFO</code> are not shown in log files by default whereas warnings are shown more prominently.</p> <p>The [http://docs.python.org/library/telnetlib.html|telnetlib module] used by this library has a custom logging system for logging content it sends and receives. By default these messages are written using <code>TRACE</code> level, but the level is configurable with the <code>telnetlib_log_level</code> option either in the library initialization, to the <code>Open Connection</code> or by using the <code>Set Telnetlib Log Level</code> keyword to the active connection. Special level <code>NONE</code> con be used to disable the logging altogether.</p> <p>= Time string format =</p> <p>Timeouts and other times used must be given as a time string using format like <code>15 seconds</code> or <code>1min 10s</code>. If the timeout is given as just a number, for example, <code>10</code> or <code>1.5</code>, it is considered to be seconds. The time string format is described in more detail in an appendix of [http://robotframework.org/robotframework/#user-guide|Robot Framework User Guide].</p> <p>= Boolean arguments =</p> <p>Some keywords accept arguments that are handled as Boolean values true or false. If such an argument is given as a string, it is considered false if it is an empty string or equal to <code>FALSE</code>, <code>NONE</code>, <code>NO</code>, <code>OFF</code> or <code>0</code>, case-insensitively. Other strings are considered true regardless their value, and other argument types are tested using the same [http://docs.python.org/library/stdtypes.html#truth|rules as in Python].</p> <p>True examples: | <code>Open Connection</code> | lolcathost | terminal_emulation=True    | # Strings are generally true.    | | <code>Open Connection</code> | lolcathost | terminal_emulation=yes     | # Same as the above.             | | <code>Open Connection</code> | lolcathost | terminal_emulation=${TRUE} | # Python <code>True</code> is true.       | | <code>Open Connection</code> | lolcathost | terminal_emulation=${42}   | # Numbers other than 0 are true. |</p> <p>False examples: | <code>Open Connection</code> | lolcathost | terminal_emulation=False    | # String <code>false</code> is false.   | | <code>Open Connection</code> | lolcathost | terminal_emulation=no       | # Also string <code>no</code> is false. | | <code>Open Connection</code> | lolcathost | terminal_emulation=${EMPTY} | # Empty string is false.       | | <code>Open Connection</code> | lolcathost | terminal_emulation=${FALSE} | # Python <code>False</code> is false.   |</p> <p>Considering string <code>NONE</code> false is new in Robot Framework 3.0.3 and considering also <code>OFF</code> and <code>0</code> false is new in Robot Framework 3.1.</p> <p>Telnet library can be imported with optional configuration parameters.</p> <p>Configuration parameters are used as default values when new connections are opened with <code>Open Connection</code> keyword. They can also be overridden after opening the connection using the <code>Set ...</code> <code>keywords</code>. See these keywords as well as <code>Configuration</code>, <code>Terminal emulation</code> and <code>Logging</code> sections above for more information about these parameters and their possible values.</p> <p>See <code>Time string format</code> and <code>Boolean arguments</code> sections for information about using arguments accepting times and Boolean values, respectively.</p> <p>Examples (use only one of these): | = Setting = | = Value = | = Value =                | = Value =            | = Value =           | = Comment = | | Library     | Telnet    |                          |                      |                     | # default values | | Library     | Telnet    | 5 seconds                |                      |                     | # set only timeout | | Library     | Telnet    | newline=LF               | encoding=ISO-8859-1  |                     | # set newline and encoding using named arguments | | Library     | Telnet    | prompt=$                 |                      |                     | # set prompt | | Library     | Telnet    | prompt=(&gt; |# )           | prompt_is_regexp=yes |                     | # set prompt as a regular expression | | Library     | Telnet    | terminal_emulation=True  | terminal_type=vt100  | window_size=400x100 | # use terminal emulation with defined window size and terminal type | | Library     | Telnet    | telnetlib_log_level=NONE |                      |                     | # disable logging messages from the underlying telnetlib |</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def __init__(self, timeout='3 seconds', newline='CRLF',\n             prompt=None, prompt_is_regexp=False,\n             encoding='UTF-8', encoding_errors='ignore',\n             default_log_level='INFO', window_size=None,\n             environ_user=None, terminal_emulation=False,\n             terminal_type=None, telnetlib_log_level='TRACE',\n             connection_timeout=None):\n    \"\"\"Telnet library can be imported with optional configuration parameters.\n\n    Configuration parameters are used as default values when new\n    connections are opened with `Open Connection` keyword. They can also be\n    overridden after opening the connection using the `Set ...` `keywords`.\n    See these keywords as well as `Configuration`, `Terminal emulation` and\n    `Logging` sections above for more information about these parameters\n    and their possible values.\n\n    See `Time string format` and `Boolean arguments` sections for\n    information about using arguments accepting times and Boolean values,\n    respectively.\n\n    Examples (use only one of these):\n    | = Setting = | = Value = | = Value =                | = Value =            | = Value =           | = Comment = |\n    | Library     | Telnet    |                          |                      |                     | # default values |\n    | Library     | Telnet    | 5 seconds                |                      |                     | # set only timeout |\n    | Library     | Telnet    | newline=LF               | encoding=ISO-8859-1  |                     | # set newline and encoding using named arguments |\n    | Library     | Telnet    | prompt=$                 |                      |                     | # set prompt |\n    | Library     | Telnet    | prompt=(&gt; |# )           | prompt_is_regexp=yes |                     | # set prompt as a regular expression |\n    | Library     | Telnet    | terminal_emulation=True  | terminal_type=vt100  | window_size=400x100 | # use terminal emulation with defined window size and terminal type |\n    | Library     | Telnet    | telnetlib_log_level=NONE |                      |                     | # disable logging messages from the underlying telnetlib |\n    \"\"\"\n    self._timeout = timeout or 3.0\n    self._set_connection_timeout(connection_timeout)\n    self._newline = newline or 'CRLF'\n    self._prompt = (prompt, prompt_is_regexp)\n    self._encoding = encoding\n    self._encoding_errors = encoding_errors\n    self._default_log_level = default_log_level\n    self._window_size = window_size\n    self._environ_user = environ_user\n    self._terminal_emulation = terminal_emulation\n    self._terminal_type = terminal_type\n    self._telnetlib_log_level = telnetlib_log_level\n    self._cache = ConnectionCache()\n    self._conn = None\n    self._conn_kws = self._lib_kws = None\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.Telnet.open_connection","title":"open_connection","text":"<pre><code>open_connection(\n    host,\n    alias=None,\n    port=23,\n    timeout=None,\n    newline=None,\n    prompt=None,\n    prompt_is_regexp=False,\n    encoding=None,\n    encoding_errors=None,\n    default_log_level=None,\n    window_size=None,\n    environ_user=None,\n    terminal_emulation=None,\n    terminal_type=None,\n    telnetlib_log_level=None,\n    connection_timeout=None,\n)\n</code></pre> <p>Opens a new Telnet connection to the given host and port.</p> <p>The <code>timeout</code>, <code>newline</code>, <code>prompt</code>, <code>prompt_is_regexp</code>, <code>encoding</code>, <code>default_log_level</code>, <code>window_size</code>, <code>environ_user</code>, <code>terminal_emulation</code>, <code>terminal_type</code> and <code>telnetlib_log_level</code> arguments get default values when the library is [#Importing|imported]. Setting them here overrides those values for the opened connection. See <code>Configuration</code>, <code>Terminal emulation</code> and <code>Logging</code> sections for more information about these parameters and their possible values.</p> <p>Possible already opened connections are cached and it is possible to switch back to them using <code>Switch Connection</code> keyword. It is possible to switch either using explicitly given <code>alias</code> or using index returned by this keyword. Indexing starts from 1 and is reset back to it by <code>Close All Connections</code> keyword.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>@keyword(types=None)\ndef open_connection(self, host, alias=None, port=23, timeout=None,\n                    newline=None, prompt=None, prompt_is_regexp=False,\n                    encoding=None, encoding_errors=None,\n                    default_log_level=None, window_size=None,\n                    environ_user=None, terminal_emulation=None,\n                    terminal_type=None, telnetlib_log_level=None,\n                    connection_timeout=None):\n    \"\"\"Opens a new Telnet connection to the given host and port.\n\n    The ``timeout``, ``newline``, ``prompt``, ``prompt_is_regexp``,\n    ``encoding``, ``default_log_level``, ``window_size``, ``environ_user``,\n    ``terminal_emulation``, ``terminal_type`` and ``telnetlib_log_level``\n    arguments get default values when the library is [#Importing|imported].\n    Setting them here overrides those values for the opened connection.\n    See `Configuration`, `Terminal emulation` and `Logging` sections for\n    more information about these parameters and their possible values.\n\n    Possible already opened connections are cached and it is possible to\n    switch back to them using `Switch Connection` keyword. It is possible to\n    switch either using explicitly given ``alias`` or using index returned\n    by this keyword. Indexing starts from 1 and is reset back to it by\n    `Close All Connections` keyword.\n    \"\"\"\n    timeout = timeout or self._timeout\n    connection_timeout = (timestr_to_secs(connection_timeout)\n                          if connection_timeout\n                          else self._connection_timeout)\n    newline = newline or self._newline\n    encoding = encoding or self._encoding\n    encoding_errors = encoding_errors or self._encoding_errors\n    default_log_level = default_log_level or self._default_log_level\n    window_size = self._parse_window_size(window_size or self._window_size)\n    environ_user = environ_user or self._environ_user\n    if terminal_emulation is None:\n        terminal_emulation = self._terminal_emulation\n    terminal_type = terminal_type or self._terminal_type\n    telnetlib_log_level = telnetlib_log_level or self._telnetlib_log_level\n    if not prompt:\n        prompt, prompt_is_regexp = self._prompt\n    logger.info('Opening connection to %s:%s with prompt: %s%s'\n                % (host, port, prompt, ' (regexp)' if prompt_is_regexp else ''))\n    self._conn = self._get_connection(host, port, timeout, newline,\n                                      prompt, is_truthy(prompt_is_regexp),\n                                      encoding, encoding_errors,\n                                      default_log_level,\n                                      window_size,\n                                      environ_user,\n                                      is_truthy(terminal_emulation),\n                                      terminal_type,\n                                      telnetlib_log_level,\n                                      connection_timeout)\n    return self._cache.register(self._conn, alias)\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.Telnet.switch_connection","title":"switch_connection","text":"<pre><code>switch_connection(index_or_alias)\n</code></pre> <p>Switches between active connections using an index or an alias.</p> <p>Aliases can be given to <code>Open Connection</code> keyword which also always returns the connection index.</p> <p>This keyword returns the index of previous active connection.</p> <p>Example: | <code>Open Connection</code>   | myhost.net              |          |           | | <code>Login</code>             | john                    | secret   |           | | <code>Write</code>             | some command            |          |           | | <code>Open Connection</code>   | yourhost.com            | 2nd conn |           | | <code>Login</code>             | root                    | password |           | | <code>Write</code>             | another cmd             |          |           | | ${old index}=       | <code>Switch Connection</code>     | 1        | # index   | | <code>Write</code>             | something               |          |           | | <code>Switch Connection</code> | 2nd conn                |          | # alias   | | <code>Write</code>             | whatever                |          |           | | <code>Switch Connection</code> | ${old index}            | | # back to original | | [Teardown]          | <code>Close All Connections</code> |          |           |</p> <p>The example above expects that there were no other open connections when opening the first one, because it used index <code>1</code> when switching to the connection later. If you are not sure about that, you can store the index into a variable as shown below.</p> <p>| ${index} =          | <code>Open Connection</code> | myhost.net | | <code>Do Something</code>      |                   |            | | <code>Switch Connection</code> | ${index}          |            |</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def switch_connection(self, index_or_alias):\n    \"\"\"Switches between active connections using an index or an alias.\n\n    Aliases can be given to `Open Connection` keyword which also always\n    returns the connection index.\n\n    This keyword returns the index of previous active connection.\n\n    Example:\n    | `Open Connection`   | myhost.net              |          |           |\n    | `Login`             | john                    | secret   |           |\n    | `Write`             | some command            |          |           |\n    | `Open Connection`   | yourhost.com            | 2nd conn |           |\n    | `Login`             | root                    | password |           |\n    | `Write`             | another cmd             |          |           |\n    | ${old index}=       | `Switch Connection`     | 1        | # index   |\n    | `Write`             | something               |          |           |\n    | `Switch Connection` | 2nd conn                |          | # alias   |\n    | `Write`             | whatever                |          |           |\n    | `Switch Connection` | ${old index}            | | # back to original |\n    | [Teardown]          | `Close All Connections` |          |           |\n\n    The example above expects that there were no other open\n    connections when opening the first one, because it used index\n    ``1`` when switching to the connection later. If you are not\n    sure about that, you can store the index into a variable as\n    shown below.\n\n    | ${index} =          | `Open Connection` | myhost.net |\n    | `Do Something`      |                   |            |\n    | `Switch Connection` | ${index}          |            |\n    \"\"\"\n    old_index = self._cache.current_index\n    self._conn = self._cache.switch(index_or_alias)\n    return old_index\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.Telnet.close_all_connections","title":"close_all_connections","text":"<pre><code>close_all_connections()\n</code></pre> <p>Closes all open connections and empties the connection cache.</p> <p>If multiple connections are opened, this keyword should be used in a test or suite teardown to make sure that all connections are closed. It is not an error if some of the connections have already been closed by <code>Close Connection</code>.</p> <p>After this keyword, new indexes returned by <code>Open Connection</code> keyword are reset to 1.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def close_all_connections(self):\n    \"\"\"Closes all open connections and empties the connection cache.\n\n    If multiple connections are opened, this keyword should be used in\n    a test or suite teardown to make sure that all connections are closed.\n    It is not an error if some of the connections have already been closed\n    by `Close Connection`.\n\n    After this keyword, new indexes returned by `Open Connection`\n    keyword are reset to 1.\n    \"\"\"\n    self._conn = self._cache.close_all()\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection","title":"TelnetConnection","text":"<pre><code>TelnetConnection(\n    host=None,\n    port=23,\n    timeout=3.0,\n    newline=\"CRLF\",\n    prompt=None,\n    prompt_is_regexp=False,\n    encoding=\"UTF-8\",\n    encoding_errors=\"ignore\",\n    default_log_level=\"INFO\",\n    window_size=None,\n    environ_user=None,\n    terminal_emulation=False,\n    terminal_type=None,\n    telnetlib_log_level=\"TRACE\",\n    connection_timeout=None,\n)\n</code></pre> <p>               Bases: <code>Telnet</code></p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def __init__(self, host=None, port=23, timeout=3.0, newline='CRLF',\n             prompt=None, prompt_is_regexp=False,\n             encoding='UTF-8', encoding_errors='ignore',\n             default_log_level='INFO', window_size=None, environ_user=None,\n             terminal_emulation=False, terminal_type=None,\n             telnetlib_log_level='TRACE', connection_timeout=None):\n    if connection_timeout is None:\n        telnetlib.Telnet.__init__(self, host, int(port) if port else 23)\n    else:\n        telnetlib.Telnet.__init__(self, host, int(port) if port else 23,\n                                  connection_timeout)\n    self._set_timeout(timeout)\n    self._set_newline(newline)\n    self._set_prompt(prompt, prompt_is_regexp)\n    self._set_encoding(encoding, encoding_errors)\n    self._set_default_log_level(default_log_level)\n    self._window_size = window_size\n    self._environ_user = self._encode(environ_user) if environ_user else None\n    self._terminal_emulator = self._check_terminal_emulation(terminal_emulation)\n    self._terminal_type = self._encode(terminal_type) if terminal_type else None\n    self.set_option_negotiation_callback(self._negotiate_options)\n    self._set_telnetlib_log_level(telnetlib_log_level)\n    self._opt_responses = list()\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.set_timeout","title":"set_timeout","text":"<pre><code>set_timeout(timeout)\n</code></pre> <p>Sets the timeout used for waiting output in the current connection.</p> <p>Read operations that expect some output to appear (<code>Read Until</code>, <code>Read Until Regexp</code>, <code>Read Until Prompt</code>, <code>Login</code>) use this timeout and fail if the expected output does not appear before this timeout expires.</p> <p>The <code>timeout</code> must be given in <code>time string format</code>. The old timeout is returned and can be used to restore the timeout later.</p> <p>Example: | ${old} =       | <code>Set Timeout</code> | 2 minute 30 seconds | | <code>Do Something</code> | | <code>Set Timeout</code>  | ${old}  |</p> <p>See <code>Configuration</code> section for more information about global and connection specific configuration.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def set_timeout(self, timeout):\n    \"\"\"Sets the timeout used for waiting output in the current connection.\n\n    Read operations that expect some output to appear (`Read Until`, `Read\n    Until Regexp`, `Read Until Prompt`, `Login`) use this timeout and fail\n    if the expected output does not appear before this timeout expires.\n\n    The ``timeout`` must be given in `time string format`. The old timeout\n    is returned and can be used to restore the timeout later.\n\n    Example:\n    | ${old} =       | `Set Timeout` | 2 minute 30 seconds |\n    | `Do Something` |\n    | `Set Timeout`  | ${old}  |\n\n    See `Configuration` section for more information about global and\n    connection specific configuration.\n    \"\"\"\n    self._verify_connection()\n    old = self._timeout\n    self._set_timeout(timeout)\n    return secs_to_timestr(old)\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.set_newline","title":"set_newline","text":"<pre><code>set_newline(newline)\n</code></pre> <p>Sets the newline used by <code>Write</code> keyword in the current connection.</p> <p>The old newline is returned and can be used to restore the newline later. See <code>Set Timeout</code> for a similar example.</p> <p>If terminal emulation is used, the newline can not be changed on an open connection.</p> <p>See <code>Configuration</code> section for more information about global and connection specific configuration.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def set_newline(self, newline):\n    \"\"\"Sets the newline used by `Write` keyword in the current connection.\n\n    The old newline is returned and can be used to restore the newline later.\n    See `Set Timeout` for a similar example.\n\n    If terminal emulation is used, the newline can not be changed on an open\n    connection.\n\n    See `Configuration` section for more information about global and\n    connection specific configuration.\n    \"\"\"\n    self._verify_connection()\n    if self._terminal_emulator:\n        raise AssertionError(\"Newline can not be changed when terminal emulation is used.\")\n    old = self._newline\n    self._set_newline(newline)\n    return old\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.set_prompt","title":"set_prompt","text":"<pre><code>set_prompt(prompt, prompt_is_regexp=False)\n</code></pre> <p>Sets the prompt used by <code>Read Until Prompt</code> and <code>Login</code> in the current connection.</p> <p>If <code>prompt_is_regexp</code> is given a true value (see <code>Boolean arguments</code>), the given <code>prompt</code> is considered to be a regular expression.</p> <p>The old prompt is returned and can be used to restore the prompt later.</p> <p>Example: | ${prompt} | ${regexp} = | <code>Set Prompt</code> | $ | | <code>Do Something</code> | | <code>Set Prompt</code> | ${prompt} | ${regexp} |</p> <p>See the documentation of [http://docs.python.org/library/re.html|Python re module] for more information about the supported regular expression syntax. Notice that possible backslashes need to be escaped in Robot Framework data.</p> <p>See <code>Configuration</code> section for more information about global and connection specific configuration.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def set_prompt(self, prompt, prompt_is_regexp=False):\n    \"\"\"Sets the prompt used by `Read Until Prompt` and `Login` in the current connection.\n\n    If ``prompt_is_regexp`` is given a true value (see `Boolean arguments`),\n    the given ``prompt`` is considered to be a regular expression.\n\n    The old prompt is returned and can be used to restore the prompt later.\n\n    Example:\n    | ${prompt} | ${regexp} = | `Set Prompt` | $ |\n    | `Do Something` |\n    | `Set Prompt` | ${prompt} | ${regexp} |\n\n    See the documentation of\n    [http://docs.python.org/library/re.html|Python re module]\n    for more information about the supported regular expression syntax.\n    Notice that possible backslashes need to be escaped in Robot Framework data.\n\n    See `Configuration` section for more information about global and\n    connection specific configuration.\n    \"\"\"\n    self._verify_connection()\n    old = self._prompt\n    self._set_prompt(prompt, prompt_is_regexp)\n    if old[1]:\n        return old[0].pattern, True\n    return old\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.set_encoding","title":"set_encoding","text":"<pre><code>set_encoding(encoding=None, errors=None)\n</code></pre> <p>Sets the encoding to use for <code>writing and reading</code> in the current connection.</p> <p>The given <code>encoding</code> specifies the encoding to use when written/read text is encoded/decoded, and <code>errors</code> specifies the error handler to use if encoding/decoding fails. Either of these can be omitted and in that case the old value is not affected. Use string <code>NONE</code> to disable encoding altogether.</p> <p>See <code>Configuration</code> section for more information about encoding and error handlers, as well as global and connection specific configuration in general.</p> <p>The old values are returned and can be used to restore the encoding and the error handler later. See <code>Set Prompt</code> for a similar example.</p> <p>If terminal emulation is used, the encoding can not be changed on an open connection.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>@keyword(types=None)\ndef set_encoding(self, encoding=None, errors=None):\n    \"\"\"Sets the encoding to use for `writing and reading` in the current connection.\n\n    The given ``encoding`` specifies the encoding to use when written/read\n    text is encoded/decoded, and ``errors`` specifies the error handler to\n    use if encoding/decoding fails. Either of these can be omitted and in\n    that case the old value is not affected. Use string ``NONE`` to disable\n    encoding altogether.\n\n    See `Configuration` section for more information about encoding and\n    error handlers, as well as global and connection specific configuration\n    in general.\n\n    The old values are returned and can be used to restore the encoding\n    and the error handler later. See `Set Prompt` for a similar example.\n\n    If terminal emulation is used, the encoding can not be changed on an open\n    connection.\n    \"\"\"\n    self._verify_connection()\n    if self._terminal_emulator:\n        raise AssertionError(\"Encoding can not be changed when terminal emulation is used.\")\n    old = self._encoding\n    self._set_encoding(encoding or old[0], errors or old[1])\n    return old\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.set_telnetlib_log_level","title":"set_telnetlib_log_level","text":"<pre><code>set_telnetlib_log_level(level)\n</code></pre> <p>Sets the log level used for <code>logging</code> in the underlying <code>telnetlib</code>.</p> <p>Note that <code>telnetlib</code> can be very noisy thus using the level <code>NONE</code> can shutdown the messages generated by this library.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def set_telnetlib_log_level(self, level):\n    \"\"\"Sets the log level used for `logging` in the underlying ``telnetlib``.\n\n    Note that ``telnetlib`` can be very noisy thus using the level ``NONE``\n    can shutdown the messages generated by this library.\n    \"\"\"\n    self._verify_connection()\n    old = self._telnetlib_log_level\n    self._set_telnetlib_log_level(level)\n    return old\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.set_default_log_level","title":"set_default_log_level","text":"<pre><code>set_default_log_level(level)\n</code></pre> <p>Sets the default log level used for <code>logging</code> in the current connection.</p> <p>The old default log level is returned and can be used to restore the log level later.</p> <p>See <code>Configuration</code> section for more information about global and connection specific configuration.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def set_default_log_level(self, level):\n    \"\"\"Sets the default log level used for `logging` in the current connection.\n\n    The old default log level is returned and can be used to restore the\n    log level later.\n\n    See `Configuration` section for more information about global and\n    connection specific configuration.\n    \"\"\"\n    self._verify_connection()\n    old = self._default_log_level\n    self._set_default_log_level(level)\n    return old\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.close_connection","title":"close_connection","text":"<pre><code>close_connection(loglevel=None)\n</code></pre> <p>Closes the current Telnet connection.</p> <p>Remaining output in the connection is read, logged, and returned. It is not an error to close an already closed connection.</p> <p>Use <code>Close All Connections</code> if you want to make sure all opened connections are closed.</p> <p>See <code>Logging</code> section for more information about log levels.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def close_connection(self, loglevel=None):\n    \"\"\"Closes the current Telnet connection.\n\n    Remaining output in the connection is read, logged, and returned.\n    It is not an error to close an already closed connection.\n\n    Use `Close All Connections` if you want to make sure all opened\n    connections are closed.\n\n    See `Logging` section for more information about log levels.\n    \"\"\"\n    if self.sock:\n        self.sock.shutdown(socket.SHUT_RDWR)\n    self.close()\n    output = self._decode(self.read_all())\n    self._log(output, loglevel)\n    return output\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.login","title":"login","text":"<pre><code>login(\n    username,\n    password,\n    login_prompt=\"login: \",\n    password_prompt=\"Password: \",\n    login_timeout=\"1 second\",\n    login_incorrect=\"Login incorrect\",\n)\n</code></pre> <p>Logs in to the Telnet server with the given user information.</p> <p>This keyword reads from the connection until the <code>login_prompt</code> is encountered and then types the given <code>username</code>. Then it reads until the <code>password_prompt</code> and types the given <code>password</code>. In both cases a newline is appended automatically and the connection specific timeout used when waiting for outputs.</p> <p>How logging status is verified depends on whether a prompt is set for this connection or not:</p> <p>1) If the prompt is set, this keyword reads the output until the prompt is found using the normal timeout. If no prompt is found, login is considered failed and also this keyword fails. Note that in this case both <code>login_timeout</code> and <code>login_incorrect</code> arguments are ignored.</p> <p>2) If the prompt is not set, this keywords sleeps until <code>login_timeout</code> and then reads all the output available on the connection. If the output contains <code>login_incorrect</code> text, login is considered failed and also this keyword fails.</p> <p>See <code>Configuration</code> section for more information about setting newline, timeout, and prompt.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def login(self, username, password, login_prompt='login: ',\n          password_prompt='Password: ', login_timeout='1 second',\n          login_incorrect='Login incorrect'):\n    \"\"\"Logs in to the Telnet server with the given user information.\n\n    This keyword reads from the connection until the ``login_prompt`` is\n    encountered and then types the given ``username``. Then it reads until\n    the ``password_prompt`` and types the given ``password``. In both cases\n    a newline is appended automatically and the connection specific\n    timeout used when waiting for outputs.\n\n    How logging status is verified depends on whether a prompt is set for\n    this connection or not:\n\n    1) If the prompt is set, this keyword reads the output until the prompt\n    is found using the normal timeout. If no prompt is found, login is\n    considered failed and also this keyword fails. Note that in this case\n    both ``login_timeout`` and ``login_incorrect`` arguments are ignored.\n\n    2) If the prompt is not set, this keywords sleeps until ``login_timeout``\n    and then reads all the output available on the connection. If the\n    output contains ``login_incorrect`` text, login is considered failed\n    and also this keyword fails.\n\n    See `Configuration` section for more information about setting\n    newline, timeout, and prompt.\n    \"\"\"\n    output = self._submit_credentials(username, password, login_prompt,\n                                      password_prompt)\n    if self._prompt_is_set():\n        success, output2 = self._read_until_prompt()\n    else:\n        success, output2 = self._verify_login_without_prompt(\n                login_timeout, login_incorrect)\n    output += output2\n    self._log(output)\n    if not success:\n        raise AssertionError('Login incorrect')\n    return output\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.write","title":"write","text":"<pre><code>write(text, loglevel=None)\n</code></pre> <p>Writes the given text plus a newline into the connection.</p> <p>The newline character sequence to use can be [#Configuration|configured] both globally and per connection basis. The default value is <code>CRLF</code>.</p> <p>This keyword consumes the written text, until the added newline, from the output and logs and returns it. The given text itself must not contain newlines. Use <code>Write Bare</code> instead if either of these features causes a problem.</p> <p>Note: This keyword does not return the possible output of the executed command. To get the output, one of the <code>Read ...</code> <code>keywords</code> must be used. See <code>Writing and reading</code> section for more details.</p> <p>See <code>Logging</code> section for more information about log levels.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def write(self, text, loglevel=None):\n    \"\"\"Writes the given text plus a newline into the connection.\n\n    The newline character sequence to use can be [#Configuration|configured]\n    both globally and per connection basis. The default value is ``CRLF``.\n\n    This keyword consumes the written text, until the added newline, from\n    the output and logs and returns it. The given text itself must not\n    contain newlines. Use `Write Bare` instead if either of these features\n    causes a problem.\n\n    *Note:* This keyword does not return the possible output of the executed\n    command. To get the output, one of the `Read ...` `keywords` must be\n    used. See `Writing and reading` section for more details.\n\n    See `Logging` section for more information about log levels.\n    \"\"\"\n    newline = self._get_newline_for(text)\n    if newline in text:\n        raise RuntimeError(\"'Write' keyword cannot be used with strings \"\n                           \"containing newlines. Use 'Write Bare' instead.\")\n    self.write_bare(text + newline)\n    # Can't read until 'text' because long lines are cut strangely in the output\n    return self.read_until(self._newline, loglevel)\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.write_bare","title":"write_bare","text":"<pre><code>write_bare(text)\n</code></pre> <p>Writes the given text, and nothing else, into the connection.</p> <p>This keyword does not append a newline nor consume the written text. Use <code>Write</code> if these features are needed.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def write_bare(self, text):\n    \"\"\"Writes the given text, and nothing else, into the connection.\n\n    This keyword does not append a newline nor consume the written text.\n    Use `Write` if these features are needed.\n    \"\"\"\n    self._verify_connection()\n    telnetlib.Telnet.write(self, self._encode(text))\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.write_until_expected_output","title":"write_until_expected_output","text":"<pre><code>write_until_expected_output(\n    text, expected, timeout, retry_interval, loglevel=None\n)\n</code></pre> <p>Writes the given <code>text</code> repeatedly, until <code>expected</code> appears in the output.</p> <p><code>text</code> is written without appending a newline and it is consumed from the output before trying to find <code>expected</code>. If <code>expected</code> does not appear in the output within <code>timeout</code>, this keyword fails.</p> <p><code>retry_interval</code> defines the time to wait <code>expected</code> to appear before writing the <code>text</code> again. Consuming the written <code>text</code> is subject to the normal [#Configuration|configured timeout].</p> <p>Both <code>timeout</code> and <code>retry_interval</code> must be given in <code>time string format</code>. See <code>Logging</code> section for more information about log levels.</p> <p>Example: | Write Until Expected Output | ps -ef| grep myprocess\\r\\n | myprocess | | ...                         | 5 s                          | 0.5 s     |</p> <p>The above example writes command <code>ps -ef | grep myprocess\\r\\n</code> until <code>myprocess</code> appears in the output. The command is written every 0.5 seconds and the keyword fails if <code>myprocess</code> does not appear in the output in 5 seconds.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def write_until_expected_output(self, text, expected, timeout,\n                                retry_interval, loglevel=None):\n    \"\"\"Writes the given ``text`` repeatedly, until ``expected`` appears in the output.\n\n    ``text`` is written without appending a newline and it is consumed from\n    the output before trying to find ``expected``. If ``expected`` does not\n    appear in the output within ``timeout``, this keyword fails.\n\n    ``retry_interval`` defines the time to wait ``expected`` to appear before\n    writing the ``text`` again. Consuming the written ``text`` is subject to\n    the normal [#Configuration|configured timeout].\n\n    Both ``timeout`` and ``retry_interval`` must be given in `time string\n    format`. See `Logging` section for more information about log levels.\n\n    Example:\n    | Write Until Expected Output | ps -ef| grep myprocess\\\\r\\\\n | myprocess |\n    | ...                         | 5 s                          | 0.5 s     |\n\n    The above example writes command ``ps -ef | grep myprocess\\\\r\\\\n`` until\n    ``myprocess`` appears in the output. The command is written every 0.5\n    seconds and the keyword fails if ``myprocess`` does not appear in\n    the output in 5 seconds.\n    \"\"\"\n    timeout = timestr_to_secs(timeout)\n    retry_interval = timestr_to_secs(retry_interval)\n    maxtime = time.time() + timeout\n    while time.time() &lt; maxtime:\n        self.write_bare(text)\n        self.read_until(text, loglevel)\n        try:\n            with self._custom_timeout(retry_interval):\n                return self.read_until(expected, loglevel)\n        except AssertionError:\n            pass\n    raise NoMatchError(expected, timeout)\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.write_control_character","title":"write_control_character","text":"<pre><code>write_control_character(character)\n</code></pre> <p>Writes the given control character into the connection.</p> <p>The control character is prepended with an IAC (interpret as command) character.</p> <p>The following control character names are supported: BRK, IP, AO, AYT, EC, EL, NOP. Additionally, you can use arbitrary numbers to send any control character.</p> <p>Example: | Write Control Character | BRK | # Send Break command | | Write Control Character | 241 | # Send No operation command |</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def write_control_character(self, character):\n    \"\"\"Writes the given control character into the connection.\n\n    The control character is prepended with an IAC (interpret as command)\n    character.\n\n    The following control character names are supported: BRK, IP, AO, AYT,\n    EC, EL, NOP. Additionally, you can use arbitrary numbers to send any\n    control character.\n\n    Example:\n    | Write Control Character | BRK | # Send Break command |\n    | Write Control Character | 241 | # Send No operation command |\n    \"\"\"\n    self._verify_connection()\n    self.sock.sendall(telnetlib.IAC + self._get_control_character(character))\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.read","title":"read","text":"<pre><code>read(loglevel=None)\n</code></pre> <p>Reads everything that is currently available in the output.</p> <p>Read output is both returned and logged. See <code>Logging</code> section for more information about log levels.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def read(self, loglevel=None):\n    \"\"\"Reads everything that is currently available in the output.\n\n    Read output is both returned and logged. See `Logging` section for more\n    information about log levels.\n    \"\"\"\n    self._verify_connection()\n    output = self._decode(self.read_very_eager())\n    if self._terminal_emulator:\n        self._terminal_emulator.feed(output)\n        output = self._terminal_emulator.read()\n    self._log(output, loglevel)\n    return output\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.read_until","title":"read_until","text":"<pre><code>read_until(expected, loglevel=None)\n</code></pre> <p>Reads output until <code>expected</code> text is encountered.</p> <p>Text up to and including the match is returned and logged. If no match is found, this keyword fails. How much to wait for the output depends on the [#Configuration|configured timeout].</p> <p>See <code>Logging</code> section for more information about log levels. Use <code>Read Until Regexp</code> if more complex matching is needed.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def read_until(self, expected, loglevel=None):\n    \"\"\"Reads output until ``expected`` text is encountered.\n\n    Text up to and including the match is returned and logged. If no match\n    is found, this keyword fails. How much to wait for the output depends\n    on the [#Configuration|configured timeout].\n\n    See `Logging` section for more information about log levels. Use\n    `Read Until Regexp` if more complex matching is needed.\n    \"\"\"\n    success, output = self._read_until(expected)\n    self._log(output, loglevel)\n    if not success:\n        raise NoMatchError(expected, self._timeout, output)\n    return output\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.read_until_regexp","title":"read_until_regexp","text":"<pre><code>read_until_regexp(*expected)\n</code></pre> <p>Reads output until any of the <code>expected</code> regular expressions match.</p> <p>This keyword accepts any number of regular expressions patterns or compiled Python regular expression objects as arguments. Text up to and including the first match to any of the regular expressions is returned and logged. If no match is found, this keyword fails. How much to wait for the output depends on the [#Configuration|configured timeout].</p> <p>If the last given argument is a [#Logging|valid log level], it is used as <code>loglevel</code> similarly as with <code>Read Until</code> keyword.</p> <p>See the documentation of [http://docs.python.org/library/re.html|Python re module] for more information about the supported regular expression syntax. Notice that possible backslashes need to be escaped in Robot Framework data.</p> <p>Examples: | <code>Read Until Regexp</code> | (#|$) | | <code>Read Until Regexp</code> | first_regexp | second_regexp | | <code>Read Until Regexp</code> | \\d{4}-\\d{2}-\\d{2} | DEBUG |</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def read_until_regexp(self, *expected):\n    \"\"\"Reads output until any of the ``expected`` regular expressions match.\n\n    This keyword accepts any number of regular expressions patterns or\n    compiled Python regular expression objects as arguments. Text up to\n    and including the first match to any of the regular expressions is\n    returned and logged. If no match is found, this keyword fails. How much\n    to wait for the output depends on the [#Configuration|configured timeout].\n\n    If the last given argument is a [#Logging|valid log level], it is used\n    as ``loglevel`` similarly as with `Read Until` keyword.\n\n    See the documentation of\n    [http://docs.python.org/library/re.html|Python re module]\n    for more information about the supported regular expression syntax.\n    Notice that possible backslashes need to be escaped in Robot Framework data.\n\n    Examples:\n    | `Read Until Regexp` | (#|$) |\n    | `Read Until Regexp` | first_regexp | second_regexp |\n    | `Read Until Regexp` | \\\\\\\\d{4}-\\\\\\\\d{2}-\\\\\\\\d{2} | DEBUG |\n    \"\"\"\n    if not expected:\n        raise RuntimeError('At least one pattern required')\n    if self._is_valid_log_level(expected[-1]):\n        loglevel = expected[-1]\n        expected = expected[:-1]\n    else:\n        loglevel = None\n    success, output = self._read_until_regexp(*expected)\n    self._log(output, loglevel)\n    if not success:\n        expected = [exp if is_string(exp) else exp.pattern\n                    for exp in expected]\n        raise NoMatchError(expected, self._timeout, output)\n    return output\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.read_until_prompt","title":"read_until_prompt","text":"<pre><code>read_until_prompt(loglevel=None, strip_prompt=False)\n</code></pre> <p>Reads output until the prompt is encountered.</p> <p>This keyword requires the prompt to be [#Configuration|configured] either in <code>importing</code> or with <code>Open Connection</code> or <code>Set Prompt</code> keyword.</p> <p>By default, text up to and including the prompt is returned and logged. If no prompt is found, this keyword fails. How much to wait for the output depends on the [#Configuration|configured timeout].</p> <p>If you want to exclude the prompt from the returned output, set <code>strip_prompt</code> to a true value (see <code>Boolean arguments</code>). If your prompt is a regular expression, make sure that the expression spans the whole prompt, because only the part of the output that matches the regular expression is stripped away.</p> <p>See <code>Logging</code> section for more information about log levels.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def read_until_prompt(self, loglevel=None, strip_prompt=False):\n    \"\"\"Reads output until the prompt is encountered.\n\n    This keyword requires the prompt to be [#Configuration|configured]\n    either in `importing` or with `Open Connection` or `Set Prompt` keyword.\n\n    By default, text up to and including the prompt is returned and logged.\n    If no prompt is found, this keyword fails. How much to wait for the\n    output depends on the [#Configuration|configured timeout].\n\n    If you want to exclude the prompt from the returned output, set\n    ``strip_prompt`` to a true value (see `Boolean arguments`). If your\n    prompt is a regular expression, make sure that the expression spans the\n    whole prompt, because only the part of the output that matches the\n    regular expression is stripped away.\n\n    See `Logging` section for more information about log levels.\n    \"\"\"\n    if not self._prompt_is_set():\n        raise RuntimeError('Prompt is not set.')\n    success, output = self._read_until_prompt()\n    self._log(output, loglevel)\n    if not success:\n        prompt, regexp = self._prompt\n        raise AssertionError(\"Prompt '%s' not found in %s.\"\n                             % (prompt if not regexp else prompt.pattern,\n                                secs_to_timestr(self._timeout)))\n    if is_truthy(strip_prompt):\n        output = self._strip_prompt(output)\n    return output\n</code></pre>"},{"location":"api/robot/libraries/Telnet/#robot.libraries.Telnet.TelnetConnection.execute_command","title":"execute_command","text":"<pre><code>execute_command(command, loglevel=None, strip_prompt=False)\n</code></pre> <p>Executes the given <code>command</code> and reads, logs, and returns everything until the prompt.</p> <p>This keyword requires the prompt to be [#Configuration|configured] either in <code>importing</code> or with <code>Open Connection</code> or <code>Set Prompt</code> keyword.</p> <p>This is a convenience keyword that uses <code>Write</code> and <code>Read Until Prompt</code> internally. Following two examples are thus functionally identical:</p> <p>| ${out} = | <code>Execute Command</code>   | pwd |</p> <p>| <code>Write</code>  | pwd                 | | ${out} = | <code>Read Until Prompt</code> |</p> <p>See <code>Logging</code> section for more information about log levels and <code>Read Until Prompt</code> for more information about the <code>strip_prompt</code> parameter.</p> Source code in <code>src/robot/libraries/Telnet.py</code> <pre><code>def execute_command(self, command, loglevel=None, strip_prompt=False):\n    \"\"\"Executes the given ``command`` and reads, logs, and returns everything until the prompt.\n\n    This keyword requires the prompt to be [#Configuration|configured]\n    either in `importing` or with `Open Connection` or `Set Prompt` keyword.\n\n    This is a convenience keyword that uses `Write` and `Read Until Prompt`\n    internally. Following two examples are thus functionally identical:\n\n    | ${out} = | `Execute Command`   | pwd |\n\n    | `Write`  | pwd                 |\n    | ${out} = | `Read Until Prompt` |\n\n    See `Logging` section for more information about log levels and `Read\n    Until Prompt` for more information about the ``strip_prompt`` parameter.\n    \"\"\"\n    self.write(command, loglevel)\n    return self.read_until_prompt(loglevel, strip_prompt)\n</code></pre>"},{"location":"api/robot/libraries/XML/","title":"robot.libraries.XML","text":""},{"location":"api/robot/libraries/XML/#robot.libraries.XML","title":"robot.libraries.XML","text":""},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML","title":"XML","text":"<pre><code>XML(use_lxml=False)\n</code></pre> <p>Robot Framework library for verifying and modifying XML documents.</p> <p>As the name implies, XML is a library for verifying contents of XML files. In practice, it is a pretty thin wrapper on top of Python's [http://docs.python.org/library/xml.etree.elementtree.html|ElementTree XML API].</p> <p>The library has the following main usages:</p> <ul> <li>Parsing an XML file, or a string containing XML, into an XML element   structure and finding certain elements from it for further analysis   (e.g. <code>Parse XML</code> and <code>Get Element</code> keywords).</li> <li>Getting text or attributes of elements   (e.g. <code>Get Element Text</code> and <code>Get Element Attribute</code>).</li> <li>Directly verifying text, attributes, or whole elements   (e.g <code>Element Text Should Be</code> and <code>Elements Should Be Equal</code>).</li> <li>Modifying XML and saving it (e.g. <code>Set Element Text</code>, <code>Add Element</code>   and <code>Save XML</code>).</li> </ul> <p>== Table of contents ==</p> <p>%TOC%</p> <p>= Parsing XML =</p> <p>XML can be parsed into an element structure using <code>Parse XML</code> keyword. The XML to be parsed can be specified using a path to an XML file or as a string or bytes that contain XML directly. The keyword returns the root element of the structure, which then contains other elements as its children and their children. Possible comments and processing instructions in the source XML are removed.</p> <p>XML is not validated during parsing even if it has a schema defined. How possible doctype elements are handled otherwise depends on the used XML module and on the platform. The standard ElementTree strips doctypes altogether, but when <code>using lxml</code> they are preserved when XML is saved.</p> <p>The element structure returned by <code>Parse XML</code>, as well as elements returned by keywords such as <code>Get Element</code>, can be used as the <code>source</code> argument with other keywords. In addition to an already parsed XML structure, other keywords also accept paths to XML files and strings containing XML similarly as <code>Parse XML</code>. Notice that keywords that modify XML do not write those changes back to disk even if the source would be given as a path to a file. Changes must always be saved explicitly using <code>Save XML</code> keyword.</p> <p>When the source is given as a path to a file, the forward slash character (<code>/</code>) can be used as the path separator regardless the operating system. On Windows also the backslash works, but in the data it needs to be escaped by doubling it (<code>\\\\</code>). Using the built-in variable <code>${/}</code> naturally works too.</p> <p>= Using lxml =</p> <p>By default, this library uses Python's standard [http://docs.python.org/library/xml.etree.elementtree.html|ElementTree] module for parsing XML, but it can be configured to use [http://lxml.de|lxml] module instead when <code>importing</code> the library. The resulting element structure has same API regardless which module is used for parsing.</p> <p>The main benefits of using lxml is that it supports richer xpath syntax than the standard ElementTree and enables using <code>Evaluate Xpath</code> keyword. It also preserves the doctype and possible namespace prefixes saving XML.</p> <p>= Example =</p> <p>The following simple example demonstrates parsing XML and verifying its contents both using keywords in this library and in BuiltIn and Collections libraries. How to use xpath expressions to find elements and what attributes the returned elements contain are discussed, with more examples, in <code>Finding elements with xpath</code> and <code>Element attributes</code> sections.</p> <p>In this example, as well as in many other examples in this documentation, <code>${XML}</code> refers to the following example XML document. In practice <code>${XML}</code> could either be a path to an XML file or it could contain the XML itself.</p> <p>|  |   text |    |      |    |    |     more text |      |      |    |    |     <p> |       Text with bold and italics. |     </p> |    | </p> <p>| ${root} =                | <code>Parse XML</code>   | ${XML}  |       |             | | <code>Should Be Equal</code>        | ${root.tag}   | example |       |             | | ${first} =               | <code>Get Element</code> | ${root} | first |             | | <code>Should Be Equal</code>        | ${first.text} | text    |       |             | | <code>Dictionary Should Contain Key</code> | ${first.attrib}  | id    |             | | <code>Element Text Should Be</code> | ${first}      | text    |       |             | | <code>Element Attribute Should Be</code> | ${first} | id      | 1     |             | | <code>Element Attribute Should Be</code> | ${root}  | id      | 1     | xpath=first | | <code>Element Attribute Should Be</code> | ${XML}   | id      | 1     | xpath=first |</p> <p>Notice that in the example three last lines are equivalent. Which one to use in practice depends on which other elements you need to get or verify. If you only need to do one verification, using the last line alone would suffice. If more verifications are needed, parsing the XML with <code>Parse XML</code> only once would be more efficient.</p> <p>= Finding elements with xpath =</p> <p>ElementTree, and thus also this library, supports finding elements using xpath expressions. ElementTree does not, however, support the full xpath standard. The supported xpath syntax is explained below and [https://docs.python.org/library/xml.etree.elementtree.html#xpath-support| ElementTree documentation] provides more details. In the examples <code>${XML}</code> refers to the same XML structure as in the earlier example.</p> <p>If lxml support is enabled when <code>importing</code> the library, the whole [http://www.w3.org/TR/xpath/|xpath 1.0 standard] is supported. That includes everything listed below but also a lot of other useful constructs.</p> <p>== Tag names ==</p> <p>When just a single tag name is used, xpath matches all direct child elements that have that tag name.</p> <p>| ${elem} =          | <code>Get Element</code>  | ${XML}      | third | | <code>Should Be Equal</code>  | ${elem.tag}    | third       |       | | @{children} =      | <code>Get Elements</code> | ${elem}     | child | | <code>Length Should Be</code> | ${children}    | 2           |       |</p> <p>== Paths ==</p> <p>Paths are created by combining tag names with a forward slash (<code>/</code>). For example, <code>parent/child</code> matches all <code>child</code> elements under <code>parent</code> element. Notice that if there are multiple <code>parent</code> elements that all have <code>child</code> elements, <code>parent/child</code> xpath will match all these <code>child</code> elements.</p> <p>| ${elem} =         | <code>Get Element</code> | ${XML}     | second/child            | | <code>Should Be Equal</code> | ${elem.tag}   | child      |                         | | ${elem} =         | <code>Get Element</code> | ${XML}     | third/child/grandchild  | | <code>Should Be Equal</code> | ${elem.tag}   | grandchild |                         |</p> <p>== Wildcards ==</p> <p>An asterisk (<code>*</code>) can be used in paths instead of a tag name to denote any element.</p> <p>| @{children} =      | <code>Get Elements</code> | ${XML} | */child | | <code>Length Should Be</code> | ${children}    | 3      |         |</p> <p>== Current element ==</p> <p>The current element is denoted with a dot (<code>.</code>). Normally the current element is implicit and does not need to be included in the xpath.</p> <p>== Parent element ==</p> <p>The parent element of another element is denoted with two dots (<code>..</code>). Notice that it is not possible to refer to the parent of the current element.</p> <p>| ${elem} =         | <code>Get Element</code> | ${XML} | */second/.. | | <code>Should Be Equal</code> | ${elem.tag}   | third  |             |</p> <p>== Search all sub elements ==</p> <p>Two forward slashes (<code>//</code>) mean that all sub elements, not only the direct children, are searched. If the search is started from the current element, an explicit dot is required.</p> <p>| @{elements} =      | <code>Get Elements</code> | ${XML} | .//second | | <code>Length Should Be</code> | ${elements}    | 2      |           | | ${b} =             | <code>Get Element</code>  | ${XML} | html//b   | | <code>Should Be Equal</code>  | ${b.text}      | bold   |           |</p> <p>== Predicates ==</p> <p>Predicates allow selecting elements using also other criteria than tag names, for example, attributes or position. They are specified after the normal tag name or path using syntax <code>path[predicate]</code>. The path can have wildcards and other special syntax explained earlier. What predicates the standard ElementTree supports is explained in the table below.</p> <p>|  = Predicate =  |             = Matches =           |    = Example =     | | @attrib         | Elements with attribute <code>attrib</code>. | second[@id]        | | @attrib=\"value\" | Elements with attribute <code>attrib</code> having value <code>value</code>. | *[@id=\"2\"] | | position        | Elements at the specified position. Position can be an integer (starting from 1), expression <code>last()</code>, or relative expression like <code>last() - 1</code>. | third/child[1] | | tag             | Elements with a child element named <code>tag</code>. | third/child[grandchild] |</p> <p>Predicates can also be stacked like <code>path[predicate1][predicate2]</code>. A limitation is that possible position predicate must always be first.</p> <p>= Element attributes =</p> <p>All keywords returning elements, such as <code>Parse XML</code>, and <code>Get Element</code>, return ElementTree's [http://docs.python.org/library/xml.etree.elementtree.html#element-objects|Element objects]. These elements can be used as inputs for other keywords, but they also contain several useful attributes that can be accessed directly using the extended variable syntax.</p> <p>The attributes that are both useful and convenient to use in the data are explained below. Also other attributes, including methods, can be accessed, but that is typically better to do in custom libraries than directly in the data.</p> <p>The examples use the same <code>${XML}</code> structure as the earlier examples.</p> <p>== tag ==</p> <p>The tag of the element.</p> <p>| ${root} =         | <code>Parse XML</code> | ${XML}  | | <code>Should Be Equal</code> | ${root.tag} | example |</p> <p>== text ==</p> <p>The text that the element contains or Python <code>None</code> if the element has no text. Notice that the text does not contain texts of possible child elements nor text after or between children. Notice also that in XML whitespace is significant, so the text contains also possible indentation and newlines. To get also text of the possible children, optionally whitespace normalized, use <code>Get Element Text</code> keyword.</p> <p>| ${1st} =          | <code>Get Element</code> | ${XML}  | first        | | <code>Should Be Equal</code> | ${1st.text}   | text    |              | | ${2nd} =          | <code>Get Element</code> | ${XML}  | second/child | | <code>Should Be Equal</code> | ${2nd.text}   | ${NONE} |              | | ${p} =            | <code>Get Element</code> | ${XML}  | html/p       | | <code>Should Be Equal</code> | ${p.text}     | \\n${SPACE*6}Text with${SPACE} |</p> <p>== tail ==</p> <p>The text after the element before the next opening or closing tag. Python <code>None</code> if the element has no tail. Similarly as with <code>text</code>, also <code>tail</code> contains possible indentation and newlines.</p> <p>| ${b} =            | <code>Get Element</code> | ${XML}  | html/p/b  | | <code>Should Be Equal</code> | ${b.tail}     | ${SPACE}and${SPACE} |</p> <p>== attrib ==</p> <p>A Python dictionary containing attributes of the element.</p> <p>| ${2nd} =          | <code>Get Element</code>       | ${XML} | second | | <code>Should Be Equal</code> | ${2nd.attrib['id']} | 2      |        | | ${3rd} =          | <code>Get Element</code>       | ${XML} | third  | | <code>Should Be Empty</code> | ${3rd.attrib}       |        |        |</p> <p>= Handling XML namespaces =</p> <p>ElementTree and lxml handle possible namespaces in XML documents by adding the namespace URI to tag names in so-called Clark Notation. That is inconvenient especially with xpaths, and by default this library strips those namespaces away and moves them to <code>xmlns</code> attribute instead. That can be avoided by passing <code>keep_clark_notation</code> argument to <code>Parse XML</code> keyword. Alternatively <code>Parse XML</code> supports stripping namespace information altogether by using <code>strip_namespaces</code> argument. The pros and cons of different approaches are discussed in more detail below.</p> <p>== How ElementTree handles namespaces ==</p> <p>If an XML document has namespaces, ElementTree adds namespace information to tag names in [http://www.jclark.com/xml/xmlns.htm|Clark Notation] (e.g. <code>{http://ns.uri}tag</code>) and removes original <code>xmlns</code> attributes. This is done both with default namespaces and with namespaces with a prefix. How it works in practice is illustrated by the following example, where <code>${NS}</code> variable contains this XML document:</p> <p>|  |    |      |    | </p> <p>| ${root} = | <code>Parse XML</code> | ${NS} | keep_clark_notation=yes | | <code>Should Be Equal</code> | ${root.tag} | {http://www.w3.org/1999/XSL/Transform}stylesheet | | <code>Element Should Exist</code> | ${root} | {http://www.w3.org/1999/XSL/Transform}template/{http://www.w3.org/1999/xhtml}html | | <code>Should Be Empty</code> | ${root.attrib} |</p> <p>As you can see, including the namespace URI in tag names makes xpaths really long and complex.</p> <p>If you save the XML, ElementTree moves namespace information back to <code>xmlns</code> attributes. Unfortunately it does not restore the original prefixes:</p> <p>|  |    |      |    | </p> <p>The resulting output is semantically same as the original, but mangling prefixes like this may still not be desirable. Notice also that the actual output depends slightly on ElementTree version.</p> <p>== Default namespace handling ==</p> <p>Because the way ElementTree handles namespaces makes xpaths so complicated, this library, by default, strips namespaces from tag names and moves that information back to <code>xmlns</code> attributes. How this works in practice is shown by the example below, where <code>${NS}</code> variable contains the same XML document as in the previous example.</p> <p>| ${root} = | <code>Parse XML</code> | ${NS} | | <code>Should Be Equal</code> | ${root.tag} | stylesheet | | <code>Element Should Exist</code> | ${root} | template/html | | <code>Element Attribute Should Be</code> | ${root} | xmlns | http://www.w3.org/1999/XSL/Transform | | <code>Element Attribute Should Be</code> | ${root} | xmlns | http://www.w3.org/1999/xhtml | xpath=template/html |</p> <p>Now that tags do not contain namespace information, xpaths are simple again.</p> <p>A minor limitation of this approach is that namespace prefixes are lost. As a result the saved output is not exactly same as the original one in this case either:</p> <p>|  |    |      |    | </p> <p>Also this output is semantically same as the original. If the original XML had only default namespaces, the output would also look identical.</p> <p>== Namespaces when using lxml ==</p> <p>This library handles namespaces same way both when <code>using lxml</code> and when not using it. There are, however, differences how lxml internally handles namespaces compared to the standard ElementTree. The main difference is that lxml stores information about namespace prefixes and they are thus preserved if XML is saved. Another visible difference is that lxml includes namespace information in child elements got with <code>Get Element</code> if the parent element has namespaces.</p> <p>== Stripping namespaces altogether ==</p> <p>Because namespaces often add unnecessary complexity, <code>Parse XML</code> supports stripping them altogether by using <code>strip_namespaces=True</code>. When this option is enabled, namespaces are not shown anywhere nor are they included if XML is saved.</p> <p>== Attribute namespaces ==</p> <p>Attributes in XML documents are, by default, in the same namespaces as the element they belong to. It is possible to use different namespaces by using prefixes, but this is pretty rare.</p> <p>If an attribute has a namespace prefix, ElementTree will replace it with Clark Notation the same way it handles elements. Because stripping namespaces from attributes could cause attribute conflicts, this library does not handle attribute namespaces at all. Thus the following example works the same way regardless how namespaces are handled.</p> <p>| ${root} = | <code>Parse XML</code> |  | | <code>Element Attribute Should Be</code> | ${root} | id | 1 | | <code>Element Attribute Should Be</code> | ${root} | {http://my.ns}id | 2 |</p> <p>= Boolean arguments =</p> <p>Some keywords accept arguments that are handled as Boolean values true or false. If such an argument is given as a string, it is considered false if it is an empty string or equal to <code>FALSE</code>, <code>NONE</code>, <code>NO</code>, <code>OFF</code> or <code>0</code>, case-insensitively. Other strings are considered true regardless their value, and other argument types are tested using the same [http://docs.python.org/library/stdtypes.html#truth|rules as in Python].</p> <p>True examples: | <code>Parse XML</code> | ${XML} | keep_clark_notation=True    | # Strings are generally true.    | | <code>Parse XML</code> | ${XML} | keep_clark_notation=yes     | # Same as the above.             | | <code>Parse XML</code> | ${XML} | keep_clark_notation=${TRUE} | # Python <code>True</code> is true.       | | <code>Parse XML</code> | ${XML} | keep_clark_notation=${42}   | # Numbers other than 0 are true. |</p> <p>False examples: | <code>Parse XML</code> | ${XML} | keep_clark_notation=False    | # String <code>false</code> is false.   | | <code>Parse XML</code> | ${XML} | keep_clark_notation=no       | # Also string <code>no</code> is false. | | <code>Parse XML</code> | ${XML} | keep_clark_notation=${EMPTY} | # Empty string is false.       | | <code>Parse XML</code> | ${XML} | keep_clark_notation=${FALSE} | # Python <code>False</code> is false.   |</p> <p>== Pattern matching ==</p> <p>Some keywords, for example <code>Elements Should Match</code>, support so called [http://en.wikipedia.org/wiki/Glob_(programming)|glob patterns] where:</p> <p>| <code>*</code>        | matches any string, even an empty string                | | <code>?</code>        | matches any single character                            | | <code>[chars]</code>  | matches one character in the bracket                    | | <code>[!chars]</code> | matches one character not in the bracket                | | <code>[a-z]</code>    | matches one character from the range in the bracket     | | <code>[!a-z]</code>   | matches one character not from the range in the bracket |</p> <p>Unlike with glob patterns normally, path separator characters <code>/</code> and <code>\\</code> and the newline character <code>\\n</code> are matches by the above wildcards.</p> <p>Import library with optionally lxml mode enabled.</p> <p>This library uses Python's standard [http://docs.python.org/library/xml.etree.elementtree.html|ElementTree] module for parsing XML by default. If <code>use_lxml</code> argument is given a true value (see <code>Boolean arguments</code>), the [http://lxml.de|lxml] module is used instead. See the <code>Using lxml</code> section for benefits provided by lxml.</p> <p>Using lxml requires that the lxml module is installed on the system. If lxml mode is enabled but the module is not installed, this library emits a warning and reverts back to using the standard ElementTree.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def __init__(self, use_lxml=False):\n    \"\"\"Import library with optionally lxml mode enabled.\n\n    This library uses Python's standard\n    [http://docs.python.org/library/xml.etree.elementtree.html|ElementTree]\n    module for parsing XML by default. If ``use_lxml`` argument is given\n    a true value (see `Boolean arguments`), the [http://lxml.de|lxml] module\n    is used instead. See the `Using lxml` section for benefits provided by lxml.\n\n    Using lxml requires that the lxml module is installed on the system.\n    If lxml mode is enabled but the module is not installed, this library\n    emits a warning and reverts back to using the standard ElementTree.\n    \"\"\"\n    if use_lxml and lxml_etree:\n        self.etree = lxml_etree\n        self.modern_etree = True\n        self.lxml_etree = True\n    else:\n        self.etree = ET\n        self.modern_etree = ET.VERSION &gt;= '1.3'\n        self.lxml_etree = False\n    if use_lxml and not lxml_etree:\n        logger.warn('XML library reverted to use standard ElementTree '\n                    'because lxml module is not installed.')\n    self._ns_stripper = NameSpaceStripper(self.etree, self.lxml_etree)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.parse_xml","title":"parse_xml","text":"<pre><code>parse_xml(\n    source,\n    keep_clark_notation=False,\n    strip_namespaces=False,\n)\n</code></pre> <p>Parses the given XML file or string into an element structure.</p> <p>The <code>source</code> can either be a path to an XML file or a string containing XML. In both cases the XML is parsed into ElementTree [http://docs.python.org/library/xml.etree.elementtree.html#element-objects|element structure] and the root element is returned. Possible comments and processing instructions in the source XML are removed.</p> <p>As discussed in <code>Handling XML namespaces</code> section, this keyword, by default, removes namespace information ElementTree has added to tag names and moves it into <code>xmlns</code> attributes. This typically eases handling XML documents with namespaces considerably. If you do not want that to happen, or want to avoid the small overhead of going through the element structure when your XML does not have namespaces, you can disable this feature by giving <code>keep_clark_notation</code> argument a true value (see <code>Boolean arguments</code>).</p> <p>If you want to strip namespace information altogether so that it is not included even if XML is saved, you can give a true value to <code>strip_namespaces</code> argument.</p> <p>Examples: | ${root} = | Parse XML |  | | ${xml} = | Parse XML | ${CURDIR}/test.xml | keep_clark_notation=True | | ${xml} = | Parse XML | ${CURDIR}/test.xml | strip_namespaces=True |</p> <p>Use <code>Get Element</code> keyword if you want to get a certain element and not the whole structure. See <code>Parsing XML</code> section for more details and examples.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def parse_xml(self, source, keep_clark_notation=False, strip_namespaces=False):\n    \"\"\"Parses the given XML file or string into an element structure.\n\n    The ``source`` can either be a path to an XML file or a string\n    containing XML. In both cases the XML is parsed into ElementTree\n    [http://docs.python.org/library/xml.etree.elementtree.html#element-objects|element structure]\n    and the root element is returned. Possible comments and processing\n    instructions in the source XML are removed.\n\n    As discussed in `Handling XML namespaces` section, this keyword, by\n    default, removes namespace information ElementTree has added to tag\n    names and moves it into ``xmlns`` attributes. This typically eases\n    handling XML documents with namespaces considerably. If you do not\n    want that to happen, or want to avoid the small overhead of going\n    through the element structure when your XML does not have namespaces,\n    you can disable this feature by giving ``keep_clark_notation`` argument\n    a true value (see `Boolean arguments`).\n\n    If you want to strip namespace information altogether so that it is\n    not included even if XML is saved, you can give a true value to\n    ``strip_namespaces`` argument.\n\n    Examples:\n    | ${root} = | Parse XML | &lt;root&gt;&lt;child/&gt;&lt;/root&gt; |\n    | ${xml} = | Parse XML | ${CURDIR}/test.xml | keep_clark_notation=True |\n    | ${xml} = | Parse XML | ${CURDIR}/test.xml | strip_namespaces=True |\n\n    Use `Get Element` keyword if you want to get a certain element and not\n    the whole structure. See `Parsing XML` section for more details and\n    examples.\n    \"\"\"\n    if isinstance(source, os.PathLike):\n        source = str(source)\n    with ETSource(source) as source:\n        tree = self.etree.parse(source)\n    if self.lxml_etree:\n        strip = (lxml_etree.Comment, lxml_etree.ProcessingInstruction)\n        lxml_etree.strip_elements(tree, *strip, **dict(with_tail=False))\n    root = tree.getroot()\n    if not keep_clark_notation:\n        self._ns_stripper.strip(root, preserve=not strip_namespaces)\n    return root\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.get_element","title":"get_element","text":"<pre><code>get_element(source, xpath='.')\n</code></pre> <p>Returns an element in the <code>source</code> matching the <code>xpath</code>.</p> <p>The <code>source</code> can be a path to an XML file, a string containing XML, or an already parsed XML element. The <code>xpath</code> specifies which element to find. See the <code>introduction</code> for more details about both the possible sources and the supported xpath syntax.</p> <p>The keyword fails if more, or less, than one element matches the <code>xpath</code>. Use <code>Get Elements</code> if you want all matching elements to be returned.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | ${element} = | Get Element | ${XML}     | second | | ${child} =   | Get Element | ${element} | child  |</p> <p><code>Parse XML</code> is recommended for parsing XML when the whole structure is needed. It must be used if there is a need to configure how XML namespaces are handled.</p> <p>Many other keywords use this keyword internally, and keywords modifying XML are typically documented to both to modify the given source and to return it. Modifying the source does not apply if the source is given as a string. The XML structure parsed based on the string and then modified is nevertheless returned.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def get_element(self, source, xpath='.'):\n    \"\"\"Returns an element in the ``source`` matching the ``xpath``.\n\n    The ``source`` can be a path to an XML file, a string containing XML, or\n    an already parsed XML element. The ``xpath`` specifies which element to\n    find. See the `introduction` for more details about both the possible\n    sources and the supported xpath syntax.\n\n    The keyword fails if more, or less, than one element matches the\n    ``xpath``. Use `Get Elements` if you want all matching elements to be\n    returned.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | ${element} = | Get Element | ${XML}     | second |\n    | ${child} =   | Get Element | ${element} | child  |\n\n    `Parse XML` is recommended for parsing XML when the whole structure\n    is needed. It must be used if there is a need to configure how XML\n    namespaces are handled.\n\n    Many other keywords use this keyword internally, and keywords modifying\n    XML are typically documented to both to modify the given source and\n    to return it. Modifying the source does not apply if the source is\n    given as a string. The XML structure parsed based on the string and\n    then modified is nevertheless returned.\n    \"\"\"\n    elements = self.get_elements(source, xpath)\n    if len(elements) != 1:\n        self._raise_wrong_number_of_matches(len(elements), xpath)\n    return elements[0]\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.get_elements","title":"get_elements","text":"<pre><code>get_elements(source, xpath)\n</code></pre> <p>Returns a list of elements in the <code>source</code> matching the <code>xpath</code>.</p> <p>The <code>source</code> can be a path to an XML file, a string containing XML, or an already parsed XML element. The <code>xpath</code> specifies which element to find. See the <code>introduction</code> for more details.</p> <p>Elements matching the <code>xpath</code> are returned as a list. If no elements match, an empty list is returned. Use <code>Get Element</code> if you want to get exactly one match.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | ${children} =    | Get Elements | ${XML} | third/child | | Length Should Be | ${children}  | 2      |             | | ${children} =    | Get Elements | ${XML} | first/child | | Should Be Empty  |  ${children} |        |             |</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def get_elements(self, source, xpath):\n    \"\"\"Returns a list of elements in the ``source`` matching the ``xpath``.\n\n    The ``source`` can be a path to an XML file, a string containing XML, or\n    an already parsed XML element. The ``xpath`` specifies which element to\n    find. See the `introduction` for more details.\n\n    Elements matching the ``xpath`` are returned as a list. If no elements\n    match, an empty list is returned. Use `Get Element` if you want to get\n    exactly one match.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | ${children} =    | Get Elements | ${XML} | third/child |\n    | Length Should Be | ${children}  | 2      |             |\n    | ${children} =    | Get Elements | ${XML} | first/child |\n    | Should Be Empty  |  ${children} |        |             |\n    \"\"\"\n    if isinstance(source, (str, bytes, os.PathLike)):\n        source = self.parse_xml(source)\n    finder = ElementFinder(self.etree, self.modern_etree, self.lxml_etree)\n    return finder.find_all(source, xpath)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.get_child_elements","title":"get_child_elements","text":"<pre><code>get_child_elements(source, xpath='.')\n</code></pre> <p>Returns the child elements of the specified element as a list.</p> <p>The element whose children to return is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword.</p> <p>All the direct child elements of the specified element are returned. If the element has no children, an empty list is returned.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | ${children} =    | Get Child Elements | ${XML} |             | | Length Should Be | ${children}        | 4      |             | | ${children} =    | Get Child Elements | ${XML} | xpath=first | | Should Be Empty  | ${children}        |        |             |</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def get_child_elements(self, source, xpath='.'):\n    \"\"\"Returns the child elements of the specified element as a list.\n\n    The element whose children to return is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword.\n\n    All the direct child elements of the specified element are returned.\n    If the element has no children, an empty list is returned.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | ${children} =    | Get Child Elements | ${XML} |             |\n    | Length Should Be | ${children}        | 4      |             |\n    | ${children} =    | Get Child Elements | ${XML} | xpath=first |\n    | Should Be Empty  | ${children}        |        |             |\n    \"\"\"\n    return list(self.get_element(source, xpath))\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.get_element_count","title":"get_element_count","text":"<pre><code>get_element_count(source, xpath='.')\n</code></pre> <p>Returns and logs how many elements the given <code>xpath</code> matches.</p> <p>Arguments <code>source</code> and <code>xpath</code> have exactly the same semantics as with <code>Get Elements</code> keyword that this keyword uses internally.</p> <p>See also <code>Element Should Exist</code> and <code>Element Should Not Exist</code>.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def get_element_count(self, source, xpath='.'):\n    \"\"\"Returns and logs how many elements the given ``xpath`` matches.\n\n    Arguments ``source`` and ``xpath`` have exactly the same semantics as\n    with `Get Elements` keyword that this keyword uses internally.\n\n    See also `Element Should Exist` and `Element Should Not Exist`.\n    \"\"\"\n    count = len(self.get_elements(source, xpath))\n    logger.info(f\"{count} element{s(count)} matched '{xpath}'.\")\n    return count\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.element_should_exist","title":"element_should_exist","text":"<pre><code>element_should_exist(source, xpath='.', message=None)\n</code></pre> <p>Verifies that one or more element match the given <code>xpath</code>.</p> <p>Arguments <code>source</code> and <code>xpath</code> have exactly the same semantics as with <code>Get Elements</code> keyword. Keyword passes if the <code>xpath</code> matches one or more elements in the <code>source</code>. The default error message can be overridden with the <code>message</code> argument.</p> <p>See also <code>Element Should Not Exist</code> as well as <code>Get Element Count</code> that this keyword uses internally.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def element_should_exist(self, source, xpath='.', message=None):\n    \"\"\"Verifies that one or more element match the given ``xpath``.\n\n    Arguments ``source`` and ``xpath`` have exactly the same semantics as\n    with `Get Elements` keyword. Keyword passes if the ``xpath`` matches\n    one or more elements in the ``source``. The default error message can\n    be overridden with the ``message`` argument.\n\n    See also `Element Should Not Exist` as well as `Get Element Count`\n    that this keyword uses internally.\n    \"\"\"\n    count = self.get_element_count(source, xpath)\n    if not count:\n        self._raise_wrong_number_of_matches(count, xpath, message)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.element_should_not_exist","title":"element_should_not_exist","text":"<pre><code>element_should_not_exist(source, xpath='.', message=None)\n</code></pre> <p>Verifies that no element match the given <code>xpath</code>.</p> <p>Arguments <code>source</code> and <code>xpath</code> have exactly the same semantics as with <code>Get Elements</code> keyword. Keyword fails if the <code>xpath</code> matches any element in the <code>source</code>. The default error message can be overridden with the <code>message</code> argument.</p> <p>See also <code>Element Should Exist</code> as well as <code>Get Element Count</code> that this keyword uses internally.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def element_should_not_exist(self, source, xpath='.', message=None):\n    \"\"\"Verifies that no element match the given ``xpath``.\n\n    Arguments ``source`` and ``xpath`` have exactly the same semantics as\n    with `Get Elements` keyword. Keyword fails if the ``xpath`` matches any\n    element in the ``source``. The default error message can be overridden\n    with the ``message`` argument.\n\n    See also `Element Should Exist` as well as `Get Element Count`\n    that this keyword uses internally.\n    \"\"\"\n    count = self.get_element_count(source, xpath)\n    if count:\n        self._raise_wrong_number_of_matches(count, xpath, message)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.get_element_text","title":"get_element_text","text":"<pre><code>get_element_text(\n    source, xpath=\".\", normalize_whitespace=False\n)\n</code></pre> <p>Returns all text of the element, possibly whitespace normalized.</p> <p>The element whose text to return is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword.</p> <p>This keyword returns all the text of the specified element, including all the text its children and grandchildren contain. If the element has no text, an empty string is returned. The returned text is thus not always the same as the <code>text</code> attribute of the element.</p> <p>By default all whitespace, including newlines and indentation, inside the element is returned as-is. If <code>normalize_whitespace</code> is given a true value (see <code>Boolean arguments</code>), then leading and trailing whitespace is stripped, newlines and tabs converted to spaces, and multiple spaces collapsed into one. This is especially useful when dealing with HTML data.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | ${text} =       | Get Element Text | ${XML}       | first        | | Should Be Equal | ${text}          | text         |              | | ${text} =       | Get Element Text | ${XML}       | second/child | | Should Be Empty | ${text}          |              |              | | ${paragraph} =  | Get Element      | ${XML}       | html/p       | | ${text} =       | Get Element Text | ${paragraph} | normalize_whitespace=yes | | Should Be Equal | ${text}          | Text with bold and italics. |</p> <p>See also <code>Get Elements Texts</code>, <code>Element Text Should Be</code> and <code>Element Text Should Match</code>.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def get_element_text(self, source, xpath='.', normalize_whitespace=False):\n    \"\"\"Returns all text of the element, possibly whitespace normalized.\n\n    The element whose text to return is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword.\n\n    This keyword returns all the text of the specified element, including\n    all the text its children and grandchildren contain. If the element\n    has no text, an empty string is returned. The returned text is thus not\n    always the same as the `text` attribute of the element.\n\n    By default all whitespace, including newlines and indentation, inside\n    the element is returned as-is. If ``normalize_whitespace`` is given\n    a true value (see `Boolean arguments`), then leading and trailing\n    whitespace is stripped, newlines and tabs converted to spaces, and\n    multiple spaces collapsed into one. This is especially useful when\n    dealing with HTML data.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | ${text} =       | Get Element Text | ${XML}       | first        |\n    | Should Be Equal | ${text}          | text         |              |\n    | ${text} =       | Get Element Text | ${XML}       | second/child |\n    | Should Be Empty | ${text}          |              |              |\n    | ${paragraph} =  | Get Element      | ${XML}       | html/p       |\n    | ${text} =       | Get Element Text | ${paragraph} | normalize_whitespace=yes |\n    | Should Be Equal | ${text}          | Text with bold and italics. |\n\n    See also `Get Elements Texts`, `Element Text Should Be` and\n    `Element Text Should Match`.\n    \"\"\"\n    element = self.get_element(source, xpath)\n    text = ''.join(self._yield_texts(element))\n    if normalize_whitespace:\n        text = self._normalize_whitespace(text)\n    return text\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.get_elements_texts","title":"get_elements_texts","text":"<pre><code>get_elements_texts(\n    source, xpath, normalize_whitespace=False\n)\n</code></pre> <p>Returns text of all elements matching <code>xpath</code> as a list.</p> <p>The elements whose text to return is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Elements</code> keyword.</p> <p>The text of the matched elements is returned using the same logic as with <code>Get Element Text</code>. This includes optional whitespace normalization using the <code>normalize_whitespace</code> option.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | @{texts} =       | Get Elements Texts | ${XML}    | third/child | | Length Should Be | ${texts}           | 2         |             | | Should Be Equal  | @{texts}[0]        | more text |             | | Should Be Equal  | @{texts}[1]        | ${EMPTY}  |             |</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def get_elements_texts(self, source, xpath, normalize_whitespace=False):\n    \"\"\"Returns text of all elements matching ``xpath`` as a list.\n\n    The elements whose text to return is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Elements`\n    keyword.\n\n    The text of the matched elements is returned using the same logic\n    as with `Get Element Text`. This includes optional whitespace\n    normalization using the ``normalize_whitespace`` option.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | @{texts} =       | Get Elements Texts | ${XML}    | third/child |\n    | Length Should Be | ${texts}           | 2         |             |\n    | Should Be Equal  | @{texts}[0]        | more text |             |\n    | Should Be Equal  | @{texts}[1]        | ${EMPTY}  |             |\n    \"\"\"\n    return [self.get_element_text(elem, normalize_whitespace=normalize_whitespace)\n            for elem in self.get_elements(source, xpath)]\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.element_text_should_be","title":"element_text_should_be","text":"<pre><code>element_text_should_be(\n    source,\n    expected,\n    xpath=\".\",\n    normalize_whitespace=False,\n    message=None,\n)\n</code></pre> <p>Verifies that the text of the specified element is <code>expected</code>.</p> <p>The element whose text is verified is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword.</p> <p>The text to verify is got from the specified element using the same logic as with <code>Get Element Text</code>. This includes optional whitespace normalization using the <code>normalize_whitespace</code> option.</p> <p>The keyword passes if the text of the element is equal to the <code>expected</code> value, and otherwise it fails. The default error message can be overridden with the <code>message</code> argument.  Use <code>Element Text Should Match</code> to verify the text against a pattern instead of an exact value.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Element Text Should Be | ${XML}       | text     | xpath=first      | | Element Text Should Be | ${XML}       | ${EMPTY} | xpath=second/child | | ${paragraph} =         | Get Element  | ${XML}   | xpath=html/p     | | Element Text Should Be | ${paragraph} | Text with bold and italics. | normalize_whitespace=yes |</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def element_text_should_be(self, source, expected, xpath='.',\n                           normalize_whitespace=False, message=None):\n    \"\"\"Verifies that the text of the specified element is ``expected``.\n\n    The element whose text is verified is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword.\n\n    The text to verify is got from the specified element using the same\n    logic as with `Get Element Text`. This includes optional whitespace\n    normalization using the ``normalize_whitespace`` option.\n\n    The keyword passes if the text of the element is equal to the\n    ``expected`` value, and otherwise it fails. The default error message\n    can be overridden with the ``message`` argument.  Use `Element Text\n    Should Match` to verify the text against a pattern instead of an exact\n    value.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Element Text Should Be | ${XML}       | text     | xpath=first      |\n    | Element Text Should Be | ${XML}       | ${EMPTY} | xpath=second/child |\n    | ${paragraph} =         | Get Element  | ${XML}   | xpath=html/p     |\n    | Element Text Should Be | ${paragraph} | Text with bold and italics. | normalize_whitespace=yes |\n    \"\"\"\n    text = self.get_element_text(source, xpath, normalize_whitespace)\n    should_be_equal(text, expected, message, values=False)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.element_text_should_match","title":"element_text_should_match","text":"<pre><code>element_text_should_match(\n    source,\n    pattern,\n    xpath=\".\",\n    normalize_whitespace=False,\n    message=None,\n)\n</code></pre> <p>Verifies that the text of the specified element matches <code>expected</code>.</p> <p>This keyword works exactly like <code>Element Text Should Be</code> except that the expected value can be given as a pattern that the text of the element must match.</p> <p>Pattern matching is similar as matching files in a shell with <code>*</code>, <code>?</code> and <code>[chars]</code> acting as wildcards. See the <code>Pattern matching</code> section for more information.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Element Text Should Match | ${XML}       | t???   | xpath=first  | | ${paragraph} =            | Get Element  | ${XML} | xpath=html/p | | Element Text Should Match | ${paragraph} | Text with * and *. | normalize_whitespace=yes |</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def element_text_should_match(self, source, pattern, xpath='.',\n                              normalize_whitespace=False, message=None):\n    \"\"\"Verifies that the text of the specified element matches ``expected``.\n\n    This keyword works exactly like `Element Text Should Be` except that\n    the expected value can be given as a pattern that the text of the\n    element must match.\n\n    Pattern matching is similar as matching files in a shell with\n    ``*``, ``?`` and ``[chars]`` acting as wildcards. See the\n    `Pattern matching` section for more information.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Element Text Should Match | ${XML}       | t???   | xpath=first  |\n    | ${paragraph} =            | Get Element  | ${XML} | xpath=html/p |\n    | Element Text Should Match | ${paragraph} | Text with * and *. | normalize_whitespace=yes |\n    \"\"\"\n    text = self.get_element_text(source, xpath, normalize_whitespace)\n    should_match(text, pattern, message, values=False)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.get_element_attribute","title":"get_element_attribute","text":"<pre><code>get_element_attribute(\n    source, name, xpath=\".\", default=None\n)\n</code></pre> <p>Returns the named attribute of the specified element.</p> <p>The element whose attribute to return is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword.</p> <p>The value of the attribute <code>name</code> of the specified element is returned. If the element does not have such element, the <code>default</code> value is returned instead.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | ${attribute} =  | Get Element Attribute | ${XML} | id | xpath=first | | Should Be Equal | ${attribute}          | 1      |    |             | | ${attribute} =  | Get Element Attribute | ${XML} | xx | xpath=first | default=value | | Should Be Equal | ${attribute}          | value  |    |             |</p> <p>See also <code>Get Element Attributes</code>, <code>Element Attribute Should Be</code>, <code>Element Attribute Should Match</code> and <code>Element Should Not Have Attribute</code>.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>@keyword(types=None)\ndef get_element_attribute(self, source, name, xpath='.', default=None):\n    \"\"\"Returns the named attribute of the specified element.\n\n    The element whose attribute to return is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword.\n\n    The value of the attribute ``name`` of the specified element is returned.\n    If the element does not have such element, the ``default`` value is\n    returned instead.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | ${attribute} =  | Get Element Attribute | ${XML} | id | xpath=first |\n    | Should Be Equal | ${attribute}          | 1      |    |             |\n    | ${attribute} =  | Get Element Attribute | ${XML} | xx | xpath=first | default=value |\n    | Should Be Equal | ${attribute}          | value  |    |             |\n\n    See also `Get Element Attributes`, `Element Attribute Should Be`,\n    `Element Attribute Should Match` and `Element Should Not Have Attribute`.\n    \"\"\"\n    return self.get_element(source, xpath).get(name, default)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.get_element_attributes","title":"get_element_attributes","text":"<pre><code>get_element_attributes(source, xpath='.')\n</code></pre> <p>Returns all attributes of the specified element.</p> <p>The element whose attributes to return is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword.</p> <p>Attributes are returned as a Python dictionary. It is a copy of the original attributes so modifying it has no effect on the XML structure.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | ${attributes} = | Get Element Attributes      | ${XML} | first | | Dictionary Should Contain Key | ${attributes} | id     |       | | ${attributes} = | Get Element Attributes      | ${XML} | third | | Should Be Empty | ${attributes}               |        |       |</p> <p>Use <code>Get Element Attribute</code> to get the value of a single attribute.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def get_element_attributes(self, source, xpath='.'):\n    \"\"\"Returns all attributes of the specified element.\n\n    The element whose attributes to return is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword.\n\n    Attributes are returned as a Python dictionary. It is a copy of the\n    original attributes so modifying it has no effect on the XML structure.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | ${attributes} = | Get Element Attributes      | ${XML} | first |\n    | Dictionary Should Contain Key | ${attributes} | id     |       |\n    | ${attributes} = | Get Element Attributes      | ${XML} | third |\n    | Should Be Empty | ${attributes}               |        |       |\n\n    Use `Get Element Attribute` to get the value of a single attribute.\n    \"\"\"\n    return dict(self.get_element(source, xpath).attrib)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.element_attribute_should_be","title":"element_attribute_should_be","text":"<pre><code>element_attribute_should_be(\n    source, name, expected, xpath=\".\", message=None\n)\n</code></pre> <p>Verifies that the specified attribute is <code>expected</code>.</p> <p>The element whose attribute is verified is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword.</p> <p>The keyword passes if the attribute <code>name</code> of the element is equal to the <code>expected</code> value, and otherwise it fails. The default error message can be overridden with the <code>message</code> argument.</p> <p>To test that the element does not have a certain attribute, Python <code>None</code> (i.e. variable <code>${NONE}</code>) can be used as the expected value. A cleaner alternative is using <code>Element Should Not Have Attribute</code>.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Element Attribute Should Be | ${XML} | id | 1       | xpath=first | | Element Attribute Should Be | ${XML} | id | ${NONE} |             |</p> <p>See also <code>Element Attribute Should Match</code> and <code>Get Element Attribute</code>.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def element_attribute_should_be(self, source, name, expected, xpath='.',\n                                message=None):\n    \"\"\"Verifies that the specified attribute is ``expected``.\n\n    The element whose attribute is verified is specified using ``source``\n    and ``xpath``. They have exactly the same semantics as with\n    `Get Element` keyword.\n\n    The keyword passes if the attribute ``name`` of the element is equal to\n    the ``expected`` value, and otherwise it fails. The default error\n    message can be overridden with the ``message`` argument.\n\n    To test that the element does not have a certain attribute, Python\n    ``None`` (i.e. variable ``${NONE}``) can be used as the expected value.\n    A cleaner alternative is using `Element Should Not Have Attribute`.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Element Attribute Should Be | ${XML} | id | 1       | xpath=first |\n    | Element Attribute Should Be | ${XML} | id | ${NONE} |             |\n\n    See also `Element Attribute Should Match` and `Get Element Attribute`.\n    \"\"\"\n    attr = self.get_element_attribute(source, name, xpath)\n    should_be_equal(attr, expected, message, values=False)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.element_attribute_should_match","title":"element_attribute_should_match","text":"<pre><code>element_attribute_should_match(\n    source, name, pattern, xpath=\".\", message=None\n)\n</code></pre> <p>Verifies that the specified attribute matches <code>expected</code>.</p> <p>This keyword works exactly like <code>Element Attribute Should Be</code> except that the expected value can be given as a pattern that the attribute of the element must match.</p> <p>Pattern matching is similar as matching files in a shell with <code>*</code>, <code>?</code> and <code>[chars]</code> acting as wildcards. See the <code>Pattern matching</code> section for more information.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Element Attribute Should Match | ${XML} | id | ?   | xpath=first | | Element Attribute Should Match | ${XML} | id | c*d | xpath=third/second |</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def element_attribute_should_match(self, source, name, pattern, xpath='.',\n                                   message=None):\n    \"\"\"Verifies that the specified attribute matches ``expected``.\n\n    This keyword works exactly like `Element Attribute Should Be` except\n    that the expected value can be given as a pattern that the attribute of\n    the element must match.\n\n    Pattern matching is similar as matching files in a shell with\n    ``*``, ``?`` and ``[chars]`` acting as wildcards. See the\n    `Pattern matching` section for more information.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Element Attribute Should Match | ${XML} | id | ?   | xpath=first |\n    | Element Attribute Should Match | ${XML} | id | c*d | xpath=third/second |\n    \"\"\"\n    attr = self.get_element_attribute(source, name, xpath)\n    if attr is None:\n        raise AssertionError(f\"Attribute '{name}' does not exist.\")\n    should_match(attr, pattern, message, values=False)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.element_should_not_have_attribute","title":"element_should_not_have_attribute","text":"<pre><code>element_should_not_have_attribute(\n    source, name, xpath=\".\", message=None\n)\n</code></pre> <p>Verifies that the specified element does not have attribute <code>name</code>.</p> <p>The element whose attribute is verified is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword.</p> <p>The keyword fails if the specified element has attribute <code>name</code>. The default error message can be overridden with the <code>message</code> argument.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Element Should Not Have Attribute | ${XML} | id  | | Element Should Not Have Attribute | ${XML} | xxx | xpath=first |</p> <p>See also <code>Get Element Attribute</code>, <code>Get Element Attributes</code>, <code>Element Text Should Be</code> and <code>Element Text Should Match</code>.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def element_should_not_have_attribute(self, source, name, xpath='.', message=None):\n    \"\"\"Verifies that the specified element does not have attribute ``name``.\n\n    The element whose attribute is verified is specified using ``source``\n    and ``xpath``. They have exactly the same semantics as with\n    `Get Element` keyword.\n\n    The keyword fails if the specified element has attribute ``name``. The\n    default error message can be overridden with the ``message`` argument.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Element Should Not Have Attribute | ${XML} | id  |\n    | Element Should Not Have Attribute | ${XML} | xxx | xpath=first |\n\n    See also `Get Element Attribute`, `Get Element Attributes`,\n    `Element Text Should Be` and `Element Text Should Match`.\n    \"\"\"\n    attr = self.get_element_attribute(source, name, xpath)\n    if attr is not None:\n        raise AssertionError(message or\n                             f\"Attribute '{name}' exists and has value '{attr}'.\")\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.elements_should_be_equal","title":"elements_should_be_equal","text":"<pre><code>elements_should_be_equal(\n    source,\n    expected,\n    exclude_children=False,\n    normalize_whitespace=False,\n    sort_children=False,\n)\n</code></pre> <p>Verifies that the given <code>source</code> element is equal to <code>expected</code>.</p> <p>Both <code>source</code> and <code>expected</code> can be given as a path to an XML file, as a string containing XML, or as an already parsed XML element structure. See <code>introduction</code> for more information about parsing XML in general.</p> <p>The keyword passes if the <code>source</code> element and <code>expected</code> element are equal. This includes testing the tag names, texts, and attributes of the elements. By default, also child elements are verified the same way, but this can be disabled by setting <code>exclude_children</code> to a true value (see <code>Boolean arguments</code>). Child elements are expected to be in the same order, but that can be changed by giving <code>sort_children</code> a true value. Notice that elements are sorted solely based on tag names.</p> <p>All texts inside the given elements are verified, but possible text outside them is not. By default, texts must match exactly, but setting <code>normalize_whitespace</code> to a true value makes text verification independent on newlines, tabs, and the amount of spaces. For more details about handling text see <code>Get Element Text</code> keyword and discussion about elements' <code>text</code> and <code>tail</code> attributes in the <code>introduction</code>.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | ${first} =               | Get Element | ${XML} | first             | | Elements Should Be Equal | ${first}    | text | | ${p} =                   | Get Element | ${XML} | html/p            | | Elements Should Be Equal | ${p} | <p>Text with bold and italics.</p> | normalize_whitespace=yes | | Elements Should Be Equal | ${p} | <p>Text with</p> | exclude | normalize |</p> <p>The last example may look a bit strange because the <code>&lt;p&gt;</code> element only has text <code>Text with</code>. The reason is that rest of the text inside <code>&lt;p&gt;</code> actually belongs to the child elements. This includes the <code>.</code> at the end that is the <code>tail</code> text of the <code>&lt;i&gt;</code> element.</p> <p>See also <code>Elements Should Match</code>.</p> <p><code>sort_children</code> is new in Robot Framework 7.0.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def elements_should_be_equal(self, source, expected, exclude_children=False,\n                             normalize_whitespace=False, sort_children=False):\n    \"\"\"Verifies that the given ``source`` element is equal to ``expected``.\n\n    Both ``source`` and ``expected`` can be given as a path to an XML file,\n    as a string containing XML, or as an already parsed XML element\n    structure. See `introduction` for more information about parsing XML in\n    general.\n\n    The keyword passes if the ``source`` element and ``expected`` element\n    are equal. This includes testing the tag names, texts, and attributes\n    of the elements. By default, also child elements are verified the same\n    way, but this can be disabled by setting ``exclude_children`` to a\n    true value (see `Boolean arguments`). Child elements are expected to\n    be in the same order, but that can be changed by giving ``sort_children``\n    a true value. Notice that elements are sorted solely based on tag names.\n\n    All texts inside the given elements are verified, but possible text\n    outside them is not. By default, texts must match exactly, but setting\n    ``normalize_whitespace`` to a true value makes text verification\n    independent on newlines, tabs, and the amount of spaces. For more\n    details about handling text see `Get Element Text` keyword and\n    discussion about elements' `text` and `tail` attributes in the\n    `introduction`.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | ${first} =               | Get Element | ${XML} | first             |\n    | Elements Should Be Equal | ${first}    | &lt;first id=\"1\"&gt;text&lt;/first&gt; |\n    | ${p} =                   | Get Element | ${XML} | html/p            |\n    | Elements Should Be Equal | ${p} | &lt;p&gt;Text with &lt;b&gt;bold&lt;/b&gt; and &lt;i&gt;italics&lt;/i&gt;.&lt;/p&gt; | normalize_whitespace=yes |\n    | Elements Should Be Equal | ${p} | &lt;p&gt;Text with&lt;/p&gt; | exclude | normalize |\n\n    The last example may look a bit strange because the ``&lt;p&gt;`` element\n    only has text ``Text with``. The reason is that rest of the text\n    inside ``&lt;p&gt;`` actually belongs to the child elements. This includes\n    the ``.`` at the end that is the `tail` text of the ``&lt;i&gt;`` element.\n\n    See also `Elements Should Match`.\n\n    ``sort_children`` is new in Robot Framework 7.0.\n    \"\"\"\n    self._compare_elements(source, expected, should_be_equal, exclude_children,\n                           sort_children, normalize_whitespace)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.elements_should_match","title":"elements_should_match","text":"<pre><code>elements_should_match(\n    source,\n    expected,\n    exclude_children=False,\n    normalize_whitespace=False,\n    sort_children=False,\n)\n</code></pre> <p>Verifies that the given <code>source</code> element matches <code>expected</code>.</p> <p>This keyword works exactly like <code>Elements Should Be Equal</code> except that texts and attribute values in the expected value can be given as patterns.</p> <p>Pattern matching is similar as matching files in a shell with <code>*</code>, <code>?</code> and <code>[chars]</code> acting as wildcards. See the <code>Pattern matching</code> section for more information.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | ${first} =            | Get Element | ${XML} | first          | | Elements Should Match | ${first}    | * |</p> <p>See <code>Elements Should Be Equal</code> for more examples.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def elements_should_match(self, source, expected, exclude_children=False,\n                          normalize_whitespace=False, sort_children=False):\n    \"\"\"Verifies that the given ``source`` element matches ``expected``.\n\n    This keyword works exactly like `Elements Should Be Equal` except that\n    texts and attribute values in the expected value can be given as\n    patterns.\n\n    Pattern matching is similar as matching files in a shell with\n    ``*``, ``?`` and ``[chars]`` acting as wildcards. See the\n    `Pattern matching` section for more information.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | ${first} =            | Get Element | ${XML} | first          |\n    | Elements Should Match | ${first}    | &lt;first id=\"?\"&gt;*&lt;/first&gt; |\n\n    See `Elements Should Be Equal` for more examples.\n    \"\"\"\n    self._compare_elements(source, expected, should_match, exclude_children,\n                           sort_children, normalize_whitespace)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.set_element_tag","title":"set_element_tag","text":"<pre><code>set_element_tag(source, tag, xpath='.')\n</code></pre> <p>Sets the tag of the specified element.</p> <p>The element whose tag to set is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword. The resulting XML structure is returned, and if the <code>source</code> is an already parsed XML structure, it is also modified in place.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Set Element Tag      | ${XML}     | newTag     | | Should Be Equal      | ${XML.tag} | newTag     | | Set Element Tag      | ${XML}     | xxx        | xpath=second/child | | Element Should Exist | ${XML}     | second/xxx | | Element Should Not Exist | ${XML} | second/child |</p> <p>Can only set the tag of a single element. Use <code>Set Elements Tag</code> to set the tag of multiple elements in one call.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def set_element_tag(self, source, tag, xpath='.'):\n    \"\"\"Sets the tag of the specified element.\n\n    The element whose tag to set is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword. The resulting XML structure is returned, and if the ``source``\n    is an already parsed XML structure, it is also modified in place.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Set Element Tag      | ${XML}     | newTag     |\n    | Should Be Equal      | ${XML.tag} | newTag     |\n    | Set Element Tag      | ${XML}     | xxx        | xpath=second/child |\n    | Element Should Exist | ${XML}     | second/xxx |\n    | Element Should Not Exist | ${XML} | second/child |\n\n    Can only set the tag of a single element. Use `Set Elements Tag` to set\n    the tag of multiple elements in one call.\n    \"\"\"\n    source = self.get_element(source)\n    self.get_element(source, xpath).tag = tag\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.set_elements_tag","title":"set_elements_tag","text":"<pre><code>set_elements_tag(source, tag, xpath='.')\n</code></pre> <p>Sets the tag of the specified elements.</p> <p>Like <code>Set Element Tag</code> but sets the tag of all elements matching the given <code>xpath</code>.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def set_elements_tag(self, source, tag, xpath='.'):\n    \"\"\"Sets the tag of the specified elements.\n\n    Like `Set Element Tag` but sets the tag of all elements matching\n    the given ``xpath``.\n    \"\"\"\n    source = self.get_element(source)\n    for elem in self.get_elements(source, xpath):\n        self.set_element_tag(elem, tag)\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.set_element_text","title":"set_element_text","text":"<pre><code>set_element_text(source, text=None, tail=None, xpath='.')\n</code></pre> <p>Sets text and/or tail text of the specified element.</p> <p>The element whose text to set is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword. The resulting XML structure is returned, and if the <code>source</code> is an already parsed XML structure, it is also modified in place.</p> <p>Element's text and tail text are changed only if new <code>text</code> and/or <code>tail</code> values are given. See <code>Element attributes</code> section for more information about <code>text</code> and <code>tail</code> in general.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Set Element Text       | ${XML} | new text | xpath=first    | | Element Text Should Be | ${XML} | new text | xpath=first    | | Set Element Text       | ${XML} | tail=&amp;   | xpath=html/p/b | | Element Text Should Be | ${XML} | Text with bold&amp;italics. | xpath=html/p  | normalize_whitespace=yes | | Set Element Text       | ${XML} | slanted  | !! | xpath=html/p/i | | Element Text Should Be | ${XML} | Text with bold&amp;slanted!! | xpath=html/p  | normalize_whitespace=yes |</p> <p>Can only set the text/tail of a single element. Use <code>Set Elements Text</code> to set the text/tail of multiple elements in one call.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>@keyword(types=None)\ndef set_element_text(self, source, text=None, tail=None, xpath='.'):\n    \"\"\"Sets text and/or tail text of the specified element.\n\n    The element whose text to set is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword. The resulting XML structure is returned, and if the ``source``\n    is an already parsed XML structure, it is also modified in place.\n\n    Element's text and tail text are changed only if new ``text`` and/or\n    ``tail`` values are given. See `Element attributes` section for more\n    information about `text` and `tail` in general.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Set Element Text       | ${XML} | new text | xpath=first    |\n    | Element Text Should Be | ${XML} | new text | xpath=first    |\n    | Set Element Text       | ${XML} | tail=&amp;   | xpath=html/p/b |\n    | Element Text Should Be | ${XML} | Text with bold&amp;italics. | xpath=html/p  | normalize_whitespace=yes |\n    | Set Element Text       | ${XML} | slanted  | !! | xpath=html/p/i |\n    | Element Text Should Be | ${XML} | Text with bold&amp;slanted!! | xpath=html/p  | normalize_whitespace=yes |\n\n    Can only set the text/tail of a single element. Use `Set Elements Text`\n    to set the text/tail of multiple elements in one call.\n    \"\"\"\n    source = self.get_element(source)\n    element = self.get_element(source, xpath)\n    if text is not None:\n        element.text = text\n    if tail is not None:\n        element.tail = tail\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.set_elements_text","title":"set_elements_text","text":"<pre><code>set_elements_text(source, text=None, tail=None, xpath='.')\n</code></pre> <p>Sets text and/or tail text of the specified elements.</p> <p>Like <code>Set Element Text</code> but sets the text or tail of all elements matching the given <code>xpath</code>.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>@keyword(types=None)\ndef set_elements_text(self, source, text=None, tail=None, xpath='.'):\n    \"\"\"Sets text and/or tail text of the specified elements.\n\n    Like `Set Element Text` but sets the text or tail of all elements\n    matching the given ``xpath``.\n    \"\"\"\n    source = self.get_element(source)\n    for elem in self.get_elements(source, xpath):\n        self.set_element_text(elem, text, tail)\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.set_element_attribute","title":"set_element_attribute","text":"<pre><code>set_element_attribute(source, name, value, xpath='.')\n</code></pre> <p>Sets attribute <code>name</code> of the specified element to <code>value</code>.</p> <p>The element whose attribute to set is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword. The resulting XML structure is returned, and if the <code>source</code> is an already parsed XML structure, it is also modified in place.</p> <p>It is possible to both set new attributes and to overwrite existing. Use <code>Remove Element Attribute</code> or <code>Remove Element Attributes</code> for removing them.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Set Element Attribute       | ${XML} | attr | value | | Element Attribute Should Be | ${XML} | attr | value | | Set Element Attribute       | ${XML} | id   | new   | xpath=first | | Element Attribute Should Be | ${XML} | id   | new   | xpath=first |</p> <p>Can only set an attribute of a single element. Use <code>Set Elements Attribute</code> to set an attribute of multiple elements in one call.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def set_element_attribute(self, source, name, value, xpath='.'):\n    \"\"\"Sets attribute ``name`` of the specified element to ``value``.\n\n    The element whose attribute to set is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword. The resulting XML structure is returned, and if the ``source``\n    is an already parsed XML structure, it is also modified in place.\n\n    It is possible to both set new attributes and to overwrite existing.\n    Use `Remove Element Attribute` or `Remove Element Attributes` for\n    removing them.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Set Element Attribute       | ${XML} | attr | value |\n    | Element Attribute Should Be | ${XML} | attr | value |\n    | Set Element Attribute       | ${XML} | id   | new   | xpath=first |\n    | Element Attribute Should Be | ${XML} | id   | new   | xpath=first |\n\n    Can only set an attribute of a single element. Use `Set Elements\n    Attribute` to set an attribute of multiple elements in one call.\n    \"\"\"\n    if not name:\n        raise RuntimeError('Attribute name can not be empty.')\n    source = self.get_element(source)\n    self.get_element(source, xpath).attrib[name] = value\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.set_elements_attribute","title":"set_elements_attribute","text":"<pre><code>set_elements_attribute(source, name, value, xpath='.')\n</code></pre> <p>Sets attribute <code>name</code> of the specified elements to <code>value</code>.</p> <p>Like <code>Set Element Attribute</code> but sets the attribute of all elements matching the given <code>xpath</code>.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def set_elements_attribute(self, source, name, value, xpath='.'):\n    \"\"\"Sets attribute ``name`` of the specified elements to ``value``.\n\n    Like `Set Element Attribute` but sets the attribute of all elements\n    matching the given ``xpath``.\n    \"\"\"\n    source = self.get_element(source)\n    for elem in self.get_elements(source, xpath):\n        self.set_element_attribute(elem, name, value)\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.remove_element_attribute","title":"remove_element_attribute","text":"<pre><code>remove_element_attribute(source, name, xpath='.')\n</code></pre> <p>Removes attribute <code>name</code> from the specified element.</p> <p>The element whose attribute to remove is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword. The resulting XML structure is returned, and if the <code>source</code> is an already parsed XML structure, it is also modified in place.</p> <p>It is not a failure to remove a non-existing attribute. Use <code>Remove Element Attributes</code> to remove all attributes and <code>Set Element Attribute</code> to set them.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Remove Element Attribute          | ${XML} | id | xpath=first | | Element Should Not Have Attribute | ${XML} | id | xpath=first |</p> <p>Can only remove an attribute from a single element. Use <code>Remove Elements Attribute</code> to remove an attribute of multiple elements in one call.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def remove_element_attribute(self, source, name, xpath='.'):\n    \"\"\"Removes attribute ``name`` from the specified element.\n\n    The element whose attribute to remove is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword. The resulting XML structure is returned, and if the ``source``\n    is an already parsed XML structure, it is also modified in place.\n\n    It is not a failure to remove a non-existing attribute. Use `Remove\n    Element Attributes` to remove all attributes and `Set Element Attribute`\n    to set them.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Remove Element Attribute          | ${XML} | id | xpath=first |\n    | Element Should Not Have Attribute | ${XML} | id | xpath=first |\n\n    Can only remove an attribute from a single element. Use `Remove Elements\n    Attribute` to remove an attribute of multiple elements in one call.\n    \"\"\"\n    source = self.get_element(source)\n    attrib = self.get_element(source, xpath).attrib\n    if name in attrib:\n        attrib.pop(name)\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.remove_elements_attribute","title":"remove_elements_attribute","text":"<pre><code>remove_elements_attribute(source, name, xpath='.')\n</code></pre> <p>Removes attribute <code>name</code> from the specified elements.</p> <p>Like <code>Remove Element Attribute</code> but removes the attribute of all elements matching the given <code>xpath</code>.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def remove_elements_attribute(self, source, name, xpath='.'):\n    \"\"\"Removes attribute ``name`` from the specified elements.\n\n    Like `Remove Element Attribute` but removes the attribute of all\n    elements matching the given ``xpath``.\n    \"\"\"\n    source = self.get_element(source)\n    for elem in self.get_elements(source, xpath):\n        self.remove_element_attribute(elem, name)\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.remove_element_attributes","title":"remove_element_attributes","text":"<pre><code>remove_element_attributes(source, xpath='.')\n</code></pre> <p>Removes all attributes from the specified element.</p> <p>The element whose attributes to remove is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword. The resulting XML structure is returned, and if the <code>source</code> is an already parsed XML structure, it is also modified in place.</p> <p>Use <code>Remove Element Attribute</code> to remove a single attribute and <code>Set Element Attribute</code> to set them.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Remove Element Attributes         | ${XML} | xpath=first | | Element Should Not Have Attribute | ${XML} | id | xpath=first |</p> <p>Can only remove attributes from a single element. Use <code>Remove Elements Attributes</code> to remove all attributes of multiple elements in one call.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def remove_element_attributes(self, source, xpath='.'):\n    \"\"\"Removes all attributes from the specified element.\n\n    The element whose attributes to remove is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword. The resulting XML structure is returned, and if the ``source``\n    is an already parsed XML structure, it is also modified in place.\n\n    Use `Remove Element Attribute` to remove a single attribute and\n    `Set Element Attribute` to set them.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Remove Element Attributes         | ${XML} | xpath=first |\n    | Element Should Not Have Attribute | ${XML} | id | xpath=first |\n\n    Can only remove attributes from a single element. Use `Remove Elements\n    Attributes` to remove all attributes of multiple elements in one call.\n    \"\"\"\n    source = self.get_element(source)\n    self.get_element(source, xpath).attrib.clear()\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.remove_elements_attributes","title":"remove_elements_attributes","text":"<pre><code>remove_elements_attributes(source, xpath='.')\n</code></pre> <p>Removes all attributes from the specified elements.</p> <p>Like <code>Remove Element Attributes</code> but removes all attributes of all elements matching the given <code>xpath</code>.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def remove_elements_attributes(self, source, xpath='.'):\n    \"\"\"Removes all attributes from the specified elements.\n\n    Like `Remove Element Attributes` but removes all attributes of all\n    elements matching the given ``xpath``.\n    \"\"\"\n    source = self.get_element(source)\n    for elem in self.get_elements(source, xpath):\n        self.remove_element_attributes(elem)\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.add_element","title":"add_element","text":"<pre><code>add_element(source, element, index=None, xpath='.')\n</code></pre> <p>Adds a child element to the specified element.</p> <p>The element to whom to add the new element is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword. The resulting XML structure is returned, and if the <code>source</code> is an already parsed XML structure, it is also modified in place.</p> <p>The <code>element</code> to add can be specified as a path to an XML file or as a string containing XML, or it can be an already parsed XML element. The element is copied before adding so modifying either the original or the added element has no effect on the other . The element is added as the last child by default, but a custom index can be used to alter the position. Indices start from zero (0 = first position, 1 = second position, etc.), and negative numbers refer to positions at the end (-1 = second last position, -2 = third last, etc.).</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Add Element | ${XML} |  | | Add Element | ${XML} |  | xpath=new | | Add Element | ${XML} |  | index=1 | xpath=new | | ${new} = | Get Element | ${XML} | new | | Elements Should Be Equal | ${new} |  |</p> <p>Use <code>Remove Element</code> or <code>Remove Elements</code> to remove elements.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def add_element(self, source, element, index=None, xpath='.'):\n    \"\"\"Adds a child element to the specified element.\n\n    The element to whom to add the new element is specified using ``source``\n    and ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword. The resulting XML structure is returned, and if the ``source``\n    is an already parsed XML structure, it is also modified in place.\n\n    The ``element`` to add can be specified as a path to an XML file or\n    as a string containing XML, or it can be an already parsed XML element.\n    The element is copied before adding so modifying either the original\n    or the added element has no effect on the other\n    .\n    The element is added as the last child by default, but a custom index\n    can be used to alter the position. Indices start from zero (0 = first\n    position, 1 = second position, etc.), and negative numbers refer to\n    positions at the end (-1 = second last position, -2 = third last, etc.).\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Add Element | ${XML} | &lt;new id=\"x\"&gt;&lt;c1/&gt;&lt;/new&gt; |\n    | Add Element | ${XML} | &lt;c2/&gt; | xpath=new |\n    | Add Element | ${XML} | &lt;c3/&gt; | index=1 | xpath=new |\n    | ${new} = | Get Element | ${XML} | new |\n    | Elements Should Be Equal | ${new} | &lt;new id=\"x\"&gt;&lt;c1/&gt;&lt;c3/&gt;&lt;c2/&gt;&lt;/new&gt; |\n\n    Use `Remove Element` or `Remove Elements` to remove elements.\n    \"\"\"\n    source = self.get_element(source)\n    parent = self.get_element(source, xpath)\n    element = self.copy_element(element)\n    if index is None:\n        parent.append(element)\n    else:\n        parent.insert(int(index), element)\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.remove_element","title":"remove_element","text":"<pre><code>remove_element(source, xpath='', remove_tail=False)\n</code></pre> <p>Removes the element matching <code>xpath</code> from the <code>source</code> structure.</p> <p>The element to remove from the <code>source</code> is specified with <code>xpath</code> using the same semantics as with <code>Get Element</code> keyword. The resulting XML structure is returned, and if the <code>source</code> is an already parsed XML structure, it is also modified in place.</p> <p>The keyword fails if <code>xpath</code> does not match exactly one element. Use <code>Remove Elements</code> to remove all matched elements.</p> <p>Element's tail text is not removed by default, but that can be changed by giving <code>remove_tail</code> a true value (see <code>Boolean arguments</code>). See <code>Element attributes</code> section for more information about <code>tail</code> in general.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Remove Element           | ${XML} | xpath=second | | Element Should Not Exist | ${XML} | xpath=second | | Remove Element           | ${XML} | xpath=html/p/b | remove_tail=yes | | Element Text Should Be   | ${XML} | Text with italics. | xpath=html/p | normalize_whitespace=yes |</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def remove_element(self, source, xpath='', remove_tail=False):\n    \"\"\"Removes the element matching ``xpath`` from the ``source`` structure.\n\n    The element to remove from the ``source`` is specified with ``xpath``\n    using the same semantics as with `Get Element` keyword. The resulting\n    XML structure is returned, and if the ``source`` is an already parsed\n    XML structure, it is also modified in place.\n\n    The keyword fails if ``xpath`` does not match exactly one element.\n    Use `Remove Elements` to remove all matched elements.\n\n    Element's tail text is not removed by default, but that can be changed\n    by giving ``remove_tail`` a true value (see `Boolean arguments`). See\n    `Element attributes` section for more information about `tail` in\n    general.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Remove Element           | ${XML} | xpath=second |\n    | Element Should Not Exist | ${XML} | xpath=second |\n    | Remove Element           | ${XML} | xpath=html/p/b | remove_tail=yes |\n    | Element Text Should Be   | ${XML} | Text with italics. | xpath=html/p | normalize_whitespace=yes |\n    \"\"\"\n    source = self.get_element(source)\n    self._remove_element(source, self.get_element(source, xpath), remove_tail)\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.remove_elements","title":"remove_elements","text":"<pre><code>remove_elements(source, xpath='', remove_tail=False)\n</code></pre> <p>Removes all elements matching <code>xpath</code> from the <code>source</code> structure.</p> <p>The elements to remove from the <code>source</code> are specified with <code>xpath</code> using the same semantics as with <code>Get Elements</code> keyword. The resulting XML structure is returned, and if the <code>source</code> is an already parsed XML structure, it is also modified in place.</p> <p>It is not a failure if <code>xpath</code> matches no elements. Use <code>Remove Element</code> to remove exactly one element.</p> <p>Element's tail text is not removed by default, but that can be changed by using <code>remove_tail</code> argument similarly as with <code>Remove Element</code>.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Remove Elements          | ${XML} | xpath=*/child      | | Element Should Not Exist | ${XML} | xpath=second/child | | Element Should Not Exist | ${XML} | xpath=third/child  |</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def remove_elements(self, source, xpath='', remove_tail=False):\n    \"\"\"Removes all elements matching ``xpath`` from the ``source`` structure.\n\n    The elements to remove from the ``source`` are specified with ``xpath``\n    using the same semantics as with `Get Elements` keyword. The resulting\n    XML structure is returned, and if the ``source`` is an already parsed\n    XML structure, it is also modified in place.\n\n    It is not a failure if ``xpath`` matches no elements. Use `Remove\n    Element` to remove exactly one element.\n\n    Element's tail text is not removed by default, but that can be changed\n    by using ``remove_tail`` argument similarly as with `Remove Element`.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Remove Elements          | ${XML} | xpath=*/child      |\n    | Element Should Not Exist | ${XML} | xpath=second/child |\n    | Element Should Not Exist | ${XML} | xpath=third/child  |\n    \"\"\"\n    source = self.get_element(source)\n    for element in self.get_elements(source, xpath):\n        self._remove_element(source, element, remove_tail)\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.clear_element","title":"clear_element","text":"<pre><code>clear_element(source, xpath='.', clear_tail=False)\n</code></pre> <p>Clears the contents of the specified element.</p> <p>The element to clear is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword. The resulting XML structure is returned, and if the <code>source</code> is an already parsed XML structure, it is also modified in place.</p> <p>Clearing the element means removing its text, attributes, and children. Element's tail text is not removed by default, but that can be changed by giving <code>clear_tail</code> a true value (see <code>Boolean arguments</code>). See <code>Element attributes</code> section for more information about tail in general.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | Clear Element            | ${XML}   | xpath=first | | ${first} = | Get Element | ${XML}   | xpath=first | | Elements Should Be Equal | ${first} |     | | Clear Element            | ${XML}   | xpath=html/p/b | clear_tail=yes | | Element Text Should Be   | ${XML}   | Text with italics. | xpath=html/p | normalize_whitespace=yes | | Clear Element            | ${XML}   | | Elements Should Be Equal | ${XML}   |  |</p> <p>Use <code>Remove Element</code> to remove the whole element.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def clear_element(self, source, xpath='.', clear_tail=False):\n    \"\"\"Clears the contents of the specified element.\n\n    The element to clear is specified using ``source`` and ``xpath``. They\n    have exactly the same semantics as with `Get Element` keyword.\n    The resulting XML structure is returned, and if the ``source`` is\n    an already parsed XML structure, it is also modified in place.\n\n    Clearing the element means removing its text, attributes, and children.\n    Element's tail text is not removed by default, but that can be changed\n    by giving ``clear_tail`` a true value (see `Boolean arguments`). See\n    `Element attributes` section for more information about tail in\n    general.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | Clear Element            | ${XML}   | xpath=first |\n    | ${first} = | Get Element | ${XML}   | xpath=first |\n    | Elements Should Be Equal | ${first} | &lt;first/&gt;    |\n    | Clear Element            | ${XML}   | xpath=html/p/b | clear_tail=yes |\n    | Element Text Should Be   | ${XML}   | Text with italics. | xpath=html/p | normalize_whitespace=yes |\n    | Clear Element            | ${XML}   |\n    | Elements Should Be Equal | ${XML}   | &lt;example/&gt; |\n\n    Use `Remove Element` to remove the whole element.\n    \"\"\"\n    source = self.get_element(source)\n    element = self.get_element(source, xpath)\n    tail = element.tail\n    element.clear()\n    if not clear_tail:\n        element.tail = tail\n    return source\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.copy_element","title":"copy_element","text":"<pre><code>copy_element(source, xpath='.')\n</code></pre> <p>Returns a copy of the specified element.</p> <p>The element to copy is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword.</p> <p>If the copy or the original element is modified afterward, the changes have no effect on the other.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | ${elem} =  | Get Element  | ${XML}  | xpath=first | | ${copy1} = | Copy Element | ${elem} | | ${copy2} = | Copy Element | ${XML}  | xpath=first | | Set Element Text         | ${XML}   | new text    | xpath=first      | | Set Element Attribute    | ${copy1} | id          | new              | | Elements Should Be Equal | ${elem}  | new text | | Elements Should Be Equal | ${copy1} | text   | | Elements Should Be Equal | ${copy2} | text     |</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def copy_element(self, source, xpath='.'):\n    \"\"\"Returns a copy of the specified element.\n\n    The element to copy is specified using ``source`` and ``xpath``. They\n    have exactly the same semantics as with `Get Element` keyword.\n\n    If the copy or the original element is modified afterward, the changes\n    have no effect on the other.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | ${elem} =  | Get Element  | ${XML}  | xpath=first |\n    | ${copy1} = | Copy Element | ${elem} |\n    | ${copy2} = | Copy Element | ${XML}  | xpath=first |\n    | Set Element Text         | ${XML}   | new text    | xpath=first      |\n    | Set Element Attribute    | ${copy1} | id          | new              |\n    | Elements Should Be Equal | ${elem}  | &lt;first id=\"1\"&gt;new text&lt;/first&gt; |\n    | Elements Should Be Equal | ${copy1} | &lt;first id=\"new\"&gt;text&lt;/first&gt;   |\n    | Elements Should Be Equal | ${copy2} | &lt;first id=\"1\"&gt;text&lt;/first&gt;     |\n    \"\"\"\n    return copy.deepcopy(self.get_element(source, xpath))\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.element_to_string","title":"element_to_string","text":"<pre><code>element_to_string(source, xpath='.', encoding=None)\n</code></pre> <p>Returns the string representation of the specified element.</p> <p>The element to convert to a string is specified using <code>source</code> and <code>xpath</code>. They have exactly the same semantics as with <code>Get Element</code> keyword.</p> <p>The string is returned as Unicode by default. If <code>encoding</code> argument is given any value, the string is returned as bytes in the specified encoding. The resulting string never contains the XML declaration.</p> <p>See also <code>Log Element</code> and <code>Save XML</code>.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def element_to_string(self, source, xpath='.', encoding=None):\n    \"\"\"Returns the string representation of the specified element.\n\n    The element to convert to a string is specified using ``source`` and\n    ``xpath``. They have exactly the same semantics as with `Get Element`\n    keyword.\n\n    The string is returned as Unicode by default. If ``encoding`` argument\n    is given any value, the string is returned as bytes in the specified\n    encoding. The resulting string never contains the XML declaration.\n\n    See also `Log Element` and `Save XML`.\n    \"\"\"\n    source = self.get_element(source, xpath)\n    if self.lxml_etree:\n        source = self._ns_stripper.unstrip(source)\n    string = self.etree.tostring(source, encoding='UTF-8').decode('UTF-8')\n    string = re.sub(r'^&lt;\\?xml .*\\?&gt;', '', string).strip()\n    if encoding:\n        string = string.encode(encoding)\n    return string\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.log_element","title":"log_element","text":"<pre><code>log_element(source, level='INFO', xpath='.')\n</code></pre> <p>Logs the string representation of the specified element.</p> <p>The element specified with <code>source</code> and <code>xpath</code> is first converted into a string using <code>Element To String</code> keyword internally. The resulting string is then logged using the given <code>level</code>.</p> <p>The logged string is also returned.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def log_element(self, source, level='INFO', xpath='.'):\n    \"\"\"Logs the string representation of the specified element.\n\n    The element specified with ``source`` and ``xpath`` is first converted\n    into a string using `Element To String` keyword internally. The\n    resulting string is then logged using the given ``level``.\n\n    The logged string is also returned.\n    \"\"\"\n    string = self.element_to_string(source, xpath)\n    logger.write(string, level)\n    return string\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.save_xml","title":"save_xml","text":"<pre><code>save_xml(source, path, encoding='UTF-8')\n</code></pre> <p>Saves the given element to the specified file.</p> <p>The element to save is specified with <code>source</code> using the same semantics as with <code>Get Element</code> keyword.</p> <p>The file where the element is saved is denoted with <code>path</code> and the encoding to use with <code>encoding</code>. The resulting file always contains the XML declaration.</p> <p>The resulting XML file may not be exactly the same as the original: - Comments and processing instructions are always stripped. - Possible doctype and namespace prefixes are only preserved when   <code>using lxml</code>. - Other small differences are possible depending on the ElementTree   or lxml version.</p> <p>Use <code>Element To String</code> if you just need a string representation of the element.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def save_xml(self, source, path, encoding='UTF-8'):\n    \"\"\"Saves the given element to the specified file.\n\n    The element to save is specified with ``source`` using the same\n    semantics as with `Get Element` keyword.\n\n    The file where the element is saved is denoted with ``path`` and the\n    encoding to use with ``encoding``. The resulting file always contains\n    the XML declaration.\n\n    The resulting XML file may not be exactly the same as the original:\n    - Comments and processing instructions are always stripped.\n    - Possible doctype and namespace prefixes are only preserved when\n      `using lxml`.\n    - Other small differences are possible depending on the ElementTree\n      or lxml version.\n\n    Use `Element To String` if you just need a string representation of\n    the element.\n    \"\"\"\n    path = os.path.abspath(str(path) if isinstance(path, os.PathLike)\n                           else path.replace('/', os.sep))\n    elem = self.get_element(source)\n    tree = self.etree.ElementTree(elem)\n    config = {'encoding': encoding}\n    if self.modern_etree:\n        config['xml_declaration'] = True\n    if self.lxml_etree:\n        elem = self._ns_stripper.unstrip(elem)\n        # https://bugs.launchpad.net/lxml/+bug/1660433\n        if tree.docinfo.doctype:\n            config['doctype'] = tree.docinfo.doctype\n        tree = self.etree.ElementTree(elem)\n    with open(path, 'wb') as output:\n        if 'doctype' in config:\n            output.write(self.etree.tostring(tree, **config))\n        else:\n            tree.write(output, **config)\n    logger.info(f'XML saved to &lt;a href=\"file://{path}\"&gt;{path}&lt;/a&gt;.', html=True)\n</code></pre>"},{"location":"api/robot/libraries/XML/#robot.libraries.XML.XML.evaluate_xpath","title":"evaluate_xpath","text":"<pre><code>evaluate_xpath(source, expression, context='.')\n</code></pre> <p>Evaluates the given xpath expression and returns results.</p> <p>The element in which context the expression is executed is specified using <code>source</code> and <code>context</code> arguments. They have exactly the same semantics as <code>source</code> and <code>xpath</code> arguments have with <code>Get Element</code> keyword.</p> <p>The xpath expression to evaluate is given as <code>expression</code> argument. The result of the evaluation is returned as-is.</p> <p>Examples using <code>${XML}</code> structure from <code>Example</code>: | ${count} =      | Evaluate Xpath | ${XML}  | count(third/) | | Should Be Equal | ${count}       | ${3}    | | ${text} =       | Evaluate Xpath | ${XML}  | string(descendant::second[last()]/@id) | | Should Be Equal | ${text}        | child   | | ${bold} =       | Evaluate Xpath | ${XML}  | boolean(preceding-sibling::[1] = 'bold') | context=html/p/i | | Should Be Equal | ${bold}        | ${True} |</p> <p>This keyword works only if lxml mode is taken into use when <code>importing</code> the library.</p> Source code in <code>src/robot/libraries/XML.py</code> <pre><code>def evaluate_xpath(self, source, expression, context='.'):\n    \"\"\"Evaluates the given xpath expression and returns results.\n\n    The element in which context the expression is executed is specified\n    using ``source`` and ``context`` arguments. They have exactly the same\n    semantics as ``source`` and ``xpath`` arguments have with `Get Element`\n    keyword.\n\n    The xpath expression to evaluate is given as ``expression`` argument.\n    The result of the evaluation is returned as-is.\n\n    Examples using ``${XML}`` structure from `Example`:\n    | ${count} =      | Evaluate Xpath | ${XML}  | count(third/*) |\n    | Should Be Equal | ${count}       | ${3}    |\n    | ${text} =       | Evaluate Xpath | ${XML}  | string(descendant::second[last()]/@id) |\n    | Should Be Equal | ${text}        | child   |\n    | ${bold} =       | Evaluate Xpath | ${XML}  | boolean(preceding-sibling::*[1] = 'bold') | context=html/p/i |\n    | Should Be Equal | ${bold}        | ${True} |\n\n    This keyword works only if lxml mode is taken into use when `importing`\n    the library.\n    \"\"\"\n    if not self.lxml_etree:\n        raise RuntimeError(\"'Evaluate Xpath' keyword only works in lxml mode.\")\n    return self.get_element(source, context).xpath(expression)\n</code></pre>"},{"location":"api/robot/libraries/dialogs_py/","title":"robot.libraries.dialogs_py","text":""},{"location":"api/robot/libraries/dialogs_py/#robot.libraries.dialogs_py","title":"robot.libraries.dialogs_py","text":""},{"location":"api/robot/model/","title":"robot.model","text":""},{"location":"api/robot/model/#robot.model","title":"robot.model","text":"<p>Package with generic, reusable and extensible model classes.</p> <p>This package contains, for example, :class:<code>~robot.model.testsuite.TestSuite</code>, :class:<code>~robot.model.testcase.TestCase</code>, :class:<code>~robot.model.keyword.Keyword</code> and :class:<code>~robot.model.visitor.SuiteVisitor</code> base classes. These classes are extended both by :mod:<code>execution &lt;robot.running.model&gt;</code> and :mod:<code>result &lt;robot.result.model&gt;</code> related model objects and used also elsewhere.</p> <p>This package is considered stable.</p>"},{"location":"api/robot/model/body/","title":"robot.model.body","text":""},{"location":"api/robot/model/body/#robot.model.body","title":"robot.model.body","text":""},{"location":"api/robot/model/body/#robot.model.body.BodyItem","title":"BodyItem","text":"<p>               Bases: <code>ModelObject</code></p>"},{"location":"api/robot/model/body/#robot.model.body.BodyItem.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BodyItem.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BodyItem.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BodyItem.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BodyItem.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BodyItem.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BodyItem.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/model/body/#robot.model.body.BaseBody","title":"BaseBody","text":"<pre><code>BaseBody(\n    parent: BodyItemParent = None,\n    items: Iterable[BodyItem | DataDict] = (),\n)\n</code></pre> <p>               Bases: <code>ItemList[BodyItem]</code>, <code>Generic[KW, F, W, I, T, V, R, C, B, M, E]</code></p> <p>Base class for Body and Branches objects.</p> Source code in <code>src/robot/model/body.py</code> <pre><code>def __init__(self, parent: BodyItemParent = None,\n             items: 'Iterable[BodyItem|DataDict]' = ()):\n    super().__init__(BodyItem, {'parent': parent}, items)\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BaseBody.to_dicts","title":"to_dicts","text":"<pre><code>to_dicts() -&gt; list[DataDict]\n</code></pre> <p>Return list of items converted to dictionaries.</p> <p>Items are converted to dictionaries using the <code>to_dict</code> method, if they have it, or the built-in <code>vars()</code>.</p> <p>New in Robot Framework 6.1.</p> Source code in <code>src/robot/model/itemlist.py</code> <pre><code>def to_dicts(self) -&gt; 'list[DataDict]':\n    \"\"\"Return list of items converted to dictionaries.\n\n    Items are converted to dictionaries using the ``to_dict`` method, if\n    they have it, or the built-in ``vars()``.\n\n    New in Robot Framework 6.1.\n    \"\"\"\n    if not hasattr(self._item_class, 'to_dict'):\n        return [vars(item) for item in self]\n    return [item.to_dict() for item in self]    # type: ignore\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BaseBody.filter","title":"filter","text":"<pre><code>filter(\n    keywords: bool | None = None,\n    messages: bool | None = None,\n    predicate: Callable[[T], bool] | None = None,\n)\n</code></pre> <p>Filter body items based on type and/or custom predicate.</p> <p>To include or exclude items based on types, give matching arguments <code>True</code> or <code>False</code> values. For example, to include only keywords, use <code>body.filter(keywords=True)</code> and to exclude messages use <code>body.filter(messages=False)</code>. Including and excluding by types at the same time is not supported and filtering my <code>messages</code> is supported only if the <code>Body</code> object actually supports messages.</p> <p>Custom <code>predicate</code> is a callable getting each body item as an argument that must return <code>True/False</code> depending on should the item be included or not.</p> <p>Selected items are returned as a list and the original body is not modified.</p> <p>It was earlier possible to filter also based on FOR and IF types. That support was removed in RF 5.0 because it was not considered useful in general and because adding support for all new control structures would have required extra work. To exclude all control structures, use <code>body.filter(keywords=True, messages=True)</code> and to only include them use <code>body.filter(keywords=False</code>, messages=False)<code>. For more detailed filtering it is possible to use</code>predicate``.</p> Source code in <code>src/robot/model/body.py</code> <pre><code>def filter(self, keywords: 'bool|None' = None, messages: 'bool|None' = None,\n           predicate: 'Callable[[T], bool]|None' = None):\n    \"\"\"Filter body items based on type and/or custom predicate.\n\n    To include or exclude items based on types, give matching arguments\n    ``True`` or ``False`` values. For example, to include only keywords,\n    use ``body.filter(keywords=True)`` and to exclude messages use\n    ``body.filter(messages=False)``. Including and excluding by types\n    at the same time is not supported and filtering my ``messages``\n    is supported only if the ``Body`` object actually supports messages.\n\n    Custom ``predicate`` is a callable getting each body item as an argument\n    that must return ``True/False`` depending on should the item be included\n    or not.\n\n    Selected items are returned as a list and the original body is not modified.\n\n    It was earlier possible to filter also based on FOR and IF types.\n    That support was removed in RF 5.0 because it was not considered useful\n    in general and because adding support for all new control structures\n    would have required extra work. To exclude all control structures, use\n    ``body.filter(keywords=True, messages=True)`` and to only include them\n    use ``body.filter(keywords=False``, messages=False)``. For more detailed\n    filtering it is possible to use ``predicate``.\n    \"\"\"\n    if messages is not None and self.message_class is KnownAtRuntime:\n        raise TypeError(f\"'{full_name(self)}' object does not support \"\n                        f\"filtering by 'messages'.\")\n    return self._filter([(self.keyword_class, keywords),\n                         (self.message_class, messages)], predicate)\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BaseBody.flatten","title":"flatten","text":"<pre><code>flatten() -&gt; list[BodyItem]\n</code></pre> <p>Return steps so that IF and TRY structures are flattened.</p> <p>Basically the IF/ELSE and TRY/EXCEPT root elements are replaced with their branches. This is how they are shown in log files.</p> Source code in <code>src/robot/model/body.py</code> <pre><code>def flatten(self) -&gt; 'list[BodyItem]':\n    \"\"\"Return steps so that IF and TRY structures are flattened.\n\n    Basically the IF/ELSE and TRY/EXCEPT root elements are replaced\n    with their branches. This is how they are shown in log files.\n    \"\"\"\n    roots = BodyItem.IF_ELSE_ROOT, BodyItem.TRY_EXCEPT_ROOT\n    steps = []\n    for item in self:\n        if item.type in roots:\n            item = cast('Try|If', item)\n            steps.extend(item.body)\n        else:\n            steps.append(item)\n    return steps\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.Body","title":"Body","text":"<pre><code>Body(\n    parent: BodyItemParent = None,\n    items: Iterable[BodyItem | DataDict] = (),\n)\n</code></pre> <p>               Bases: <code>BaseBody['Keyword', 'For', 'While', 'If', 'Try', 'Var', 'Return', 'Continue', 'Break', 'Message', 'Error']</code></p> <p>A list-like object representing a body of a test, keyword, etc.</p> <p>Body contains the keywords and other structures such as FOR loops.</p> Source code in <code>src/robot/model/body.py</code> <pre><code>def __init__(self, parent: BodyItemParent = None,\n             items: 'Iterable[BodyItem|DataDict]' = ()):\n    super().__init__(BodyItem, {'parent': parent}, items)\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.Body.to_dicts","title":"to_dicts","text":"<pre><code>to_dicts() -&gt; list[DataDict]\n</code></pre> <p>Return list of items converted to dictionaries.</p> <p>Items are converted to dictionaries using the <code>to_dict</code> method, if they have it, or the built-in <code>vars()</code>.</p> <p>New in Robot Framework 6.1.</p> Source code in <code>src/robot/model/itemlist.py</code> <pre><code>def to_dicts(self) -&gt; 'list[DataDict]':\n    \"\"\"Return list of items converted to dictionaries.\n\n    Items are converted to dictionaries using the ``to_dict`` method, if\n    they have it, or the built-in ``vars()``.\n\n    New in Robot Framework 6.1.\n    \"\"\"\n    if not hasattr(self._item_class, 'to_dict'):\n        return [vars(item) for item in self]\n    return [item.to_dict() for item in self]    # type: ignore\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.Body.filter","title":"filter","text":"<pre><code>filter(\n    keywords: bool | None = None,\n    messages: bool | None = None,\n    predicate: Callable[[T], bool] | None = None,\n)\n</code></pre> <p>Filter body items based on type and/or custom predicate.</p> <p>To include or exclude items based on types, give matching arguments <code>True</code> or <code>False</code> values. For example, to include only keywords, use <code>body.filter(keywords=True)</code> and to exclude messages use <code>body.filter(messages=False)</code>. Including and excluding by types at the same time is not supported and filtering my <code>messages</code> is supported only if the <code>Body</code> object actually supports messages.</p> <p>Custom <code>predicate</code> is a callable getting each body item as an argument that must return <code>True/False</code> depending on should the item be included or not.</p> <p>Selected items are returned as a list and the original body is not modified.</p> <p>It was earlier possible to filter also based on FOR and IF types. That support was removed in RF 5.0 because it was not considered useful in general and because adding support for all new control structures would have required extra work. To exclude all control structures, use <code>body.filter(keywords=True, messages=True)</code> and to only include them use <code>body.filter(keywords=False</code>, messages=False)<code>. For more detailed filtering it is possible to use</code>predicate``.</p> Source code in <code>src/robot/model/body.py</code> <pre><code>def filter(self, keywords: 'bool|None' = None, messages: 'bool|None' = None,\n           predicate: 'Callable[[T], bool]|None' = None):\n    \"\"\"Filter body items based on type and/or custom predicate.\n\n    To include or exclude items based on types, give matching arguments\n    ``True`` or ``False`` values. For example, to include only keywords,\n    use ``body.filter(keywords=True)`` and to exclude messages use\n    ``body.filter(messages=False)``. Including and excluding by types\n    at the same time is not supported and filtering my ``messages``\n    is supported only if the ``Body`` object actually supports messages.\n\n    Custom ``predicate`` is a callable getting each body item as an argument\n    that must return ``True/False`` depending on should the item be included\n    or not.\n\n    Selected items are returned as a list and the original body is not modified.\n\n    It was earlier possible to filter also based on FOR and IF types.\n    That support was removed in RF 5.0 because it was not considered useful\n    in general and because adding support for all new control structures\n    would have required extra work. To exclude all control structures, use\n    ``body.filter(keywords=True, messages=True)`` and to only include them\n    use ``body.filter(keywords=False``, messages=False)``. For more detailed\n    filtering it is possible to use ``predicate``.\n    \"\"\"\n    if messages is not None and self.message_class is KnownAtRuntime:\n        raise TypeError(f\"'{full_name(self)}' object does not support \"\n                        f\"filtering by 'messages'.\")\n    return self._filter([(self.keyword_class, keywords),\n                         (self.message_class, messages)], predicate)\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.Body.flatten","title":"flatten","text":"<pre><code>flatten() -&gt; list[BodyItem]\n</code></pre> <p>Return steps so that IF and TRY structures are flattened.</p> <p>Basically the IF/ELSE and TRY/EXCEPT root elements are replaced with their branches. This is how they are shown in log files.</p> Source code in <code>src/robot/model/body.py</code> <pre><code>def flatten(self) -&gt; 'list[BodyItem]':\n    \"\"\"Return steps so that IF and TRY structures are flattened.\n\n    Basically the IF/ELSE and TRY/EXCEPT root elements are replaced\n    with their branches. This is how they are shown in log files.\n    \"\"\"\n    roots = BodyItem.IF_ELSE_ROOT, BodyItem.TRY_EXCEPT_ROOT\n    steps = []\n    for item in self:\n        if item.type in roots:\n            item = cast('Try|If', item)\n            steps.extend(item.body)\n        else:\n            steps.append(item)\n    return steps\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BaseBranches","title":"BaseBranches","text":"<pre><code>BaseBranches(\n    branch_class: Type[IT],\n    parent: BodyItemParent = None,\n    items: Iterable[IT | DataDict] = (),\n)\n</code></pre> <p>               Bases: <code>BaseBody[KW, F, W, I, T, V, R, C, B, M, E]</code>, <code>BranchType[IT]</code></p> <p>A list-like object representing IF and TRY branches.</p> Source code in <code>src/robot/model/body.py</code> <pre><code>def __init__(self, branch_class: Type[IT],\n             parent: BodyItemParent = None,\n             items: 'Iterable[IT|DataDict]' = ()):\n    self.branch_class = branch_class\n    super().__init__(parent, items)\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BaseBranches.to_dicts","title":"to_dicts","text":"<pre><code>to_dicts() -&gt; list[DataDict]\n</code></pre> <p>Return list of items converted to dictionaries.</p> <p>Items are converted to dictionaries using the <code>to_dict</code> method, if they have it, or the built-in <code>vars()</code>.</p> <p>New in Robot Framework 6.1.</p> Source code in <code>src/robot/model/itemlist.py</code> <pre><code>def to_dicts(self) -&gt; 'list[DataDict]':\n    \"\"\"Return list of items converted to dictionaries.\n\n    Items are converted to dictionaries using the ``to_dict`` method, if\n    they have it, or the built-in ``vars()``.\n\n    New in Robot Framework 6.1.\n    \"\"\"\n    if not hasattr(self._item_class, 'to_dict'):\n        return [vars(item) for item in self]\n    return [item.to_dict() for item in self]    # type: ignore\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BaseBranches.filter","title":"filter","text":"<pre><code>filter(\n    keywords: bool | None = None,\n    messages: bool | None = None,\n    predicate: Callable[[T], bool] | None = None,\n)\n</code></pre> <p>Filter body items based on type and/or custom predicate.</p> <p>To include or exclude items based on types, give matching arguments <code>True</code> or <code>False</code> values. For example, to include only keywords, use <code>body.filter(keywords=True)</code> and to exclude messages use <code>body.filter(messages=False)</code>. Including and excluding by types at the same time is not supported and filtering my <code>messages</code> is supported only if the <code>Body</code> object actually supports messages.</p> <p>Custom <code>predicate</code> is a callable getting each body item as an argument that must return <code>True/False</code> depending on should the item be included or not.</p> <p>Selected items are returned as a list and the original body is not modified.</p> <p>It was earlier possible to filter also based on FOR and IF types. That support was removed in RF 5.0 because it was not considered useful in general and because adding support for all new control structures would have required extra work. To exclude all control structures, use <code>body.filter(keywords=True, messages=True)</code> and to only include them use <code>body.filter(keywords=False</code>, messages=False)<code>. For more detailed filtering it is possible to use</code>predicate``.</p> Source code in <code>src/robot/model/body.py</code> <pre><code>def filter(self, keywords: 'bool|None' = None, messages: 'bool|None' = None,\n           predicate: 'Callable[[T], bool]|None' = None):\n    \"\"\"Filter body items based on type and/or custom predicate.\n\n    To include or exclude items based on types, give matching arguments\n    ``True`` or ``False`` values. For example, to include only keywords,\n    use ``body.filter(keywords=True)`` and to exclude messages use\n    ``body.filter(messages=False)``. Including and excluding by types\n    at the same time is not supported and filtering my ``messages``\n    is supported only if the ``Body`` object actually supports messages.\n\n    Custom ``predicate`` is a callable getting each body item as an argument\n    that must return ``True/False`` depending on should the item be included\n    or not.\n\n    Selected items are returned as a list and the original body is not modified.\n\n    It was earlier possible to filter also based on FOR and IF types.\n    That support was removed in RF 5.0 because it was not considered useful\n    in general and because adding support for all new control structures\n    would have required extra work. To exclude all control structures, use\n    ``body.filter(keywords=True, messages=True)`` and to only include them\n    use ``body.filter(keywords=False``, messages=False)``. For more detailed\n    filtering it is possible to use ``predicate``.\n    \"\"\"\n    if messages is not None and self.message_class is KnownAtRuntime:\n        raise TypeError(f\"'{full_name(self)}' object does not support \"\n                        f\"filtering by 'messages'.\")\n    return self._filter([(self.keyword_class, keywords),\n                         (self.message_class, messages)], predicate)\n</code></pre>"},{"location":"api/robot/model/body/#robot.model.body.BaseBranches.flatten","title":"flatten","text":"<pre><code>flatten() -&gt; list[BodyItem]\n</code></pre> <p>Return steps so that IF and TRY structures are flattened.</p> <p>Basically the IF/ELSE and TRY/EXCEPT root elements are replaced with their branches. This is how they are shown in log files.</p> Source code in <code>src/robot/model/body.py</code> <pre><code>def flatten(self) -&gt; 'list[BodyItem]':\n    \"\"\"Return steps so that IF and TRY structures are flattened.\n\n    Basically the IF/ELSE and TRY/EXCEPT root elements are replaced\n    with their branches. This is how they are shown in log files.\n    \"\"\"\n    roots = BodyItem.IF_ELSE_ROOT, BodyItem.TRY_EXCEPT_ROOT\n    steps = []\n    for item in self:\n        if item.type in roots:\n            item = cast('Try|If', item)\n            steps.extend(item.body)\n        else:\n            steps.append(item)\n    return steps\n</code></pre>"},{"location":"api/robot/model/configurer/","title":"robot.model.configurer","text":""},{"location":"api/robot/model/configurer/#robot.model.configurer","title":"robot.model.configurer","text":""},{"location":"api/robot/model/control/","title":"robot.model.control","text":""},{"location":"api/robot/model/control/#robot.model.control","title":"robot.model.control","text":""},{"location":"api/robot/model/control/#robot.model.control.ForIteration","title":"ForIteration","text":"<pre><code>ForIteration(\n    assign: Mapping[str, str] | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Represents one FOR loop iteration.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, assign: 'Mapping[str, str]|None' = None,\n             parent: BodyItemParent = None):\n    self.assign = OrderedDict(assign or ())\n    self.parent = parent\n    self.body = ()\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.ForIteration.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.ForIteration.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.ForIteration.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.ForIteration.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.ForIteration.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.ForIteration.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.ForIteration.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/model/control/#robot.model.control.ForIteration.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Mapping[str, str]\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>assign</code> instead.</p>"},{"location":"api/robot/model/control/#robot.model.control.For","title":"For","text":"<pre><code>For(\n    assign: Sequence[str] = (),\n    flavor: Literal[\n        \"IN\", \"IN RANGE\", \"IN ENUMERATE\", \"IN ZIP\"\n    ] = \"IN\",\n    values: Sequence[str] = (),\n    start: str | None = None,\n    mode: str | None = None,\n    fill: str | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Represents <code>FOR</code> loops.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, assign: Sequence[str] = (),\n             flavor: Literal['IN', 'IN RANGE', 'IN ENUMERATE', 'IN ZIP'] = 'IN',\n             values: Sequence[str] = (),\n             start: 'str|None' = None,\n             mode: 'str|None' = None,\n             fill: 'str|None' = None,\n             parent: BodyItemParent = None):\n    self.assign = tuple(assign)\n    self.flavor = flavor\n    self.values = tuple(values)\n    self.start = start\n    self.mode = mode\n    self.fill = fill\n    self.parent = parent\n    self.body = ()\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.For.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.For.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.For.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.For.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.For.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.For.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.For.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/model/control/#robot.model.control.For.variables","title":"variables  <code>property</code> <code>writable</code>","text":"<pre><code>variables: tuple[str, ...]\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>assign</code> instead.</p>"},{"location":"api/robot/model/control/#robot.model.control.WhileIteration","title":"WhileIteration","text":"<pre><code>WhileIteration(parent: BodyItemParent = None)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Represents one WHILE loop iteration.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, parent: BodyItemParent = None):\n    self.parent = parent\n    self.body = ()\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.WhileIteration.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.WhileIteration.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.WhileIteration.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.WhileIteration.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.WhileIteration.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.WhileIteration.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.WhileIteration.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/model/control/#robot.model.control.While","title":"While","text":"<pre><code>While(\n    condition: str | None = None,\n    limit: str | None = None,\n    on_limit: str | None = None,\n    on_limit_message: str | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Represents <code>WHILE</code> loops.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, condition: 'str|None' = None,\n             limit: 'str|None' = None,\n             on_limit: 'str|None' = None,\n             on_limit_message: 'str|None' = None,\n             parent: BodyItemParent = None):\n    self.condition = condition\n    self.on_limit = on_limit\n    self.limit = limit\n    self.on_limit_message = on_limit_message\n    self.parent = parent\n    self.body = ()\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.While.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.While.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.While.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.While.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.While.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.While.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.While.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/model/control/#robot.model.control.IfBranch","title":"IfBranch","text":"<pre><code>IfBranch(\n    type: str = IF,\n    condition: str | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Represents individual <code>IF</code>, <code>ELSE IF</code> or <code>ELSE</code> branch.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, type: str = BodyItem.IF,\n             condition: 'str|None' = None,\n             parent: BodyItemParent = None):\n    self.type = type\n    self.condition = condition\n    self.parent = parent\n    self.body = ()\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.IfBranch.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.IfBranch.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.IfBranch.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.IfBranch.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.IfBranch.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.IfBranch.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.IfBranch.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre> <p>Branch id omits IF/ELSE root from the parent id part.</p>"},{"location":"api/robot/model/control/#robot.model.control.If","title":"If","text":"<pre><code>If(parent: BodyItemParent = None)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>IF/ELSE structure root. Branches are stored in :attr:<code>body</code>.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, parent: BodyItemParent = None):\n    self.parent = parent\n    self.body = ()\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.If.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.If.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.If.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.If.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.If.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.If.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.If.id","title":"id  <code>property</code>","text":"<pre><code>id: None\n</code></pre> <p>Root IF/ELSE id is always <code>None</code>.</p>"},{"location":"api/robot/model/control/#robot.model.control.TryBranch","title":"TryBranch","text":"<pre><code>TryBranch(\n    type: str = TRY,\n    patterns: Sequence[str] = (),\n    pattern_type: str | None = None,\n    assign: str | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Represents individual <code>TRY</code>, <code>EXCEPT</code>, <code>ELSE</code> or <code>FINALLY</code> branch.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, type: str = BodyItem.TRY,\n             patterns: Sequence[str] = (),\n             pattern_type: 'str|None' = None,\n             assign: 'str|None' = None,\n             parent: BodyItemParent = None):\n    if (patterns or pattern_type or assign) and type != BodyItem.EXCEPT:\n        raise TypeError(f\"'{type}' branches do not accept patterns or assignment.\")\n    self.type = type\n    self.patterns = tuple(patterns)\n    self.pattern_type = pattern_type\n    self.assign = assign\n    self.parent = parent\n    self.body = ()\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.TryBranch.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.TryBranch.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.TryBranch.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.TryBranch.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.TryBranch.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.TryBranch.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.TryBranch.variable","title":"variable  <code>property</code> <code>writable</code>","text":"<pre><code>variable: str | None\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>assign</code> instead.</p>"},{"location":"api/robot/model/control/#robot.model.control.TryBranch.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre> <p>Branch id omits TRY/EXCEPT root from the parent id part.</p>"},{"location":"api/robot/model/control/#robot.model.control.Try","title":"Try","text":"<pre><code>Try(parent: BodyItemParent = None)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>TRY/EXCEPT structure root. Branches are stored in :attr:<code>body</code>.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, parent: BodyItemParent = None):\n    self.parent = parent\n    self.body = ()\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Try.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Try.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Try.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Try.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Try.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Try.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Try.id","title":"id  <code>property</code>","text":"<pre><code>id: None\n</code></pre> <p>Root TRY/EXCEPT id is always <code>None</code>.</p>"},{"location":"api/robot/model/control/#robot.model.control.Var","title":"Var","text":"<pre><code>Var(\n    name: str = \"\",\n    value: str | Sequence[str] = (),\n    scope: str | None = None,\n    separator: str | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Represents <code>VAR</code>.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, name: str = '',\n             value: 'str|Sequence[str]' = (),\n             scope: 'str|None' = None,\n             separator: 'str|None' = None,\n             parent: BodyItemParent = None):\n    self.name = name\n    self.value = (value,) if isinstance(value, str) else tuple(value)\n    self.scope = scope\n    self.separator = separator\n    self.parent = parent\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Var.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Var.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Var.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Var.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Var.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Var.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Var.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/model/control/#robot.model.control.Return","title":"Return","text":"<pre><code>Return(\n    values: Sequence[str] = (),\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Represents <code>RETURN</code>.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, values: Sequence[str] = (),\n             parent: BodyItemParent = None):\n    self.values = tuple(values)\n    self.parent = parent\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Return.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Return.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Return.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Return.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Return.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Return.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Return.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/model/control/#robot.model.control.Continue","title":"Continue","text":"<pre><code>Continue(parent: BodyItemParent = None)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Represents <code>CONTINUE</code>.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, parent: BodyItemParent = None):\n    self.parent = parent\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Continue.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Continue.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Continue.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Continue.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Continue.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Continue.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Continue.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/model/control/#robot.model.control.Break","title":"Break","text":"<pre><code>Break(parent: BodyItemParent = None)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Represents <code>BREAK</code>.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, parent: BodyItemParent = None):\n    self.parent = parent\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Break.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Break.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Break.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Break.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Break.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Break.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Break.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/model/control/#robot.model.control.Error","title":"Error","text":"<pre><code>Error(\n    values: Sequence[str] = (),\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Represents syntax error in data.</p> <p>For example, an invalid setting like <code>[Setpu]</code> or <code>END</code> in wrong place.</p> Source code in <code>src/robot/model/control.py</code> <pre><code>def __init__(self, values: Sequence[str] = (),\n             parent: BodyItemParent = None):\n    self.values = tuple(values)\n    self.parent = parent\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Error.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Error.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Error.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Error.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Error.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Error.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/control/#robot.model.control.Error.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/model/filter/","title":"robot.model.filter","text":""},{"location":"api/robot/model/filter/#robot.model.filter","title":"robot.model.filter","text":""},{"location":"api/robot/model/fixture/","title":"robot.model.fixture","text":""},{"location":"api/robot/model/fixture/#robot.model.fixture","title":"robot.model.fixture","text":""},{"location":"api/robot/model/fixture/#robot.model.fixture.create_fixture","title":"create_fixture","text":"<pre><code>create_fixture(\n    fixture_class: Type[T],\n    fixture: T | DataDict | None,\n    parent: TestCase | TestSuite | Keyword | UserKeyword,\n    fixture_type: str,\n) -&gt; T\n</code></pre> <p>Create or configure a <code>fixture_class</code> instance.</p> Source code in <code>src/robot/model/fixture.py</code> <pre><code>def create_fixture(fixture_class: Type[T],\n                   fixture: 'T|DataDict|None',\n                   parent: 'TestCase|TestSuite|Keyword|UserKeyword',\n                   fixture_type: str) -&gt; T:\n    \"\"\"Create or configure a `fixture_class` instance.\"\"\"\n    # If a fixture instance has been passed in update the config\n    if isinstance(fixture, fixture_class):\n        return fixture.config(parent=parent, type=fixture_type)\n    # If a Mapping has been passed in, create a fixture instance from it\n    if isinstance(fixture, Mapping):\n        return fixture_class.from_dict(fixture).config(parent=parent, type=fixture_type)\n    # If nothing has been passed in then return a new fixture instance from it\n    if fixture is None:\n        return fixture_class(None, parent=parent, type=fixture_type)\n    raise TypeError(f\"Invalid fixture type '{type(fixture).__name__}'.\")\n</code></pre>"},{"location":"api/robot/model/itemlist/","title":"robot.model.itemlist","text":""},{"location":"api/robot/model/itemlist/#robot.model.itemlist","title":"robot.model.itemlist","text":""},{"location":"api/robot/model/itemlist/#robot.model.itemlist.ItemList","title":"ItemList","text":"<pre><code>ItemList(\n    item_class: Type[T],\n    common_attrs: dict[str, Any] | None = None,\n    items: Iterable[T | DataDict] = (),\n)\n</code></pre> <p>               Bases: <code>MutableSequence[T]</code></p> <p>List of items of a certain enforced type.</p> <p>New items can be created using the :meth:<code>create</code> method and existing items added using the common list methods like :meth:<code>append</code> or :meth:<code>insert</code>. In addition to the common type, items can have certain common and automatically assigned attributes.</p> <p>Starting from Robot Framework 6.1, items can be added as dictionaries and actual items are generated based on them automatically. If the type has a <code>from_dict</code> class method, it is used, and otherwise dictionary data is passed to the type as keyword arguments.</p> Source code in <code>src/robot/model/itemlist.py</code> <pre><code>def __init__(self, item_class: Type[T],\n             common_attrs: 'dict[str, Any]|None' = None,\n             items: 'Iterable[T|DataDict]' = ()):\n    self._item_class = item_class\n    self._common_attrs = common_attrs\n    self._items: 'list[T]' = []\n    if items:\n        self.extend(items)\n</code></pre>"},{"location":"api/robot/model/itemlist/#robot.model.itemlist.ItemList.create","title":"create","text":"<pre><code>create(*args, **kwargs) -&gt; T\n</code></pre> <p>Create a new item using the provided arguments.</p> Source code in <code>src/robot/model/itemlist.py</code> <pre><code>@copy_signature(item_type)\ndef create(self, *args, **kwargs) -&gt; T:\n    \"\"\"Create a new item using the provided arguments.\"\"\"\n    return self.append(self._item_class(*args, **kwargs))\n</code></pre>"},{"location":"api/robot/model/itemlist/#robot.model.itemlist.ItemList.to_dicts","title":"to_dicts","text":"<pre><code>to_dicts() -&gt; list[DataDict]\n</code></pre> <p>Return list of items converted to dictionaries.</p> <p>Items are converted to dictionaries using the <code>to_dict</code> method, if they have it, or the built-in <code>vars()</code>.</p> <p>New in Robot Framework 6.1.</p> Source code in <code>src/robot/model/itemlist.py</code> <pre><code>def to_dicts(self) -&gt; 'list[DataDict]':\n    \"\"\"Return list of items converted to dictionaries.\n\n    Items are converted to dictionaries using the ``to_dict`` method, if\n    they have it, or the built-in ``vars()``.\n\n    New in Robot Framework 6.1.\n    \"\"\"\n    if not hasattr(self._item_class, 'to_dict'):\n        return [vars(item) for item in self]\n    return [item.to_dict() for item in self]    # type: ignore\n</code></pre>"},{"location":"api/robot/model/keyword/","title":"robot.model.keyword","text":""},{"location":"api/robot/model/keyword/#robot.model.keyword","title":"robot.model.keyword","text":""},{"location":"api/robot/model/keyword/#robot.model.keyword.Keyword","title":"Keyword","text":"<pre><code>Keyword(\n    name: str | None = \"\",\n    args: Sequence[str] = (),\n    assign: Sequence[str] = (),\n    type: str = KEYWORD,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>Base model for a single keyword.</p> <p>Extended by :class:<code>robot.running.model.Keyword</code> and :class:<code>robot.result.model.Keyword</code>.</p> Source code in <code>src/robot/model/keyword.py</code> <pre><code>def __init__(self, name: 'str|None' = '',\n             args: Sequence[str] = (),\n             assign: Sequence[str] = (),\n             type: str = BodyItem.KEYWORD,\n             parent: BodyItemParent = None):\n    self.name = name\n    self.args = tuple(args)\n    self.assign = tuple(assign)\n    self.type = type\n    self.parent = parent\n</code></pre>"},{"location":"api/robot/model/keyword/#robot.model.keyword.Keyword.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/keyword/#robot.model.keyword.Keyword.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/keyword/#robot.model.keyword.Keyword.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/keyword/#robot.model.keyword.Keyword.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/keyword/#robot.model.keyword.Keyword.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/keyword/#robot.model.keyword.Keyword.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/keyword/#robot.model.keyword.Keyword.visit","title":"visit","text":"<pre><code>visit(visitor: SuiteVisitor)\n</code></pre> <p>:mod:<code>Visitor interface &lt;robot.model.visitor&gt;</code> entry-point.</p> Source code in <code>src/robot/model/keyword.py</code> <pre><code>def visit(self, visitor: 'SuiteVisitor'):\n    \"\"\":mod:`Visitor interface &lt;robot.model.visitor&gt;` entry-point.\"\"\"\n    if self:\n        visitor.visit_keyword(self)\n</code></pre>"},{"location":"api/robot/model/message/","title":"robot.model.message","text":""},{"location":"api/robot/model/message/#robot.model.message","title":"robot.model.message","text":""},{"location":"api/robot/model/message/#robot.model.message.Message","title":"Message","text":"<pre><code>Message(\n    message: str = \"\",\n    level: MessageLevel = \"INFO\",\n    html: bool = False,\n    timestamp: datetime | str | None = None,\n    parent: BodyItem | None = None,\n)\n</code></pre> <p>               Bases: <code>BodyItem</code></p> <p>A message created during the test execution.</p> <p>Can be a log message triggered by a keyword, or a warning or an error that occurred during parsing or test execution.</p> Source code in <code>src/robot/model/message.py</code> <pre><code>def __init__(self, message: str = '',\n             level: MessageLevel = 'INFO',\n             html: bool = False,\n             timestamp: 'datetime|str|None' = None,\n             parent: 'BodyItem|None' = None):\n    self.message = message\n    self.level = level\n    self.html = html\n    self.timestamp = timestamp\n    self.parent = parent\n</code></pre>"},{"location":"api/robot/model/message/#robot.model.message.Message.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/message/#robot.model.message.Message.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/message/#robot.model.message.Message.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/message/#robot.model.message.Message.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/message/#robot.model.message.Message.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/message/#robot.model.message.Message.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/message/#robot.model.message.Message.html_message","title":"html_message  <code>property</code>","text":"<pre><code>html_message\n</code></pre> <p>Returns the message content as HTML.</p>"},{"location":"api/robot/model/message/#robot.model.message.Message.visit","title":"visit","text":"<pre><code>visit(visitor)\n</code></pre> <p>:mod:<code>Visitor interface &lt;robot.model.visitor&gt;</code> entry-point.</p> Source code in <code>src/robot/model/message.py</code> <pre><code>def visit(self, visitor):\n    \"\"\":mod:`Visitor interface &lt;robot.model.visitor&gt;` entry-point.\"\"\"\n    visitor.visit_message(self)\n</code></pre>"},{"location":"api/robot/model/metadata/","title":"robot.model.metadata","text":""},{"location":"api/robot/model/metadata/#robot.model.metadata","title":"robot.model.metadata","text":""},{"location":"api/robot/model/metadata/#robot.model.metadata.Metadata","title":"Metadata","text":"<pre><code>Metadata(\n    initial: (\n        Mapping[str, str] | Iterable[tuple[str, str]] | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>NormalizedDict[str]</code></p> <p>Free suite metadata as a mapping.</p> <p>Keys are case, space, and underscore insensitive.</p> Source code in <code>src/robot/model/metadata.py</code> <pre><code>def __init__(self, initial: 'Mapping[str, str]|Iterable[tuple[str, str]]|None' = None):\n    super().__init__(initial, ignore='_')\n</code></pre>"},{"location":"api/robot/model/modelobject/","title":"robot.model.modelobject","text":""},{"location":"api/robot/model/modelobject/#robot.model.modelobject","title":"robot.model.modelobject","text":""},{"location":"api/robot/model/modelobject/#robot.model.modelobject.ModelObject","title":"ModelObject","text":""},{"location":"api/robot/model/modelobject/#robot.model.modelobject.ModelObject.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/modelobject/#robot.model.modelobject.ModelObject.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/modelobject/#robot.model.modelobject.ModelObject.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; DataDict\n</code></pre> <p>Serialize this object into a dictionary.</p> <p>The object can be later restored by using the :meth:<code>from_dict</code> method.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_dict(self) -&gt; DataDict:\n    \"\"\"Serialize this object into a dictionary.\n\n    The object can be later restored by using the :meth:`from_dict` method.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/model/modelobject/#robot.model.modelobject.ModelObject.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/modelobject/#robot.model.modelobject.ModelObject.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/modelobject/#robot.model.modelobject.ModelObject.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/modelobject/#robot.model.modelobject.ModelObject.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/modifier/","title":"robot.model.modifier","text":""},{"location":"api/robot/model/modifier/#robot.model.modifier","title":"robot.model.modifier","text":""},{"location":"api/robot/model/namepatterns/","title":"robot.model.namepatterns","text":""},{"location":"api/robot/model/namepatterns/#robot.model.namepatterns","title":"robot.model.namepatterns","text":""},{"location":"api/robot/model/statistics/","title":"robot.model.statistics","text":""},{"location":"api/robot/model/statistics/#robot.model.statistics","title":"robot.model.statistics","text":""},{"location":"api/robot/model/statistics/#robot.model.statistics.Statistics","title":"Statistics","text":"<pre><code>Statistics(\n    suite,\n    suite_stat_level=-1,\n    tag_stat_include=None,\n    tag_stat_exclude=None,\n    tag_stat_combine=None,\n    tag_doc=None,\n    tag_stat_link=None,\n    rpa=False,\n)\n</code></pre> <p>Container for total, suite and tag statistics.</p> <p>Accepted parameters have the same semantics as the matching command line options.</p> Source code in <code>src/robot/model/statistics.py</code> <pre><code>def __init__(self, suite, suite_stat_level=-1, tag_stat_include=None,\n             tag_stat_exclude=None, tag_stat_combine=None, tag_doc=None,\n             tag_stat_link=None, rpa=False):\n    total_builder = TotalStatisticsBuilder(rpa=rpa)\n    suite_builder = SuiteStatisticsBuilder(suite_stat_level)\n    tag_builder = TagStatisticsBuilder(tag_stat_include,\n                                       tag_stat_exclude, tag_stat_combine,\n                                       tag_doc, tag_stat_link)\n    suite.visit(StatisticsBuilder(total_builder, suite_builder, tag_builder))\n    self.total: TotalStatistics = total_builder.stats\n    self.suite: SuiteStatistics = suite_builder.stats\n    self.tags: TagStatistics = tag_builder.stats\n</code></pre>"},{"location":"api/robot/model/stats/","title":"robot.model.stats","text":""},{"location":"api/robot/model/stats/#robot.model.stats","title":"robot.model.stats","text":""},{"location":"api/robot/model/stats/#robot.model.stats.Stat","title":"Stat","text":"<pre><code>Stat(name)\n</code></pre> <p>               Bases: <code>Sortable</code></p> <p>Generic statistic object used for storing all the statistic values.</p> Source code in <code>src/robot/model/stats.py</code> <pre><code>def __init__(self, name):\n    #: Human readable identifier of the object these statistics\n    #: belong to. `All Tests` for\n    #: :class:`~robot.model.totalstatistics.TotalStatistics`,\n    #: long name of the suite for\n    #: :class:`~robot.model.suitestatistics.SuiteStatistics`\n    #: or name of the tag for\n    #: :class:`~robot.model.tagstatistics.TagStatistics`\n    self.name = name\n    self.passed = 0\n    self.failed = 0\n    self.skipped = 0\n    self.elapsed = timedelta()\n    self._norm_name = normalize(name, ignore='_')\n</code></pre>"},{"location":"api/robot/model/stats/#robot.model.stats.TotalStat","title":"TotalStat","text":"<pre><code>TotalStat(name)\n</code></pre> <p>               Bases: <code>Stat</code></p> <p>Stores statistic values for a test run.</p> Source code in <code>src/robot/model/stats.py</code> <pre><code>def __init__(self, name):\n    #: Human readable identifier of the object these statistics\n    #: belong to. `All Tests` for\n    #: :class:`~robot.model.totalstatistics.TotalStatistics`,\n    #: long name of the suite for\n    #: :class:`~robot.model.suitestatistics.SuiteStatistics`\n    #: or name of the tag for\n    #: :class:`~robot.model.tagstatistics.TagStatistics`\n    self.name = name\n    self.passed = 0\n    self.failed = 0\n    self.skipped = 0\n    self.elapsed = timedelta()\n    self._norm_name = normalize(name, ignore='_')\n</code></pre>"},{"location":"api/robot/model/stats/#robot.model.stats.SuiteStat","title":"SuiteStat","text":"<pre><code>SuiteStat(suite)\n</code></pre> <p>               Bases: <code>Stat</code></p> <p>Stores statistics values for a single suite.</p> Source code in <code>src/robot/model/stats.py</code> <pre><code>def __init__(self, suite):\n    super().__init__(suite.full_name)\n    self.id = suite.id\n    self.elapsed = suite.elapsed_time\n    self._name = suite.name\n</code></pre>"},{"location":"api/robot/model/stats/#robot.model.stats.TagStat","title":"TagStat","text":"<pre><code>TagStat(name, doc='', links=None, combined=None)\n</code></pre> <p>               Bases: <code>Stat</code></p> <p>Stores statistic values for a single tag.</p> Source code in <code>src/robot/model/stats.py</code> <pre><code>def __init__(self, name, doc='', links=None, combined=None):\n    super().__init__(name)\n    #: Documentation of tag as a string.\n    self.doc = doc\n    #: List of tuples in which the first value is the link URL and\n    #: the second is the link title. An empty list by default.\n    self.links = links or []\n    #: Pattern as a string if the tag is combined, ``None`` otherwise.\n    self.combined = combined\n</code></pre>"},{"location":"api/robot/model/stats/#robot.model.stats.TagStat.info","title":"info  <code>property</code>","text":"<pre><code>info\n</code></pre> <p>Returns additional information of the tag statistics are about. Either <code>combined</code> or an empty string.</p>"},{"location":"api/robot/model/suitestatistics/","title":"robot.model.suitestatistics","text":""},{"location":"api/robot/model/suitestatistics/#robot.model.suitestatistics","title":"robot.model.suitestatistics","text":""},{"location":"api/robot/model/suitestatistics/#robot.model.suitestatistics.SuiteStatistics","title":"SuiteStatistics","text":"<pre><code>SuiteStatistics(suite)\n</code></pre> <p>Container for suite statistics.</p> Source code in <code>src/robot/model/suitestatistics.py</code> <pre><code>def __init__(self, suite):\n    self.stat = SuiteStat(suite)\n    self.suites: list[SuiteStatistics] = []\n</code></pre>"},{"location":"api/robot/model/tags/","title":"robot.model.tags","text":""},{"location":"api/robot/model/tags/#robot.model.tags","title":"robot.model.tags","text":""},{"location":"api/robot/model/tags/#robot.model.tags.Tags","title":"Tags","text":"<pre><code>Tags(tags: Iterable[str] = ())\n</code></pre> <p>               Bases: <code>Sequence[str]</code></p> Source code in <code>src/robot/model/tags.py</code> <pre><code>def __init__(self, tags: Iterable[str] = ()):\n    if isinstance(tags, Tags):\n        self._tags, self._reserved = tags._tags, tags._reserved\n    else:\n        self._tags, self._reserved = self._init_tags(tags)\n</code></pre>"},{"location":"api/robot/model/tags/#robot.model.tags.Tags.robot","title":"robot","text":"<pre><code>robot(name: str) -&gt; bool\n</code></pre> <p>Check do tags contain a reserved tag in format <code>robot:&lt;name&gt;</code>.</p> <p>This is same as <code>'robot:&lt;name&gt;' in tags</code> but considerably faster.</p> Source code in <code>src/robot/model/tags.py</code> <pre><code>def robot(self, name: str) -&gt; bool:\n    \"\"\"Check do tags contain a reserved tag in format `robot:&lt;name&gt;`.\n\n    This is same as `'robot:&lt;name&gt;' in tags` but considerably faster.\n    \"\"\"\n    return name in self._reserved\n</code></pre>"},{"location":"api/robot/model/tags/#robot.model.tags.normalize_tags","title":"normalize_tags","text":"<pre><code>normalize_tags(tags: Iterable[str]) -&gt; Iterable[str]\n</code></pre> <p>Performance optimization to normalize tags only once.</p> Source code in <code>src/robot/model/tags.py</code> <pre><code>def normalize_tags(tags: Iterable[str]) -&gt; Iterable[str]:\n    \"\"\"Performance optimization to normalize tags only once.\"\"\"\n    if isinstance(tags, NormalizedTags):\n        return tags\n    if isinstance(tags, str):\n        tags = [tags]\n    return NormalizedTags([normalize(t, ignore='_') for t in tags])\n</code></pre>"},{"location":"api/robot/model/tagsetter/","title":"robot.model.tagsetter","text":""},{"location":"api/robot/model/tagsetter/#robot.model.tagsetter","title":"robot.model.tagsetter","text":""},{"location":"api/robot/model/tagstatistics/","title":"robot.model.tagstatistics","text":""},{"location":"api/robot/model/tagstatistics/#robot.model.tagstatistics","title":"robot.model.tagstatistics","text":""},{"location":"api/robot/model/tagstatistics/#robot.model.tagstatistics.TagStatistics","title":"TagStatistics","text":"<pre><code>TagStatistics(combined_stats)\n</code></pre> <p>Container for tag statistics.</p> Source code in <code>src/robot/model/tagstatistics.py</code> <pre><code>def __init__(self, combined_stats):\n    #: Dictionary, where key is the name of the tag as a string and value\n    #: is an instance of :class:`~robot.model.stats.TagStat`.\n    self.tags = NormalizedDict(ignore='_')\n    #: List of :class:`~robot.model.stats.CombinedTagStat` objects.\n    self.combined = combined_stats\n</code></pre>"},{"location":"api/robot/model/testcase/","title":"robot.model.testcase","text":""},{"location":"api/robot/model/testcase/#robot.model.testcase","title":"robot.model.testcase","text":""},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase","title":"TestCase","text":"<pre><code>TestCase(\n    name: str = \"\",\n    doc: str = \"\",\n    tags: Tags | Sequence[str] = (),\n    timeout: str | None = None,\n    lineno: int | None = None,\n    parent: TestSuite[KW, TestCase[KW]] | None = None,\n)\n</code></pre> <p>               Bases: <code>ModelObject</code>, <code>Generic[KW]</code></p> <p>Base model for a single test case.</p> <p>Extended by :class:<code>robot.running.model.TestCase</code> and :class:<code>robot.result.model.TestCase</code>.</p> Source code in <code>src/robot/model/testcase.py</code> <pre><code>def __init__(self, name: str = '',\n             doc: str = '',\n             tags: 'Tags|Sequence[str]' = (),\n             timeout: 'str|None' = None,\n             lineno: 'int|None' = None,\n             parent: 'TestSuite[KW, TestCase[KW]]|None' = None):\n    self.name = name\n    self.doc = doc\n    self.tags = tags\n    self.timeout = timeout\n    self.lineno = lineno\n    self.parent = parent\n    self.body = []\n    self._setup: 'KW|None' = None\n    self._teardown: 'KW|None' = None\n</code></pre>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.body","title":"body","text":"<pre><code>body(body: Sequence[BodyItem | DataDict]) -&gt; Body\n</code></pre> <p>Test body as a :class:<code>~robot.model.body.Body</code> object.</p> Source code in <code>src/robot/model/testcase.py</code> <pre><code>@setter\ndef body(self, body: 'Sequence[BodyItem|DataDict]') -&gt; Body:\n    \"\"\"Test body as a :class:`~robot.model.body.Body` object.\"\"\"\n    return self.body_class(self, body)\n</code></pre>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.tags","title":"tags","text":"<pre><code>tags(tags: Tags | Sequence[str]) -&gt; Tags\n</code></pre> <p>Test tags as a :class:<code>~.model.tags.Tags</code> object.</p> Source code in <code>src/robot/model/testcase.py</code> <pre><code>@setter\ndef tags(self, tags: 'Tags|Sequence[str]') -&gt; Tags:\n    \"\"\"Test tags as a :class:`~.model.tags.Tags` object.\"\"\"\n    return Tags(tags)\n</code></pre>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.setup","title":"setup  <code>property</code> <code>writable</code>","text":"<pre><code>setup: KW\n</code></pre> <p>Test setup as a :class:<code>~.model.keyword.Keyword</code> object.</p> <p>This attribute is a <code>Keyword</code> object also when a test has no setup but in that case its truth value is <code>False</code>.</p> <p>Setup can be modified by setting attributes directly::</p> <pre><code>test.setup.name = 'Example'\ntest.setup.args = ('First', 'Second')\n</code></pre> <p>Alternatively the :meth:<code>config</code> method can be used to set multiple attributes in one call::</p> <pre><code>test.setup.config(name='Example', args=('First', 'Second'))\n</code></pre> <p>The easiest way to reset the whole setup is setting it to <code>None</code>. It will automatically recreate the underlying <code>Keyword</code> object::</p> <pre><code>test.setup = None\n</code></pre> <p>New in Robot Framework 4.0. Earlier setup was accessed like <code>test.keywords.setup</code>.</p>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.has_setup","title":"has_setup  <code>property</code>","text":"<pre><code>has_setup: bool\n</code></pre> <p>Check does a suite have a setup without creating a setup object.</p> <p>A difference between using <code>if test.has_setup:</code> and <code>if test.setup:</code> is that accessing the :attr:<code>setup</code> attribute creates a :class:<code>Keyword</code> object representing the setup even when the test actually does not have one. This typically does not matter, but with bigger suite structures containing a huge about of tests it can have an effect on memory usage.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.teardown","title":"teardown  <code>property</code> <code>writable</code>","text":"<pre><code>teardown: KW\n</code></pre> <p>Test teardown as a :class:<code>~.model.keyword.Keyword</code> object.</p> <p>See :attr:<code>setup</code> for more information.</p>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.has_teardown","title":"has_teardown  <code>property</code>","text":"<pre><code>has_teardown: bool\n</code></pre> <p>Check does a test have a teardown without creating a teardown object.</p> <p>See :attr:<code>has_setup</code> for more information.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre> <p>Test case id in format like <code>s1-t3</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Test name prefixed with the full name of the parent suite.</p>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.longname","title":"longname  <code>property</code>","text":"<pre><code>longname: str\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>full_name</code> instead.</p>"},{"location":"api/robot/model/testcase/#robot.model.testcase.TestCase.visit","title":"visit","text":"<pre><code>visit(visitor: SuiteVisitor)\n</code></pre> <p>:mod:<code>Visitor interface &lt;robot.model.visitor&gt;</code> entry-point.</p> Source code in <code>src/robot/model/testcase.py</code> <pre><code>def visit(self, visitor: 'SuiteVisitor'):\n    \"\"\":mod:`Visitor interface &lt;robot.model.visitor&gt;` entry-point.\"\"\"\n    visitor.visit_test(self)\n</code></pre>"},{"location":"api/robot/model/testsuite/","title":"robot.model.testsuite","text":""},{"location":"api/robot/model/testsuite/#robot.model.testsuite","title":"robot.model.testsuite","text":""},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite","title":"TestSuite","text":"<pre><code>TestSuite(\n    name: str = \"\",\n    doc: str = \"\",\n    metadata: Mapping[str, str] | None = None,\n    source: Path | str | None = None,\n    rpa: bool | None = False,\n    parent: TestSuite[KW, TC] | None = None,\n)\n</code></pre> <p>               Bases: <code>ModelObject</code>, <code>Generic[KW, TC]</code></p> <p>Base model for single suite.</p> <p>Extended by :class:<code>robot.running.model.TestSuite</code> and :class:<code>robot.result.model.TestSuite</code>.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def __init__(self, name: str = '',\n             doc: str = '',\n             metadata: 'Mapping[str, str]|None' = None,\n             source: 'Path|str|None' = None,\n             rpa: 'bool|None' = False,\n             parent: 'TestSuite[KW, TC]|None' = None):\n    self._name = name\n    self.doc = doc\n    self.metadata = metadata\n    self.source = source\n    self.parent = parent\n    self.rpa = rpa\n    self.suites = []\n    self.tests = []\n    self._setup: 'KW|None' = None\n    self._teardown: 'KW|None' = None\n    self._my_visitors: 'list[SuiteVisitor]' = []\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.name_from_source","title":"name_from_source  <code>staticmethod</code>","text":"<pre><code>name_from_source(\n    source: Path | str | None, extension: Sequence[str] = ()\n) -&gt; str\n</code></pre> <p>Create suite name based on the given <code>source</code>.</p> <p>This method is used by Robot Framework itself when it builds suites. External parsers and other tools that want to produce suites with names matching names created by Robot Framework can use this method as well. This method is also used if :attr:<code>name</code> is not set and someone accesses it.</p> <p>The algorithm is as follows:</p> <ul> <li>If the source is <code>None</code> or empty, return an empty string.</li> <li>Get the base name of the source. Read more below.</li> <li>Remove possible prefix separated with <code>__</code>.</li> <li>Convert underscores to spaces.</li> <li>If the name is all lower case, title case it.</li> </ul> <p>The base name of files is got by calling <code>Path.stem</code>__ that drops the file extension. It typically works fine, but gives wrong result if the extension has multiple parts like in <code>tests.robot.zip</code>. That problem can be avoided by giving valid file extension or extensions as the optional <code>extension</code> argument.</p> <p>Examples::</p> <pre><code>TestSuite.name_from_source(source)\nTestSuite.name_from_source(source, extension='.robot.zip')\nTestSuite.name_from_source(source, ('.robot', '.robot.zip'))\n</code></pre> <p>__ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.stem</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>@staticmethod\ndef name_from_source(source: 'Path|str|None', extension: Sequence[str] = ()) -&gt; str:\n    \"\"\"Create suite name based on the given ``source``.\n\n    This method is used by Robot Framework itself when it builds suites.\n    External parsers and other tools that want to produce suites with\n    names matching names created by Robot Framework can use this method as\n    well. This method is also used if :attr:`name` is not set and someone\n    accesses it.\n\n    The algorithm is as follows:\n\n    - If the source is ``None`` or empty, return an empty string.\n    - Get the base name of the source. Read more below.\n    - Remove possible prefix separated with ``__``.\n    - Convert underscores to spaces.\n    - If the name is all lower case, title case it.\n\n    The base name of files is got by calling `Path.stem`__ that drops\n    the file extension. It typically works fine, but gives wrong result\n    if the extension has multiple parts like in ``tests.robot.zip``.\n    That problem can be avoided by giving valid file extension or extensions\n    as the optional ``extension`` argument.\n\n    Examples::\n\n        TestSuite.name_from_source(source)\n        TestSuite.name_from_source(source, extension='.robot.zip')\n        TestSuite.name_from_source(source, ('.robot', '.robot.zip'))\n\n    __ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.stem\n    \"\"\"\n    if not source:\n        return ''\n    if not isinstance(source, Path):\n        source = Path(source)\n    name = TestSuite._get_base_name(source, extension)\n    if '__' in name:\n        name = name.split('__', 1)[1] or name\n    name = name.replace('_', ' ').strip()\n    return name.title() if name.islower() else name\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Suite name.</p> <p>If name is not set, it is constructed from source. If source is not set, name is constructed from child suite names by concatenating them with <code>&amp;</code>. If there are no child suites, name is an empty string.</p>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.adjust_source","title":"adjust_source","text":"<pre><code>adjust_source(\n    relative_to: Path | str | None = None,\n    root: Path | str | None = None,\n)\n</code></pre> <p>Adjust suite source and child suite sources, recursively.</p> <p>:param relative_to: Make suite source relative to the given path. Calls     <code>pathlib.Path.relative_to()</code>__ internally. Raises <code>ValueError</code>     if creating a relative path is not possible. :param root: Make given path a new root directory for the source. Raises     <code>ValueError</code> if suite source is absolute.</p> <p>Adjusting the source is especially useful when moving data around as JSON::</p> <pre><code>from robot.api import TestSuite\n\n# Create a suite, adjust source and convert to JSON.\nsuite = TestSuite.from_file_system('/path/to/data')\nsuite.adjust_source(relative_to='/path/to')\nsuite.to_json('data.rbt')\n\n# Recreate suite elsewhere and adjust source accordingly.\nsuite = TestSuite.from_json('data.rbt')\nsuite.adjust_source(root='/new/path/to')\n</code></pre> <p>New in Robot Framework 6.1.</p> <p>__ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.relative_to</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def adjust_source(self, relative_to: 'Path|str|None' = None,\n                  root: 'Path|str|None' = None):\n    \"\"\"Adjust suite source and child suite sources, recursively.\n\n    :param relative_to: Make suite source relative to the given path. Calls\n        `pathlib.Path.relative_to()`__ internally. Raises ``ValueError``\n        if creating a relative path is not possible.\n    :param root: Make given path a new root directory for the source. Raises\n        ``ValueError`` if suite source is absolute.\n\n    Adjusting the source is especially useful when moving data around as JSON::\n\n        from robot.api import TestSuite\n\n        # Create a suite, adjust source and convert to JSON.\n        suite = TestSuite.from_file_system('/path/to/data')\n        suite.adjust_source(relative_to='/path/to')\n        suite.to_json('data.rbt')\n\n        # Recreate suite elsewhere and adjust source accordingly.\n        suite = TestSuite.from_json('data.rbt')\n        suite.adjust_source(root='/new/path/to')\n\n    New in Robot Framework 6.1.\n\n    __ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.relative_to\n    \"\"\"\n    if not self.source:\n        raise ValueError('Suite has no source.')\n    if relative_to:\n        self.source = self.source.relative_to(relative_to)\n    if root:\n        if self.source.is_absolute():\n            raise ValueError(f\"Cannot set root for absolute source '{self.source}'.\")\n        self.source = root / self.source\n    for suite in self.suites:\n        suite.adjust_source(relative_to, root)\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Suite name prefixed with the full name of the possible parent suite.</p> <p>Just :attr:<code>name</code> of the suite if it has no :attr:<code>parent</code>.</p>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.longname","title":"longname  <code>property</code>","text":"<pre><code>longname: str\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>full_name</code> instead.</p>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.metadata","title":"metadata","text":"<pre><code>metadata(metadata: Mapping[str, str] | None) -&gt; Metadata\n</code></pre> <p>Free suite metadata as a :class:<code>~.metadata.Metadata</code> object.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>@setter\ndef metadata(self, metadata: 'Mapping[str, str]|None') -&gt; Metadata:\n    \"\"\"Free suite metadata as a :class:`~.metadata.Metadata` object.\"\"\"\n    return Metadata(metadata)\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.validate_execution_mode","title":"validate_execution_mode","text":"<pre><code>validate_execution_mode() -&gt; bool | None\n</code></pre> <p>Validate that suite execution mode is set consistently.</p> <p>Raise an exception if the execution mode is not set (i.e. the :attr:<code>rpa</code> attribute is <code>None</code>) and child suites have conflicting execution modes.</p> <p>The execution mode is returned. New in RF 6.1.1.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def validate_execution_mode(self) -&gt; 'bool|None':\n    \"\"\"Validate that suite execution mode is set consistently.\n\n    Raise an exception if the execution mode is not set (i.e. the :attr:`rpa`\n    attribute is ``None``) and child suites have conflicting execution modes.\n\n    The execution mode is returned. New in RF 6.1.1.\n    \"\"\"\n    if self.rpa is None:\n        rpa = name = None\n        for suite in self.suites:\n            suite.validate_execution_mode()\n            if rpa is None:\n                rpa = suite.rpa\n                name = suite.full_name\n            elif rpa is not suite.rpa:\n                mode1, mode2 = ('tasks', 'tests') if rpa else ('tests', 'tasks')\n                raise DataError(\n                    f\"Conflicting execution modes: Suite '{name}' has {mode1} but \"\n                    f\"suite '{suite.full_name}' has {mode2}. Resolve the conflict \"\n                    f\"or use '--rpa' or '--norpa' options to set the execution \"\n                    f\"mode explicitly.\"\n                )\n        self.rpa = rpa\n    return self.rpa\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.setup","title":"setup  <code>property</code> <code>writable</code>","text":"<pre><code>setup: KW\n</code></pre> <p>Suite setup.</p> <p>This attribute is a <code>Keyword</code> object also when a suite has no setup but in that case its truth value is <code>False</code>. The preferred way to check does a suite have a setup is using :attr:<code>has_setup</code>.</p> <p>Setup can be modified by setting attributes directly::</p> <pre><code>suite.setup.name = 'Example'\nsuite.setup.args = ('First', 'Second')\n</code></pre> <p>Alternatively the :meth:<code>config</code> method can be used to set multiple attributes in one call::</p> <pre><code>suite.setup.config(name='Example', args=('First', 'Second'))\n</code></pre> <p>The easiest way to reset the whole setup is setting it to <code>None</code>. It will automatically recreate the underlying <code>Keyword</code> object::</p> <pre><code>suite.setup = None\n</code></pre> <p>New in Robot Framework 4.0. Earlier setup was accessed like <code>suite.keywords.setup</code>.</p>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.has_setup","title":"has_setup  <code>property</code>","text":"<pre><code>has_setup: bool\n</code></pre> <p>Check does a suite have a setup without creating a setup object.</p> <p>A difference between using <code>if suite.has_setup:</code> and <code>if suite.setup:</code> is that accessing the :attr:<code>setup</code> attribute creates a :class:<code>Keyword</code> object representing the setup even when the suite actually does not have one. This typically does not matter, but with bigger suite structures it can have some effect on memory usage.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.teardown","title":"teardown  <code>property</code> <code>writable</code>","text":"<pre><code>teardown: KW\n</code></pre> <p>Suite teardown.</p> <p>See :attr:<code>setup</code> for more information.</p>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.has_teardown","title":"has_teardown  <code>property</code>","text":"<pre><code>has_teardown: bool\n</code></pre> <p>Check does a suite have a teardown without creating a teardown object.</p> <p>See :attr:<code>has_setup</code> for more information.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre> <p>An automatically generated unique id.</p> <p>The root suite has id <code>s1</code>, its child suites have ids <code>s1-s1</code>, <code>s1-s2</code>, ..., their child suites get ids <code>s1-s1-s1</code>, <code>s1-s1-s2</code>, ..., <code>s1-s2-s1</code>, ..., and so on.</p> <p>The first test in a suite has an id like <code>s1-t1</code>, the second has an id <code>s1-t2</code>, and so on. Similarly, keywords in suites (setup/teardown) and in tests get ids like <code>s1-k1</code>, <code>s1-t1-k1</code>, and <code>s1-s4-t2-k5</code>.</p>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.all_tests","title":"all_tests  <code>property</code>","text":"<pre><code>all_tests: Iterator[TestCase]\n</code></pre> <p>Yields all tests this suite and its child suites contain.</p> <p>New in Robot Framework 6.1.</p>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.test_count","title":"test_count  <code>property</code>","text":"<pre><code>test_count: int\n</code></pre> <p>Total number of the tests in this suite and in its child suites.</p>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.set_tags","title":"set_tags","text":"<pre><code>set_tags(\n    add: Sequence[str] = (),\n    remove: Sequence[str] = (),\n    persist: bool = False,\n)\n</code></pre> <p>Add and/or remove specified tags to the tests in this suite.</p> <p>:param add: Tags to add as a list or, if adding only one,     as a single string. :param remove: Tags to remove as a list or as a single string.     Can be given as patterns where <code>*</code> and <code>?</code> work as wildcards. :param persist: Add/remove specified tags also to new tests added     to this suite in the future.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def set_tags(self, add: Sequence[str] = (), remove: Sequence[str] = (),\n             persist: bool = False):\n    \"\"\"Add and/or remove specified tags to the tests in this suite.\n\n    :param add: Tags to add as a list or, if adding only one,\n        as a single string.\n    :param remove: Tags to remove as a list or as a single string.\n        Can be given as patterns where ``*`` and ``?`` work as wildcards.\n    :param persist: Add/remove specified tags also to new tests added\n        to this suite in the future.\n    \"\"\"\n    setter = TagSetter(add, remove)\n    self.visit(setter)\n    if persist:\n        self._my_visitors.append(setter)\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.filter","title":"filter","text":"<pre><code>filter(\n    included_suites: Sequence[str] | None = None,\n    included_tests: Sequence[str] | None = None,\n    included_tags: Sequence[str] | None = None,\n    excluded_tags: Sequence[str] | None = None,\n)\n</code></pre> <p>Select test cases and remove others from this suite.</p> <p>Parameters have the same semantics as <code>--suite</code>, <code>--test</code>, <code>--include</code>, and <code>--exclude</code> command line options. All of them can be given as a list of strings, or when selecting only one, as a single string.</p> <p>Child suites that contain no tests after filtering are automatically removed.</p> <p>Example::</p> <pre><code>suite.filter(included_tests=['Test 1', '* Example'],\n             included_tags='priority-1')\n</code></pre> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def filter(self, included_suites: 'Sequence[str]|None' = None,\n           included_tests: 'Sequence[str]|None' = None,\n           included_tags: 'Sequence[str]|None' = None,\n           excluded_tags: 'Sequence[str]|None' = None):\n    \"\"\"Select test cases and remove others from this suite.\n\n    Parameters have the same semantics as ``--suite``, ``--test``,\n    ``--include``, and ``--exclude`` command line options. All of them\n    can be given as a list of strings, or when selecting only one, as\n    a single string.\n\n    Child suites that contain no tests after filtering are automatically\n    removed.\n\n    Example::\n\n        suite.filter(included_tests=['Test 1', '* Example'],\n                     included_tags='priority-1')\n    \"\"\"\n    self.visit(Filter(included_suites, included_tests,\n                      included_tags, excluded_tags))\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.configure","title":"configure","text":"<pre><code>configure(**options)\n</code></pre> <p>A shortcut to configure a suite using one method call.</p> <p>Can only be used with the root test suite.</p> <p>:param options: Passed to     :class:<code>~robot.model.configurer.SuiteConfigurer</code> that will then     set suite attributes, call :meth:<code>filter</code>, etc. as needed.</p> <p>Not to be confused with :meth:<code>config</code> method that suites, tests, and keywords have to make it possible to set multiple attributes in one call.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def configure(self, **options):\n    \"\"\"A shortcut to configure a suite using one method call.\n\n    Can only be used with the root test suite.\n\n    :param options: Passed to\n        :class:`~robot.model.configurer.SuiteConfigurer` that will then\n        set suite attributes, call :meth:`filter`, etc. as needed.\n\n    Not to be confused with :meth:`config` method that suites, tests,\n    and keywords have to make it possible to set multiple attributes in\n    one call.\n    \"\"\"\n    if self.parent is not None:\n        raise ValueError(\"'TestSuite.configure()' can only be used with \"\n                         \"the root test suite.\")\n    if options:\n        self.visit(SuiteConfigurer(**options))\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.remove_empty_suites","title":"remove_empty_suites","text":"<pre><code>remove_empty_suites(preserve_direct_children: bool = False)\n</code></pre> <p>Removes all child suites not containing any tests, recursively.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def remove_empty_suites(self, preserve_direct_children: bool = False):\n    \"\"\"Removes all child suites not containing any tests, recursively.\"\"\"\n    self.visit(EmptySuiteRemover(preserve_direct_children))\n</code></pre>"},{"location":"api/robot/model/testsuite/#robot.model.testsuite.TestSuite.visit","title":"visit","text":"<pre><code>visit(visitor: SuiteVisitor)\n</code></pre> <p>:mod:<code>Visitor interface &lt;robot.model.visitor&gt;</code> entry-point.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def visit(self, visitor: SuiteVisitor):\n    \"\"\":mod:`Visitor interface &lt;robot.model.visitor&gt;` entry-point.\"\"\"\n    visitor.visit_suite(self)\n</code></pre>"},{"location":"api/robot/model/totalstatistics/","title":"robot.model.totalstatistics","text":""},{"location":"api/robot/model/totalstatistics/#robot.model.totalstatistics","title":"robot.model.totalstatistics","text":""},{"location":"api/robot/model/totalstatistics/#robot.model.totalstatistics.TotalStatistics","title":"TotalStatistics","text":"<pre><code>TotalStatistics(rpa: bool = False)\n</code></pre> <p>Container for total statistics.</p> Source code in <code>src/robot/model/totalstatistics.py</code> <pre><code>def __init__(self, rpa: bool = False):\n    #: Instance of :class:`~robot.model.stats.TotalStat` for all the tests.\n    self.stat = TotalStat(test_or_task('All {Test}s', rpa))\n    self._rpa = rpa\n</code></pre>"},{"location":"api/robot/model/totalstatistics/#robot.model.totalstatistics.TotalStatistics.message","title":"message  <code>property</code>","text":"<pre><code>message: str\n</code></pre> <p>String representation of the statistics.</p> <p>For example::     2 tests, 1 passed, 1 failed</p>"},{"location":"api/robot/model/visitor/","title":"robot.model.visitor","text":""},{"location":"api/robot/model/visitor/#robot.model.visitor","title":"robot.model.visitor","text":"<p>Interface to ease traversing through a test suite structure.</p> <p>Visitors make it easy to modify test suite structures or to collect information from them. They work both with the :mod:<code>executable model &lt;robot.running.model&gt;</code> and the :mod:<code>result model &lt;robot.result.model&gt;</code>, but the objects passed to the visitor methods are slightly different depending on the model they are used with. The main differences are that on the execution side keywords do not have child keywords nor messages, and that only the result objects have status related attributes like :attr:<code>status</code> and :attr:<code>start_time</code>.</p> <p>This module contains :class:<code>SuiteVisitor</code> that implements the core logic to visit a test suite structure, and the :mod:<code>~robot.result</code> package contains :class:<code>~robot.result.visitor.ResultVisitor</code> that supports visiting the whole test execution result structure. Both of these visitors should be imported via the :mod:<code>robot.api</code> package when used by external code.</p>"},{"location":"api/robot/model/visitor/#robot.model.visitor--visitor-algorithm","title":"Visitor algorithm","text":"<p>All suite, test, keyword and message objects have a :meth:<code>visit</code> method that accepts a visitor instance. These methods will then call the correct visitor method :meth:<code>~SuiteVisitor.visit_suite</code>, :meth:<code>~SuiteVisitor.visit_test</code>, :meth:<code>~SuiteVisitor.visit_keyword</code> or :meth:<code>~SuiteVisitor.visit_message</code>, depending on the instance where the :meth:<code>visit</code> method exists.</p> <p>The recommended and definitely the easiest way to implement a visitor is extending the :class:<code>SuiteVisitor</code> base class. The default implementation of its :meth:<code>visit_x</code> methods take care of traversing child elements of the object :obj:<code>x</code> recursively. A :meth:<code>visit_x</code> method first calls a corresponding :meth:<code>start_x</code> method (e.g. :meth:<code>visit_suite</code> calls :meth:<code>start_suite</code>), then calls :meth:<code>visit</code> for all child objects of the :obj:<code>x</code> object, and finally calls the corresponding :meth:<code>end_x</code> method. The default implementations of :meth:<code>start_x</code> and :meth:<code>end_x</code> do nothing.</p> <p>All items that can appear inside tests have their own visit methods. These include :meth:<code>visit_keyword</code>, :meth:<code>visit_message</code> (only applicable with results, not with executable data), :meth:<code>visit_for</code>, :meth:<code>visit_if</code>, and so on, as well as their appropriate <code>start/end</code> methods like :meth:<code>start_keyword</code> and :meth:<code>end_for</code>. If there is a need to visit all these items, it is possible to implement only :meth:<code>start_body_item</code> and :meth:<code>end_body_item</code> methods that are, by default, called by the appropriate <code>start/end</code> methods. These generic methods are new in Robot Framework 5.0.</p> <p>Visitors extending the :class:<code>SuiteVisitor</code> can stop visiting at a certain level either by overriding suitable :meth:<code>visit_x</code> method or by returning an explicit <code>False</code> from any :meth:<code>start_x</code> method.</p>"},{"location":"api/robot/model/visitor/#robot.model.visitor--examples","title":"Examples","text":"<p>The following example visitor modifies the test suite structure it visits. It could be used, for example, with Robot Framework's <code>--prerunmodifier</code> option to modify test data before execution.</p> <p>.. literalinclude:: ../../../doc/api/code_examples/SelectEveryXthTest.py    :language: python</p> <p>For more examples it is possible to look at the source code of visitors used internally by Robot Framework itself. Some good examples are :class:<code>~robot.model.tagsetter.TagSetter</code> and :mod:<code>keyword removers &lt;robot.result.keywordremover&gt;</code>.</p>"},{"location":"api/robot/model/visitor/#robot.model.visitor--type-hints","title":"Type hints","text":"<p>Visitor methods have type hints to give more information about the model objects they receive to editors. Because visitors can be used with both running and result models, the types that are used as type hints are base classes from the :mod:<code>robot.model</code> module. Actual visitor implementations can import appropriate types from the :mod:<code>robot.running</code> or the :mod:<code>robot.result</code> module instead. For example, this visitor uses the result side model objects::</p> <pre><code>from robot.api import SuiteVisitor\nfrom robot.result import TestCase, TestSuite\n\n\nclass FailurePrinter(SuiteVisitor):\n\n    def start_suite(self, suite: TestSuite):\n        print(f\"{suite.full_name}: {suite.statistics.failed} failed\")\n\n    def visit_test(self, test: TestCase):\n        if test.failed:\n            print(f'- {test.name}: {test.message}')\n</code></pre> <p>Type hints were added in Robot Framework 6.1. They are optional and can be removed altogether if they get in the way.</p>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor","title":"SuiteVisitor","text":"<p>Abstract class to ease traversing through the suite structure.</p> <p>See the :mod:<code>module level &lt;robot.model.visitor&gt;</code> documentation for more information and an example.</p>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_suite","title":"visit_suite","text":"<pre><code>visit_suite(suite: TestSuite)\n</code></pre> <p>Implements traversing through suites.</p> <p>Can be overridden to allow modifying the passed in <code>suite</code> without calling :meth:<code>start_suite</code> or :meth:<code>end_suite</code> nor visiting child suites, tests or setup and teardown at all.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_suite(self, suite: 'TestSuite'):\n    \"\"\"Implements traversing through suites.\n\n    Can be overridden to allow modifying the passed in ``suite`` without\n    calling :meth:`start_suite` or :meth:`end_suite` nor visiting child\n    suites, tests or setup and teardown at all.\n    \"\"\"\n    if self.start_suite(suite) is not False:\n        if suite.has_setup:\n            suite.setup.visit(self)\n        suite.suites.visit(self)\n        suite.tests.visit(self)\n        if suite.has_teardown:\n            suite.teardown.visit(self)\n        self.end_suite(suite)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_suite","title":"start_suite","text":"<pre><code>start_suite(suite: TestSuite) -&gt; bool | None\n</code></pre> <p>Called when a suite starts. Default implementation does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_suite(self, suite: 'TestSuite') -&gt; 'bool|None':\n    \"\"\"Called when a suite starts. Default implementation does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_suite","title":"end_suite","text":"<pre><code>end_suite(suite: TestSuite)\n</code></pre> <p>Called when a suite ends. Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_suite(self, suite: 'TestSuite'):\n    \"\"\"Called when a suite ends. Default implementation does nothing.\"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_test","title":"visit_test","text":"<pre><code>visit_test(test: TestCase)\n</code></pre> <p>Implements traversing through tests.</p> <p>Can be overridden to allow modifying the passed in <code>test</code> without calling :meth:<code>start_test</code> or :meth:<code>end_test</code> nor visiting the body of the test.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_test(self, test: 'TestCase'):\n    \"\"\"Implements traversing through tests.\n\n    Can be overridden to allow modifying the passed in ``test`` without calling\n    :meth:`start_test` or :meth:`end_test` nor visiting the body of the test.\n    \"\"\"\n    if self.start_test(test) is not False:\n        if test.has_setup:\n            test.setup.visit(self)\n        test.body.visit(self)\n        if test.has_teardown:\n            test.teardown.visit(self)\n        self.end_test(test)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_test","title":"start_test","text":"<pre><code>start_test(test: TestCase) -&gt; bool | None\n</code></pre> <p>Called when a test starts. Default implementation does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_test(self, test: 'TestCase') -&gt; 'bool|None':\n    \"\"\"Called when a test starts. Default implementation does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_test","title":"end_test","text":"<pre><code>end_test(test: TestCase)\n</code></pre> <p>Called when a test ends. Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_test(self, test: 'TestCase'):\n    \"\"\"Called when a test ends. Default implementation does nothing.\"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_keyword","title":"visit_keyword","text":"<pre><code>visit_keyword(keyword: Keyword)\n</code></pre> <p>Implements traversing through keywords.</p> <p>Can be overridden to allow modifying the passed in <code>kw</code> without calling :meth:<code>start_keyword</code> or :meth:<code>end_keyword</code> nor visiting the body of the keyword</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_keyword(self, keyword: 'Keyword'):\n    \"\"\"Implements traversing through keywords.\n\n    Can be overridden to allow modifying the passed in ``kw`` without\n    calling :meth:`start_keyword` or :meth:`end_keyword` nor visiting\n    the body of the keyword\n    \"\"\"\n    if self.start_keyword(keyword) is not False:\n        self._possible_setup(keyword)\n        self._possible_body(keyword)\n        self._possible_teardown(keyword)\n        self.end_keyword(keyword)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_keyword","title":"start_keyword","text":"<pre><code>start_keyword(keyword: Keyword) -&gt; bool | None\n</code></pre> <p>Called when a keyword starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_keyword(self, keyword: 'Keyword') -&gt; 'bool|None':\n    \"\"\"Called when a keyword starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(keyword)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_keyword","title":"end_keyword","text":"<pre><code>end_keyword(keyword: Keyword)\n</code></pre> <p>Called when a keyword ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_keyword(self, keyword: 'Keyword'):\n    \"\"\"Called when a keyword ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(keyword)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_for","title":"visit_for","text":"<pre><code>visit_for(for_: For)\n</code></pre> <p>Implements traversing through FOR loops.</p> <p>Can be overridden to allow modifying the passed in <code>for_</code> without calling :meth:<code>start_for</code> or :meth:<code>end_for</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_for(self, for_: 'For'):\n    \"\"\"Implements traversing through FOR loops.\n\n    Can be overridden to allow modifying the passed in ``for_`` without\n    calling :meth:`start_for` or :meth:`end_for` nor visiting body.\n    \"\"\"\n    if self.start_for(for_) is not False:\n        for_.body.visit(self)\n        self.end_for(for_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_for","title":"start_for","text":"<pre><code>start_for(for_: For) -&gt; bool | None\n</code></pre> <p>Called when a FOR loop starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_for(self, for_: 'For') -&gt; 'bool|None':\n    \"\"\"Called when a FOR loop starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(for_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_for","title":"end_for","text":"<pre><code>end_for(for_: For)\n</code></pre> <p>Called when a FOR loop ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_for(self, for_: 'For'):\n    \"\"\"Called when a FOR loop ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(for_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_for_iteration","title":"visit_for_iteration","text":"<pre><code>visit_for_iteration(iteration: ForIteration)\n</code></pre> <p>Implements traversing through single FOR loop iteration.</p> <p>This is only used with the result side model because on the running side there are no iterations.</p> <p>Can be overridden to allow modifying the passed in <code>iteration</code> without calling :meth:<code>start_for_iteration</code> or :meth:<code>end_for_iteration</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_for_iteration(self, iteration: 'ForIteration'):\n    \"\"\"Implements traversing through single FOR loop iteration.\n\n    This is only used with the result side model because on the running side\n    there are no iterations.\n\n    Can be overridden to allow modifying the passed in ``iteration`` without\n    calling :meth:`start_for_iteration` or :meth:`end_for_iteration` nor visiting\n    body.\n    \"\"\"\n    if self.start_for_iteration(iteration) is not False:\n        iteration.body.visit(self)\n        self.end_for_iteration(iteration)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_for_iteration","title":"start_for_iteration","text":"<pre><code>start_for_iteration(iteration: ForIteration) -&gt; bool | None\n</code></pre> <p>Called when a FOR loop iteration starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_for_iteration(self, iteration: 'ForIteration') -&gt; 'bool|None':\n    \"\"\"Called when a FOR loop iteration starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(iteration)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_for_iteration","title":"end_for_iteration","text":"<pre><code>end_for_iteration(iteration: ForIteration)\n</code></pre> <p>Called when a FOR loop iteration ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_for_iteration(self, iteration: 'ForIteration'):\n    \"\"\"Called when a FOR loop iteration ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(iteration)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_if","title":"visit_if","text":"<pre><code>visit_if(if_: If)\n</code></pre> <p>Implements traversing through IF/ELSE structures.</p> <p>Notice that <code>if_</code> does not have any data directly. Actual IF/ELSE branches are in its <code>body</code> and they are visited separately using :meth:<code>visit_if_branch</code>.</p> <p>Can be overridden to allow modifying the passed in <code>if_</code> without calling :meth:<code>start_if</code> or :meth:<code>end_if</code> nor visiting branches.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_if(self, if_: 'If'):\n    \"\"\"Implements traversing through IF/ELSE structures.\n\n    Notice that ``if_`` does not have any data directly. Actual IF/ELSE\n    branches are in its ``body`` and they are visited separately using\n    :meth:`visit_if_branch`.\n\n    Can be overridden to allow modifying the passed in ``if_`` without\n    calling :meth:`start_if` or :meth:`end_if` nor visiting branches.\n    \"\"\"\n    if self.start_if(if_) is not False:\n        if_.body.visit(self)\n        self.end_if(if_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_if","title":"start_if","text":"<pre><code>start_if(if_: If) -&gt; bool | None\n</code></pre> <p>Called when an IF/ELSE structure starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_if(self, if_: 'If') -&gt; 'bool|None':\n    \"\"\"Called when an IF/ELSE structure starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(if_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_if","title":"end_if","text":"<pre><code>end_if(if_: If)\n</code></pre> <p>Called when an IF/ELSE structure ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_if(self, if_: 'If'):\n    \"\"\"Called when an IF/ELSE structure ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(if_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_if_branch","title":"visit_if_branch","text":"<pre><code>visit_if_branch(branch: IfBranch)\n</code></pre> <p>Implements traversing through single IF/ELSE branch.</p> <p>Can be overridden to allow modifying the passed in <code>branch</code> without calling :meth:<code>start_if_branch</code> or :meth:<code>end_if_branch</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_if_branch(self, branch: 'IfBranch'):\n    \"\"\"Implements traversing through single IF/ELSE branch.\n\n    Can be overridden to allow modifying the passed in ``branch`` without\n    calling :meth:`start_if_branch` or :meth:`end_if_branch` nor visiting body.\n    \"\"\"\n    if self.start_if_branch(branch) is not False:\n        branch.body.visit(self)\n        self.end_if_branch(branch)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_if_branch","title":"start_if_branch","text":"<pre><code>start_if_branch(branch: IfBranch) -&gt; bool | None\n</code></pre> <p>Called when an IF/ELSE branch starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_if_branch(self, branch: 'IfBranch') -&gt; 'bool|None':\n    \"\"\"Called when an IF/ELSE branch starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(branch)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_if_branch","title":"end_if_branch","text":"<pre><code>end_if_branch(branch: IfBranch)\n</code></pre> <p>Called when an IF/ELSE branch ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_if_branch(self, branch: 'IfBranch'):\n    \"\"\"Called when an IF/ELSE branch ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(branch)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_try","title":"visit_try","text":"<pre><code>visit_try(try_: Try)\n</code></pre> <p>Implements traversing through TRY/EXCEPT structures.</p> <p>This method is used with the TRY/EXCEPT root element. Actual TRY, EXCEPT, ELSE and FINALLY branches are visited separately using :meth:<code>visit_try_branch</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_try(self, try_: 'Try'):\n    \"\"\"Implements traversing through TRY/EXCEPT structures.\n\n    This method is used with the TRY/EXCEPT root element. Actual TRY, EXCEPT, ELSE\n    and FINALLY branches are visited separately using :meth:`visit_try_branch`.\n    \"\"\"\n    if self.start_try(try_) is not False:\n        try_.body.visit(self)\n        self.end_try(try_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_try","title":"start_try","text":"<pre><code>start_try(try_: Try) -&gt; bool | None\n</code></pre> <p>Called when a TRY/EXCEPT structure starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_try(self, try_: 'Try') -&gt; 'bool|None':\n    \"\"\"Called when a TRY/EXCEPT structure starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(try_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_try","title":"end_try","text":"<pre><code>end_try(try_: Try)\n</code></pre> <p>Called when a TRY/EXCEPT structure ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_try(self, try_: 'Try'):\n    \"\"\"Called when a TRY/EXCEPT structure ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(try_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_try_branch","title":"visit_try_branch","text":"<pre><code>visit_try_branch(branch: TryBranch)\n</code></pre> <p>Visits individual TRY, EXCEPT, ELSE and FINALLY branches.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_try_branch(self, branch: 'TryBranch'):\n    \"\"\"Visits individual TRY, EXCEPT, ELSE and FINALLY branches.\"\"\"\n    if self.start_try_branch(branch) is not False:\n        branch.body.visit(self)\n        self.end_try_branch(branch)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_try_branch","title":"start_try_branch","text":"<pre><code>start_try_branch(branch: TryBranch) -&gt; bool | None\n</code></pre> <p>Called when TRY, EXCEPT, ELSE or FINALLY branches start.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_try_branch(self, branch: 'TryBranch') -&gt; 'bool|None':\n    \"\"\"Called when TRY, EXCEPT, ELSE or FINALLY branches start.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(branch)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_try_branch","title":"end_try_branch","text":"<pre><code>end_try_branch(branch: TryBranch)\n</code></pre> <p>Called when TRY, EXCEPT, ELSE and FINALLY branches end.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_try_branch(self, branch: 'TryBranch'):\n    \"\"\"Called when TRY, EXCEPT, ELSE and FINALLY branches end.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(branch)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_while","title":"visit_while","text":"<pre><code>visit_while(while_: While)\n</code></pre> <p>Implements traversing through WHILE loops.</p> <p>Can be overridden to allow modifying the passed in <code>while_</code> without calling :meth:<code>start_while</code> or :meth:<code>end_while</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_while(self, while_: 'While'):\n    \"\"\"Implements traversing through WHILE loops.\n\n    Can be overridden to allow modifying the passed in ``while_`` without\n    calling :meth:`start_while` or :meth:`end_while` nor visiting body.\n    \"\"\"\n    if self.start_while(while_) is not False:\n        while_.body.visit(self)\n        self.end_while(while_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_while","title":"start_while","text":"<pre><code>start_while(while_: While) -&gt; bool | None\n</code></pre> <p>Called when a WHILE loop starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_while(self, while_: 'While') -&gt; 'bool|None':\n    \"\"\"Called when a WHILE loop starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(while_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_while","title":"end_while","text":"<pre><code>end_while(while_: While)\n</code></pre> <p>Called when a WHILE loop ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_while(self, while_: 'While'):\n    \"\"\"Called when a WHILE loop ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(while_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_while_iteration","title":"visit_while_iteration","text":"<pre><code>visit_while_iteration(iteration: WhileIteration)\n</code></pre> <p>Implements traversing through single WHILE loop iteration.</p> <p>This is only used with the result side model because on the running side there are no iterations.</p> <p>Can be overridden to allow modifying the passed in <code>iteration</code> without calling :meth:<code>start_while_iteration</code> or :meth:<code>end_while_iteration</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_while_iteration(self, iteration: 'WhileIteration'):\n    \"\"\"Implements traversing through single WHILE loop iteration.\n\n    This is only used with the result side model because on the running side\n    there are no iterations.\n\n    Can be overridden to allow modifying the passed in ``iteration`` without\n    calling :meth:`start_while_iteration` or :meth:`end_while_iteration` nor visiting\n    body.\n    \"\"\"\n    if self.start_while_iteration(iteration) is not False:\n        iteration.body.visit(self)\n        self.end_while_iteration(iteration)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_while_iteration","title":"start_while_iteration","text":"<pre><code>start_while_iteration(\n    iteration: WhileIteration,\n) -&gt; bool | None\n</code></pre> <p>Called when a WHILE loop iteration starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_while_iteration(self, iteration: 'WhileIteration') -&gt; 'bool|None':\n    \"\"\"Called when a WHILE loop iteration starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(iteration)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_while_iteration","title":"end_while_iteration","text":"<pre><code>end_while_iteration(iteration: WhileIteration)\n</code></pre> <p>Called when a WHILE loop iteration ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_while_iteration(self, iteration: 'WhileIteration'):\n    \"\"\"Called when a WHILE loop iteration ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(iteration)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_var","title":"visit_var","text":"<pre><code>visit_var(var: Var)\n</code></pre> <p>Visits a VAR elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_var(self, var: 'Var'):\n    \"\"\"Visits a VAR elements.\"\"\"\n    if self.start_var(var) is not False:\n        self._possible_body(var)\n        self.end_var(var)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_var","title":"start_var","text":"<pre><code>start_var(var: Var) -&gt; bool | None\n</code></pre> <p>Called when a VAR element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_var(self, var: 'Var') -&gt; 'bool|None':\n    \"\"\"Called when a VAR element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(var)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_var","title":"end_var","text":"<pre><code>end_var(var: Var)\n</code></pre> <p>Called when a VAR element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_var(self, var: 'Var'):\n    \"\"\"Called when a VAR element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(var)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_return","title":"visit_return","text":"<pre><code>visit_return(return_: Return)\n</code></pre> <p>Visits a RETURN elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_return(self, return_: 'Return'):\n    \"\"\"Visits a RETURN elements.\"\"\"\n    if self.start_return(return_) is not False:\n        self._possible_body(return_)\n        self.end_return(return_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_return","title":"start_return","text":"<pre><code>start_return(return_: Return) -&gt; bool | None\n</code></pre> <p>Called when a RETURN element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_return(self, return_: 'Return') -&gt; 'bool|None':\n    \"\"\"Called when a RETURN element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(return_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_return","title":"end_return","text":"<pre><code>end_return(return_: Return)\n</code></pre> <p>Called when a RETURN element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_return(self, return_: 'Return'):\n    \"\"\"Called when a RETURN element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(return_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_continue","title":"visit_continue","text":"<pre><code>visit_continue(continue_: Continue)\n</code></pre> <p>Visits CONTINUE elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_continue(self, continue_: 'Continue'):\n    \"\"\"Visits CONTINUE elements.\"\"\"\n    if self.start_continue(continue_) is not False:\n        self._possible_body(continue_)\n        self.end_continue(continue_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_continue","title":"start_continue","text":"<pre><code>start_continue(continue_: Continue) -&gt; bool | None\n</code></pre> <p>Called when a CONTINUE element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_continue(self, continue_: 'Continue') -&gt; 'bool|None':\n    \"\"\"Called when a CONTINUE element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(continue_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_continue","title":"end_continue","text":"<pre><code>end_continue(continue_: Continue)\n</code></pre> <p>Called when a CONTINUE element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_continue(self, continue_: 'Continue'):\n    \"\"\"Called when a CONTINUE element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(continue_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_break","title":"visit_break","text":"<pre><code>visit_break(break_: Break)\n</code></pre> <p>Visits BREAK elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_break(self, break_: 'Break'):\n    \"\"\"Visits BREAK elements.\"\"\"\n    if self.start_break(break_) is not False:\n        self._possible_body(break_)\n        self.end_break(break_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_break","title":"start_break","text":"<pre><code>start_break(break_: Break) -&gt; bool | None\n</code></pre> <p>Called when a BREAK element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_break(self, break_: 'Break') -&gt; 'bool|None':\n    \"\"\"Called when a BREAK element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(break_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_break","title":"end_break","text":"<pre><code>end_break(break_: Break)\n</code></pre> <p>Called when a BREAK element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_break(self, break_: 'Break'):\n    \"\"\"Called when a BREAK element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(break_)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_error","title":"visit_error","text":"<pre><code>visit_error(error: Error)\n</code></pre> <p>Visits body items resulting from invalid syntax.</p> <p>Examples include syntax like <code>END</code> or <code>ELSE</code> in wrong place and invalid setting like <code>[Invalid]</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_error(self, error: 'Error'):\n    \"\"\"Visits body items resulting from invalid syntax.\n\n    Examples include syntax like ``END`` or ``ELSE`` in wrong place and\n    invalid setting like ``[Invalid]``.\n    \"\"\"\n    if self.start_error(error) is not False:\n        self._possible_body(error)\n        self.end_error(error)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_error","title":"start_error","text":"<pre><code>start_error(error: Error) -&gt; bool | None\n</code></pre> <p>Called when a ERROR element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_error(self, error: 'Error') -&gt; 'bool|None':\n    \"\"\"Called when a ERROR element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(error)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_error","title":"end_error","text":"<pre><code>end_error(error: Error)\n</code></pre> <p>Called when a ERROR element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_error(self, error: 'Error'):\n    \"\"\"Called when a ERROR element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(error)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.visit_message","title":"visit_message","text":"<pre><code>visit_message(message: Message)\n</code></pre> <p>Implements visiting messages.</p> <p>Can be overridden to allow modifying the passed in <code>msg</code> without calling :meth:<code>start_message</code> or :meth:<code>end_message</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_message(self, message: 'Message'):\n    \"\"\"Implements visiting messages.\n\n    Can be overridden to allow modifying the passed in ``msg`` without\n    calling :meth:`start_message` or :meth:`end_message`.\n    \"\"\"\n    if self.start_message(message) is not False:\n        self.end_message(message)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_message","title":"start_message","text":"<pre><code>start_message(message: Message) -&gt; bool | None\n</code></pre> <p>Called when a message starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_message(self, message: 'Message') -&gt; 'bool|None':\n    \"\"\"Called when a message starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(message)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_message","title":"end_message","text":"<pre><code>end_message(message: Message)\n</code></pre> <p>Called when a message ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_message(self, message: 'Message'):\n    \"\"\"Called when a message ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(message)\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.start_body_item","title":"start_body_item","text":"<pre><code>start_body_item(item: BodyItem) -&gt; bool | None\n</code></pre> <p>Called, by default, when keywords, messages or control structures start.</p> <p>More specific :meth:<code>start_keyword</code>, :meth:<code>start_message</code>, <code>:meth:</code>start_for`, etc. can be implemented to visit only keywords, messages or specific control structures.</p> <p>Can return explicit <code>False</code> to stop visiting. Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_body_item(self, item: 'BodyItem') -&gt; 'bool|None':\n    \"\"\"Called, by default, when keywords, messages or control structures start.\n\n    More specific :meth:`start_keyword`, :meth:`start_message`, `:meth:`start_for`,\n    etc. can be implemented to visit only keywords, messages or specific control\n    structures.\n\n    Can return explicit ``False`` to stop visiting. Default implementation does\n    nothing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/model/visitor/#robot.model.visitor.SuiteVisitor.end_body_item","title":"end_body_item","text":"<pre><code>end_body_item(item: BodyItem)\n</code></pre> <p>Called, by default, when keywords, messages or control structures end.</p> <p>More specific :meth:<code>end_keyword</code>, :meth:<code>end_message</code>, <code>:meth:</code>end_for`, etc. can be implemented to visit only keywords, messages or specific control structures.</p> <p>Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_body_item(self, item: 'BodyItem'):\n    \"\"\"Called, by default, when keywords, messages or control structures end.\n\n    More specific :meth:`end_keyword`, :meth:`end_message`, `:meth:`end_for`,\n    etc. can be implemented to visit only keywords, messages or specific control\n    structures.\n\n    Default implementation does nothing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/output/","title":"robot.output","text":""},{"location":"api/robot/output/#robot.output","title":"robot.output","text":"<p>Package for internal logging and other output.</p> <p>Not part of the public API, and also subject to change in the future when test execution is refactored.</p>"},{"location":"api/robot/output/debugfile/","title":"robot.output.debugfile","text":""},{"location":"api/robot/output/debugfile/#robot.output.debugfile","title":"robot.output.debugfile","text":""},{"location":"api/robot/output/filelogger/","title":"robot.output.filelogger","text":""},{"location":"api/robot/output/filelogger/#robot.output.filelogger","title":"robot.output.filelogger","text":""},{"location":"api/robot/output/librarylogger/","title":"robot.output.librarylogger","text":""},{"location":"api/robot/output/librarylogger/#robot.output.librarylogger","title":"robot.output.librarylogger","text":"<p>Implementation of the public logging API for libraries.</p> <p>This is exposed via mod:<code>robot.api.logger</code>. Implementation must reside here to avoid cyclic imports.</p>"},{"location":"api/robot/output/listeners/","title":"robot.output.listeners","text":""},{"location":"api/robot/output/listeners/#robot.output.listeners","title":"robot.output.listeners","text":""},{"location":"api/robot/output/logger/","title":"robot.output.logger","text":""},{"location":"api/robot/output/logger/#robot.output.logger","title":"robot.output.logger","text":""},{"location":"api/robot/output/logger/#robot.output.logger.Logger","title":"Logger","text":"<pre><code>Logger(register_console_logger=True)\n</code></pre> <p>               Bases: <code>AbstractLogger</code></p> <p>A global logger proxy to delegating messages to registered loggers.</p> <p>Whenever something is written to LOGGER in code, all registered loggers are notified.  Messages are also cached and cached messages written to new loggers when they are registered.</p> <p>NOTE: This API is likely to change in future versions.</p> Source code in <code>src/robot/output/logger.py</code> <pre><code>def __init__(self, register_console_logger=True):\n    self._console_logger = None\n    self._syslog = None\n    self._xml_logger = None\n    self._cli_listeners = None\n    self._lib_listeners = None\n    self._other_loggers = []\n    self._message_cache = []\n    self._log_message_cache = None\n    self._started_keywords = 0\n    self._error_occurred = False\n    self._error_listener = None\n    self._prev_log_message_handlers = []\n    self._enabled = 0\n    self._cache_only = False\n    if register_console_logger:\n        self.register_console_logger()\n</code></pre>"},{"location":"api/robot/output/logger/#robot.output.logger.Logger.message","title":"message","text":"<pre><code>message(msg)\n</code></pre> <p>Messages about what the framework is doing, warnings, errors, ...</p> Source code in <code>src/robot/output/logger.py</code> <pre><code>def message(self, msg):\n    \"\"\"Messages about what the framework is doing, warnings, errors, ...\"\"\"\n    if not self._cache_only:\n        for logger in self:\n            logger.message(msg)\n    if self._message_cache is not None:\n        self._message_cache.append(msg)\n    if msg.level == 'ERROR':\n        self._error_occurred = True\n        if self._error_listener:\n            self._error_listener()\n</code></pre>"},{"location":"api/robot/output/loggerapi/","title":"robot.output.loggerapi","text":""},{"location":"api/robot/output/loggerapi/#robot.output.loggerapi","title":"robot.output.loggerapi","text":""},{"location":"api/robot/output/loggerapi/#robot.output.loggerapi.LoggerApi","title":"LoggerApi","text":""},{"location":"api/robot/output/loggerapi/#robot.output.loggerapi.LoggerApi.output_file","title":"output_file","text":"<pre><code>output_file(path: Path)\n</code></pre> <p>Called when XML output file is closed.</p> <p>Calls :meth:<code>result_file</code> by default.</p> Source code in <code>src/robot/output/loggerapi.py</code> <pre><code>def output_file(self, path: Path):\n    \"\"\"Called when XML output file is closed.\n\n    Calls :meth:`result_file` by default.\n    \"\"\"\n    self.result_file('Output', path)\n</code></pre>"},{"location":"api/robot/output/loggerapi/#robot.output.loggerapi.LoggerApi.report_file","title":"report_file","text":"<pre><code>report_file(path: Path)\n</code></pre> <p>Called when report file is closed.</p> <p>Calls :meth:<code>result_file</code> by default.</p> Source code in <code>src/robot/output/loggerapi.py</code> <pre><code>def report_file(self, path: Path):\n    \"\"\"Called when report file is closed.\n\n    Calls :meth:`result_file` by default.\n    \"\"\"\n    self.result_file('Report', path)\n</code></pre>"},{"location":"api/robot/output/loggerapi/#robot.output.loggerapi.LoggerApi.log_file","title":"log_file","text":"<pre><code>log_file(path: Path)\n</code></pre> <p>Called when log file is closed.</p> <p>Calls :meth:<code>result_file</code> by default.</p> Source code in <code>src/robot/output/loggerapi.py</code> <pre><code>def log_file(self, path: Path):\n    \"\"\"Called when log file is closed.\n\n    Calls :meth:`result_file` by default.\n    \"\"\"\n    self.result_file('Log', path)\n</code></pre>"},{"location":"api/robot/output/loggerapi/#robot.output.loggerapi.LoggerApi.xunit_file","title":"xunit_file","text":"<pre><code>xunit_file(path: Path)\n</code></pre> <p>Called when xunit file is closed.</p> <p>Calls :meth:<code>result_file</code> by default.</p> Source code in <code>src/robot/output/loggerapi.py</code> <pre><code>def xunit_file(self, path: Path):\n    \"\"\"Called when xunit file is closed.\n\n    Calls :meth:`result_file` by default.\n    \"\"\"\n    self.result_file('XUnit', path)\n</code></pre>"},{"location":"api/robot/output/loggerapi/#robot.output.loggerapi.LoggerApi.debug_file","title":"debug_file","text":"<pre><code>debug_file(path: Path)\n</code></pre> <p>Called when debug file is closed.</p> <p>Calls :meth:<code>result_file</code> by default.</p> Source code in <code>src/robot/output/loggerapi.py</code> <pre><code>def debug_file(self, path: Path):\n    \"\"\"Called when debug file is closed.\n\n    Calls :meth:`result_file` by default.\n    \"\"\"\n    self.result_file('Debug', path)\n</code></pre>"},{"location":"api/robot/output/loggerapi/#robot.output.loggerapi.LoggerApi.result_file","title":"result_file","text":"<pre><code>result_file(\n    kind: Literal[\n        \"Output\", \"Report\", \"Log\", \"XUnit\", \"Debug\"\n    ],\n    path: Path,\n)\n</code></pre> <p>Called when any result file is closed by default.</p> <p><code>kind</code> specifies the file type. This method is not called if a result file specific method like :meth:<code>output_file</code> is implemented.</p> Source code in <code>src/robot/output/loggerapi.py</code> <pre><code>def result_file(self, kind: Literal['Output', 'Report', 'Log', 'XUnit', 'Debug'],\n                path: Path):\n    \"\"\"Called when any result file is closed by default.\n\n    ``kind`` specifies the file type. This method is not called if a result\n    file specific method like :meth:`output_file` is implemented.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/output/loggerhelper/","title":"robot.output.loggerhelper","text":""},{"location":"api/robot/output/loggerhelper/#robot.output.loggerhelper","title":"robot.output.loggerhelper","text":""},{"location":"api/robot/output/output/","title":"robot.output.output","text":""},{"location":"api/robot/output/output/#robot.output.output","title":"robot.output.output","text":""},{"location":"api/robot/output/pyloggingconf/","title":"robot.output.pyloggingconf","text":""},{"location":"api/robot/output/pyloggingconf/#robot.output.pyloggingconf","title":"robot.output.pyloggingconf","text":""},{"location":"api/robot/output/stdoutlogsplitter/","title":"robot.output.stdoutlogsplitter","text":""},{"location":"api/robot/output/stdoutlogsplitter/#robot.output.stdoutlogsplitter","title":"robot.output.stdoutlogsplitter","text":""},{"location":"api/robot/output/stdoutlogsplitter/#robot.output.stdoutlogsplitter.StdoutLogSplitter","title":"StdoutLogSplitter","text":"<pre><code>StdoutLogSplitter(output)\n</code></pre> <p>Splits messages logged through stdout (or stderr) into Message objects</p> Source code in <code>src/robot/output/stdoutlogsplitter.py</code> <pre><code>def __init__(self, output):\n    self._messages = list(self._get_messages(output.strip()))\n</code></pre>"},{"location":"api/robot/output/xmllogger/","title":"robot.output.xmllogger","text":""},{"location":"api/robot/output/xmllogger/#robot.output.xmllogger","title":"robot.output.xmllogger","text":""},{"location":"api/robot/output/console/","title":"robot.output.console","text":""},{"location":"api/robot/output/console/#robot.output.console","title":"robot.output.console","text":""},{"location":"api/robot/output/console/dotted/","title":"robot.output.console.dotted","text":""},{"location":"api/robot/output/console/dotted/#robot.output.console.dotted","title":"robot.output.console.dotted","text":""},{"location":"api/robot/output/console/highlighting/","title":"robot.output.console.highlighting","text":""},{"location":"api/robot/output/console/highlighting/#robot.output.console.highlighting","title":"robot.output.console.highlighting","text":""},{"location":"api/robot/output/console/quiet/","title":"robot.output.console.quiet","text":""},{"location":"api/robot/output/console/quiet/#robot.output.console.quiet","title":"robot.output.console.quiet","text":""},{"location":"api/robot/output/console/verbose/","title":"robot.output.console.verbose","text":""},{"location":"api/robot/output/console/verbose/#robot.output.console.verbose","title":"robot.output.console.verbose","text":""},{"location":"api/robot/parsing/","title":"robot.parsing","text":""},{"location":"api/robot/parsing/#robot.parsing","title":"robot.parsing","text":"<p>Module implementing test data parsing.</p> <p>Public API is exposed via the :mod:<code>robot.api.parsing</code> module. See its documentation for more information and examples. If external code needs to import something from this module directly, issue should be submitted about exposing it explicitly via :mod:<code>robot.api.parsing</code>.</p>"},{"location":"api/robot/parsing/suitestructure/","title":"robot.parsing.suitestructure","text":""},{"location":"api/robot/parsing/suitestructure/#robot.parsing.suitestructure","title":"robot.parsing.suitestructure","text":""},{"location":"api/robot/parsing/lexer/","title":"robot.parsing.lexer","text":""},{"location":"api/robot/parsing/lexer/#robot.parsing.lexer","title":"robot.parsing.lexer","text":""},{"location":"api/robot/parsing/lexer/blocklexers/","title":"robot.parsing.lexer.blocklexers","text":""},{"location":"api/robot/parsing/lexer/blocklexers/#robot.parsing.lexer.blocklexers","title":"robot.parsing.lexer.blocklexers","text":""},{"location":"api/robot/parsing/lexer/context/","title":"robot.parsing.lexer.context","text":""},{"location":"api/robot/parsing/lexer/context/#robot.parsing.lexer.context","title":"robot.parsing.lexer.context","text":""},{"location":"api/robot/parsing/lexer/lexer/","title":"robot.parsing.lexer.lexer","text":""},{"location":"api/robot/parsing/lexer/lexer/#robot.parsing.lexer.lexer","title":"robot.parsing.lexer.lexer","text":""},{"location":"api/robot/parsing/lexer/lexer/#robot.parsing.lexer.lexer.get_tokens","title":"get_tokens","text":"<pre><code>get_tokens(\n    source: Source,\n    data_only: bool = False,\n    tokenize_variables: bool = False,\n    lang: LanguagesLike = None,\n) -&gt; Iterator[Token]\n</code></pre> <p>Parses the given source to tokens.</p> <p>:param source: The source where to read the data. Can be a path to     a source file as a string or as <code>pathlib.Path</code> object, an already     opened file object, or Unicode text containing the date directly.     Source files must be UTF-8 encoded. :param data_only: When <code>False</code> (default), returns all tokens. When set     to <code>True</code>, omits separators, comments, continuation markers, and     other non-data tokens. :param tokenize_variables: When <code>True</code>, possible variables in keyword     arguments and elsewhere are tokenized. See the     :meth:<code>~robot.parsing.lexer.tokens.Token.tokenize_variables</code>     method for details. :param lang: Additional languages to be supported during parsing.     Can be a string matching any of the supported language codes or names,     an initialized :class:<code>~robot.conf.languages.Language</code> subclass,     a list containing such strings or instances, or a     :class:<code>~robot.conf.languages.Languages</code> instance.</p> <p>Returns a generator that yields :class:<code>~robot.parsing.lexer.tokens.Token</code> instances.</p> Source code in <code>src/robot/parsing/lexer/lexer.py</code> <pre><code>def get_tokens(source: Source, data_only: bool = False,\n               tokenize_variables: bool = False,\n               lang: LanguagesLike = None) -&gt; 'Iterator[Token]':\n    \"\"\"Parses the given source to tokens.\n\n    :param source: The source where to read the data. Can be a path to\n        a source file as a string or as ``pathlib.Path`` object, an already\n        opened file object, or Unicode text containing the date directly.\n        Source files must be UTF-8 encoded.\n    :param data_only: When ``False`` (default), returns all tokens. When set\n        to ``True``, omits separators, comments, continuation markers, and\n        other non-data tokens.\n    :param tokenize_variables: When ``True``, possible variables in keyword\n        arguments and elsewhere are tokenized. See the\n        :meth:`~robot.parsing.lexer.tokens.Token.tokenize_variables`\n        method for details.\n    :param lang: Additional languages to be supported during parsing.\n        Can be a string matching any of the supported language codes or names,\n        an initialized :class:`~robot.conf.languages.Language` subclass,\n        a list containing such strings or instances, or a\n        :class:`~robot.conf.languages.Languages` instance.\n\n    Returns a generator that yields :class:`~robot.parsing.lexer.tokens.Token`\n    instances.\n    \"\"\"\n    lexer = Lexer(SuiteFileContext(lang=lang), data_only, tokenize_variables)\n    lexer.input(source)\n    return lexer.get_tokens()\n</code></pre>"},{"location":"api/robot/parsing/lexer/lexer/#robot.parsing.lexer.lexer.get_resource_tokens","title":"get_resource_tokens","text":"<pre><code>get_resource_tokens(\n    source: Source,\n    data_only: bool = False,\n    tokenize_variables: bool = False,\n    lang: LanguagesLike = None,\n) -&gt; Iterator[Token]\n</code></pre> <p>Parses the given source to resource file tokens.</p> <p>Same as :func:<code>get_tokens</code> otherwise, but the source is considered to be a resource file. This affects, for example, what settings are valid.</p> Source code in <code>src/robot/parsing/lexer/lexer.py</code> <pre><code>def get_resource_tokens(source: Source, data_only: bool = False,\n                        tokenize_variables: bool = False,\n                        lang: LanguagesLike = None) -&gt; 'Iterator[Token]':\n    \"\"\"Parses the given source to resource file tokens.\n\n    Same as :func:`get_tokens` otherwise, but the source is considered to be\n    a resource file. This affects, for example, what settings are valid.\n    \"\"\"\n    lexer = Lexer(ResourceFileContext(lang=lang), data_only, tokenize_variables)\n    lexer.input(source)\n    return lexer.get_tokens()\n</code></pre>"},{"location":"api/robot/parsing/lexer/lexer/#robot.parsing.lexer.lexer.get_init_tokens","title":"get_init_tokens","text":"<pre><code>get_init_tokens(\n    source: Source,\n    data_only: bool = False,\n    tokenize_variables: bool = False,\n    lang: LanguagesLike = None,\n) -&gt; Iterator[Token]\n</code></pre> <p>Parses the given source to init file tokens.</p> <p>Same as :func:<code>get_tokens</code> otherwise, but the source is considered to be a suite initialization file. This affects, for example, what settings are valid.</p> Source code in <code>src/robot/parsing/lexer/lexer.py</code> <pre><code>def get_init_tokens(source: Source, data_only: bool = False,\n                    tokenize_variables: bool = False,\n                    lang: LanguagesLike = None) -&gt; 'Iterator[Token]':\n    \"\"\"Parses the given source to init file tokens.\n\n    Same as :func:`get_tokens` otherwise, but the source is considered to be\n    a suite initialization file. This affects, for example, what settings are\n    valid.\n    \"\"\"\n    lexer = Lexer(InitFileContext(lang=lang), data_only, tokenize_variables)\n    lexer.input(source)\n    return lexer.get_tokens()\n</code></pre>"},{"location":"api/robot/parsing/lexer/settings/","title":"robot.parsing.lexer.settings","text":""},{"location":"api/robot/parsing/lexer/settings/#robot.parsing.lexer.settings","title":"robot.parsing.lexer.settings","text":""},{"location":"api/robot/parsing/lexer/statementlexers/","title":"robot.parsing.lexer.statementlexers","text":""},{"location":"api/robot/parsing/lexer/statementlexers/#robot.parsing.lexer.statementlexers","title":"robot.parsing.lexer.statementlexers","text":""},{"location":"api/robot/parsing/lexer/tokenizer/","title":"robot.parsing.lexer.tokenizer","text":""},{"location":"api/robot/parsing/lexer/tokenizer/#robot.parsing.lexer.tokenizer","title":"robot.parsing.lexer.tokenizer","text":""},{"location":"api/robot/parsing/lexer/tokens/","title":"robot.parsing.lexer.tokens","text":""},{"location":"api/robot/parsing/lexer/tokens/#robot.parsing.lexer.tokens","title":"robot.parsing.lexer.tokens","text":""},{"location":"api/robot/parsing/lexer/tokens/#robot.parsing.lexer.tokens.Token","title":"Token","text":"<pre><code>Token(\n    type: str | None = None,\n    value: str | None = None,\n    lineno: int = -1,\n    col_offset: int = -1,\n    error: str | None = None,\n)\n</code></pre> <p>Token representing piece of Robot Framework data.</p> <p>Each token has type, value, line number, column offset and end column offset in :attr:<code>type</code>, :attr:<code>value</code>, :attr:<code>lineno</code>, :attr:<code>col_offset</code> and :attr:<code>end_col_offset</code> attributes, respectively. Tokens representing error also have their error message in :attr:<code>error</code> attribute.</p> <p>Token types are declared as class attributes such as :attr:<code>SETTING_HEADER</code> and :attr:<code>EOL</code>. Values of these constants have changed slightly in Robot Framework 4.0, and they may change again in the future. It is thus safer to use the constants, not their values, when types are needed. For example, use <code>Token(Token.EOL)</code> instead of <code>Token('EOL')</code> and <code>token.type == Token.EOL</code> instead of <code>token.type == 'EOL'</code>.</p> <p>If :attr:<code>value</code> is not given and :attr:<code>type</code> is a special marker like :attr:<code>IF</code> or <code>:attr:</code>EOL`, the value is set automatically.</p> Source code in <code>src/robot/parsing/lexer/tokens.py</code> <pre><code>def __init__(self, type: 'str|None' = None, value: 'str|None' = None,\n             lineno: int = -1, col_offset: int = -1, error: 'str|None' = None):\n    self.type = type\n    if value is None:\n        value = {\n            Token.IF: 'IF', Token.INLINE_IF: 'IF', Token.ELSE_IF: 'ELSE IF',\n            Token.ELSE: 'ELSE', Token.FOR: 'FOR', Token.WHILE: 'WHILE',\n            Token.TRY: 'TRY', Token.EXCEPT: 'EXCEPT', Token.FINALLY: 'FINALLY',\n            Token.END: 'END', Token.VAR: 'VAR', Token.CONTINUE: 'CONTINUE',\n            Token.BREAK: 'BREAK', Token.RETURN_STATEMENT: 'RETURN',\n            Token.CONTINUATION: '...', Token.EOL: '\\n', Token.WITH_NAME: 'AS',\n            Token.AS: 'AS'\n        }.get(type, '')    # type: ignore\n    self.value = cast(str, value)\n    self.lineno = lineno\n    self.col_offset = col_offset\n    self.error = error\n    # Used internally be lexer to indicate that EOS is needed before/after.\n    self._add_eos_before = False\n    self._add_eos_after = False\n</code></pre>"},{"location":"api/robot/parsing/lexer/tokens/#robot.parsing.lexer.tokens.Token.tokenize_variables","title":"tokenize_variables","text":"<pre><code>tokenize_variables() -&gt; Iterator[Token]\n</code></pre> <p>Tokenizes possible variables in token value.</p> <p>Yields the token itself if the token does not allow variables (see :attr:<code>Token.ALLOW_VARIABLES</code>) or its value does not contain variables. Otherwise, yields variable tokens as well as tokens before, after, or between variables so that they have the same type as the original token.</p> Source code in <code>src/robot/parsing/lexer/tokens.py</code> <pre><code>def tokenize_variables(self) -&gt; 'Iterator[Token]':\n    \"\"\"Tokenizes possible variables in token value.\n\n    Yields the token itself if the token does not allow variables (see\n    :attr:`Token.ALLOW_VARIABLES`) or its value does not contain\n    variables. Otherwise, yields variable tokens as well as tokens\n    before, after, or between variables so that they have the same\n    type as the original token.\n    \"\"\"\n    if self.type not in Token.ALLOW_VARIABLES:\n        return self._tokenize_no_variables()\n    matches = VariableMatches(self.value)\n    if not matches:\n        return self._tokenize_no_variables()\n    return self._tokenize_variables(matches)\n</code></pre>"},{"location":"api/robot/parsing/lexer/tokens/#robot.parsing.lexer.tokens.EOS","title":"EOS","text":"<pre><code>EOS(lineno: int = -1, col_offset: int = -1)\n</code></pre> <p>               Bases: <code>Token</code></p> <p>Token representing end of a statement.</p> Source code in <code>src/robot/parsing/lexer/tokens.py</code> <pre><code>def __init__(self, lineno: int = -1, col_offset: int = -1):\n    super().__init__(Token.EOS, '', lineno, col_offset)\n</code></pre>"},{"location":"api/robot/parsing/lexer/tokens/#robot.parsing.lexer.tokens.EOS.tokenize_variables","title":"tokenize_variables","text":"<pre><code>tokenize_variables() -&gt; Iterator[Token]\n</code></pre> <p>Tokenizes possible variables in token value.</p> <p>Yields the token itself if the token does not allow variables (see :attr:<code>Token.ALLOW_VARIABLES</code>) or its value does not contain variables. Otherwise, yields variable tokens as well as tokens before, after, or between variables so that they have the same type as the original token.</p> Source code in <code>src/robot/parsing/lexer/tokens.py</code> <pre><code>def tokenize_variables(self) -&gt; 'Iterator[Token]':\n    \"\"\"Tokenizes possible variables in token value.\n\n    Yields the token itself if the token does not allow variables (see\n    :attr:`Token.ALLOW_VARIABLES`) or its value does not contain\n    variables. Otherwise, yields variable tokens as well as tokens\n    before, after, or between variables so that they have the same\n    type as the original token.\n    \"\"\"\n    if self.type not in Token.ALLOW_VARIABLES:\n        return self._tokenize_no_variables()\n    matches = VariableMatches(self.value)\n    if not matches:\n        return self._tokenize_no_variables()\n    return self._tokenize_variables(matches)\n</code></pre>"},{"location":"api/robot/parsing/lexer/tokens/#robot.parsing.lexer.tokens.END","title":"END","text":"<pre><code>END(\n    lineno: int = -1,\n    col_offset: int = -1,\n    virtual: bool = False,\n)\n</code></pre> <p>               Bases: <code>Token</code></p> <p>Token representing END token used to signify block ending.</p> <p>Virtual END tokens have '' as their value, with \"real\" END tokens the value is 'END'.</p> Source code in <code>src/robot/parsing/lexer/tokens.py</code> <pre><code>def __init__(self, lineno: int = -1, col_offset: int = -1, virtual: bool = False):\n    value = 'END' if not virtual else ''\n    super().__init__(Token.END, value, lineno, col_offset)\n</code></pre>"},{"location":"api/robot/parsing/lexer/tokens/#robot.parsing.lexer.tokens.END.tokenize_variables","title":"tokenize_variables","text":"<pre><code>tokenize_variables() -&gt; Iterator[Token]\n</code></pre> <p>Tokenizes possible variables in token value.</p> <p>Yields the token itself if the token does not allow variables (see :attr:<code>Token.ALLOW_VARIABLES</code>) or its value does not contain variables. Otherwise, yields variable tokens as well as tokens before, after, or between variables so that they have the same type as the original token.</p> Source code in <code>src/robot/parsing/lexer/tokens.py</code> <pre><code>def tokenize_variables(self) -&gt; 'Iterator[Token]':\n    \"\"\"Tokenizes possible variables in token value.\n\n    Yields the token itself if the token does not allow variables (see\n    :attr:`Token.ALLOW_VARIABLES`) or its value does not contain\n    variables. Otherwise, yields variable tokens as well as tokens\n    before, after, or between variables so that they have the same\n    type as the original token.\n    \"\"\"\n    if self.type not in Token.ALLOW_VARIABLES:\n        return self._tokenize_no_variables()\n    matches = VariableMatches(self.value)\n    if not matches:\n        return self._tokenize_no_variables()\n    return self._tokenize_variables(matches)\n</code></pre>"},{"location":"api/robot/parsing/model/","title":"robot.parsing.model","text":""},{"location":"api/robot/parsing/model/#robot.parsing.model","title":"robot.parsing.model","text":""},{"location":"api/robot/parsing/model/blocks/","title":"robot.parsing.model.blocks","text":""},{"location":"api/robot/parsing/model/blocks/#robot.parsing.model.blocks","title":"robot.parsing.model.blocks","text":""},{"location":"api/robot/parsing/model/blocks/#robot.parsing.model.blocks.File","title":"File","text":"<pre><code>File(\n    sections: Sequence[Section] = (),\n    source: Path | None = None,\n    languages: Sequence[str] = (),\n)\n</code></pre> <p>               Bases: <code>Container</code></p> Source code in <code>src/robot/parsing/model/blocks.py</code> <pre><code>def __init__(self, sections: 'Sequence[Section]' = (), source: 'Path|None' = None,\n             languages: Sequence[str] = ()):\n    super().__init__()\n    self.sections = list(sections)\n    self.source = source\n    self.languages = list(languages)\n</code></pre>"},{"location":"api/robot/parsing/model/blocks/#robot.parsing.model.blocks.File.save","title":"save","text":"<pre><code>save(output: Path | str | TextIO | None = None)\n</code></pre> <p>Save model to the given <code>output</code> or to the original source file.</p> <p>The <code>output</code> can be a path to a file or an already opened file object. If <code>output</code> is not given, the original source file will be overwritten.</p> Source code in <code>src/robot/parsing/model/blocks.py</code> <pre><code>def save(self, output: 'Path|str|TextIO|None' = None):\n    \"\"\"Save model to the given ``output`` or to the original source file.\n\n    The ``output`` can be a path to a file or an already opened file\n    object. If ``output`` is not given, the original source file will\n    be overwritten.\n    \"\"\"\n    output = output or self.source\n    if output is None:\n        raise TypeError('Saving model requires explicit output '\n                        'when original source is not path.')\n    ModelWriter(output).write(self)\n</code></pre>"},{"location":"api/robot/parsing/model/blocks/#robot.parsing.model.blocks.If","title":"If","text":"<pre><code>If(\n    header: Statement,\n    body: Body = (),\n    orelse: If | None = None,\n    end: End | None = None,\n    errors: Errors = (),\n)\n</code></pre> <p>               Bases: <code>NestedBlock</code></p> <p>Represents IF structures in the model.</p> <p>Used with IF, Inline IF, ELSE IF and ELSE nodes. The :attr:<code>type</code> attribute specifies the type.</p> Source code in <code>src/robot/parsing/model/blocks.py</code> <pre><code>def __init__(self, header: Statement, body: Body = (), orelse: 'If|None' = None,\n             end: 'End|None' = None, errors: Errors = ()):\n    super().__init__(header, body, end, errors)\n    self.orelse = orelse\n</code></pre>"},{"location":"api/robot/parsing/model/statements/","title":"robot.parsing.model.statements","text":""},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements","title":"robot.parsing.model.statements","text":""},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Statement","title":"Statement","text":"<pre><code>Statement(\n    tokens: Sequence[Token], errors: Sequence[str] = ()\n)\n</code></pre> <p>               Bases: <code>Node</code>, <code>ABC</code></p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def __init__(self, tokens: 'Sequence[Token]', errors: 'Sequence[str]' = ()):\n    self.tokens = tuple(tokens)\n    self.errors = tuple(errors)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Statement.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(tokens: Sequence[Token]) -&gt; Statement\n</code></pre> <p>Create a statement from given tokens.</p> <p>Statement type is got automatically from token types.</p> <p>This classmethod should be called from :class:<code>Statement</code>, not from its subclasses. If you know the subclass to use, simply create an instance of it directly.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>@classmethod\ndef from_tokens(cls, tokens: 'Sequence[Token]') -&gt; 'Statement':\n    \"\"\"Create a statement from given tokens.\n\n    Statement type is got automatically from token types.\n\n    This classmethod should be called from :class:`Statement`, not from\n    its subclasses. If you know the subclass to use, simply create an\n    instance of it directly.\n    \"\"\"\n    handlers = cls.statement_handlers\n    for token in tokens:\n        if token.type in handlers:\n            return handlers[token.type](tokens)\n    if any(token.type == Token.ASSIGN for token in tokens):\n        return KeywordCall(tokens)\n    return EmptyLine(tokens)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Statement.from_params","title":"from_params  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_params(*args, **kwargs) -&gt; Statement\n</code></pre> <p>Create a statement from passed parameters.</p> <p>Required and optional arguments in general match class properties. Values are used to create matching tokens.</p> <p>Most implementations support following general properties:</p> <ul> <li><code>separator</code> whitespace inserted between each token. Default is four spaces.</li> <li><code>indent</code> whitespace inserted before first token. Default is four spaces.</li> <li><code>eol</code> end of line sign. Default is <code>'\\n'</code>.</li> </ul> <p>This classmethod should be called from the :class:<code>Statement</code> subclass to create, not from the :class:<code>Statement</code> class itself.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_params(cls, *args, **kwargs) -&gt; 'Statement':\n    \"\"\"Create a statement from passed parameters.\n\n    Required and optional arguments in general match class properties.\n    Values are used to create matching tokens.\n\n    Most implementations support following general properties:\n\n    - ``separator`` whitespace inserted between each token. Default is four spaces.\n    - ``indent`` whitespace inserted before first token. Default is four spaces.\n    - ``eol`` end of line sign. Default is ``'\\\\n'``.\n\n    This classmethod should be called from the :class:`Statement` subclass\n    to create, not from the :class:`Statement` class itself.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Statement.get_token","title":"get_token","text":"<pre><code>get_token(*types: str) -&gt; Token | None\n</code></pre> <p>Return a token with any of the given <code>types</code>.</p> <p>If there are no matches, return <code>None</code>. If there are multiple matches, return the first match.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_token(self, *types: str) -&gt; 'Token|None':\n    \"\"\"Return a token with any of the given ``types``.\n\n    If there are no matches, return ``None``. If there are multiple\n    matches, return the first match.\n    \"\"\"\n    for token in self.tokens:\n        if token.type in types:\n            return token\n    return None\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Statement.get_tokens","title":"get_tokens","text":"<pre><code>get_tokens(*types: str) -&gt; list[Token]\n</code></pre> <p>Return tokens having any of the given <code>types</code>.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_tokens(self, *types: str) -&gt; 'list[Token]':\n    \"\"\"Return tokens having any of the given ``types``.\"\"\"\n    return [t for t in self.tokens if t.type in types]\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Statement.get_value","title":"get_value","text":"<pre><code>get_value(type: str, default: str) -&gt; str\n</code></pre><pre><code>get_value(type: str, default: None = None) -&gt; str | None\n</code></pre> <pre><code>get_value(\n    type: str, default: str | None = None\n) -&gt; str | None\n</code></pre> <p>Return value of a token with the given <code>type</code>.</p> <p>If there are no matches, return <code>default</code>. If there are multiple matches, return the value of the first match.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_value(self, type: str, default: 'str|None' = None) -&gt; 'str|None':\n    \"\"\"Return value of a token with the given ``type``.\n\n    If there are no matches, return ``default``. If there are multiple\n    matches, return the value of the first match.\n    \"\"\"\n    token = self.get_token(type)\n    return token.value if token else default\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Statement.get_values","title":"get_values","text":"<pre><code>get_values(*types: str) -&gt; tuple[str, ...]\n</code></pre> <p>Return values of tokens having any of the given <code>types</code>.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_values(self, *types: str) -&gt; 'tuple[str, ...]':\n    \"\"\"Return values of tokens having any of the given ``types``.\"\"\"\n    return tuple(t.value for t in self.tokens if t.type in types)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Statement.get_option","title":"get_option","text":"<pre><code>get_option(\n    name: str, default: str | None = None\n) -&gt; str | None\n</code></pre> <p>Return value of a configuration option with the given <code>name</code>.</p> <p>If the option has not been used, return <code>default</code>.</p> <p>If the option has been used multiple times, values are joined together. This is typically an error situation and validated elsewhere.</p> <p>New in Robot Framework 6.1.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_option(self, name: str, default: 'str|None' = None) -&gt; 'str|None':\n    \"\"\"Return value of a configuration option with the given ``name``.\n\n    If the option has not been used, return ``default``.\n\n    If the option has been used multiple times, values are joined together.\n    This is typically an error situation and validated elsewhere.\n\n    New in Robot Framework 6.1.\n    \"\"\"\n    return self._get_options().get(name, default)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.ReturnSetting","title":"ReturnSetting","text":"<pre><code>ReturnSetting(\n    tokens: Sequence[Token], errors: Sequence[str] = ()\n)\n</code></pre> <p>               Bases: <code>MultiValue</code></p> <p>Represents the deprecated <code>[Return]</code> setting.</p> <p>This class was named <code>Return</code> prior to Robot Framework 7.0. A forward compatible <code>ReturnSetting</code> alias existed already in Robot Framework 6.1.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def __init__(self, tokens: 'Sequence[Token]', errors: 'Sequence[str]' = ()):\n    self.tokens = tuple(tokens)\n    self.errors = tuple(errors)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.ReturnSetting.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(tokens: Sequence[Token]) -&gt; Statement\n</code></pre> <p>Create a statement from given tokens.</p> <p>Statement type is got automatically from token types.</p> <p>This classmethod should be called from :class:<code>Statement</code>, not from its subclasses. If you know the subclass to use, simply create an instance of it directly.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>@classmethod\ndef from_tokens(cls, tokens: 'Sequence[Token]') -&gt; 'Statement':\n    \"\"\"Create a statement from given tokens.\n\n    Statement type is got automatically from token types.\n\n    This classmethod should be called from :class:`Statement`, not from\n    its subclasses. If you know the subclass to use, simply create an\n    instance of it directly.\n    \"\"\"\n    handlers = cls.statement_handlers\n    for token in tokens:\n        if token.type in handlers:\n            return handlers[token.type](tokens)\n    if any(token.type == Token.ASSIGN for token in tokens):\n        return KeywordCall(tokens)\n    return EmptyLine(tokens)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.ReturnSetting.get_token","title":"get_token","text":"<pre><code>get_token(*types: str) -&gt; Token | None\n</code></pre> <p>Return a token with any of the given <code>types</code>.</p> <p>If there are no matches, return <code>None</code>. If there are multiple matches, return the first match.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_token(self, *types: str) -&gt; 'Token|None':\n    \"\"\"Return a token with any of the given ``types``.\n\n    If there are no matches, return ``None``. If there are multiple\n    matches, return the first match.\n    \"\"\"\n    for token in self.tokens:\n        if token.type in types:\n            return token\n    return None\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.ReturnSetting.get_tokens","title":"get_tokens","text":"<pre><code>get_tokens(*types: str) -&gt; list[Token]\n</code></pre> <p>Return tokens having any of the given <code>types</code>.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_tokens(self, *types: str) -&gt; 'list[Token]':\n    \"\"\"Return tokens having any of the given ``types``.\"\"\"\n    return [t for t in self.tokens if t.type in types]\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.ReturnSetting.get_value","title":"get_value","text":"<pre><code>get_value(type: str, default: str) -&gt; str\n</code></pre><pre><code>get_value(type: str, default: None = None) -&gt; str | None\n</code></pre> <pre><code>get_value(\n    type: str, default: str | None = None\n) -&gt; str | None\n</code></pre> <p>Return value of a token with the given <code>type</code>.</p> <p>If there are no matches, return <code>default</code>. If there are multiple matches, return the value of the first match.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_value(self, type: str, default: 'str|None' = None) -&gt; 'str|None':\n    \"\"\"Return value of a token with the given ``type``.\n\n    If there are no matches, return ``default``. If there are multiple\n    matches, return the value of the first match.\n    \"\"\"\n    token = self.get_token(type)\n    return token.value if token else default\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.ReturnSetting.get_values","title":"get_values","text":"<pre><code>get_values(*types: str) -&gt; tuple[str, ...]\n</code></pre> <p>Return values of tokens having any of the given <code>types</code>.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_values(self, *types: str) -&gt; 'tuple[str, ...]':\n    \"\"\"Return values of tokens having any of the given ``types``.\"\"\"\n    return tuple(t.value for t in self.tokens if t.type in types)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.ReturnSetting.get_option","title":"get_option","text":"<pre><code>get_option(\n    name: str, default: str | None = None\n) -&gt; str | None\n</code></pre> <p>Return value of a configuration option with the given <code>name</code>.</p> <p>If the option has not been used, return <code>default</code>.</p> <p>If the option has been used multiple times, values are joined together. This is typically an error situation and validated elsewhere.</p> <p>New in Robot Framework 6.1.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_option(self, name: str, default: 'str|None' = None) -&gt; 'str|None':\n    \"\"\"Return value of a configuration option with the given ``name``.\n\n    If the option has not been used, return ``default``.\n\n    If the option has been used multiple times, values are joined together.\n    This is typically an error situation and validated elsewhere.\n\n    New in Robot Framework 6.1.\n    \"\"\"\n    return self._get_options().get(name, default)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Return","title":"Return","text":"<pre><code>Return(tokens: Sequence[Token], errors: Sequence[str] = ())\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>Represents the RETURN statement.</p> <p>This class named <code>ReturnStatement</code> prior to Robot Framework 7.0. The old name still exists as a backwards compatible alias.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def __init__(self, tokens: 'Sequence[Token]', errors: 'Sequence[str]' = ()):\n    self.tokens = tuple(tokens)\n    self.errors = tuple(errors)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Return.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(tokens: Sequence[Token]) -&gt; Statement\n</code></pre> <p>Create a statement from given tokens.</p> <p>Statement type is got automatically from token types.</p> <p>This classmethod should be called from :class:<code>Statement</code>, not from its subclasses. If you know the subclass to use, simply create an instance of it directly.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>@classmethod\ndef from_tokens(cls, tokens: 'Sequence[Token]') -&gt; 'Statement':\n    \"\"\"Create a statement from given tokens.\n\n    Statement type is got automatically from token types.\n\n    This classmethod should be called from :class:`Statement`, not from\n    its subclasses. If you know the subclass to use, simply create an\n    instance of it directly.\n    \"\"\"\n    handlers = cls.statement_handlers\n    for token in tokens:\n        if token.type in handlers:\n            return handlers[token.type](tokens)\n    if any(token.type == Token.ASSIGN for token in tokens):\n        return KeywordCall(tokens)\n    return EmptyLine(tokens)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Return.get_token","title":"get_token","text":"<pre><code>get_token(*types: str) -&gt; Token | None\n</code></pre> <p>Return a token with any of the given <code>types</code>.</p> <p>If there are no matches, return <code>None</code>. If there are multiple matches, return the first match.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_token(self, *types: str) -&gt; 'Token|None':\n    \"\"\"Return a token with any of the given ``types``.\n\n    If there are no matches, return ``None``. If there are multiple\n    matches, return the first match.\n    \"\"\"\n    for token in self.tokens:\n        if token.type in types:\n            return token\n    return None\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Return.get_tokens","title":"get_tokens","text":"<pre><code>get_tokens(*types: str) -&gt; list[Token]\n</code></pre> <p>Return tokens having any of the given <code>types</code>.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_tokens(self, *types: str) -&gt; 'list[Token]':\n    \"\"\"Return tokens having any of the given ``types``.\"\"\"\n    return [t for t in self.tokens if t.type in types]\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Return.get_value","title":"get_value","text":"<pre><code>get_value(type: str, default: str) -&gt; str\n</code></pre><pre><code>get_value(type: str, default: None = None) -&gt; str | None\n</code></pre> <pre><code>get_value(\n    type: str, default: str | None = None\n) -&gt; str | None\n</code></pre> <p>Return value of a token with the given <code>type</code>.</p> <p>If there are no matches, return <code>default</code>. If there are multiple matches, return the value of the first match.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_value(self, type: str, default: 'str|None' = None) -&gt; 'str|None':\n    \"\"\"Return value of a token with the given ``type``.\n\n    If there are no matches, return ``default``. If there are multiple\n    matches, return the value of the first match.\n    \"\"\"\n    token = self.get_token(type)\n    return token.value if token else default\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Return.get_values","title":"get_values","text":"<pre><code>get_values(*types: str) -&gt; tuple[str, ...]\n</code></pre> <p>Return values of tokens having any of the given <code>types</code>.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_values(self, *types: str) -&gt; 'tuple[str, ...]':\n    \"\"\"Return values of tokens having any of the given ``types``.\"\"\"\n    return tuple(t.value for t in self.tokens if t.type in types)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Return.get_option","title":"get_option","text":"<pre><code>get_option(\n    name: str, default: str | None = None\n) -&gt; str | None\n</code></pre> <p>Return value of a configuration option with the given <code>name</code>.</p> <p>If the option has not been used, return <code>default</code>.</p> <p>If the option has been used multiple times, values are joined together. This is typically an error situation and validated elsewhere.</p> <p>New in Robot Framework 6.1.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_option(self, name: str, default: 'str|None' = None) -&gt; 'str|None':\n    \"\"\"Return value of a configuration option with the given ``name``.\n\n    If the option has not been used, return ``default``.\n\n    If the option has been used multiple times, values are joined together.\n    This is typically an error situation and validated elsewhere.\n\n    New in Robot Framework 6.1.\n    \"\"\"\n    return self._get_options().get(name, default)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Error","title":"Error","text":"<pre><code>Error(tokens: Sequence[Token], errors: Sequence[str] = ())\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def __init__(self, tokens: 'Sequence[Token]', errors: 'Sequence[str]' = ()):\n    self.tokens = tuple(tokens)\n    self.errors = tuple(errors)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Error.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(tokens: Sequence[Token]) -&gt; Statement\n</code></pre> <p>Create a statement from given tokens.</p> <p>Statement type is got automatically from token types.</p> <p>This classmethod should be called from :class:<code>Statement</code>, not from its subclasses. If you know the subclass to use, simply create an instance of it directly.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>@classmethod\ndef from_tokens(cls, tokens: 'Sequence[Token]') -&gt; 'Statement':\n    \"\"\"Create a statement from given tokens.\n\n    Statement type is got automatically from token types.\n\n    This classmethod should be called from :class:`Statement`, not from\n    its subclasses. If you know the subclass to use, simply create an\n    instance of it directly.\n    \"\"\"\n    handlers = cls.statement_handlers\n    for token in tokens:\n        if token.type in handlers:\n            return handlers[token.type](tokens)\n    if any(token.type == Token.ASSIGN for token in tokens):\n        return KeywordCall(tokens)\n    return EmptyLine(tokens)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Error.get_token","title":"get_token","text":"<pre><code>get_token(*types: str) -&gt; Token | None\n</code></pre> <p>Return a token with any of the given <code>types</code>.</p> <p>If there are no matches, return <code>None</code>. If there are multiple matches, return the first match.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_token(self, *types: str) -&gt; 'Token|None':\n    \"\"\"Return a token with any of the given ``types``.\n\n    If there are no matches, return ``None``. If there are multiple\n    matches, return the first match.\n    \"\"\"\n    for token in self.tokens:\n        if token.type in types:\n            return token\n    return None\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Error.get_tokens","title":"get_tokens","text":"<pre><code>get_tokens(*types: str) -&gt; list[Token]\n</code></pre> <p>Return tokens having any of the given <code>types</code>.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_tokens(self, *types: str) -&gt; 'list[Token]':\n    \"\"\"Return tokens having any of the given ``types``.\"\"\"\n    return [t for t in self.tokens if t.type in types]\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Error.get_value","title":"get_value","text":"<pre><code>get_value(type: str, default: str) -&gt; str\n</code></pre><pre><code>get_value(type: str, default: None = None) -&gt; str | None\n</code></pre> <pre><code>get_value(\n    type: str, default: str | None = None\n) -&gt; str | None\n</code></pre> <p>Return value of a token with the given <code>type</code>.</p> <p>If there are no matches, return <code>default</code>. If there are multiple matches, return the value of the first match.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_value(self, type: str, default: 'str|None' = None) -&gt; 'str|None':\n    \"\"\"Return value of a token with the given ``type``.\n\n    If there are no matches, return ``default``. If there are multiple\n    matches, return the value of the first match.\n    \"\"\"\n    token = self.get_token(type)\n    return token.value if token else default\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Error.get_values","title":"get_values","text":"<pre><code>get_values(*types: str) -&gt; tuple[str, ...]\n</code></pre> <p>Return values of tokens having any of the given <code>types</code>.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_values(self, *types: str) -&gt; 'tuple[str, ...]':\n    \"\"\"Return values of tokens having any of the given ``types``.\"\"\"\n    return tuple(t.value for t in self.tokens if t.type in types)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Error.get_option","title":"get_option","text":"<pre><code>get_option(\n    name: str, default: str | None = None\n) -&gt; str | None\n</code></pre> <p>Return value of a configuration option with the given <code>name</code>.</p> <p>If the option has not been used, return <code>default</code>.</p> <p>If the option has been used multiple times, values are joined together. This is typically an error situation and validated elsewhere.</p> <p>New in Robot Framework 6.1.</p> Source code in <code>src/robot/parsing/model/statements.py</code> <pre><code>def get_option(self, name: str, default: 'str|None' = None) -&gt; 'str|None':\n    \"\"\"Return value of a configuration option with the given ``name``.\n\n    If the option has not been used, return ``default``.\n\n    If the option has been used multiple times, values are joined together.\n    This is typically an error situation and validated elsewhere.\n\n    New in Robot Framework 6.1.\n    \"\"\"\n    return self._get_options().get(name, default)\n</code></pre>"},{"location":"api/robot/parsing/model/statements/#robot.parsing.model.statements.Error.errors","title":"errors  <code>property</code> <code>writable</code>","text":"<pre><code>errors: tuple[str, ...]\n</code></pre> <p>Errors got from the underlying <code>ERROR</code>token.</p> <p>Errors can be set also explicitly. When accessing errors, they are returned along with errors got from tokens.</p>"},{"location":"api/robot/parsing/model/visitor/","title":"robot.parsing.model.visitor","text":""},{"location":"api/robot/parsing/model/visitor/#robot.parsing.model.visitor","title":"robot.parsing.model.visitor","text":""},{"location":"api/robot/parsing/model/visitor/#robot.parsing.model.visitor.ModelVisitor","title":"ModelVisitor","text":"<p>               Bases: <code>NodeVisitor</code>, <code>VisitorFinder</code></p> <p>NodeVisitor that supports matching nodes based on their base classes.</p> <p>The biggest difference compared to the standard <code>ast.NodeVisitor &lt;https://docs.python.org/library/ast.html#ast.NodeVisitor&gt;</code>__, is that this class allows creating <code>visit_ClassName</code> methods so that the <code>ClassName</code> is one of the base classes of the node. For example, the following visitor method matches all node classes that extend <code>Statement</code>::</p> <pre><code>def visit_Statement(self, node):\n    ...\n</code></pre> <p>Another difference is that visitor methods are cached for performance reasons. This means that dynamically adding <code>visit_Something</code> methods does not work.</p>"},{"location":"api/robot/parsing/model/visitor/#robot.parsing.model.visitor.ModelTransformer","title":"ModelTransformer","text":"<p>               Bases: <code>NodeTransformer</code>, <code>VisitorFinder</code></p> <p>NodeTransformer that supports matching nodes based on their base classes.</p> <p>See :class:<code>ModelVisitor</code> for explanation how this is different compared to the standard <code>ast.NodeTransformer &lt;https://docs.python.org/library/ast.html#ast.NodeTransformer&gt;</code>__.</p>"},{"location":"api/robot/parsing/parser/","title":"robot.parsing.parser","text":""},{"location":"api/robot/parsing/parser/#robot.parsing.parser","title":"robot.parsing.parser","text":""},{"location":"api/robot/parsing/parser/blockparsers/","title":"robot.parsing.parser.blockparsers","text":""},{"location":"api/robot/parsing/parser/blockparsers/#robot.parsing.parser.blockparsers","title":"robot.parsing.parser.blockparsers","text":""},{"location":"api/robot/parsing/parser/fileparser/","title":"robot.parsing.parser.fileparser","text":""},{"location":"api/robot/parsing/parser/fileparser/#robot.parsing.parser.fileparser","title":"robot.parsing.parser.fileparser","text":""},{"location":"api/robot/parsing/parser/parser/","title":"robot.parsing.parser.parser","text":""},{"location":"api/robot/parsing/parser/parser/#robot.parsing.parser.parser","title":"robot.parsing.parser.parser","text":""},{"location":"api/robot/parsing/parser/parser/#robot.parsing.parser.parser.get_model","title":"get_model","text":"<pre><code>get_model(\n    source: Source,\n    data_only: bool = False,\n    curdir: str | None = None,\n    lang: LanguagesLike = None,\n) -&gt; File\n</code></pre> <p>Parses the given source into a model represented as an AST.</p> <p>How to use the model is explained more thoroughly in the general documentation of the :mod:<code>robot.parsing</code> module.</p> <p>:param source: The source where to read the data. Can be a path to     a source file as a string or as <code>pathlib.Path</code> object, an already     opened file object, or Unicode text containing the date directly.     Source files must be UTF-8 encoded. :param data_only: When <code>False</code> (default), returns all tokens. When set     to <code>True</code>, omits separators, comments, continuation markers, and     other non-data tokens. Model like this cannot be saved back to     file system. :param curdir: Directory where the source file exists. This path is used     to set the value of the built-in <code>${CURDIR}</code> variable during parsing.     When not given, the variable is left as-is. Should only be given     only if the model will be executed afterward. If the model is saved     back to disk, resolving <code>${CURDIR}</code> is typically not a good idea. :param lang: Additional languages to be supported during parsing.     Can be a string matching any of the supported language codes or names,     an initialized :class:<code>~robot.conf.languages.Language</code> subclass,     a list containing such strings or instances, or a     :class:<code>~robot.conf.languages.Languages</code> instance.</p> <p>Use :func:<code>get_resource_model</code> or :func:<code>get_init_model</code> when parsing resource or suite initialization files, respectively.</p> Source code in <code>src/robot/parsing/parser/parser.py</code> <pre><code>def get_model(source: Source, data_only: bool = False, curdir: 'str|None' = None,\n              lang: LanguagesLike = None) -&gt; File:\n    \"\"\"Parses the given source into a model represented as an AST.\n\n    How to use the model is explained more thoroughly in the general\n    documentation of the :mod:`robot.parsing` module.\n\n    :param source: The source where to read the data. Can be a path to\n        a source file as a string or as ``pathlib.Path`` object, an already\n        opened file object, or Unicode text containing the date directly.\n        Source files must be UTF-8 encoded.\n    :param data_only: When ``False`` (default), returns all tokens. When set\n        to ``True``, omits separators, comments, continuation markers, and\n        other non-data tokens. Model like this cannot be saved back to\n        file system.\n    :param curdir: Directory where the source file exists. This path is used\n        to set the value of the built-in ``${CURDIR}`` variable during parsing.\n        When not given, the variable is left as-is. Should only be given\n        only if the model will be executed afterward. If the model is saved\n        back to disk, resolving ``${CURDIR}`` is typically not a good idea.\n    :param lang: Additional languages to be supported during parsing.\n        Can be a string matching any of the supported language codes or names,\n        an initialized :class:`~robot.conf.languages.Language` subclass,\n        a list containing such strings or instances, or a\n        :class:`~robot.conf.languages.Languages` instance.\n\n    Use :func:`get_resource_model` or :func:`get_init_model` when parsing\n    resource or suite initialization files, respectively.\n    \"\"\"\n    return _get_model(get_tokens, source, data_only, curdir, lang)\n</code></pre>"},{"location":"api/robot/parsing/parser/parser/#robot.parsing.parser.parser.get_resource_model","title":"get_resource_model","text":"<pre><code>get_resource_model(\n    source: Source,\n    data_only: bool = False,\n    curdir: str | None = None,\n    lang: LanguagesLike = None,\n) -&gt; File\n</code></pre> <p>Parses the given source into a resource file model.</p> <p>Same as :func:<code>get_model</code> otherwise, but the source is considered to be a resource file. This affects, for example, what settings are valid.</p> Source code in <code>src/robot/parsing/parser/parser.py</code> <pre><code>def get_resource_model(source: Source, data_only: bool = False,\n                       curdir: 'str|None' = None, lang: LanguagesLike = None) -&gt; File:\n    \"\"\"Parses the given source into a resource file model.\n\n    Same as :func:`get_model` otherwise, but the source is considered to be\n    a resource file. This affects, for example, what settings are valid.\n    \"\"\"\n    return _get_model(get_resource_tokens, source, data_only, curdir, lang)\n</code></pre>"},{"location":"api/robot/parsing/parser/parser/#robot.parsing.parser.parser.get_init_model","title":"get_init_model","text":"<pre><code>get_init_model(\n    source: Source,\n    data_only: bool = False,\n    curdir: str | None = None,\n    lang: LanguagesLike = None,\n) -&gt; File\n</code></pre> <p>Parses the given source into an init file model.</p> <p>Same as :func:<code>get_model</code> otherwise, but the source is considered to be a suite initialization file. This affects, for example, what settings are valid.</p> Source code in <code>src/robot/parsing/parser/parser.py</code> <pre><code>def get_init_model(source: Source, data_only: bool = False, curdir: 'str|None' = None,\n                   lang: LanguagesLike = None) -&gt; File:\n    \"\"\"Parses the given source into an init file model.\n\n    Same as :func:`get_model` otherwise, but the source is considered to be\n    a suite initialization file. This affects, for example, what settings are\n    valid.\n    \"\"\"\n    return _get_model(get_init_tokens, source, data_only, curdir, lang)\n</code></pre>"},{"location":"api/robot/reporting/","title":"robot.reporting","text":""},{"location":"api/robot/reporting/#robot.reporting","title":"robot.reporting","text":"<p>Implements report, log, output XML, and xUnit file generation.</p> <p>The public API of this package is the :class:<code>~.ResultWriter</code> class. It can write result files based on XML output files on the file system, as well as based on the result objects returned by the :func:<code>~robot.result.resultbuilder.ExecutionResult</code> factory method or an executed :class:<code>~robot.running.model.TestSuite</code>.</p> <p>It is highly recommended to use the public API via the :mod:<code>robot.api</code> package.</p> <p>This package is considered stable.</p>"},{"location":"api/robot/reporting/expandkeywordmatcher/","title":"robot.reporting.expandkeywordmatcher","text":""},{"location":"api/robot/reporting/expandkeywordmatcher/#robot.reporting.expandkeywordmatcher","title":"robot.reporting.expandkeywordmatcher","text":""},{"location":"api/robot/reporting/jsbuildingcontext/","title":"robot.reporting.jsbuildingcontext","text":""},{"location":"api/robot/reporting/jsbuildingcontext/#robot.reporting.jsbuildingcontext","title":"robot.reporting.jsbuildingcontext","text":""},{"location":"api/robot/reporting/jsexecutionresult/","title":"robot.reporting.jsexecutionresult","text":""},{"location":"api/robot/reporting/jsexecutionresult/#robot.reporting.jsexecutionresult","title":"robot.reporting.jsexecutionresult","text":""},{"location":"api/robot/reporting/jsmodelbuilders/","title":"robot.reporting.jsmodelbuilders","text":""},{"location":"api/robot/reporting/jsmodelbuilders/#robot.reporting.jsmodelbuilders","title":"robot.reporting.jsmodelbuilders","text":""},{"location":"api/robot/reporting/jswriter/","title":"robot.reporting.jswriter","text":""},{"location":"api/robot/reporting/jswriter/#robot.reporting.jswriter","title":"robot.reporting.jswriter","text":""},{"location":"api/robot/reporting/logreportwriters/","title":"robot.reporting.logreportwriters","text":""},{"location":"api/robot/reporting/logreportwriters/#robot.reporting.logreportwriters","title":"robot.reporting.logreportwriters","text":""},{"location":"api/robot/reporting/outputwriter/","title":"robot.reporting.outputwriter","text":""},{"location":"api/robot/reporting/outputwriter/#robot.reporting.outputwriter","title":"robot.reporting.outputwriter","text":""},{"location":"api/robot/reporting/resultwriter/","title":"robot.reporting.resultwriter","text":""},{"location":"api/robot/reporting/resultwriter/#robot.reporting.resultwriter","title":"robot.reporting.resultwriter","text":""},{"location":"api/robot/reporting/resultwriter/#robot.reporting.resultwriter.ResultWriter","title":"ResultWriter","text":"<pre><code>ResultWriter(*sources)\n</code></pre> <p>A class to create log, report, output XML and xUnit files.</p> <p>:param sources: Either one :class:<code>~robot.result.executionresult.Result</code>     object, or one or more paths to existing output XML files.</p> <p>By default writes <code>report.html</code> and <code>log.html</code>, but no output XML or xUnit files. Custom file names can be given and results disabled or enabled using <code>settings</code> or <code>options</code> passed to the :meth:<code>write_results</code> method. The latter is typically more convenient::</p> <pre><code>writer = ResultWriter(result)\nwriter.write_results(report='custom.html', log=None, xunit='xunit.xml')\n</code></pre> Source code in <code>src/robot/reporting/resultwriter.py</code> <pre><code>def __init__(self, *sources):\n    self._sources = sources\n</code></pre>"},{"location":"api/robot/reporting/resultwriter/#robot.reporting.resultwriter.ResultWriter.write_results","title":"write_results","text":"<pre><code>write_results(settings=None, **options)\n</code></pre> <p>Writes results based on the given <code>settings</code>  or <code>options</code>.</p> <p>:param settings: :class:<code>~robot.conf.settings.RebotSettings</code> object     to configure result writing. :param options: Used to construct new     :class:<code>~robot.conf.settings.RebotSettings</code> object if <code>settings</code>     are not given.</p> Source code in <code>src/robot/reporting/resultwriter.py</code> <pre><code>def write_results(self, settings=None, **options):\n    \"\"\"Writes results based on the given ``settings``  or ``options``.\n\n    :param settings: :class:`~robot.conf.settings.RebotSettings` object\n        to configure result writing.\n    :param options: Used to construct new\n        :class:`~robot.conf.settings.RebotSettings` object if ``settings``\n        are not given.\n    \"\"\"\n    settings = settings or RebotSettings(options)\n    results = Results(settings, *self._sources)\n    if settings.output:\n        self._write_output(results.result, settings.output, settings.legacy_output)\n    if settings.xunit:\n        self._write_xunit(results.result, settings.xunit)\n    if settings.log:\n        config = dict(settings.log_config,\n                      minLevel=results.js_result.min_level)\n        self._write_log(results.js_result, settings.log, config)\n    if settings.report:\n        results.js_result.remove_data_not_needed_in_report()\n        self._write_report(results.js_result, settings.report,\n                           settings.report_config)\n    return results.return_code\n</code></pre>"},{"location":"api/robot/reporting/stringcache/","title":"robot.reporting.stringcache","text":""},{"location":"api/robot/reporting/stringcache/#robot.reporting.stringcache","title":"robot.reporting.stringcache","text":""},{"location":"api/robot/reporting/xunitwriter/","title":"robot.reporting.xunitwriter","text":""},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter","title":"robot.reporting.xunitwriter","text":""},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter","title":"XUnitFileWriter","text":"<pre><code>XUnitFileWriter(xml_writer)\n</code></pre> <p>               Bases: <code>ResultVisitor</code></p> <p>Provides an xUnit-compatible result file.</p> <p>Attempts to adhere to the de facto schema guessed by Peter Reilly, see: http://marc.info/?l=ant-dev&amp;m=123551933508682</p> Source code in <code>src/robot/reporting/xunitwriter.py</code> <pre><code>def __init__(self, xml_writer):\n    self._writer = xml_writer\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_suite","title":"visit_suite","text":"<pre><code>visit_suite(suite: TestSuite)\n</code></pre> <p>Implements traversing through suites.</p> <p>Can be overridden to allow modifying the passed in <code>suite</code> without calling :meth:<code>start_suite</code> or :meth:<code>end_suite</code> nor visiting child suites, tests or setup and teardown at all.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_suite(self, suite: 'TestSuite'):\n    \"\"\"Implements traversing through suites.\n\n    Can be overridden to allow modifying the passed in ``suite`` without\n    calling :meth:`start_suite` or :meth:`end_suite` nor visiting child\n    suites, tests or setup and teardown at all.\n    \"\"\"\n    if self.start_suite(suite) is not False:\n        if suite.has_setup:\n            suite.setup.visit(self)\n        suite.suites.visit(self)\n        suite.tests.visit(self)\n        if suite.has_teardown:\n            suite.teardown.visit(self)\n        self.end_suite(suite)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_test","title":"start_test","text":"<pre><code>start_test(test: TestCase) -&gt; bool | None\n</code></pre> <p>Called when a test starts. Default implementation does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_test(self, test: 'TestCase') -&gt; 'bool|None':\n    \"\"\"Called when a test starts. Default implementation does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_test","title":"end_test","text":"<pre><code>end_test(test: TestCase)\n</code></pre> <p>Called when a test ends. Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_test(self, test: 'TestCase'):\n    \"\"\"Called when a test ends. Default implementation does nothing.\"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_keyword","title":"start_keyword","text":"<pre><code>start_keyword(keyword: Keyword) -&gt; bool | None\n</code></pre> <p>Called when a keyword starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_keyword(self, keyword: 'Keyword') -&gt; 'bool|None':\n    \"\"\"Called when a keyword starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(keyword)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_keyword","title":"end_keyword","text":"<pre><code>end_keyword(keyword: Keyword)\n</code></pre> <p>Called when a keyword ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_keyword(self, keyword: 'Keyword'):\n    \"\"\"Called when a keyword ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(keyword)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_for","title":"visit_for","text":"<pre><code>visit_for(for_: For)\n</code></pre> <p>Implements traversing through FOR loops.</p> <p>Can be overridden to allow modifying the passed in <code>for_</code> without calling :meth:<code>start_for</code> or :meth:<code>end_for</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_for(self, for_: 'For'):\n    \"\"\"Implements traversing through FOR loops.\n\n    Can be overridden to allow modifying the passed in ``for_`` without\n    calling :meth:`start_for` or :meth:`end_for` nor visiting body.\n    \"\"\"\n    if self.start_for(for_) is not False:\n        for_.body.visit(self)\n        self.end_for(for_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_for","title":"start_for","text":"<pre><code>start_for(for_: For) -&gt; bool | None\n</code></pre> <p>Called when a FOR loop starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_for(self, for_: 'For') -&gt; 'bool|None':\n    \"\"\"Called when a FOR loop starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(for_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_for","title":"end_for","text":"<pre><code>end_for(for_: For)\n</code></pre> <p>Called when a FOR loop ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_for(self, for_: 'For'):\n    \"\"\"Called when a FOR loop ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(for_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_for_iteration","title":"visit_for_iteration","text":"<pre><code>visit_for_iteration(iteration: ForIteration)\n</code></pre> <p>Implements traversing through single FOR loop iteration.</p> <p>This is only used with the result side model because on the running side there are no iterations.</p> <p>Can be overridden to allow modifying the passed in <code>iteration</code> without calling :meth:<code>start_for_iteration</code> or :meth:<code>end_for_iteration</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_for_iteration(self, iteration: 'ForIteration'):\n    \"\"\"Implements traversing through single FOR loop iteration.\n\n    This is only used with the result side model because on the running side\n    there are no iterations.\n\n    Can be overridden to allow modifying the passed in ``iteration`` without\n    calling :meth:`start_for_iteration` or :meth:`end_for_iteration` nor visiting\n    body.\n    \"\"\"\n    if self.start_for_iteration(iteration) is not False:\n        iteration.body.visit(self)\n        self.end_for_iteration(iteration)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_for_iteration","title":"start_for_iteration","text":"<pre><code>start_for_iteration(iteration: ForIteration) -&gt; bool | None\n</code></pre> <p>Called when a FOR loop iteration starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_for_iteration(self, iteration: 'ForIteration') -&gt; 'bool|None':\n    \"\"\"Called when a FOR loop iteration starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(iteration)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_for_iteration","title":"end_for_iteration","text":"<pre><code>end_for_iteration(iteration: ForIteration)\n</code></pre> <p>Called when a FOR loop iteration ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_for_iteration(self, iteration: 'ForIteration'):\n    \"\"\"Called when a FOR loop iteration ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(iteration)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_if","title":"visit_if","text":"<pre><code>visit_if(if_: If)\n</code></pre> <p>Implements traversing through IF/ELSE structures.</p> <p>Notice that <code>if_</code> does not have any data directly. Actual IF/ELSE branches are in its <code>body</code> and they are visited separately using :meth:<code>visit_if_branch</code>.</p> <p>Can be overridden to allow modifying the passed in <code>if_</code> without calling :meth:<code>start_if</code> or :meth:<code>end_if</code> nor visiting branches.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_if(self, if_: 'If'):\n    \"\"\"Implements traversing through IF/ELSE structures.\n\n    Notice that ``if_`` does not have any data directly. Actual IF/ELSE\n    branches are in its ``body`` and they are visited separately using\n    :meth:`visit_if_branch`.\n\n    Can be overridden to allow modifying the passed in ``if_`` without\n    calling :meth:`start_if` or :meth:`end_if` nor visiting branches.\n    \"\"\"\n    if self.start_if(if_) is not False:\n        if_.body.visit(self)\n        self.end_if(if_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_if","title":"start_if","text":"<pre><code>start_if(if_: If) -&gt; bool | None\n</code></pre> <p>Called when an IF/ELSE structure starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_if(self, if_: 'If') -&gt; 'bool|None':\n    \"\"\"Called when an IF/ELSE structure starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(if_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_if","title":"end_if","text":"<pre><code>end_if(if_: If)\n</code></pre> <p>Called when an IF/ELSE structure ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_if(self, if_: 'If'):\n    \"\"\"Called when an IF/ELSE structure ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(if_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_if_branch","title":"visit_if_branch","text":"<pre><code>visit_if_branch(branch: IfBranch)\n</code></pre> <p>Implements traversing through single IF/ELSE branch.</p> <p>Can be overridden to allow modifying the passed in <code>branch</code> without calling :meth:<code>start_if_branch</code> or :meth:<code>end_if_branch</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_if_branch(self, branch: 'IfBranch'):\n    \"\"\"Implements traversing through single IF/ELSE branch.\n\n    Can be overridden to allow modifying the passed in ``branch`` without\n    calling :meth:`start_if_branch` or :meth:`end_if_branch` nor visiting body.\n    \"\"\"\n    if self.start_if_branch(branch) is not False:\n        branch.body.visit(self)\n        self.end_if_branch(branch)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_if_branch","title":"start_if_branch","text":"<pre><code>start_if_branch(branch: IfBranch) -&gt; bool | None\n</code></pre> <p>Called when an IF/ELSE branch starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_if_branch(self, branch: 'IfBranch') -&gt; 'bool|None':\n    \"\"\"Called when an IF/ELSE branch starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(branch)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_if_branch","title":"end_if_branch","text":"<pre><code>end_if_branch(branch: IfBranch)\n</code></pre> <p>Called when an IF/ELSE branch ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_if_branch(self, branch: 'IfBranch'):\n    \"\"\"Called when an IF/ELSE branch ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(branch)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_try","title":"visit_try","text":"<pre><code>visit_try(try_: Try)\n</code></pre> <p>Implements traversing through TRY/EXCEPT structures.</p> <p>This method is used with the TRY/EXCEPT root element. Actual TRY, EXCEPT, ELSE and FINALLY branches are visited separately using :meth:<code>visit_try_branch</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_try(self, try_: 'Try'):\n    \"\"\"Implements traversing through TRY/EXCEPT structures.\n\n    This method is used with the TRY/EXCEPT root element. Actual TRY, EXCEPT, ELSE\n    and FINALLY branches are visited separately using :meth:`visit_try_branch`.\n    \"\"\"\n    if self.start_try(try_) is not False:\n        try_.body.visit(self)\n        self.end_try(try_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_try","title":"start_try","text":"<pre><code>start_try(try_: Try) -&gt; bool | None\n</code></pre> <p>Called when a TRY/EXCEPT structure starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_try(self, try_: 'Try') -&gt; 'bool|None':\n    \"\"\"Called when a TRY/EXCEPT structure starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(try_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_try","title":"end_try","text":"<pre><code>end_try(try_: Try)\n</code></pre> <p>Called when a TRY/EXCEPT structure ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_try(self, try_: 'Try'):\n    \"\"\"Called when a TRY/EXCEPT structure ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(try_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_try_branch","title":"visit_try_branch","text":"<pre><code>visit_try_branch(branch: TryBranch)\n</code></pre> <p>Visits individual TRY, EXCEPT, ELSE and FINALLY branches.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_try_branch(self, branch: 'TryBranch'):\n    \"\"\"Visits individual TRY, EXCEPT, ELSE and FINALLY branches.\"\"\"\n    if self.start_try_branch(branch) is not False:\n        branch.body.visit(self)\n        self.end_try_branch(branch)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_try_branch","title":"start_try_branch","text":"<pre><code>start_try_branch(branch: TryBranch) -&gt; bool | None\n</code></pre> <p>Called when TRY, EXCEPT, ELSE or FINALLY branches start.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_try_branch(self, branch: 'TryBranch') -&gt; 'bool|None':\n    \"\"\"Called when TRY, EXCEPT, ELSE or FINALLY branches start.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(branch)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_try_branch","title":"end_try_branch","text":"<pre><code>end_try_branch(branch: TryBranch)\n</code></pre> <p>Called when TRY, EXCEPT, ELSE and FINALLY branches end.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_try_branch(self, branch: 'TryBranch'):\n    \"\"\"Called when TRY, EXCEPT, ELSE and FINALLY branches end.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(branch)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_while","title":"visit_while","text":"<pre><code>visit_while(while_: While)\n</code></pre> <p>Implements traversing through WHILE loops.</p> <p>Can be overridden to allow modifying the passed in <code>while_</code> without calling :meth:<code>start_while</code> or :meth:<code>end_while</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_while(self, while_: 'While'):\n    \"\"\"Implements traversing through WHILE loops.\n\n    Can be overridden to allow modifying the passed in ``while_`` without\n    calling :meth:`start_while` or :meth:`end_while` nor visiting body.\n    \"\"\"\n    if self.start_while(while_) is not False:\n        while_.body.visit(self)\n        self.end_while(while_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_while","title":"start_while","text":"<pre><code>start_while(while_: While) -&gt; bool | None\n</code></pre> <p>Called when a WHILE loop starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_while(self, while_: 'While') -&gt; 'bool|None':\n    \"\"\"Called when a WHILE loop starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(while_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_while","title":"end_while","text":"<pre><code>end_while(while_: While)\n</code></pre> <p>Called when a WHILE loop ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_while(self, while_: 'While'):\n    \"\"\"Called when a WHILE loop ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(while_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_while_iteration","title":"visit_while_iteration","text":"<pre><code>visit_while_iteration(iteration: WhileIteration)\n</code></pre> <p>Implements traversing through single WHILE loop iteration.</p> <p>This is only used with the result side model because on the running side there are no iterations.</p> <p>Can be overridden to allow modifying the passed in <code>iteration</code> without calling :meth:<code>start_while_iteration</code> or :meth:<code>end_while_iteration</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_while_iteration(self, iteration: 'WhileIteration'):\n    \"\"\"Implements traversing through single WHILE loop iteration.\n\n    This is only used with the result side model because on the running side\n    there are no iterations.\n\n    Can be overridden to allow modifying the passed in ``iteration`` without\n    calling :meth:`start_while_iteration` or :meth:`end_while_iteration` nor visiting\n    body.\n    \"\"\"\n    if self.start_while_iteration(iteration) is not False:\n        iteration.body.visit(self)\n        self.end_while_iteration(iteration)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_while_iteration","title":"start_while_iteration","text":"<pre><code>start_while_iteration(\n    iteration: WhileIteration,\n) -&gt; bool | None\n</code></pre> <p>Called when a WHILE loop iteration starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_while_iteration(self, iteration: 'WhileIteration') -&gt; 'bool|None':\n    \"\"\"Called when a WHILE loop iteration starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(iteration)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_while_iteration","title":"end_while_iteration","text":"<pre><code>end_while_iteration(iteration: WhileIteration)\n</code></pre> <p>Called when a WHILE loop iteration ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_while_iteration(self, iteration: 'WhileIteration'):\n    \"\"\"Called when a WHILE loop iteration ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(iteration)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_var","title":"visit_var","text":"<pre><code>visit_var(var: Var)\n</code></pre> <p>Visits a VAR elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_var(self, var: 'Var'):\n    \"\"\"Visits a VAR elements.\"\"\"\n    if self.start_var(var) is not False:\n        self._possible_body(var)\n        self.end_var(var)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_var","title":"start_var","text":"<pre><code>start_var(var: Var) -&gt; bool | None\n</code></pre> <p>Called when a VAR element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_var(self, var: 'Var') -&gt; 'bool|None':\n    \"\"\"Called when a VAR element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(var)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_var","title":"end_var","text":"<pre><code>end_var(var: Var)\n</code></pre> <p>Called when a VAR element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_var(self, var: 'Var'):\n    \"\"\"Called when a VAR element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(var)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_return","title":"visit_return","text":"<pre><code>visit_return(return_: Return)\n</code></pre> <p>Visits a RETURN elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_return(self, return_: 'Return'):\n    \"\"\"Visits a RETURN elements.\"\"\"\n    if self.start_return(return_) is not False:\n        self._possible_body(return_)\n        self.end_return(return_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_return","title":"start_return","text":"<pre><code>start_return(return_: Return) -&gt; bool | None\n</code></pre> <p>Called when a RETURN element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_return(self, return_: 'Return') -&gt; 'bool|None':\n    \"\"\"Called when a RETURN element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(return_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_return","title":"end_return","text":"<pre><code>end_return(return_: Return)\n</code></pre> <p>Called when a RETURN element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_return(self, return_: 'Return'):\n    \"\"\"Called when a RETURN element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(return_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_continue","title":"visit_continue","text":"<pre><code>visit_continue(continue_: Continue)\n</code></pre> <p>Visits CONTINUE elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_continue(self, continue_: 'Continue'):\n    \"\"\"Visits CONTINUE elements.\"\"\"\n    if self.start_continue(continue_) is not False:\n        self._possible_body(continue_)\n        self.end_continue(continue_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_continue","title":"start_continue","text":"<pre><code>start_continue(continue_: Continue) -&gt; bool | None\n</code></pre> <p>Called when a CONTINUE element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_continue(self, continue_: 'Continue') -&gt; 'bool|None':\n    \"\"\"Called when a CONTINUE element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(continue_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_continue","title":"end_continue","text":"<pre><code>end_continue(continue_: Continue)\n</code></pre> <p>Called when a CONTINUE element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_continue(self, continue_: 'Continue'):\n    \"\"\"Called when a CONTINUE element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(continue_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_break","title":"visit_break","text":"<pre><code>visit_break(break_: Break)\n</code></pre> <p>Visits BREAK elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_break(self, break_: 'Break'):\n    \"\"\"Visits BREAK elements.\"\"\"\n    if self.start_break(break_) is not False:\n        self._possible_body(break_)\n        self.end_break(break_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_break","title":"start_break","text":"<pre><code>start_break(break_: Break) -&gt; bool | None\n</code></pre> <p>Called when a BREAK element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_break(self, break_: 'Break') -&gt; 'bool|None':\n    \"\"\"Called when a BREAK element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(break_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_break","title":"end_break","text":"<pre><code>end_break(break_: Break)\n</code></pre> <p>Called when a BREAK element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_break(self, break_: 'Break'):\n    \"\"\"Called when a BREAK element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(break_)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_error","title":"visit_error","text":"<pre><code>visit_error(error: Error)\n</code></pre> <p>Visits body items resulting from invalid syntax.</p> <p>Examples include syntax like <code>END</code> or <code>ELSE</code> in wrong place and invalid setting like <code>[Invalid]</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_error(self, error: 'Error'):\n    \"\"\"Visits body items resulting from invalid syntax.\n\n    Examples include syntax like ``END`` or ``ELSE`` in wrong place and\n    invalid setting like ``[Invalid]``.\n    \"\"\"\n    if self.start_error(error) is not False:\n        self._possible_body(error)\n        self.end_error(error)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_error","title":"start_error","text":"<pre><code>start_error(error: Error) -&gt; bool | None\n</code></pre> <p>Called when a ERROR element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_error(self, error: 'Error') -&gt; 'bool|None':\n    \"\"\"Called when a ERROR element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(error)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_error","title":"end_error","text":"<pre><code>end_error(error: Error)\n</code></pre> <p>Called when a ERROR element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_error(self, error: 'Error'):\n    \"\"\"Called when a ERROR element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(error)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.visit_message","title":"visit_message","text":"<pre><code>visit_message(message: Message)\n</code></pre> <p>Implements visiting messages.</p> <p>Can be overridden to allow modifying the passed in <code>msg</code> without calling :meth:<code>start_message</code> or :meth:<code>end_message</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_message(self, message: 'Message'):\n    \"\"\"Implements visiting messages.\n\n    Can be overridden to allow modifying the passed in ``msg`` without\n    calling :meth:`start_message` or :meth:`end_message`.\n    \"\"\"\n    if self.start_message(message) is not False:\n        self.end_message(message)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_message","title":"start_message","text":"<pre><code>start_message(message: Message) -&gt; bool | None\n</code></pre> <p>Called when a message starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_message(self, message: 'Message') -&gt; 'bool|None':\n    \"\"\"Called when a message starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(message)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_message","title":"end_message","text":"<pre><code>end_message(message: Message)\n</code></pre> <p>Called when a message ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_message(self, message: 'Message'):\n    \"\"\"Called when a message ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(message)\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.start_body_item","title":"start_body_item","text":"<pre><code>start_body_item(item: BodyItem) -&gt; bool | None\n</code></pre> <p>Called, by default, when keywords, messages or control structures start.</p> <p>More specific :meth:<code>start_keyword</code>, :meth:<code>start_message</code>, <code>:meth:</code>start_for`, etc. can be implemented to visit only keywords, messages or specific control structures.</p> <p>Can return explicit <code>False</code> to stop visiting. Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_body_item(self, item: 'BodyItem') -&gt; 'bool|None':\n    \"\"\"Called, by default, when keywords, messages or control structures start.\n\n    More specific :meth:`start_keyword`, :meth:`start_message`, `:meth:`start_for`,\n    etc. can be implemented to visit only keywords, messages or specific control\n    structures.\n\n    Can return explicit ``False`` to stop visiting. Default implementation does\n    nothing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/reporting/xunitwriter/#robot.reporting.xunitwriter.XUnitFileWriter.end_body_item","title":"end_body_item","text":"<pre><code>end_body_item(item: BodyItem)\n</code></pre> <p>Called, by default, when keywords, messages or control structures end.</p> <p>More specific :meth:<code>end_keyword</code>, :meth:<code>end_message</code>, <code>:meth:</code>end_for`, etc. can be implemented to visit only keywords, messages or specific control structures.</p> <p>Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_body_item(self, item: 'BodyItem'):\n    \"\"\"Called, by default, when keywords, messages or control structures end.\n\n    More specific :meth:`end_keyword`, :meth:`end_message`, `:meth:`end_for`,\n    etc. can be implemented to visit only keywords, messages or specific control\n    structures.\n\n    Default implementation does nothing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/","title":"robot.result","text":""},{"location":"api/robot/result/#robot.result","title":"robot.result","text":"<p>Implements parsing execution results from XML output files.</p> <p>The main public API of this package consists of the :func:<code>~.ExecutionResult</code> factory method, that returns :class:<code>~.Result</code> objects, and of the :class:<code>~.ResultVisitor</code> abstract class, that eases further processing the results. It is recommended to import these public entry-points via the :mod:<code>robot.api</code> package like in the example below.</p> <p>The model objects defined in the :mod:<code>robot.result.model</code> module are also part of the public API. They are used inside the :class:<code>~.Result</code> object, and they can also be inspected and modified as part of the normal test execution by using <code>pre-Rebot modifiers</code> and <code>listeners</code>. These model objects are not exposed via :mod:<code>robot.api</code>, but they can be imported from :mod:<code>robot.result</code> if needed.</p>"},{"location":"api/robot/result/#robot.result--example","title":"Example","text":"<p>.. literalinclude:: /../../doc/api/code_examples/check_test_times.py</p> <p>__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#programmatic-modification-of-results __ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-interface</p>"},{"location":"api/robot/result/configurer/","title":"robot.result.configurer","text":""},{"location":"api/robot/result/configurer/#robot.result.configurer","title":"robot.result.configurer","text":""},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer","title":"SuiteConfigurer","text":"<pre><code>SuiteConfigurer(\n    remove_keywords=None,\n    log_level=None,\n    start_time=None,\n    end_time=None,\n    **base_config\n)\n</code></pre> <p>               Bases: <code>SuiteConfigurer</code></p> <p>Result suite configured.</p> <p>Calls suite's :meth:<code>~robot.result.testsuite.TestSuite.remove_keywords</code> and :meth:<code>~robot.result.testsuite.TestSuite.filter_messages</code> methods and sets its start and end time based on the given named parameters.</p> <p><code>base_config</code> is forwarded to :class:<code>robot.model.SuiteConfigurer &lt;robot.model.configurer.SuiteConfigurer&gt;</code> that will do further configuration based on them.</p> Source code in <code>src/robot/result/configurer.py</code> <pre><code>def __init__(self, remove_keywords=None, log_level=None, start_time=None,\n             end_time=None, **base_config):\n    super().__init__(**base_config)\n    self.remove_keywords = self._get_remove_keywords(remove_keywords)\n    self.log_level = log_level\n    self.start_time = self._to_datetime(start_time)\n    self.end_time = self._to_datetime(end_time)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_suite","title":"start_suite","text":"<pre><code>start_suite(suite: TestSuite) -&gt; bool | None\n</code></pre> <p>Called when a suite starts. Default implementation does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_suite(self, suite: 'TestSuite') -&gt; 'bool|None':\n    \"\"\"Called when a suite starts. Default implementation does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_suite","title":"end_suite","text":"<pre><code>end_suite(suite: TestSuite)\n</code></pre> <p>Called when a suite ends. Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_suite(self, suite: 'TestSuite'):\n    \"\"\"Called when a suite ends. Default implementation does nothing.\"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_test","title":"visit_test","text":"<pre><code>visit_test(test: TestCase)\n</code></pre> <p>Implements traversing through tests.</p> <p>Can be overridden to allow modifying the passed in <code>test</code> without calling :meth:<code>start_test</code> or :meth:<code>end_test</code> nor visiting the body of the test.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_test(self, test: 'TestCase'):\n    \"\"\"Implements traversing through tests.\n\n    Can be overridden to allow modifying the passed in ``test`` without calling\n    :meth:`start_test` or :meth:`end_test` nor visiting the body of the test.\n    \"\"\"\n    if self.start_test(test) is not False:\n        if test.has_setup:\n            test.setup.visit(self)\n        test.body.visit(self)\n        if test.has_teardown:\n            test.teardown.visit(self)\n        self.end_test(test)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_test","title":"start_test","text":"<pre><code>start_test(test: TestCase) -&gt; bool | None\n</code></pre> <p>Called when a test starts. Default implementation does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_test(self, test: 'TestCase') -&gt; 'bool|None':\n    \"\"\"Called when a test starts. Default implementation does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_test","title":"end_test","text":"<pre><code>end_test(test: TestCase)\n</code></pre> <p>Called when a test ends. Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_test(self, test: 'TestCase'):\n    \"\"\"Called when a test ends. Default implementation does nothing.\"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_keyword","title":"visit_keyword","text":"<pre><code>visit_keyword(keyword: Keyword)\n</code></pre> <p>Implements traversing through keywords.</p> <p>Can be overridden to allow modifying the passed in <code>kw</code> without calling :meth:<code>start_keyword</code> or :meth:<code>end_keyword</code> nor visiting the body of the keyword</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_keyword(self, keyword: 'Keyword'):\n    \"\"\"Implements traversing through keywords.\n\n    Can be overridden to allow modifying the passed in ``kw`` without\n    calling :meth:`start_keyword` or :meth:`end_keyword` nor visiting\n    the body of the keyword\n    \"\"\"\n    if self.start_keyword(keyword) is not False:\n        self._possible_setup(keyword)\n        self._possible_body(keyword)\n        self._possible_teardown(keyword)\n        self.end_keyword(keyword)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_keyword","title":"start_keyword","text":"<pre><code>start_keyword(keyword: Keyword) -&gt; bool | None\n</code></pre> <p>Called when a keyword starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_keyword(self, keyword: 'Keyword') -&gt; 'bool|None':\n    \"\"\"Called when a keyword starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(keyword)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_keyword","title":"end_keyword","text":"<pre><code>end_keyword(keyword: Keyword)\n</code></pre> <p>Called when a keyword ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_keyword(self, keyword: 'Keyword'):\n    \"\"\"Called when a keyword ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(keyword)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_for","title":"visit_for","text":"<pre><code>visit_for(for_: For)\n</code></pre> <p>Implements traversing through FOR loops.</p> <p>Can be overridden to allow modifying the passed in <code>for_</code> without calling :meth:<code>start_for</code> or :meth:<code>end_for</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_for(self, for_: 'For'):\n    \"\"\"Implements traversing through FOR loops.\n\n    Can be overridden to allow modifying the passed in ``for_`` without\n    calling :meth:`start_for` or :meth:`end_for` nor visiting body.\n    \"\"\"\n    if self.start_for(for_) is not False:\n        for_.body.visit(self)\n        self.end_for(for_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_for","title":"start_for","text":"<pre><code>start_for(for_: For) -&gt; bool | None\n</code></pre> <p>Called when a FOR loop starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_for(self, for_: 'For') -&gt; 'bool|None':\n    \"\"\"Called when a FOR loop starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(for_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_for","title":"end_for","text":"<pre><code>end_for(for_: For)\n</code></pre> <p>Called when a FOR loop ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_for(self, for_: 'For'):\n    \"\"\"Called when a FOR loop ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(for_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_for_iteration","title":"visit_for_iteration","text":"<pre><code>visit_for_iteration(iteration: ForIteration)\n</code></pre> <p>Implements traversing through single FOR loop iteration.</p> <p>This is only used with the result side model because on the running side there are no iterations.</p> <p>Can be overridden to allow modifying the passed in <code>iteration</code> without calling :meth:<code>start_for_iteration</code> or :meth:<code>end_for_iteration</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_for_iteration(self, iteration: 'ForIteration'):\n    \"\"\"Implements traversing through single FOR loop iteration.\n\n    This is only used with the result side model because on the running side\n    there are no iterations.\n\n    Can be overridden to allow modifying the passed in ``iteration`` without\n    calling :meth:`start_for_iteration` or :meth:`end_for_iteration` nor visiting\n    body.\n    \"\"\"\n    if self.start_for_iteration(iteration) is not False:\n        iteration.body.visit(self)\n        self.end_for_iteration(iteration)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_for_iteration","title":"start_for_iteration","text":"<pre><code>start_for_iteration(iteration: ForIteration) -&gt; bool | None\n</code></pre> <p>Called when a FOR loop iteration starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_for_iteration(self, iteration: 'ForIteration') -&gt; 'bool|None':\n    \"\"\"Called when a FOR loop iteration starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(iteration)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_for_iteration","title":"end_for_iteration","text":"<pre><code>end_for_iteration(iteration: ForIteration)\n</code></pre> <p>Called when a FOR loop iteration ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_for_iteration(self, iteration: 'ForIteration'):\n    \"\"\"Called when a FOR loop iteration ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(iteration)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_if","title":"visit_if","text":"<pre><code>visit_if(if_: If)\n</code></pre> <p>Implements traversing through IF/ELSE structures.</p> <p>Notice that <code>if_</code> does not have any data directly. Actual IF/ELSE branches are in its <code>body</code> and they are visited separately using :meth:<code>visit_if_branch</code>.</p> <p>Can be overridden to allow modifying the passed in <code>if_</code> without calling :meth:<code>start_if</code> or :meth:<code>end_if</code> nor visiting branches.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_if(self, if_: 'If'):\n    \"\"\"Implements traversing through IF/ELSE structures.\n\n    Notice that ``if_`` does not have any data directly. Actual IF/ELSE\n    branches are in its ``body`` and they are visited separately using\n    :meth:`visit_if_branch`.\n\n    Can be overridden to allow modifying the passed in ``if_`` without\n    calling :meth:`start_if` or :meth:`end_if` nor visiting branches.\n    \"\"\"\n    if self.start_if(if_) is not False:\n        if_.body.visit(self)\n        self.end_if(if_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_if","title":"start_if","text":"<pre><code>start_if(if_: If) -&gt; bool | None\n</code></pre> <p>Called when an IF/ELSE structure starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_if(self, if_: 'If') -&gt; 'bool|None':\n    \"\"\"Called when an IF/ELSE structure starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(if_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_if","title":"end_if","text":"<pre><code>end_if(if_: If)\n</code></pre> <p>Called when an IF/ELSE structure ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_if(self, if_: 'If'):\n    \"\"\"Called when an IF/ELSE structure ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(if_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_if_branch","title":"visit_if_branch","text":"<pre><code>visit_if_branch(branch: IfBranch)\n</code></pre> <p>Implements traversing through single IF/ELSE branch.</p> <p>Can be overridden to allow modifying the passed in <code>branch</code> without calling :meth:<code>start_if_branch</code> or :meth:<code>end_if_branch</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_if_branch(self, branch: 'IfBranch'):\n    \"\"\"Implements traversing through single IF/ELSE branch.\n\n    Can be overridden to allow modifying the passed in ``branch`` without\n    calling :meth:`start_if_branch` or :meth:`end_if_branch` nor visiting body.\n    \"\"\"\n    if self.start_if_branch(branch) is not False:\n        branch.body.visit(self)\n        self.end_if_branch(branch)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_if_branch","title":"start_if_branch","text":"<pre><code>start_if_branch(branch: IfBranch) -&gt; bool | None\n</code></pre> <p>Called when an IF/ELSE branch starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_if_branch(self, branch: 'IfBranch') -&gt; 'bool|None':\n    \"\"\"Called when an IF/ELSE branch starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(branch)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_if_branch","title":"end_if_branch","text":"<pre><code>end_if_branch(branch: IfBranch)\n</code></pre> <p>Called when an IF/ELSE branch ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_if_branch(self, branch: 'IfBranch'):\n    \"\"\"Called when an IF/ELSE branch ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(branch)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_try","title":"visit_try","text":"<pre><code>visit_try(try_: Try)\n</code></pre> <p>Implements traversing through TRY/EXCEPT structures.</p> <p>This method is used with the TRY/EXCEPT root element. Actual TRY, EXCEPT, ELSE and FINALLY branches are visited separately using :meth:<code>visit_try_branch</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_try(self, try_: 'Try'):\n    \"\"\"Implements traversing through TRY/EXCEPT structures.\n\n    This method is used with the TRY/EXCEPT root element. Actual TRY, EXCEPT, ELSE\n    and FINALLY branches are visited separately using :meth:`visit_try_branch`.\n    \"\"\"\n    if self.start_try(try_) is not False:\n        try_.body.visit(self)\n        self.end_try(try_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_try","title":"start_try","text":"<pre><code>start_try(try_: Try) -&gt; bool | None\n</code></pre> <p>Called when a TRY/EXCEPT structure starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_try(self, try_: 'Try') -&gt; 'bool|None':\n    \"\"\"Called when a TRY/EXCEPT structure starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(try_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_try","title":"end_try","text":"<pre><code>end_try(try_: Try)\n</code></pre> <p>Called when a TRY/EXCEPT structure ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_try(self, try_: 'Try'):\n    \"\"\"Called when a TRY/EXCEPT structure ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(try_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_try_branch","title":"visit_try_branch","text":"<pre><code>visit_try_branch(branch: TryBranch)\n</code></pre> <p>Visits individual TRY, EXCEPT, ELSE and FINALLY branches.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_try_branch(self, branch: 'TryBranch'):\n    \"\"\"Visits individual TRY, EXCEPT, ELSE and FINALLY branches.\"\"\"\n    if self.start_try_branch(branch) is not False:\n        branch.body.visit(self)\n        self.end_try_branch(branch)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_try_branch","title":"start_try_branch","text":"<pre><code>start_try_branch(branch: TryBranch) -&gt; bool | None\n</code></pre> <p>Called when TRY, EXCEPT, ELSE or FINALLY branches start.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_try_branch(self, branch: 'TryBranch') -&gt; 'bool|None':\n    \"\"\"Called when TRY, EXCEPT, ELSE or FINALLY branches start.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(branch)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_try_branch","title":"end_try_branch","text":"<pre><code>end_try_branch(branch: TryBranch)\n</code></pre> <p>Called when TRY, EXCEPT, ELSE and FINALLY branches end.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_try_branch(self, branch: 'TryBranch'):\n    \"\"\"Called when TRY, EXCEPT, ELSE and FINALLY branches end.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(branch)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_while","title":"visit_while","text":"<pre><code>visit_while(while_: While)\n</code></pre> <p>Implements traversing through WHILE loops.</p> <p>Can be overridden to allow modifying the passed in <code>while_</code> without calling :meth:<code>start_while</code> or :meth:<code>end_while</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_while(self, while_: 'While'):\n    \"\"\"Implements traversing through WHILE loops.\n\n    Can be overridden to allow modifying the passed in ``while_`` without\n    calling :meth:`start_while` or :meth:`end_while` nor visiting body.\n    \"\"\"\n    if self.start_while(while_) is not False:\n        while_.body.visit(self)\n        self.end_while(while_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_while","title":"start_while","text":"<pre><code>start_while(while_: While) -&gt; bool | None\n</code></pre> <p>Called when a WHILE loop starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_while(self, while_: 'While') -&gt; 'bool|None':\n    \"\"\"Called when a WHILE loop starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(while_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_while","title":"end_while","text":"<pre><code>end_while(while_: While)\n</code></pre> <p>Called when a WHILE loop ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_while(self, while_: 'While'):\n    \"\"\"Called when a WHILE loop ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(while_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_while_iteration","title":"visit_while_iteration","text":"<pre><code>visit_while_iteration(iteration: WhileIteration)\n</code></pre> <p>Implements traversing through single WHILE loop iteration.</p> <p>This is only used with the result side model because on the running side there are no iterations.</p> <p>Can be overridden to allow modifying the passed in <code>iteration</code> without calling :meth:<code>start_while_iteration</code> or :meth:<code>end_while_iteration</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_while_iteration(self, iteration: 'WhileIteration'):\n    \"\"\"Implements traversing through single WHILE loop iteration.\n\n    This is only used with the result side model because on the running side\n    there are no iterations.\n\n    Can be overridden to allow modifying the passed in ``iteration`` without\n    calling :meth:`start_while_iteration` or :meth:`end_while_iteration` nor visiting\n    body.\n    \"\"\"\n    if self.start_while_iteration(iteration) is not False:\n        iteration.body.visit(self)\n        self.end_while_iteration(iteration)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_while_iteration","title":"start_while_iteration","text":"<pre><code>start_while_iteration(\n    iteration: WhileIteration,\n) -&gt; bool | None\n</code></pre> <p>Called when a WHILE loop iteration starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_while_iteration(self, iteration: 'WhileIteration') -&gt; 'bool|None':\n    \"\"\"Called when a WHILE loop iteration starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(iteration)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_while_iteration","title":"end_while_iteration","text":"<pre><code>end_while_iteration(iteration: WhileIteration)\n</code></pre> <p>Called when a WHILE loop iteration ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_while_iteration(self, iteration: 'WhileIteration'):\n    \"\"\"Called when a WHILE loop iteration ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(iteration)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_var","title":"visit_var","text":"<pre><code>visit_var(var: Var)\n</code></pre> <p>Visits a VAR elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_var(self, var: 'Var'):\n    \"\"\"Visits a VAR elements.\"\"\"\n    if self.start_var(var) is not False:\n        self._possible_body(var)\n        self.end_var(var)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_var","title":"start_var","text":"<pre><code>start_var(var: Var) -&gt; bool | None\n</code></pre> <p>Called when a VAR element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_var(self, var: 'Var') -&gt; 'bool|None':\n    \"\"\"Called when a VAR element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(var)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_var","title":"end_var","text":"<pre><code>end_var(var: Var)\n</code></pre> <p>Called when a VAR element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_var(self, var: 'Var'):\n    \"\"\"Called when a VAR element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(var)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_return","title":"visit_return","text":"<pre><code>visit_return(return_: Return)\n</code></pre> <p>Visits a RETURN elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_return(self, return_: 'Return'):\n    \"\"\"Visits a RETURN elements.\"\"\"\n    if self.start_return(return_) is not False:\n        self._possible_body(return_)\n        self.end_return(return_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_return","title":"start_return","text":"<pre><code>start_return(return_: Return) -&gt; bool | None\n</code></pre> <p>Called when a RETURN element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_return(self, return_: 'Return') -&gt; 'bool|None':\n    \"\"\"Called when a RETURN element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(return_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_return","title":"end_return","text":"<pre><code>end_return(return_: Return)\n</code></pre> <p>Called when a RETURN element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_return(self, return_: 'Return'):\n    \"\"\"Called when a RETURN element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(return_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_continue","title":"visit_continue","text":"<pre><code>visit_continue(continue_: Continue)\n</code></pre> <p>Visits CONTINUE elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_continue(self, continue_: 'Continue'):\n    \"\"\"Visits CONTINUE elements.\"\"\"\n    if self.start_continue(continue_) is not False:\n        self._possible_body(continue_)\n        self.end_continue(continue_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_continue","title":"start_continue","text":"<pre><code>start_continue(continue_: Continue) -&gt; bool | None\n</code></pre> <p>Called when a CONTINUE element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_continue(self, continue_: 'Continue') -&gt; 'bool|None':\n    \"\"\"Called when a CONTINUE element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(continue_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_continue","title":"end_continue","text":"<pre><code>end_continue(continue_: Continue)\n</code></pre> <p>Called when a CONTINUE element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_continue(self, continue_: 'Continue'):\n    \"\"\"Called when a CONTINUE element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(continue_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_break","title":"visit_break","text":"<pre><code>visit_break(break_: Break)\n</code></pre> <p>Visits BREAK elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_break(self, break_: 'Break'):\n    \"\"\"Visits BREAK elements.\"\"\"\n    if self.start_break(break_) is not False:\n        self._possible_body(break_)\n        self.end_break(break_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_break","title":"start_break","text":"<pre><code>start_break(break_: Break) -&gt; bool | None\n</code></pre> <p>Called when a BREAK element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_break(self, break_: 'Break') -&gt; 'bool|None':\n    \"\"\"Called when a BREAK element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(break_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_break","title":"end_break","text":"<pre><code>end_break(break_: Break)\n</code></pre> <p>Called when a BREAK element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_break(self, break_: 'Break'):\n    \"\"\"Called when a BREAK element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(break_)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_error","title":"visit_error","text":"<pre><code>visit_error(error: Error)\n</code></pre> <p>Visits body items resulting from invalid syntax.</p> <p>Examples include syntax like <code>END</code> or <code>ELSE</code> in wrong place and invalid setting like <code>[Invalid]</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_error(self, error: 'Error'):\n    \"\"\"Visits body items resulting from invalid syntax.\n\n    Examples include syntax like ``END`` or ``ELSE`` in wrong place and\n    invalid setting like ``[Invalid]``.\n    \"\"\"\n    if self.start_error(error) is not False:\n        self._possible_body(error)\n        self.end_error(error)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_error","title":"start_error","text":"<pre><code>start_error(error: Error) -&gt; bool | None\n</code></pre> <p>Called when a ERROR element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_error(self, error: 'Error') -&gt; 'bool|None':\n    \"\"\"Called when a ERROR element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(error)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_error","title":"end_error","text":"<pre><code>end_error(error: Error)\n</code></pre> <p>Called when a ERROR element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_error(self, error: 'Error'):\n    \"\"\"Called when a ERROR element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(error)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.visit_message","title":"visit_message","text":"<pre><code>visit_message(message: Message)\n</code></pre> <p>Implements visiting messages.</p> <p>Can be overridden to allow modifying the passed in <code>msg</code> without calling :meth:<code>start_message</code> or :meth:<code>end_message</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_message(self, message: 'Message'):\n    \"\"\"Implements visiting messages.\n\n    Can be overridden to allow modifying the passed in ``msg`` without\n    calling :meth:`start_message` or :meth:`end_message`.\n    \"\"\"\n    if self.start_message(message) is not False:\n        self.end_message(message)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_message","title":"start_message","text":"<pre><code>start_message(message: Message) -&gt; bool | None\n</code></pre> <p>Called when a message starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_message(self, message: 'Message') -&gt; 'bool|None':\n    \"\"\"Called when a message starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(message)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_message","title":"end_message","text":"<pre><code>end_message(message: Message)\n</code></pre> <p>Called when a message ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_message(self, message: 'Message'):\n    \"\"\"Called when a message ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(message)\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.start_body_item","title":"start_body_item","text":"<pre><code>start_body_item(item: BodyItem) -&gt; bool | None\n</code></pre> <p>Called, by default, when keywords, messages or control structures start.</p> <p>More specific :meth:<code>start_keyword</code>, :meth:<code>start_message</code>, <code>:meth:</code>start_for`, etc. can be implemented to visit only keywords, messages or specific control structures.</p> <p>Can return explicit <code>False</code> to stop visiting. Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_body_item(self, item: 'BodyItem') -&gt; 'bool|None':\n    \"\"\"Called, by default, when keywords, messages or control structures start.\n\n    More specific :meth:`start_keyword`, :meth:`start_message`, `:meth:`start_for`,\n    etc. can be implemented to visit only keywords, messages or specific control\n    structures.\n\n    Can return explicit ``False`` to stop visiting. Default implementation does\n    nothing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/configurer/#robot.result.configurer.SuiteConfigurer.end_body_item","title":"end_body_item","text":"<pre><code>end_body_item(item: BodyItem)\n</code></pre> <p>Called, by default, when keywords, messages or control structures end.</p> <p>More specific :meth:<code>end_keyword</code>, :meth:<code>end_message</code>, <code>:meth:</code>end_for`, etc. can be implemented to visit only keywords, messages or specific control structures.</p> <p>Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_body_item(self, item: 'BodyItem'):\n    \"\"\"Called, by default, when keywords, messages or control structures end.\n\n    More specific :meth:`end_keyword`, :meth:`end_message`, `:meth:`end_for`,\n    etc. can be implemented to visit only keywords, messages or specific control\n    structures.\n\n    Default implementation does nothing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/executionerrors/","title":"robot.result.executionerrors","text":""},{"location":"api/robot/result/executionerrors/#robot.result.executionerrors","title":"robot.result.executionerrors","text":""},{"location":"api/robot/result/executionerrors/#robot.result.executionerrors.ExecutionErrors","title":"ExecutionErrors","text":"<pre><code>ExecutionErrors(messages: Sequence[Message] = ())\n</code></pre> <p>Represents errors occurred during the execution of tests.</p> <p>An error might be, for example, that importing a library has failed.</p> Source code in <code>src/robot/result/executionerrors.py</code> <pre><code>def __init__(self, messages: Sequence[Message] = ()):\n    self.messages = messages\n</code></pre>"},{"location":"api/robot/result/executionresult/","title":"robot.result.executionresult","text":""},{"location":"api/robot/result/executionresult/#robot.result.executionresult","title":"robot.result.executionresult","text":""},{"location":"api/robot/result/executionresult/#robot.result.executionresult.Result","title":"Result","text":"<pre><code>Result(\n    source: Path | str | None = None,\n    suite: TestSuite | None = None,\n    errors: ExecutionErrors | None = None,\n    rpa: bool | None = None,\n    generator: str = \"unknown\",\n    generation_time: datetime | None = None,\n)\n</code></pre> <p>Test execution results.</p> <p>Can be created based on XML output files using the :func:<code>~.resultbuilder.ExecutionResult</code> factory method. Also returned by the :meth:<code>robot.running.TestSuite.run &lt;robot.running.model.TestSuite.run&gt;</code> method.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def __init__(self, source: 'Path|str|None' = None,\n             suite: 'TestSuite|None' = None,\n             errors: 'ExecutionErrors|None' = None,\n             rpa: 'bool|None' = None,\n             generator: str = 'unknown',\n             generation_time: 'datetime|None' = None):\n    self.source = Path(source) if isinstance(source, str) else source\n    self.suite = suite or TestSuite()\n    self.errors = errors or ExecutionErrors()\n    self.rpa = rpa\n    self.generator = generator\n    self.generation_time = generation_time\n    self._status_rc = True\n    self._stat_config = {}\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.Result.statistics","title":"statistics  <code>property</code>","text":"<pre><code>statistics: Statistics\n</code></pre> <p>Execution statistics.</p> <p>Statistics are created based on the contained <code>suite</code> and possible :func:<code>configuration &lt;configure&gt;</code>.</p> <p>Statistics are created every time this property is accessed. Saving them to a variable is thus often a good idea to avoid re-creating them unnecessarily::</p> <pre><code>from robot.api import ExecutionResult\n\nresult = ExecutionResult('output.xml')\nresult.configure(stat_config={'suite_stat_level': 2,\n                              'tag_stat_combine': 'tagANDanother'})\nstats = result.statistics\nprint(stats.total.failed)\nprint(stats.total.passed)\nprint(stats.tags.combined[0].total)\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.Result.return_code","title":"return_code  <code>property</code>","text":"<pre><code>return_code: int\n</code></pre> <p>Execution return code.</p> <p>By default, returns the number of failed tests or tasks (max 250), but can be :func:<code>configured &lt;configure&gt;</code> to always return 0.</p>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.Result.configure","title":"configure","text":"<pre><code>configure(\n    status_rc=True, suite_config=None, stat_config=None\n)\n</code></pre> <p>Configures the result object and objects it contains.</p> <p>:param status_rc: If set to <code>False</code>, :attr:<code>return_code</code> always     returns 0. :param suite_config: A dictionary of configuration options passed     to :meth:<code>~.result.testsuite.TestSuite.configure</code> method of     the contained <code>suite</code>. :param stat_config: A dictionary of configuration options used when     creating :attr:<code>statistics</code>.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def configure(self, status_rc=True, suite_config=None, stat_config=None):\n    \"\"\"Configures the result object and objects it contains.\n\n    :param status_rc: If set to ``False``, :attr:`return_code` always\n        returns 0.\n    :param suite_config: A dictionary of configuration options passed\n        to :meth:`~.result.testsuite.TestSuite.configure` method of\n        the contained ``suite``.\n    :param stat_config: A dictionary of configuration options used when\n        creating :attr:`statistics`.\n    \"\"\"\n    if suite_config:\n        self.suite.configure(**suite_config)\n    self._status_rc = status_rc\n    self._stat_config = stat_config or {}\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.Result.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; Result\n</code></pre> <p>Construct a result object from JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>Data can contain either:</p> <ul> <li>full result data (contains suite information, execution errors, etc.)   got, for example, from the :meth:<code>to_json</code> method, or</li> <li>only suite information got, for example, from   :meth:<code>result.testsuite.TestSuite.to_json &lt;TestSuite.to_json&gt;</code>.</li> </ul> <p>:attr:<code>statistics</code> are populated automatically based on suite information and thus ignored if they are present in the data.</p> <p>New in Robot Framework 7.2.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>@classmethod\ndef from_json(cls, source: 'str|bytes|TextIO|Path') -&gt; 'Result':\n    \"\"\"Construct a result object from JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    Data can contain either:\n\n    - full result data (contains suite information, execution errors, etc.)\n      got, for example, from the :meth:`to_json` method, or\n    - only suite information got, for example, from\n      :meth:`result.testsuite.TestSuite.to_json &lt;TestSuite.to_json&gt;`.\n\n    :attr:`statistics` are populated automatically based on suite information\n    and thus ignored if they are present in the data.\n\n    New in Robot Framework 7.2.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    if 'suite' in data:\n        result = cls._from_full_json(data)\n    else:\n        result = cls._from_suite_json(data)\n    if isinstance(source, Path):\n        result.source = source\n    elif isinstance(source, str) and source[0] != '{' and Path(source).exists():\n        result.source = Path(source)\n    return result\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.Result.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    include_statistics: bool = True,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    include_statistics: bool = True,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    include_statistics: bool = True,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize results into JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>The <code>include_statistics</code> controls including statistics information in the resulting JSON data. Statistics are not needed if the serialized JSON data is converted back to a <code>Result</code> object, but they can be useful for external tools.</p> <p>The remaining optional parameters are used for JSON formatting. They are passed directly to the underlying json__ module, but the defaults differ from what <code>json</code> uses.</p> <p>New in Robot Framework 7.2.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            include_statistics: bool = True,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize results into JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    The ``include_statistics`` controls including statistics information\n    in the resulting JSON data. Statistics are not needed if the serialized\n    JSON data is converted back to a ``Result`` object, but they can be\n    useful for external tools.\n\n    The remaining optional parameters are used for JSON formatting.\n    They are passed directly to the underlying json__ module, but\n    the defaults differ from what ``json`` uses.\n\n    New in Robot Framework 7.2.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    data = {'generator': get_full_version('Rebot'),\n            'generated': datetime.now().isoformat(),\n            'rpa': self.rpa,\n            'suite': self.suite.to_dict()}\n    if include_statistics:\n        data['statistics'] = self.statistics.to_dict()\n    data['errors'] = self.errors.messages.to_dicts()\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(data, file)\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.Result.save","title":"save","text":"<pre><code>save(target=None, legacy_output=False)\n</code></pre> <p>Save results as XML or JSON file.</p> <p>:param target: Target where to save results to. Can be a path     (<code>pathlib.Path</code> or <code>str</code>) or an open file object. If omitted,     uses the :attr:<code>source</code> which overwrites the original file. :param legacy_output: Save XML results in Robot Framework 6.x compatible     format. New in Robot Framework 7.0.</p> <p>File type is got based on the <code>target</code>. The type is JSON if the <code>target</code> is a path that has a <code>.json</code> suffix or if it is an open file that has a <code>name</code> attribute with a <code>.json</code> suffix. Otherwise, the type is XML.</p> <p>It is also possible to use :meth:<code>to_json</code> for JSON serialization. Compared to this method, it allows returning the JSON in addition to writing it into a file, and it also supports customizing JSON formatting.</p> <p>Support for saving results in JSON is new in Robot Framework 7.0. Originally only suite information was saved in that case, but starting from Robot Framework 7.2, also JSON results contain full result data including, for example, execution errors and statistics.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def save(self, target=None, legacy_output=False):\n    \"\"\"Save results as XML or JSON file.\n\n    :param target: Target where to save results to. Can be a path\n        (``pathlib.Path`` or ``str``) or an open file object. If omitted,\n        uses the :attr:`source` which overwrites the original file.\n    :param legacy_output: Save XML results in Robot Framework 6.x compatible\n        format. New in Robot Framework 7.0.\n\n    File type is got based on the ``target``. The type is JSON if the ``target``\n    is a path that has a ``.json`` suffix or if it is an open file that has\n    a ``name`` attribute with a ``.json`` suffix. Otherwise, the type is XML.\n\n    It is also possible to use :meth:`to_json` for JSON serialization. Compared\n    to this method, it allows returning the JSON in addition to writing it\n    into a file, and it also supports customizing JSON formatting.\n\n    Support for saving results in JSON is new in Robot Framework 7.0.\n    Originally only suite information was saved in that case, but starting\n    from Robot Framework 7.2, also JSON results contain full result data\n    including, for example, execution errors and statistics.\n    \"\"\"\n    from robot.reporting.outputwriter import LegacyOutputWriter, OutputWriter\n\n    target = target or self.source\n    if not target:\n        raise ValueError('Path required.')\n    if is_json_source(target):\n        self.to_json(target)\n    else:\n        writer = OutputWriter if not legacy_output else LegacyOutputWriter\n        self.visit(writer(target, rpa=self.rpa))\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.Result.visit","title":"visit","text":"<pre><code>visit(visitor)\n</code></pre> <p>An entry point to visit the whole result object.</p> <p>:param visitor: An instance of :class:<code>~.visitor.ResultVisitor</code>.</p> <p>Visitors can gather information, modify results, etc. See :mod:<code>~robot.result</code> package for a simple usage example.</p> <p>Notice that it is also possible to call :meth:<code>result.suite.visit &lt;robot.result.testsuite.TestSuite.visit&gt;</code> if there is no need to visit the contained <code>statistics</code> or <code>errors</code>.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def visit(self, visitor):\n    \"\"\"An entry point to visit the whole result object.\n\n    :param visitor: An instance of :class:`~.visitor.ResultVisitor`.\n\n    Visitors can gather information, modify results, etc. See\n    :mod:`~robot.result` package for a simple usage example.\n\n    Notice that it is also possible to call :meth:`result.suite.visit\n    &lt;robot.result.testsuite.TestSuite.visit&gt;` if there is no need to\n    visit the contained ``statistics`` or ``errors``.\n    \"\"\"\n    visitor.visit_result(self)\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.Result.handle_suite_teardown_failures","title":"handle_suite_teardown_failures","text":"<pre><code>handle_suite_teardown_failures()\n</code></pre> <p>Internal usage only.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def handle_suite_teardown_failures(self):\n    \"\"\"Internal usage only.\"\"\"\n    if self.generated_by_robot:\n        self.suite.handle_suite_teardown_failures()\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.Result.set_execution_mode","title":"set_execution_mode","text":"<pre><code>set_execution_mode(other)\n</code></pre> <p>Set execution mode based on other result. Internal usage only.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def set_execution_mode(self, other):\n    \"\"\"Set execution mode based on other result. Internal usage only.\"\"\"\n    if other.rpa is None:\n        pass\n    elif self.rpa is None:\n        self.rpa = other.rpa\n    elif self.rpa is not other.rpa:\n        this, that = ('task', 'test') if other.rpa else ('test', 'task')\n        raise DataError(\"Conflicting execution modes. File '%s' has %ss \"\n                        \"but files parsed earlier have %ss. Use '--rpa' \"\n                        \"or '--norpa' options to set the execution mode \"\n                        \"explicitly.\" % (other.source, this, that))\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.CombinedResult","title":"CombinedResult","text":"<pre><code>CombinedResult(results=None)\n</code></pre> <p>               Bases: <code>Result</code></p> <p>Combined results of multiple test executions.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def __init__(self, results=None):\n    super().__init__()\n    for result in results or ():\n        self.add_result(result)\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.CombinedResult.statistics","title":"statistics  <code>property</code>","text":"<pre><code>statistics: Statistics\n</code></pre> <p>Execution statistics.</p> <p>Statistics are created based on the contained <code>suite</code> and possible :func:<code>configuration &lt;configure&gt;</code>.</p> <p>Statistics are created every time this property is accessed. Saving them to a variable is thus often a good idea to avoid re-creating them unnecessarily::</p> <pre><code>from robot.api import ExecutionResult\n\nresult = ExecutionResult('output.xml')\nresult.configure(stat_config={'suite_stat_level': 2,\n                              'tag_stat_combine': 'tagANDanother'})\nstats = result.statistics\nprint(stats.total.failed)\nprint(stats.total.passed)\nprint(stats.tags.combined[0].total)\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.CombinedResult.return_code","title":"return_code  <code>property</code>","text":"<pre><code>return_code: int\n</code></pre> <p>Execution return code.</p> <p>By default, returns the number of failed tests or tasks (max 250), but can be :func:<code>configured &lt;configure&gt;</code> to always return 0.</p>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.CombinedResult.configure","title":"configure","text":"<pre><code>configure(\n    status_rc=True, suite_config=None, stat_config=None\n)\n</code></pre> <p>Configures the result object and objects it contains.</p> <p>:param status_rc: If set to <code>False</code>, :attr:<code>return_code</code> always     returns 0. :param suite_config: A dictionary of configuration options passed     to :meth:<code>~.result.testsuite.TestSuite.configure</code> method of     the contained <code>suite</code>. :param stat_config: A dictionary of configuration options used when     creating :attr:<code>statistics</code>.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def configure(self, status_rc=True, suite_config=None, stat_config=None):\n    \"\"\"Configures the result object and objects it contains.\n\n    :param status_rc: If set to ``False``, :attr:`return_code` always\n        returns 0.\n    :param suite_config: A dictionary of configuration options passed\n        to :meth:`~.result.testsuite.TestSuite.configure` method of\n        the contained ``suite``.\n    :param stat_config: A dictionary of configuration options used when\n        creating :attr:`statistics`.\n    \"\"\"\n    if suite_config:\n        self.suite.configure(**suite_config)\n    self._status_rc = status_rc\n    self._stat_config = stat_config or {}\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.CombinedResult.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; Result\n</code></pre> <p>Construct a result object from JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>Data can contain either:</p> <ul> <li>full result data (contains suite information, execution errors, etc.)   got, for example, from the :meth:<code>to_json</code> method, or</li> <li>only suite information got, for example, from   :meth:<code>result.testsuite.TestSuite.to_json &lt;TestSuite.to_json&gt;</code>.</li> </ul> <p>:attr:<code>statistics</code> are populated automatically based on suite information and thus ignored if they are present in the data.</p> <p>New in Robot Framework 7.2.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>@classmethod\ndef from_json(cls, source: 'str|bytes|TextIO|Path') -&gt; 'Result':\n    \"\"\"Construct a result object from JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    Data can contain either:\n\n    - full result data (contains suite information, execution errors, etc.)\n      got, for example, from the :meth:`to_json` method, or\n    - only suite information got, for example, from\n      :meth:`result.testsuite.TestSuite.to_json &lt;TestSuite.to_json&gt;`.\n\n    :attr:`statistics` are populated automatically based on suite information\n    and thus ignored if they are present in the data.\n\n    New in Robot Framework 7.2.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    if 'suite' in data:\n        result = cls._from_full_json(data)\n    else:\n        result = cls._from_suite_json(data)\n    if isinstance(source, Path):\n        result.source = source\n    elif isinstance(source, str) and source[0] != '{' and Path(source).exists():\n        result.source = Path(source)\n    return result\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.CombinedResult.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    include_statistics: bool = True,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    include_statistics: bool = True,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    include_statistics: bool = True,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize results into JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>The <code>include_statistics</code> controls including statistics information in the resulting JSON data. Statistics are not needed if the serialized JSON data is converted back to a <code>Result</code> object, but they can be useful for external tools.</p> <p>The remaining optional parameters are used for JSON formatting. They are passed directly to the underlying json__ module, but the defaults differ from what <code>json</code> uses.</p> <p>New in Robot Framework 7.2.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            include_statistics: bool = True,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize results into JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    The ``include_statistics`` controls including statistics information\n    in the resulting JSON data. Statistics are not needed if the serialized\n    JSON data is converted back to a ``Result`` object, but they can be\n    useful for external tools.\n\n    The remaining optional parameters are used for JSON formatting.\n    They are passed directly to the underlying json__ module, but\n    the defaults differ from what ``json`` uses.\n\n    New in Robot Framework 7.2.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    data = {'generator': get_full_version('Rebot'),\n            'generated': datetime.now().isoformat(),\n            'rpa': self.rpa,\n            'suite': self.suite.to_dict()}\n    if include_statistics:\n        data['statistics'] = self.statistics.to_dict()\n    data['errors'] = self.errors.messages.to_dicts()\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(data, file)\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.CombinedResult.save","title":"save","text":"<pre><code>save(target=None, legacy_output=False)\n</code></pre> <p>Save results as XML or JSON file.</p> <p>:param target: Target where to save results to. Can be a path     (<code>pathlib.Path</code> or <code>str</code>) or an open file object. If omitted,     uses the :attr:<code>source</code> which overwrites the original file. :param legacy_output: Save XML results in Robot Framework 6.x compatible     format. New in Robot Framework 7.0.</p> <p>File type is got based on the <code>target</code>. The type is JSON if the <code>target</code> is a path that has a <code>.json</code> suffix or if it is an open file that has a <code>name</code> attribute with a <code>.json</code> suffix. Otherwise, the type is XML.</p> <p>It is also possible to use :meth:<code>to_json</code> for JSON serialization. Compared to this method, it allows returning the JSON in addition to writing it into a file, and it also supports customizing JSON formatting.</p> <p>Support for saving results in JSON is new in Robot Framework 7.0. Originally only suite information was saved in that case, but starting from Robot Framework 7.2, also JSON results contain full result data including, for example, execution errors and statistics.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def save(self, target=None, legacy_output=False):\n    \"\"\"Save results as XML or JSON file.\n\n    :param target: Target where to save results to. Can be a path\n        (``pathlib.Path`` or ``str``) or an open file object. If omitted,\n        uses the :attr:`source` which overwrites the original file.\n    :param legacy_output: Save XML results in Robot Framework 6.x compatible\n        format. New in Robot Framework 7.0.\n\n    File type is got based on the ``target``. The type is JSON if the ``target``\n    is a path that has a ``.json`` suffix or if it is an open file that has\n    a ``name`` attribute with a ``.json`` suffix. Otherwise, the type is XML.\n\n    It is also possible to use :meth:`to_json` for JSON serialization. Compared\n    to this method, it allows returning the JSON in addition to writing it\n    into a file, and it also supports customizing JSON formatting.\n\n    Support for saving results in JSON is new in Robot Framework 7.0.\n    Originally only suite information was saved in that case, but starting\n    from Robot Framework 7.2, also JSON results contain full result data\n    including, for example, execution errors and statistics.\n    \"\"\"\n    from robot.reporting.outputwriter import LegacyOutputWriter, OutputWriter\n\n    target = target or self.source\n    if not target:\n        raise ValueError('Path required.')\n    if is_json_source(target):\n        self.to_json(target)\n    else:\n        writer = OutputWriter if not legacy_output else LegacyOutputWriter\n        self.visit(writer(target, rpa=self.rpa))\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.CombinedResult.visit","title":"visit","text":"<pre><code>visit(visitor)\n</code></pre> <p>An entry point to visit the whole result object.</p> <p>:param visitor: An instance of :class:<code>~.visitor.ResultVisitor</code>.</p> <p>Visitors can gather information, modify results, etc. See :mod:<code>~robot.result</code> package for a simple usage example.</p> <p>Notice that it is also possible to call :meth:<code>result.suite.visit &lt;robot.result.testsuite.TestSuite.visit&gt;</code> if there is no need to visit the contained <code>statistics</code> or <code>errors</code>.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def visit(self, visitor):\n    \"\"\"An entry point to visit the whole result object.\n\n    :param visitor: An instance of :class:`~.visitor.ResultVisitor`.\n\n    Visitors can gather information, modify results, etc. See\n    :mod:`~robot.result` package for a simple usage example.\n\n    Notice that it is also possible to call :meth:`result.suite.visit\n    &lt;robot.result.testsuite.TestSuite.visit&gt;` if there is no need to\n    visit the contained ``statistics`` or ``errors``.\n    \"\"\"\n    visitor.visit_result(self)\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.CombinedResult.handle_suite_teardown_failures","title":"handle_suite_teardown_failures","text":"<pre><code>handle_suite_teardown_failures()\n</code></pre> <p>Internal usage only.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def handle_suite_teardown_failures(self):\n    \"\"\"Internal usage only.\"\"\"\n    if self.generated_by_robot:\n        self.suite.handle_suite_teardown_failures()\n</code></pre>"},{"location":"api/robot/result/executionresult/#robot.result.executionresult.CombinedResult.set_execution_mode","title":"set_execution_mode","text":"<pre><code>set_execution_mode(other)\n</code></pre> <p>Set execution mode based on other result. Internal usage only.</p> Source code in <code>src/robot/result/executionresult.py</code> <pre><code>def set_execution_mode(self, other):\n    \"\"\"Set execution mode based on other result. Internal usage only.\"\"\"\n    if other.rpa is None:\n        pass\n    elif self.rpa is None:\n        self.rpa = other.rpa\n    elif self.rpa is not other.rpa:\n        this, that = ('task', 'test') if other.rpa else ('test', 'task')\n        raise DataError(\"Conflicting execution modes. File '%s' has %ss \"\n                        \"but files parsed earlier have %ss. Use '--rpa' \"\n                        \"or '--norpa' options to set the execution mode \"\n                        \"explicitly.\" % (other.source, this, that))\n</code></pre>"},{"location":"api/robot/result/flattenkeywordmatcher/","title":"robot.result.flattenkeywordmatcher","text":""},{"location":"api/robot/result/flattenkeywordmatcher/#robot.result.flattenkeywordmatcher","title":"robot.result.flattenkeywordmatcher","text":""},{"location":"api/robot/result/keywordremover/","title":"robot.result.keywordremover","text":""},{"location":"api/robot/result/keywordremover/#robot.result.keywordremover","title":"robot.result.keywordremover","text":""},{"location":"api/robot/result/merger/","title":"robot.result.merger","text":""},{"location":"api/robot/result/merger/#robot.result.merger","title":"robot.result.merger","text":""},{"location":"api/robot/result/messagefilter/","title":"robot.result.messagefilter","text":""},{"location":"api/robot/result/messagefilter/#robot.result.messagefilter","title":"robot.result.messagefilter","text":""},{"location":"api/robot/result/model/","title":"robot.result.model","text":""},{"location":"api/robot/result/model/#robot.result.model","title":"robot.result.model","text":"<p>Module implementing result related model objects.</p> <p>During test execution these objects are created internally by various runners. At that time they can be inspected and modified by listeners__.</p> <p>When results are parsed from XML output files after execution to be able to create logs and reports, these objects are created by the :func:<code>~.resultbuilder.ExecutionResult</code> factory method. At that point they can be inspected and modified by <code>pre-Rebot modifiers</code>__.</p> <p>The :func:<code>~.resultbuilder.ExecutionResult</code> factory method can also be used by custom scripts and tools. In such usage it is often easiest to inspect and modify these objects using the :mod:<code>visitor interface &lt;robot.model.visitor&gt;</code>.</p> <p>If classes defined here are needed, for example, as type hints, they can be imported via the :mod:<code>robot.running</code> module.</p> <p>__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-interface __ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#programmatic-modification-of-results</p>"},{"location":"api/robot/result/model/#robot.result.model.StatusMixin","title":"StatusMixin","text":""},{"location":"api/robot/result/model/#robot.result.model.StatusMixin.start_time","title":"start_time  <code>property</code> <code>writable</code>","text":"<pre><code>start_time: datetime | None\n</code></pre> <p>Execution start time as a <code>datetime</code> or as a <code>None</code> if not set.</p> <p>If start time is not set, it is calculated based :attr:<code>end_time</code> and :attr:<code>elapsed_time</code> if possible.</p> <p>Can be set either directly as a <code>datetime</code> or as a string in ISO 8601 format.</p> <p>New in Robot Framework 6.1. Heavily enhanced in Robot Framework 7.0.</p>"},{"location":"api/robot/result/model/#robot.result.model.StatusMixin.end_time","title":"end_time  <code>property</code> <code>writable</code>","text":"<pre><code>end_time: datetime | None\n</code></pre> <p>Execution end time as a <code>datetime</code> or as a <code>None</code> if not set.</p> <p>If end time is not set, it is calculated based :attr:<code>start_time</code> and :attr:<code>elapsed_time</code> if possible.</p> <p>Can be set either directly as a <code>datetime</code> or as a string in ISO 8601 format.</p> <p>New in Robot Framework 6.1. Heavily enhanced in Robot Framework 7.0.</p>"},{"location":"api/robot/result/model/#robot.result.model.StatusMixin.elapsed_time","title":"elapsed_time  <code>property</code> <code>writable</code>","text":"<pre><code>elapsed_time: timedelta\n</code></pre> <p>Total execution time as a <code>timedelta</code>.</p> <p>If not set, calculated based on :attr:<code>start_time</code> and :attr:<code>end_time</code> if possible. If that fails, calculated based on the elapsed time of child items.</p> <p>Can be set either directly as a <code>timedelta</code> or as an integer or a float representing seconds.</p> <p>New in Robot Framework 6.1. Heavily enhanced in Robot Framework 7.0.</p>"},{"location":"api/robot/result/model/#robot.result.model.StatusMixin.starttime","title":"starttime  <code>property</code> <code>writable</code>","text":"<pre><code>starttime: str | None\n</code></pre> <p>Execution start time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>start_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.StatusMixin.endtime","title":"endtime  <code>property</code> <code>writable</code>","text":"<pre><code>endtime: str | None\n</code></pre> <p>Execution end time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>end_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.StatusMixin.elapsedtime","title":"elapsedtime  <code>property</code>","text":"<pre><code>elapsedtime: int\n</code></pre> <p>Total execution time in milliseconds.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>elapsed_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.StatusMixin.passed","title":"passed  <code>property</code> <code>writable</code>","text":"<pre><code>passed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'PASS', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.StatusMixin.failed","title":"failed  <code>property</code> <code>writable</code>","text":"<pre><code>failed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'FAIL', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.StatusMixin.skipped","title":"skipped  <code>property</code> <code>writable</code>","text":"<pre><code>skipped: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'SKIP', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.StatusMixin.not_run","title":"not_run  <code>property</code> <code>writable</code>","text":"<pre><code>not_run: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'NOT RUN', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Var","title":"Var","text":"<pre><code>Var(\n    name: str = \"\",\n    value: str | Sequence[str] = (),\n    scope: str | None = None,\n    separator: str | None = None,\n    status: str = \"FAIL\",\n    message: str = \"\",\n    start_time: datetime | str | None = None,\n    end_time: datetime | str | None = None,\n    elapsed_time: timedelta | int | float | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>Var</code>, <code>StatusMixin</code>, <code>DeprecatedAttributesMixin</code></p> Source code in <code>src/robot/result/model.py</code> <pre><code>def __init__(self, name: str = '',\n             value: 'str|Sequence[str]' = (),\n             scope: 'str|None' = None,\n             separator: 'str|None' = None,\n             status: str = 'FAIL',\n             message: str = '',\n             start_time: 'datetime|str|None' = None,\n             end_time: 'datetime|str|None' = None,\n             elapsed_time: 'timedelta|int|float|None' = None,\n             parent: BodyItemParent = None):\n    super().__init__(name, value, scope, separator, parent)\n    self.status = status\n    self.message = message\n    self.start_time = start_time\n    self.end_time = end_time\n    self.elapsed_time = elapsed_time\n    self.body = ()\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Var.starttime","title":"starttime  <code>property</code> <code>writable</code>","text":"<pre><code>starttime: str | None\n</code></pre> <p>Execution start time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>start_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Var.endtime","title":"endtime  <code>property</code> <code>writable</code>","text":"<pre><code>endtime: str | None\n</code></pre> <p>Execution end time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>end_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Var.elapsedtime","title":"elapsedtime  <code>property</code>","text":"<pre><code>elapsedtime: int\n</code></pre> <p>Total execution time in milliseconds.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>elapsed_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Var.passed","title":"passed  <code>property</code> <code>writable</code>","text":"<pre><code>passed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'PASS', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Var.failed","title":"failed  <code>property</code> <code>writable</code>","text":"<pre><code>failed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'FAIL', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Var.skipped","title":"skipped  <code>property</code> <code>writable</code>","text":"<pre><code>skipped: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'SKIP', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Var.not_run","title":"not_run  <code>property</code> <code>writable</code>","text":"<pre><code>not_run: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'NOT RUN', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Var.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Var.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Var.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Var.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Var.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Var.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Var.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/result/model/#robot.result.model.Var.body","title":"body","text":"<pre><code>body(body: Sequence[BodyItem | DataDict]) -&gt; Body\n</code></pre> <p>Child keywords and messages as a :class:<code>~.Body</code> object.</p> <p>Typically empty. Only contains something if running VAR has failed due to a syntax error or listeners have logged messages or executed keywords.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>@setter\ndef body(self, body: 'Sequence[BodyItem|DataDict]') -&gt; Body:\n    \"\"\"Child keywords and messages as a :class:`~.Body` object.\n\n    Typically empty. Only contains something if running VAR has failed\n    due to a syntax error or listeners have logged messages or executed\n    keywords.\n    \"\"\"\n    return self.body_class(self, body)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Return","title":"Return","text":"<pre><code>Return(\n    values: Sequence[str] = (),\n    status: str = \"FAIL\",\n    message: str = \"\",\n    start_time: datetime | str | None = None,\n    end_time: datetime | str | None = None,\n    elapsed_time: timedelta | int | float | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>Return</code>, <code>StatusMixin</code>, <code>DeprecatedAttributesMixin</code></p> Source code in <code>src/robot/result/model.py</code> <pre><code>def __init__(self, values: Sequence[str] = (),\n             status: str = 'FAIL',\n             message: str = '',\n             start_time: 'datetime|str|None' = None,\n             end_time: 'datetime|str|None' = None,\n             elapsed_time: 'timedelta|int|float|None' = None,\n             parent: BodyItemParent = None):\n    super().__init__(values, parent)\n    self.status = status\n    self.message = message\n    self.start_time = start_time\n    self.end_time = end_time\n    self.elapsed_time = elapsed_time\n    self.body = ()\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Return.starttime","title":"starttime  <code>property</code> <code>writable</code>","text":"<pre><code>starttime: str | None\n</code></pre> <p>Execution start time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>start_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Return.endtime","title":"endtime  <code>property</code> <code>writable</code>","text":"<pre><code>endtime: str | None\n</code></pre> <p>Execution end time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>end_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Return.elapsedtime","title":"elapsedtime  <code>property</code>","text":"<pre><code>elapsedtime: int\n</code></pre> <p>Total execution time in milliseconds.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>elapsed_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Return.passed","title":"passed  <code>property</code> <code>writable</code>","text":"<pre><code>passed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'PASS', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Return.failed","title":"failed  <code>property</code> <code>writable</code>","text":"<pre><code>failed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'FAIL', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Return.skipped","title":"skipped  <code>property</code> <code>writable</code>","text":"<pre><code>skipped: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'SKIP', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Return.not_run","title":"not_run  <code>property</code> <code>writable</code>","text":"<pre><code>not_run: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'NOT RUN', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Return.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Return.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Return.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Return.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Return.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Return.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Return.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/result/model/#robot.result.model.Return.body","title":"body","text":"<pre><code>body(body: Sequence[BodyItem | DataDict]) -&gt; Body\n</code></pre> <p>Child keywords and messages as a :class:<code>~.Body</code> object.</p> <p>Typically empty. Only contains something if running RETURN has failed due to a syntax error or listeners have logged messages or executed keywords.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>@setter\ndef body(self, body: 'Sequence[BodyItem|DataDict]') -&gt; Body:\n    \"\"\"Child keywords and messages as a :class:`~.Body` object.\n\n    Typically empty. Only contains something if running RETURN has failed\n    due to a syntax error or listeners have logged messages or executed\n    keywords.\n    \"\"\"\n    return self.body_class(self, body)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Continue","title":"Continue","text":"<pre><code>Continue(\n    status: str = \"FAIL\",\n    message: str = \"\",\n    start_time: datetime | str | None = None,\n    end_time: datetime | str | None = None,\n    elapsed_time: timedelta | int | float | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>Continue</code>, <code>StatusMixin</code>, <code>DeprecatedAttributesMixin</code></p> Source code in <code>src/robot/result/model.py</code> <pre><code>def __init__(self, status: str = 'FAIL',\n             message: str = '',\n             start_time: 'datetime|str|None' = None,\n             end_time: 'datetime|str|None' = None,\n             elapsed_time: 'timedelta|int|float|None' = None,\n             parent: BodyItemParent = None):\n    super().__init__(parent)\n    self.status = status\n    self.message = message\n    self.start_time = start_time\n    self.end_time = end_time\n    self.elapsed_time = elapsed_time\n    self.body = ()\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Continue.starttime","title":"starttime  <code>property</code> <code>writable</code>","text":"<pre><code>starttime: str | None\n</code></pre> <p>Execution start time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>start_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Continue.endtime","title":"endtime  <code>property</code> <code>writable</code>","text":"<pre><code>endtime: str | None\n</code></pre> <p>Execution end time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>end_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Continue.elapsedtime","title":"elapsedtime  <code>property</code>","text":"<pre><code>elapsedtime: int\n</code></pre> <p>Total execution time in milliseconds.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>elapsed_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Continue.passed","title":"passed  <code>property</code> <code>writable</code>","text":"<pre><code>passed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'PASS', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Continue.failed","title":"failed  <code>property</code> <code>writable</code>","text":"<pre><code>failed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'FAIL', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Continue.skipped","title":"skipped  <code>property</code> <code>writable</code>","text":"<pre><code>skipped: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'SKIP', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Continue.not_run","title":"not_run  <code>property</code> <code>writable</code>","text":"<pre><code>not_run: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'NOT RUN', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Continue.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Continue.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Continue.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Continue.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Continue.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Continue.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Continue.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/result/model/#robot.result.model.Continue.body","title":"body","text":"<pre><code>body(body: Sequence[BodyItem | DataDict]) -&gt; Body\n</code></pre> <p>Child keywords and messages as a :class:<code>~.Body</code> object.</p> <p>Typically empty. Only contains something if running CONTINUE has failed due to a syntax error or listeners have logged messages or executed keywords.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>@setter\ndef body(self, body: 'Sequence[BodyItem|DataDict]') -&gt; Body:\n    \"\"\"Child keywords and messages as a :class:`~.Body` object.\n\n    Typically empty. Only contains something if running CONTINUE has failed\n    due to a syntax error or listeners have logged messages or executed\n    keywords.\n    \"\"\"\n    return self.body_class(self, body)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Break","title":"Break","text":"<pre><code>Break(\n    status: str = \"FAIL\",\n    message: str = \"\",\n    start_time: datetime | str | None = None,\n    end_time: datetime | str | None = None,\n    elapsed_time: timedelta | int | float | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>Break</code>, <code>StatusMixin</code>, <code>DeprecatedAttributesMixin</code></p> Source code in <code>src/robot/result/model.py</code> <pre><code>def __init__(self, status: str = 'FAIL',\n             message: str = '',\n             start_time: 'datetime|str|None' = None,\n             end_time: 'datetime|str|None' = None,\n             elapsed_time: 'timedelta|int|float|None' = None,\n             parent: BodyItemParent = None):\n    super().__init__(parent)\n    self.status = status\n    self.message = message\n    self.start_time = start_time\n    self.end_time = end_time\n    self.elapsed_time = elapsed_time\n    self.body = ()\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Break.starttime","title":"starttime  <code>property</code> <code>writable</code>","text":"<pre><code>starttime: str | None\n</code></pre> <p>Execution start time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>start_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Break.endtime","title":"endtime  <code>property</code> <code>writable</code>","text":"<pre><code>endtime: str | None\n</code></pre> <p>Execution end time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>end_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Break.elapsedtime","title":"elapsedtime  <code>property</code>","text":"<pre><code>elapsedtime: int\n</code></pre> <p>Total execution time in milliseconds.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>elapsed_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Break.passed","title":"passed  <code>property</code> <code>writable</code>","text":"<pre><code>passed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'PASS', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Break.failed","title":"failed  <code>property</code> <code>writable</code>","text":"<pre><code>failed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'FAIL', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Break.skipped","title":"skipped  <code>property</code> <code>writable</code>","text":"<pre><code>skipped: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'SKIP', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Break.not_run","title":"not_run  <code>property</code> <code>writable</code>","text":"<pre><code>not_run: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'NOT RUN', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Break.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Break.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Break.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Break.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Break.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Break.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Break.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/result/model/#robot.result.model.Break.body","title":"body","text":"<pre><code>body(body: Sequence[BodyItem | DataDict]) -&gt; Body\n</code></pre> <p>Child keywords and messages as a :class:<code>~.Body</code> object.</p> <p>Typically empty. Only contains something if running BREAK has failed due to a syntax error or listeners have logged messages or executed keywords.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>@setter\ndef body(self, body: 'Sequence[BodyItem|DataDict]') -&gt; Body:\n    \"\"\"Child keywords and messages as a :class:`~.Body` object.\n\n    Typically empty. Only contains something if running BREAK has failed\n    due to a syntax error or listeners have logged messages or executed\n    keywords.\n    \"\"\"\n    return self.body_class(self, body)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Error","title":"Error","text":"<pre><code>Error(\n    values: Sequence[str] = (),\n    status: str = \"FAIL\",\n    message: str = \"\",\n    start_time: datetime | str | None = None,\n    end_time: datetime | str | None = None,\n    elapsed_time: timedelta | int | float | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>Error</code>, <code>StatusMixin</code>, <code>DeprecatedAttributesMixin</code></p> Source code in <code>src/robot/result/model.py</code> <pre><code>def __init__(self, values: Sequence[str] = (),\n             status: str = 'FAIL',\n             message: str = '',\n             start_time: 'datetime|str|None' = None,\n             end_time: 'datetime|str|None' = None,\n             elapsed_time: 'timedelta|int|float|None' = None,\n             parent: BodyItemParent = None):\n    super().__init__(values, parent)\n    self.status = status\n    self.message = message\n    self.start_time = start_time\n    self.end_time = end_time\n    self.elapsed_time = elapsed_time\n    self.body = ()\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Error.starttime","title":"starttime  <code>property</code> <code>writable</code>","text":"<pre><code>starttime: str | None\n</code></pre> <p>Execution start time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>start_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Error.endtime","title":"endtime  <code>property</code> <code>writable</code>","text":"<pre><code>endtime: str | None\n</code></pre> <p>Execution end time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>end_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Error.elapsedtime","title":"elapsedtime  <code>property</code>","text":"<pre><code>elapsedtime: int\n</code></pre> <p>Total execution time in milliseconds.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>elapsed_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Error.passed","title":"passed  <code>property</code> <code>writable</code>","text":"<pre><code>passed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'PASS', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Error.failed","title":"failed  <code>property</code> <code>writable</code>","text":"<pre><code>failed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'FAIL', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Error.skipped","title":"skipped  <code>property</code> <code>writable</code>","text":"<pre><code>skipped: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'SKIP', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Error.not_run","title":"not_run  <code>property</code> <code>writable</code>","text":"<pre><code>not_run: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'NOT RUN', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Error.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Error.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Error.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Error.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Error.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Error.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Error.id","title":"id  <code>property</code>","text":"<pre><code>id: str | None\n</code></pre> <p>Item id in format like <code>s1-t3-k1</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p> <p><code>id</code> is <code>None</code> only in these special cases:</p> <ul> <li>Keyword uses a placeholder for <code>setup</code> or <code>teardown</code> when   a <code>setup</code> or <code>teardown</code> is not actually used.</li> <li>With :class:<code>~robot.model.control.If</code> and :class:<code>~robot.model.control.Try</code>   instances representing IF/TRY structure roots.</li> </ul>"},{"location":"api/robot/result/model/#robot.result.model.Error.body","title":"body","text":"<pre><code>body(body: Sequence[BodyItem | DataDict]) -&gt; Body\n</code></pre> <p>Messages as a :class:<code>~.Body</code> object.</p> <p>Typically contains the message that caused the error.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>@setter\ndef body(self, body: 'Sequence[BodyItem|DataDict]') -&gt; Body:\n    \"\"\"Messages as a :class:`~.Body` object.\n\n    Typically contains the message that caused the error.\n    \"\"\"\n    return self.body_class(self, body)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Keyword","title":"Keyword","text":"<pre><code>Keyword(\n    name: str | None = \"\",\n    owner: str | None = None,\n    source_name: str | None = None,\n    doc: str = \"\",\n    args: Sequence[str] = (),\n    assign: Sequence[str] = (),\n    tags: Sequence[str] = (),\n    timeout: str | None = None,\n    type: str = KEYWORD,\n    status: str = \"FAIL\",\n    message: str = \"\",\n    start_time: datetime | str | None = None,\n    end_time: datetime | str | None = None,\n    elapsed_time: timedelta | int | float | None = None,\n    parent: BodyItemParent = None,\n)\n</code></pre> <p>               Bases: <code>Keyword</code>, <code>StatusMixin</code></p> <p>Represents an executed library or user keyword.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>def __init__(self, name: 'str|None' = '',\n             owner: 'str|None' = None,\n             source_name: 'str|None' = None,\n             doc: str = '',\n             args: Sequence[str] = (),\n             assign: Sequence[str] = (),\n             tags: Sequence[str] = (),\n             timeout: 'str|None' = None,\n             type: str = BodyItem.KEYWORD,\n             status: str = 'FAIL',\n             message: str = '',\n             start_time: 'datetime|str|None' = None,\n             end_time: 'datetime|str|None' = None,\n             elapsed_time: 'timedelta|int|float|None' = None,\n             parent: BodyItemParent = None):\n    super().__init__(name, args, assign, type, parent)\n    #: Name of the library or resource containing this keyword.\n    self.owner = owner\n    #: Original name of keyword with embedded arguments.\n    self.source_name = source_name\n    self.doc = doc\n    self.tags = tags\n    self.timeout = timeout\n    self.status = status\n    self.message = message\n    self.start_time = start_time\n    self.end_time = end_time\n    self.elapsed_time = elapsed_time\n    self._setup = None\n    self._teardown = None\n    self.body = ()\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.starttime","title":"starttime  <code>property</code> <code>writable</code>","text":"<pre><code>starttime: str | None\n</code></pre> <p>Execution start time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>start_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.endtime","title":"endtime  <code>property</code> <code>writable</code>","text":"<pre><code>endtime: str | None\n</code></pre> <p>Execution end time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>end_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.elapsedtime","title":"elapsedtime  <code>property</code>","text":"<pre><code>elapsedtime: int\n</code></pre> <p>Total execution time in milliseconds.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>elapsed_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.passed","title":"passed  <code>property</code> <code>writable</code>","text":"<pre><code>passed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'PASS', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.failed","title":"failed  <code>property</code> <code>writable</code>","text":"<pre><code>failed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'FAIL', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.skipped","title":"skipped  <code>property</code> <code>writable</code>","text":"<pre><code>skipped: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'SKIP', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.not_run","title":"not_run  <code>property</code> <code>writable</code>","text":"<pre><code>not_run: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'NOT RUN', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.visit","title":"visit","text":"<pre><code>visit(visitor: SuiteVisitor)\n</code></pre> <p>:mod:<code>Visitor interface &lt;robot.model.visitor&gt;</code> entry-point.</p> Source code in <code>src/robot/model/keyword.py</code> <pre><code>def visit(self, visitor: 'SuiteVisitor'):\n    \"\"\":mod:`Visitor interface &lt;robot.model.visitor&gt;` entry-point.\"\"\"\n    if self:\n        visitor.visit_keyword(self)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.body","title":"body","text":"<pre><code>body(body: Sequence[BodyItem | DataDict]) -&gt; Body\n</code></pre> <p>Possible keyword body as a :class:<code>~.Body</code> object.</p> <p>Body can consist of child keywords, messages, and control structures such as IF/ELSE. Library keywords typically have an empty body.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>@setter\ndef body(self, body: 'Sequence[BodyItem|DataDict]') -&gt; Body:\n    \"\"\"Possible keyword body as a :class:`~.Body` object.\n\n    Body can consist of child keywords, messages, and control structures\n    such as IF/ELSE. Library keywords typically have an empty body.\n    \"\"\"\n    return self.body_class(self, body)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.messages","title":"messages  <code>property</code>","text":"<pre><code>messages: list[Message]\n</code></pre> <p>Keyword's messages.</p> <p>Starting from Robot Framework 4.0 this is a list generated from messages in :attr:<code>body</code>.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str | None\n</code></pre> <p>Keyword name in format <code>owner.name</code>.</p> <p>Just <code>name</code> if :attr:<code>owner</code> is not set. In practice this is the case only with user keywords in the suite file.</p> <p>Cannot be set directly. Set :attr:<code>name</code> and :attr:<code>owner</code> separately instead.</p> <p>Notice that prior to Robot Framework 7.0, the <code>name</code> attribute contained the full name and keyword and owner names were in <code>kwname</code> and <code>libname</code>, respectively.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.kwname","title":"kwname  <code>property</code> <code>writable</code>","text":"<pre><code>kwname: str | None\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>name</code> instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.libname","title":"libname  <code>property</code> <code>writable</code>","text":"<pre><code>libname: str | None\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>owner</code> instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.sourcename","title":"sourcename  <code>property</code> <code>writable</code>","text":"<pre><code>sourcename: str\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>source_name</code> instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.setup","title":"setup  <code>property</code> <code>writable</code>","text":"<pre><code>setup: Keyword\n</code></pre> <p>Keyword setup as a :class:<code>Keyword</code> object.</p> <p>See :attr:<code>teardown</code> for more information. New in Robot Framework 7.0.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.has_setup","title":"has_setup  <code>property</code>","text":"<pre><code>has_setup: bool\n</code></pre> <p>Check does a keyword have a setup without creating a setup object.</p> <p>See :attr:<code>has_teardown</code> for more information. New in Robot Framework 7.0.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.teardown","title":"teardown  <code>property</code> <code>writable</code>","text":"<pre><code>teardown: Keyword\n</code></pre> <p>Keyword teardown as a :class:<code>Keyword</code> object.</p> <p>Teardown can be modified by setting attributes directly::</p> <pre><code>keyword.teardown.name = 'Example'\nkeyword.teardown.args = ('First', 'Second')\n</code></pre> <p>Alternatively the :meth:<code>config</code> method can be used to set multiple attributes in one call::</p> <pre><code>keyword.teardown.config(name='Example', args=('First', 'Second'))\n</code></pre> <p>The easiest way to reset the whole teardown is setting it to <code>None</code>. It will automatically recreate the underlying <code>Keyword</code> object::</p> <pre><code>keyword.teardown = None\n</code></pre> <p>This attribute is a <code>Keyword</code> object also when a keyword has no teardown but in that case its truth value is <code>False</code>. If there is a need to just check does a keyword have a teardown, using the :attr:<code>has_teardown</code> attribute avoids creating the <code>Keyword</code> object and is thus more memory efficient.</p> <p>New in Robot Framework 4.0. Earlier teardown was accessed like <code>keyword.keywords.teardown</code>. :attr:<code>has_teardown</code> is new in Robot Framework 4.1.2.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.has_teardown","title":"has_teardown  <code>property</code>","text":"<pre><code>has_teardown: bool\n</code></pre> <p>Check does a keyword have a teardown without creating a teardown object.</p> <p>A difference between using <code>if kw.has_teardown:</code> and <code>if kw.teardown:</code> is that accessing the :attr:<code>teardown</code> attribute creates a :class:<code>Keyword</code> object representing a teardown even when the keyword actually does not have one. This typically does not matter, but with bigger suite structures having lots of keywords it can have a considerable effect on memory usage.</p> <p>New in Robot Framework 4.1.2.</p>"},{"location":"api/robot/result/model/#robot.result.model.Keyword.tags","title":"tags","text":"<pre><code>tags(tags: Sequence[str]) -&gt; Tags\n</code></pre> <p>Keyword tags as a :class:<code>~.model.tags.Tags</code> object.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>@setter\ndef tags(self, tags: Sequence[str]) -&gt; model.Tags:\n    \"\"\"Keyword tags as a :class:`~.model.tags.Tags` object.\"\"\"\n    return Tags(tags)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestCase","title":"TestCase","text":"<pre><code>TestCase(\n    name: str = \"\",\n    doc: str = \"\",\n    tags: Sequence[str] = (),\n    timeout: str | None = None,\n    lineno: int | None = None,\n    status: str = \"FAIL\",\n    message: str = \"\",\n    start_time: datetime | str | None = None,\n    end_time: datetime | str | None = None,\n    elapsed_time: timedelta | int | float | None = None,\n    parent: TestSuite | None = None,\n)\n</code></pre> <p>               Bases: <code>TestCase[Keyword]</code>, <code>StatusMixin</code></p> <p>Represents results of a single test case.</p> <p>See the base class for documentation of attributes not documented here.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>def __init__(self, name: str = '',\n             doc: str = '',\n             tags: Sequence[str] = (),\n             timeout: 'str|None' = None,\n             lineno: 'int|None' = None,\n             status: str = 'FAIL',\n             message: str = '',\n             start_time: 'datetime|str|None' = None,\n             end_time: 'datetime|str|None' = None,\n             elapsed_time: 'timedelta|int|float|None' = None,\n             parent: 'TestSuite|None' = None):\n    super().__init__(name, doc, tags, timeout, lineno, parent)\n    self.status = status\n    self.message = message\n    self.start_time = start_time\n    self.end_time = end_time\n    self.elapsed_time = elapsed_time\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.starttime","title":"starttime  <code>property</code> <code>writable</code>","text":"<pre><code>starttime: str | None\n</code></pre> <p>Execution start time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>start_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.endtime","title":"endtime  <code>property</code> <code>writable</code>","text":"<pre><code>endtime: str | None\n</code></pre> <p>Execution end time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>end_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.elapsedtime","title":"elapsedtime  <code>property</code>","text":"<pre><code>elapsedtime: int\n</code></pre> <p>Total execution time in milliseconds.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>elapsed_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.passed","title":"passed  <code>property</code> <code>writable</code>","text":"<pre><code>passed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'PASS', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.failed","title":"failed  <code>property</code> <code>writable</code>","text":"<pre><code>failed: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'FAIL', <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.skipped","title":"skipped  <code>property</code> <code>writable</code>","text":"<pre><code>skipped: bool\n</code></pre> <p><code>True</code> when :attr:<code>status</code> is 'SKIP', <code>False</code> otherwise.</p> <p>Setting to <code>False</code> value is ambiguous and raises an exception.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.tags","title":"tags","text":"<pre><code>tags(tags: Tags | Sequence[str]) -&gt; Tags\n</code></pre> <p>Test tags as a :class:<code>~.model.tags.Tags</code> object.</p> Source code in <code>src/robot/model/testcase.py</code> <pre><code>@setter\ndef tags(self, tags: 'Tags|Sequence[str]') -&gt; Tags:\n    \"\"\"Test tags as a :class:`~.model.tags.Tags` object.\"\"\"\n    return Tags(tags)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.setup","title":"setup  <code>property</code> <code>writable</code>","text":"<pre><code>setup: KW\n</code></pre> <p>Test setup as a :class:<code>~.model.keyword.Keyword</code> object.</p> <p>This attribute is a <code>Keyword</code> object also when a test has no setup but in that case its truth value is <code>False</code>.</p> <p>Setup can be modified by setting attributes directly::</p> <pre><code>test.setup.name = 'Example'\ntest.setup.args = ('First', 'Second')\n</code></pre> <p>Alternatively the :meth:<code>config</code> method can be used to set multiple attributes in one call::</p> <pre><code>test.setup.config(name='Example', args=('First', 'Second'))\n</code></pre> <p>The easiest way to reset the whole setup is setting it to <code>None</code>. It will automatically recreate the underlying <code>Keyword</code> object::</p> <pre><code>test.setup = None\n</code></pre> <p>New in Robot Framework 4.0. Earlier setup was accessed like <code>test.keywords.setup</code>.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.has_setup","title":"has_setup  <code>property</code>","text":"<pre><code>has_setup: bool\n</code></pre> <p>Check does a suite have a setup without creating a setup object.</p> <p>A difference between using <code>if test.has_setup:</code> and <code>if test.setup:</code> is that accessing the :attr:<code>setup</code> attribute creates a :class:<code>Keyword</code> object representing the setup even when the test actually does not have one. This typically does not matter, but with bigger suite structures containing a huge about of tests it can have an effect on memory usage.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.teardown","title":"teardown  <code>property</code> <code>writable</code>","text":"<pre><code>teardown: KW\n</code></pre> <p>Test teardown as a :class:<code>~.model.keyword.Keyword</code> object.</p> <p>See :attr:<code>setup</code> for more information.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.has_teardown","title":"has_teardown  <code>property</code>","text":"<pre><code>has_teardown: bool\n</code></pre> <p>Check does a test have a teardown without creating a teardown object.</p> <p>See :attr:<code>has_setup</code> for more information.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre> <p>Test case id in format like <code>s1-t3</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Test name prefixed with the full name of the parent suite.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.longname","title":"longname  <code>property</code>","text":"<pre><code>longname: str\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>full_name</code> instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.visit","title":"visit","text":"<pre><code>visit(visitor: SuiteVisitor)\n</code></pre> <p>:mod:<code>Visitor interface &lt;robot.model.visitor&gt;</code> entry-point.</p> Source code in <code>src/robot/model/testcase.py</code> <pre><code>def visit(self, visitor: 'SuiteVisitor'):\n    \"\"\":mod:`Visitor interface &lt;robot.model.visitor&gt;` entry-point.\"\"\"\n    visitor.visit_test(self)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestCase.body","title":"body","text":"<pre><code>body(body: Sequence[BodyItem | DataDict]) -&gt; Body\n</code></pre> <p>Test body as a :class:<code>~robot.result.Body</code> object.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>@setter\ndef body(self, body: 'Sequence[BodyItem|DataDict]') -&gt; Body:\n    \"\"\"Test body as a :class:`~robot.result.Body` object.\"\"\"\n    return self.body_class(self, body)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite","title":"TestSuite","text":"<pre><code>TestSuite(\n    name: str = \"\",\n    doc: str = \"\",\n    metadata: Mapping[str, str] | None = None,\n    source: Path | str | None = None,\n    rpa: bool = False,\n    message: str = \"\",\n    start_time: datetime | str | None = None,\n    end_time: datetime | str | None = None,\n    elapsed_time: timedelta | int | float | None = None,\n    parent: TestSuite | None = None,\n)\n</code></pre> <p>               Bases: <code>TestSuite[Keyword, TestCase]</code>, <code>StatusMixin</code></p> <p>Represents results of a single test suite.</p> <p>See the base class for documentation of attributes not documented here.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>def __init__(self, name: str = '',\n             doc: str = '',\n             metadata: 'Mapping[str, str]|None' = None,\n             source: 'Path|str|None' = None,\n             rpa: bool = False,\n             message: str = '',\n             start_time: 'datetime|str|None' = None,\n             end_time: 'datetime|str|None' = None,\n             elapsed_time: 'timedelta|int|float|None' = None,\n             parent: 'TestSuite|None' = None):\n    super().__init__(name, doc, metadata, source, rpa, parent)\n    #: Possible suite setup or teardown error message.\n    self.message = message\n    self.start_time = start_time\n    self.end_time = end_time\n    self.elapsed_time = elapsed_time\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.starttime","title":"starttime  <code>property</code> <code>writable</code>","text":"<pre><code>starttime: str | None\n</code></pre> <p>Execution start time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>start_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.endtime","title":"endtime  <code>property</code> <code>writable</code>","text":"<pre><code>endtime: str | None\n</code></pre> <p>Execution end time as a string or as a <code>None</code> if not set.</p> <p>The string format is <code>%Y%m%d %H:%M:%S.%f</code>.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>end_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.elapsedtime","title":"elapsedtime  <code>property</code>","text":"<pre><code>elapsedtime: int\n</code></pre> <p>Total execution time in milliseconds.</p> <p>Considered deprecated starting from Robot Framework 7.0. :attr:<code>elapsed_time</code> should be used instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.metadata","title":"metadata","text":"<pre><code>metadata(metadata: Mapping[str, str] | None) -&gt; Metadata\n</code></pre> <p>Free suite metadata as a :class:<code>~.metadata.Metadata</code> object.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>@setter\ndef metadata(self, metadata: 'Mapping[str, str]|None') -&gt; Metadata:\n    \"\"\"Free suite metadata as a :class:`~.metadata.Metadata` object.\"\"\"\n    return Metadata(metadata)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.name_from_source","title":"name_from_source  <code>staticmethod</code>","text":"<pre><code>name_from_source(\n    source: Path | str | None, extension: Sequence[str] = ()\n) -&gt; str\n</code></pre> <p>Create suite name based on the given <code>source</code>.</p> <p>This method is used by Robot Framework itself when it builds suites. External parsers and other tools that want to produce suites with names matching names created by Robot Framework can use this method as well. This method is also used if :attr:<code>name</code> is not set and someone accesses it.</p> <p>The algorithm is as follows:</p> <ul> <li>If the source is <code>None</code> or empty, return an empty string.</li> <li>Get the base name of the source. Read more below.</li> <li>Remove possible prefix separated with <code>__</code>.</li> <li>Convert underscores to spaces.</li> <li>If the name is all lower case, title case it.</li> </ul> <p>The base name of files is got by calling <code>Path.stem</code>__ that drops the file extension. It typically works fine, but gives wrong result if the extension has multiple parts like in <code>tests.robot.zip</code>. That problem can be avoided by giving valid file extension or extensions as the optional <code>extension</code> argument.</p> <p>Examples::</p> <pre><code>TestSuite.name_from_source(source)\nTestSuite.name_from_source(source, extension='.robot.zip')\nTestSuite.name_from_source(source, ('.robot', '.robot.zip'))\n</code></pre> <p>__ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.stem</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>@staticmethod\ndef name_from_source(source: 'Path|str|None', extension: Sequence[str] = ()) -&gt; str:\n    \"\"\"Create suite name based on the given ``source``.\n\n    This method is used by Robot Framework itself when it builds suites.\n    External parsers and other tools that want to produce suites with\n    names matching names created by Robot Framework can use this method as\n    well. This method is also used if :attr:`name` is not set and someone\n    accesses it.\n\n    The algorithm is as follows:\n\n    - If the source is ``None`` or empty, return an empty string.\n    - Get the base name of the source. Read more below.\n    - Remove possible prefix separated with ``__``.\n    - Convert underscores to spaces.\n    - If the name is all lower case, title case it.\n\n    The base name of files is got by calling `Path.stem`__ that drops\n    the file extension. It typically works fine, but gives wrong result\n    if the extension has multiple parts like in ``tests.robot.zip``.\n    That problem can be avoided by giving valid file extension or extensions\n    as the optional ``extension`` argument.\n\n    Examples::\n\n        TestSuite.name_from_source(source)\n        TestSuite.name_from_source(source, extension='.robot.zip')\n        TestSuite.name_from_source(source, ('.robot', '.robot.zip'))\n\n    __ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.stem\n    \"\"\"\n    if not source:\n        return ''\n    if not isinstance(source, Path):\n        source = Path(source)\n    name = TestSuite._get_base_name(source, extension)\n    if '__' in name:\n        name = name.split('__', 1)[1] or name\n    name = name.replace('_', ' ').strip()\n    return name.title() if name.islower() else name\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Suite name.</p> <p>If name is not set, it is constructed from source. If source is not set, name is constructed from child suite names by concatenating them with <code>&amp;</code>. If there are no child suites, name is an empty string.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.adjust_source","title":"adjust_source","text":"<pre><code>adjust_source(\n    relative_to: Path | str | None = None,\n    root: Path | str | None = None,\n)\n</code></pre> <p>Adjust suite source and child suite sources, recursively.</p> <p>:param relative_to: Make suite source relative to the given path. Calls     <code>pathlib.Path.relative_to()</code>__ internally. Raises <code>ValueError</code>     if creating a relative path is not possible. :param root: Make given path a new root directory for the source. Raises     <code>ValueError</code> if suite source is absolute.</p> <p>Adjusting the source is especially useful when moving data around as JSON::</p> <pre><code>from robot.api import TestSuite\n\n# Create a suite, adjust source and convert to JSON.\nsuite = TestSuite.from_file_system('/path/to/data')\nsuite.adjust_source(relative_to='/path/to')\nsuite.to_json('data.rbt')\n\n# Recreate suite elsewhere and adjust source accordingly.\nsuite = TestSuite.from_json('data.rbt')\nsuite.adjust_source(root='/new/path/to')\n</code></pre> <p>New in Robot Framework 6.1.</p> <p>__ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.relative_to</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def adjust_source(self, relative_to: 'Path|str|None' = None,\n                  root: 'Path|str|None' = None):\n    \"\"\"Adjust suite source and child suite sources, recursively.\n\n    :param relative_to: Make suite source relative to the given path. Calls\n        `pathlib.Path.relative_to()`__ internally. Raises ``ValueError``\n        if creating a relative path is not possible.\n    :param root: Make given path a new root directory for the source. Raises\n        ``ValueError`` if suite source is absolute.\n\n    Adjusting the source is especially useful when moving data around as JSON::\n\n        from robot.api import TestSuite\n\n        # Create a suite, adjust source and convert to JSON.\n        suite = TestSuite.from_file_system('/path/to/data')\n        suite.adjust_source(relative_to='/path/to')\n        suite.to_json('data.rbt')\n\n        # Recreate suite elsewhere and adjust source accordingly.\n        suite = TestSuite.from_json('data.rbt')\n        suite.adjust_source(root='/new/path/to')\n\n    New in Robot Framework 6.1.\n\n    __ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.relative_to\n    \"\"\"\n    if not self.source:\n        raise ValueError('Suite has no source.')\n    if relative_to:\n        self.source = self.source.relative_to(relative_to)\n    if root:\n        if self.source.is_absolute():\n            raise ValueError(f\"Cannot set root for absolute source '{self.source}'.\")\n        self.source = root / self.source\n    for suite in self.suites:\n        suite.adjust_source(relative_to, root)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Suite name prefixed with the full name of the possible parent suite.</p> <p>Just :attr:<code>name</code> of the suite if it has no :attr:<code>parent</code>.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.longname","title":"longname  <code>property</code>","text":"<pre><code>longname: str\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>full_name</code> instead.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.validate_execution_mode","title":"validate_execution_mode","text":"<pre><code>validate_execution_mode() -&gt; bool | None\n</code></pre> <p>Validate that suite execution mode is set consistently.</p> <p>Raise an exception if the execution mode is not set (i.e. the :attr:<code>rpa</code> attribute is <code>None</code>) and child suites have conflicting execution modes.</p> <p>The execution mode is returned. New in RF 6.1.1.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def validate_execution_mode(self) -&gt; 'bool|None':\n    \"\"\"Validate that suite execution mode is set consistently.\n\n    Raise an exception if the execution mode is not set (i.e. the :attr:`rpa`\n    attribute is ``None``) and child suites have conflicting execution modes.\n\n    The execution mode is returned. New in RF 6.1.1.\n    \"\"\"\n    if self.rpa is None:\n        rpa = name = None\n        for suite in self.suites:\n            suite.validate_execution_mode()\n            if rpa is None:\n                rpa = suite.rpa\n                name = suite.full_name\n            elif rpa is not suite.rpa:\n                mode1, mode2 = ('tasks', 'tests') if rpa else ('tests', 'tasks')\n                raise DataError(\n                    f\"Conflicting execution modes: Suite '{name}' has {mode1} but \"\n                    f\"suite '{suite.full_name}' has {mode2}. Resolve the conflict \"\n                    f\"or use '--rpa' or '--norpa' options to set the execution \"\n                    f\"mode explicitly.\"\n                )\n        self.rpa = rpa\n    return self.rpa\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.setup","title":"setup  <code>property</code> <code>writable</code>","text":"<pre><code>setup: KW\n</code></pre> <p>Suite setup.</p> <p>This attribute is a <code>Keyword</code> object also when a suite has no setup but in that case its truth value is <code>False</code>. The preferred way to check does a suite have a setup is using :attr:<code>has_setup</code>.</p> <p>Setup can be modified by setting attributes directly::</p> <pre><code>suite.setup.name = 'Example'\nsuite.setup.args = ('First', 'Second')\n</code></pre> <p>Alternatively the :meth:<code>config</code> method can be used to set multiple attributes in one call::</p> <pre><code>suite.setup.config(name='Example', args=('First', 'Second'))\n</code></pre> <p>The easiest way to reset the whole setup is setting it to <code>None</code>. It will automatically recreate the underlying <code>Keyword</code> object::</p> <pre><code>suite.setup = None\n</code></pre> <p>New in Robot Framework 4.0. Earlier setup was accessed like <code>suite.keywords.setup</code>.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.has_setup","title":"has_setup  <code>property</code>","text":"<pre><code>has_setup: bool\n</code></pre> <p>Check does a suite have a setup without creating a setup object.</p> <p>A difference between using <code>if suite.has_setup:</code> and <code>if suite.setup:</code> is that accessing the :attr:<code>setup</code> attribute creates a :class:<code>Keyword</code> object representing the setup even when the suite actually does not have one. This typically does not matter, but with bigger suite structures it can have some effect on memory usage.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.teardown","title":"teardown  <code>property</code> <code>writable</code>","text":"<pre><code>teardown: KW\n</code></pre> <p>Suite teardown.</p> <p>See :attr:<code>setup</code> for more information.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.has_teardown","title":"has_teardown  <code>property</code>","text":"<pre><code>has_teardown: bool\n</code></pre> <p>Check does a suite have a teardown without creating a teardown object.</p> <p>See :attr:<code>has_setup</code> for more information.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre> <p>An automatically generated unique id.</p> <p>The root suite has id <code>s1</code>, its child suites have ids <code>s1-s1</code>, <code>s1-s2</code>, ..., their child suites get ids <code>s1-s1-s1</code>, <code>s1-s1-s2</code>, ..., <code>s1-s2-s1</code>, ..., and so on.</p> <p>The first test in a suite has an id like <code>s1-t1</code>, the second has an id <code>s1-t2</code>, and so on. Similarly, keywords in suites (setup/teardown) and in tests get ids like <code>s1-k1</code>, <code>s1-t1-k1</code>, and <code>s1-s4-t2-k5</code>.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.all_tests","title":"all_tests  <code>property</code>","text":"<pre><code>all_tests: Iterator[TestCase]\n</code></pre> <p>Yields all tests this suite and its child suites contain.</p> <p>New in Robot Framework 6.1.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.test_count","title":"test_count  <code>property</code>","text":"<pre><code>test_count: int\n</code></pre> <p>Total number of the tests in this suite and in its child suites.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.set_tags","title":"set_tags","text":"<pre><code>set_tags(\n    add: Sequence[str] = (),\n    remove: Sequence[str] = (),\n    persist: bool = False,\n)\n</code></pre> <p>Add and/or remove specified tags to the tests in this suite.</p> <p>:param add: Tags to add as a list or, if adding only one,     as a single string. :param remove: Tags to remove as a list or as a single string.     Can be given as patterns where <code>*</code> and <code>?</code> work as wildcards. :param persist: Add/remove specified tags also to new tests added     to this suite in the future.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def set_tags(self, add: Sequence[str] = (), remove: Sequence[str] = (),\n             persist: bool = False):\n    \"\"\"Add and/or remove specified tags to the tests in this suite.\n\n    :param add: Tags to add as a list or, if adding only one,\n        as a single string.\n    :param remove: Tags to remove as a list or as a single string.\n        Can be given as patterns where ``*`` and ``?`` work as wildcards.\n    :param persist: Add/remove specified tags also to new tests added\n        to this suite in the future.\n    \"\"\"\n    setter = TagSetter(add, remove)\n    self.visit(setter)\n    if persist:\n        self._my_visitors.append(setter)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.filter","title":"filter","text":"<pre><code>filter(\n    included_suites: Sequence[str] | None = None,\n    included_tests: Sequence[str] | None = None,\n    included_tags: Sequence[str] | None = None,\n    excluded_tags: Sequence[str] | None = None,\n)\n</code></pre> <p>Select test cases and remove others from this suite.</p> <p>Parameters have the same semantics as <code>--suite</code>, <code>--test</code>, <code>--include</code>, and <code>--exclude</code> command line options. All of them can be given as a list of strings, or when selecting only one, as a single string.</p> <p>Child suites that contain no tests after filtering are automatically removed.</p> <p>Example::</p> <pre><code>suite.filter(included_tests=['Test 1', '* Example'],\n             included_tags='priority-1')\n</code></pre> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def filter(self, included_suites: 'Sequence[str]|None' = None,\n           included_tests: 'Sequence[str]|None' = None,\n           included_tags: 'Sequence[str]|None' = None,\n           excluded_tags: 'Sequence[str]|None' = None):\n    \"\"\"Select test cases and remove others from this suite.\n\n    Parameters have the same semantics as ``--suite``, ``--test``,\n    ``--include``, and ``--exclude`` command line options. All of them\n    can be given as a list of strings, or when selecting only one, as\n    a single string.\n\n    Child suites that contain no tests after filtering are automatically\n    removed.\n\n    Example::\n\n        suite.filter(included_tests=['Test 1', '* Example'],\n                     included_tags='priority-1')\n    \"\"\"\n    self.visit(Filter(included_suites, included_tests,\n                      included_tags, excluded_tags))\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.remove_empty_suites","title":"remove_empty_suites","text":"<pre><code>remove_empty_suites(preserve_direct_children: bool = False)\n</code></pre> <p>Removes all child suites not containing any tests, recursively.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def remove_empty_suites(self, preserve_direct_children: bool = False):\n    \"\"\"Removes all child suites not containing any tests, recursively.\"\"\"\n    self.visit(EmptySuiteRemover(preserve_direct_children))\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.visit","title":"visit","text":"<pre><code>visit(visitor: SuiteVisitor)\n</code></pre> <p>:mod:<code>Visitor interface &lt;robot.model.visitor&gt;</code> entry-point.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def visit(self, visitor: SuiteVisitor):\n    \"\"\":mod:`Visitor interface &lt;robot.model.visitor&gt;` entry-point.\"\"\"\n    visitor.visit_suite(self)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.passed","title":"passed  <code>property</code>","text":"<pre><code>passed: bool\n</code></pre> <p><code>True</code> if no test has failed but some have passed, <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.failed","title":"failed  <code>property</code>","text":"<pre><code>failed: bool\n</code></pre> <p><code>True</code> if any test has failed, <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.skipped","title":"skipped  <code>property</code>","text":"<pre><code>skipped: bool\n</code></pre> <p><code>True</code> if there are no passed or failed tests, <code>False</code> otherwise.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.status","title":"status  <code>property</code>","text":"<pre><code>status: Literal['PASS', 'SKIP', 'FAIL']\n</code></pre> <p>'PASS', 'FAIL' or 'SKIP' depending on test statuses.</p> <ul> <li>If any test has failed, status is 'FAIL'.</li> <li>If no test has failed but at least some test has passed, status is 'PASS'.</li> <li>If there are no failed or passed tests, status is 'SKIP'. This covers both   the case when all tests have been skipped and when there are no tests.</li> </ul>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.statistics","title":"statistics  <code>property</code>","text":"<pre><code>statistics: TotalStatistics\n</code></pre> <p>Suite statistics as a :class:<code>~robot.model.totalstatistics.TotalStatistics</code> object.</p> <p>Recreated every time this property is accessed, so saving the results to a variable and inspecting it is often a good idea::</p> <pre><code>stats = suite.statistics\nprint(stats.failed)\nprint(stats.total)\nprint(stats.message)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.full_message","title":"full_message  <code>property</code>","text":"<pre><code>full_message: str\n</code></pre> <p>Combination of :attr:<code>message</code> and :attr:<code>stat_message</code>.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.stat_message","title":"stat_message  <code>property</code>","text":"<pre><code>stat_message: str\n</code></pre> <p>String representation of the :attr:<code>statistics</code>.</p>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.remove_keywords","title":"remove_keywords","text":"<pre><code>remove_keywords(how: str)\n</code></pre> <p>Remove keywords based on the given condition.</p> <p>:param how: Which approach to use when removing keywords. Either     <code>ALL</code>, <code>PASSED</code>, <code>FOR</code>, <code>WUKS</code>, or <code>NAME:&lt;pattern&gt;</code>.</p> <p>For more information about the possible values see the documentation of the <code>--removekeywords</code> command line option.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>def remove_keywords(self, how: str):\n    \"\"\"Remove keywords based on the given condition.\n\n    :param how: Which approach to use when removing keywords. Either\n        ``ALL``, ``PASSED``, ``FOR``, ``WUKS``, or ``NAME:&lt;pattern&gt;``.\n\n    For more information about the possible values see the documentation\n    of the ``--removekeywords`` command line option.\n    \"\"\"\n    self.visit(KeywordRemover.from_config(how))\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.filter_messages","title":"filter_messages","text":"<pre><code>filter_messages(log_level: str = 'TRACE')\n</code></pre> <p>Remove log messages below the specified <code>log_level</code>.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>def filter_messages(self, log_level: str = 'TRACE'):\n    \"\"\"Remove log messages below the specified ``log_level``.\"\"\"\n    self.visit(MessageFilter(log_level))\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.configure","title":"configure","text":"<pre><code>configure(**options)\n</code></pre> <p>A shortcut to configure a suite using one method call.</p> <p>Can only be used with the root test suite.</p> <p>:param options: Passed to     :class:<code>~robot.result.configurer.SuiteConfigurer</code> that will then     set suite attributes, call :meth:<code>filter</code>, etc. as needed.</p> <p>Example::</p> <pre><code>suite.configure(remove_keywords='PASSED',\n                doc='Smoke test results.')\n</code></pre> <p>Not to be confused with :meth:<code>config</code> method that suites, tests, and keywords have to make it possible to set multiple attributes in one call.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>def configure(self, **options):\n    \"\"\"A shortcut to configure a suite using one method call.\n\n    Can only be used with the root test suite.\n\n    :param options: Passed to\n        :class:`~robot.result.configurer.SuiteConfigurer` that will then\n        set suite attributes, call :meth:`filter`, etc. as needed.\n\n    Example::\n\n        suite.configure(remove_keywords='PASSED',\n                        doc='Smoke test results.')\n\n    Not to be confused with :meth:`config` method that suites, tests,\n    and keywords have to make it possible to set multiple attributes in\n    one call.\n    \"\"\"\n    super().configure()    # Parent validates is call allowed.\n    self.visit(SuiteConfigurer(**options))\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.handle_suite_teardown_failures","title":"handle_suite_teardown_failures","text":"<pre><code>handle_suite_teardown_failures()\n</code></pre> <p>Internal usage only.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>def handle_suite_teardown_failures(self):\n    \"\"\"Internal usage only.\"\"\"\n    self.visit(SuiteTeardownFailureHandler())\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.suite_teardown_failed","title":"suite_teardown_failed","text":"<pre><code>suite_teardown_failed(message: str)\n</code></pre> <p>Internal usage only.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>def suite_teardown_failed(self, message: str):\n    \"\"\"Internal usage only.\"\"\"\n    self.visit(SuiteTeardownFailed(message))\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.suite_teardown_skipped","title":"suite_teardown_skipped","text":"<pre><code>suite_teardown_skipped(message: str)\n</code></pre> <p>Internal usage only.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>def suite_teardown_skipped(self, message: str):\n    \"\"\"Internal usage only.\"\"\"\n    self.visit(SuiteTeardownFailed(message, skipped=True))\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; TestSuite\n</code></pre> <p>Create suite based on result data in a dictionary.</p> <p><code>data</code> can either contain only the suite data got, for example, from the :meth:<code>to_dict</code> method, or it can contain full result data with execution errors and other such information in addition to the suite data. In the latter case only the suite data is used, though.</p> <p>Support for full result data is new in Robot Framework 7.2.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: DataDict) -&gt; 'TestSuite':\n    \"\"\"Create suite based on result data in a dictionary.\n\n    ``data`` can either contain only the suite data got, for example, from\n    the :meth:`to_dict` method, or it can contain full result data with\n    execution errors and other such information in addition to the suite data.\n    In the latter case only the suite data is used, though.\n\n    Support for full result data is new in Robot Framework 7.2.\n    \"\"\"\n    if 'suite' in data:\n        data = data['suite']\n    return super().from_dict(data)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; TestSuite\n</code></pre> <p>Create suite based on results in JSON.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>Supports JSON produced by :meth:<code>to_json</code> that contains only the suite information, as well as full result JSON that contains also execution errors and other information. In the latter case errors and all other information is silently ignored, though. If that is a problem, :class:<code>~robot.result.resultbuilder.ExecutionResult</code> should be used instead.</p> <p>Support for full result JSON is new in Robot Framework 7.2.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>@classmethod\ndef from_json(cls, source: 'str|bytes|TextIO|Path') -&gt; 'TestSuite':\n    \"\"\"Create suite based on results in JSON.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    Supports JSON produced by :meth:`to_json` that contains only the suite\n    information, as well as full result JSON that contains also execution\n    errors and other information. In the latter case errors and all other\n    information is silently ignored, though. If that is a problem,\n    :class:`~robot.result.resultbuilder.ExecutionResult` should be used\n    instead.\n\n    Support for full result JSON is new in Robot Framework 7.2.\n    \"\"\"\n    return super().from_json(source)\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.to_xml","title":"to_xml","text":"<pre><code>to_xml(file: None = None) -&gt; str\n</code></pre><pre><code>to_xml(file: TextIO | Path | str) -&gt; None\n</code></pre> <pre><code>to_xml(\n    file: None | TextIO | Path | str = None,\n) -&gt; str | None\n</code></pre> <p>Serialize suite into XML.</p> <p>The format is the same that is used with normal output.xml files, but the <code>&lt;robot&gt;</code> root node is omitted and the result contains only the <code>&lt;suite&gt;</code> structure.</p> <p>The <code>file</code> parameter controls what to do with the resulting XML data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>A serialized suite can be recreated by using the :meth:<code>from_xml</code> method.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>def to_xml(self, file: 'None|TextIO|Path|str' = None) -&gt; 'str|None':\n    \"\"\"Serialize suite into XML.\n\n    The format is the same that is used with normal output.xml files, but\n    the ``&lt;robot&gt;`` root node is omitted and the result contains only\n    the ``&lt;suite&gt;`` structure.\n\n    The ``file`` parameter controls what to do with the resulting XML data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    A serialized suite can be recreated by using the :meth:`from_xml` method.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    from robot.reporting.outputwriter import OutputWriter\n\n    output, close = self._get_output(file)\n    try:\n        self.visit(OutputWriter(output, suite_only=True))\n    finally:\n        if close:\n            output.close()\n    return output.getvalue() if file is None else None\n</code></pre>"},{"location":"api/robot/result/model/#robot.result.model.TestSuite.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(source: str | TextIO | Path) -&gt; TestSuite\n</code></pre> <p>Create suite based on results in XML.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>Supports both normal output.xml files and files containing only the <code>&lt;suite&gt;</code> structure created, for example, with the :meth:<code>to_xml</code> method. When using normal output.xml files, possible execution errors listed in <code>&lt;errors&gt;</code> are silently ignored. If that is a problem, :class:<code>~robot.result.resultbuilder.ExecutionResult</code> should be used instead.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/result/model.py</code> <pre><code>@classmethod\ndef from_xml(cls, source: 'str|TextIO|Path') -&gt; 'TestSuite':\n    \"\"\"Create suite based on results in XML.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    Supports both normal output.xml files and files containing only the\n    ``&lt;suite&gt;`` structure created, for example, with the :meth:`to_xml`\n    method. When using normal output.xml files, possible execution errors\n    listed in ``&lt;errors&gt;`` are silently ignored. If that is a problem,\n    :class:`~robot.result.resultbuilder.ExecutionResult` should be used\n    instead.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    from .resultbuilder import ExecutionResult\n\n    return ExecutionResult(source).suite\n</code></pre>"},{"location":"api/robot/result/modeldeprecation/","title":"robot.result.modeldeprecation","text":""},{"location":"api/robot/result/modeldeprecation/#robot.result.modeldeprecation","title":"robot.result.modeldeprecation","text":""},{"location":"api/robot/result/resultbuilder/","title":"robot.result.resultbuilder","text":""},{"location":"api/robot/result/resultbuilder/#robot.result.resultbuilder","title":"robot.result.resultbuilder","text":""},{"location":"api/robot/result/resultbuilder/#robot.result.resultbuilder.ExecutionResult","title":"ExecutionResult","text":"<pre><code>ExecutionResult(*sources, **options)\n</code></pre> <p>Factory method to constructs :class:<code>~.executionresult.Result</code> objects.</p> <p>:param sources: XML or JSON source(s) containing execution results.     Can be specified as paths (<code>pathlib.Path</code> or <code>str</code>), opened file     objects, or strings/bytes containing XML/JSON directly. :param options: Configuration options.     Using <code>merge=True</code> causes multiple results to be combined so that     tests in the latter results replace the ones in the original.     Setting <code>rpa</code> either to <code>True</code> (RPA mode) or <code>False</code> (test     automation) sets execution mode explicitly. By default, it is got     from processed output files and conflicting modes cause an error.     Other options are passed directly to the     :class:<code>ExecutionResultBuilder</code> object used internally. :returns: :class:<code>~.executionresult.Result</code> instance.</p> <p>A source is considered to be JSON in these cases: - It is a path with a <code>.json</code> suffix. - It is an open file that has a <code>name</code> attribute with a <code>.json</code> suffix. - It is string or bytes starting with <code>{</code> and ending with <code>}</code>.</p> <p>This method should be imported by external code via the :mod:<code>robot.api</code> package. See the :mod:<code>robot.result</code> package for a usage example.</p> Source code in <code>src/robot/result/resultbuilder.py</code> <pre><code>def ExecutionResult(*sources, **options):\n    \"\"\"Factory method to constructs :class:`~.executionresult.Result` objects.\n\n    :param sources: XML or JSON source(s) containing execution results.\n        Can be specified as paths (``pathlib.Path`` or ``str``), opened file\n        objects, or strings/bytes containing XML/JSON directly.\n    :param options: Configuration options.\n        Using ``merge=True`` causes multiple results to be combined so that\n        tests in the latter results replace the ones in the original.\n        Setting ``rpa`` either to ``True`` (RPA mode) or ``False`` (test\n        automation) sets execution mode explicitly. By default, it is got\n        from processed output files and conflicting modes cause an error.\n        Other options are passed directly to the\n        :class:`ExecutionResultBuilder` object used internally.\n    :returns: :class:`~.executionresult.Result` instance.\n\n    A source is considered to be JSON in these cases:\n    - It is a path with a ``.json`` suffix.\n    - It is an open file that has a ``name`` attribute with a ``.json`` suffix.\n    - It is string or bytes starting with ``{`` and ending with ``}``.\n\n    This method should be imported by external code via the :mod:`robot.api`\n    package. See the :mod:`robot.result` package for a usage example.\n    \"\"\"\n    if not sources:\n        raise DataError('One or more data source needed.')\n    if options.pop('merge', False):\n        return _merge_results(sources[0], sources[1:], options)\n    if len(sources) &gt; 1:\n        return _combine_results(sources, options)\n    return _single_result(sources[0], options)\n</code></pre>"},{"location":"api/robot/result/resultbuilder/#robot.result.resultbuilder.ExecutionResultBuilder","title":"ExecutionResultBuilder","text":"<pre><code>ExecutionResultBuilder(\n    source, include_keywords=True, flattened_keywords=None\n)\n</code></pre> <p>Builds :class:<code>~.executionresult.Result</code> objects based on XML output files.</p> <p>Instead of using this builder directly, it is recommended to use the :func:<code>ExecutionResult</code> factory method.</p> <p>:param source: Path to the XML output file to build     :class:<code>~.executionresult.Result</code> objects from. :param include_keywords: Controls whether to include keywords and control     structures like FOR and IF in the result or not. They are not needed     when generating only a report. :param flattened_keywords: List of patterns controlling what keywords     and control structures to flatten. See the documentation of     the <code>--flattenkeywords</code> option for more details.</p> Source code in <code>src/robot/result/resultbuilder.py</code> <pre><code>def __init__(self, source, include_keywords=True, flattened_keywords=None):\n    \"\"\"\n    :param source: Path to the XML output file to build\n        :class:`~.executionresult.Result` objects from.\n    :param include_keywords: Controls whether to include keywords and control\n        structures like FOR and IF in the result or not. They are not needed\n        when generating only a report.\n    :param flattened_keywords: List of patterns controlling what keywords\n        and control structures to flatten. See the documentation of\n        the ``--flattenkeywords`` option for more details.\n    \"\"\"\n    self._source = source \\\n        if isinstance(source, ETSource) else ETSource(source)\n    self._include_keywords = include_keywords\n    self._flattened_keywords = flattened_keywords\n</code></pre>"},{"location":"api/robot/result/suiteteardownfailed/","title":"robot.result.suiteteardownfailed","text":""},{"location":"api/robot/result/suiteteardownfailed/#robot.result.suiteteardownfailed","title":"robot.result.suiteteardownfailed","text":""},{"location":"api/robot/result/visitor/","title":"robot.result.visitor","text":""},{"location":"api/robot/result/visitor/#robot.result.visitor","title":"robot.result.visitor","text":"<p>Visitors can be used to easily traverse result structures.</p> <p>This module contains :class:<code>ResultVisitor</code> for traversing the whole :class:<code>~robot.result.executionresult.Result</code> object. It extends :class:<code>~robot.model.visitor.SuiteVisitor</code> that contains visiting logic for the test suite structure.</p>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor","title":"ResultVisitor","text":"<p>               Bases: <code>SuiteVisitor</code></p> <p>Abstract class to conveniently travel :class:<code>~robot.result.executionresult.Result</code> objects.</p> <p>A visitor implementation can be given to the :meth:<code>visit</code> method of a result object. This will cause the result object to be traversed and the visitor's :meth:<code>visit_x</code>, :meth:<code>start_x</code>, and :meth:<code>end_x</code> methods to be called for each suite, test, keyword and message, as well as for errors, statistics, and other information in the result object. See methods below for a full list of available visitor methods.</p> <p>See the :mod:<code>result package level &lt;robot.result&gt;</code> documentation for more information about handling results and a concrete visitor example. For more information about the visitor algorithm see documentation in :mod:<code>robot.model.visitor</code> module.</p>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_suite","title":"visit_suite","text":"<pre><code>visit_suite(suite: TestSuite)\n</code></pre> <p>Implements traversing through suites.</p> <p>Can be overridden to allow modifying the passed in <code>suite</code> without calling :meth:<code>start_suite</code> or :meth:<code>end_suite</code> nor visiting child suites, tests or setup and teardown at all.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_suite(self, suite: 'TestSuite'):\n    \"\"\"Implements traversing through suites.\n\n    Can be overridden to allow modifying the passed in ``suite`` without\n    calling :meth:`start_suite` or :meth:`end_suite` nor visiting child\n    suites, tests or setup and teardown at all.\n    \"\"\"\n    if self.start_suite(suite) is not False:\n        if suite.has_setup:\n            suite.setup.visit(self)\n        suite.suites.visit(self)\n        suite.tests.visit(self)\n        if suite.has_teardown:\n            suite.teardown.visit(self)\n        self.end_suite(suite)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_suite","title":"start_suite","text":"<pre><code>start_suite(suite: TestSuite) -&gt; bool | None\n</code></pre> <p>Called when a suite starts. Default implementation does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_suite(self, suite: 'TestSuite') -&gt; 'bool|None':\n    \"\"\"Called when a suite starts. Default implementation does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_suite","title":"end_suite","text":"<pre><code>end_suite(suite: TestSuite)\n</code></pre> <p>Called when a suite ends. Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_suite(self, suite: 'TestSuite'):\n    \"\"\"Called when a suite ends. Default implementation does nothing.\"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_test","title":"visit_test","text":"<pre><code>visit_test(test: TestCase)\n</code></pre> <p>Implements traversing through tests.</p> <p>Can be overridden to allow modifying the passed in <code>test</code> without calling :meth:<code>start_test</code> or :meth:<code>end_test</code> nor visiting the body of the test.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_test(self, test: 'TestCase'):\n    \"\"\"Implements traversing through tests.\n\n    Can be overridden to allow modifying the passed in ``test`` without calling\n    :meth:`start_test` or :meth:`end_test` nor visiting the body of the test.\n    \"\"\"\n    if self.start_test(test) is not False:\n        if test.has_setup:\n            test.setup.visit(self)\n        test.body.visit(self)\n        if test.has_teardown:\n            test.teardown.visit(self)\n        self.end_test(test)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_test","title":"start_test","text":"<pre><code>start_test(test: TestCase) -&gt; bool | None\n</code></pre> <p>Called when a test starts. Default implementation does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_test(self, test: 'TestCase') -&gt; 'bool|None':\n    \"\"\"Called when a test starts. Default implementation does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_test","title":"end_test","text":"<pre><code>end_test(test: TestCase)\n</code></pre> <p>Called when a test ends. Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_test(self, test: 'TestCase'):\n    \"\"\"Called when a test ends. Default implementation does nothing.\"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_keyword","title":"visit_keyword","text":"<pre><code>visit_keyword(keyword: Keyword)\n</code></pre> <p>Implements traversing through keywords.</p> <p>Can be overridden to allow modifying the passed in <code>kw</code> without calling :meth:<code>start_keyword</code> or :meth:<code>end_keyword</code> nor visiting the body of the keyword</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_keyword(self, keyword: 'Keyword'):\n    \"\"\"Implements traversing through keywords.\n\n    Can be overridden to allow modifying the passed in ``kw`` without\n    calling :meth:`start_keyword` or :meth:`end_keyword` nor visiting\n    the body of the keyword\n    \"\"\"\n    if self.start_keyword(keyword) is not False:\n        self._possible_setup(keyword)\n        self._possible_body(keyword)\n        self._possible_teardown(keyword)\n        self.end_keyword(keyword)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_keyword","title":"start_keyword","text":"<pre><code>start_keyword(keyword: Keyword) -&gt; bool | None\n</code></pre> <p>Called when a keyword starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_keyword(self, keyword: 'Keyword') -&gt; 'bool|None':\n    \"\"\"Called when a keyword starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(keyword)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_keyword","title":"end_keyword","text":"<pre><code>end_keyword(keyword: Keyword)\n</code></pre> <p>Called when a keyword ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_keyword(self, keyword: 'Keyword'):\n    \"\"\"Called when a keyword ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(keyword)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_for","title":"visit_for","text":"<pre><code>visit_for(for_: For)\n</code></pre> <p>Implements traversing through FOR loops.</p> <p>Can be overridden to allow modifying the passed in <code>for_</code> without calling :meth:<code>start_for</code> or :meth:<code>end_for</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_for(self, for_: 'For'):\n    \"\"\"Implements traversing through FOR loops.\n\n    Can be overridden to allow modifying the passed in ``for_`` without\n    calling :meth:`start_for` or :meth:`end_for` nor visiting body.\n    \"\"\"\n    if self.start_for(for_) is not False:\n        for_.body.visit(self)\n        self.end_for(for_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_for","title":"start_for","text":"<pre><code>start_for(for_: For) -&gt; bool | None\n</code></pre> <p>Called when a FOR loop starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_for(self, for_: 'For') -&gt; 'bool|None':\n    \"\"\"Called when a FOR loop starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(for_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_for","title":"end_for","text":"<pre><code>end_for(for_: For)\n</code></pre> <p>Called when a FOR loop ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_for(self, for_: 'For'):\n    \"\"\"Called when a FOR loop ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(for_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_for_iteration","title":"visit_for_iteration","text":"<pre><code>visit_for_iteration(iteration: ForIteration)\n</code></pre> <p>Implements traversing through single FOR loop iteration.</p> <p>This is only used with the result side model because on the running side there are no iterations.</p> <p>Can be overridden to allow modifying the passed in <code>iteration</code> without calling :meth:<code>start_for_iteration</code> or :meth:<code>end_for_iteration</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_for_iteration(self, iteration: 'ForIteration'):\n    \"\"\"Implements traversing through single FOR loop iteration.\n\n    This is only used with the result side model because on the running side\n    there are no iterations.\n\n    Can be overridden to allow modifying the passed in ``iteration`` without\n    calling :meth:`start_for_iteration` or :meth:`end_for_iteration` nor visiting\n    body.\n    \"\"\"\n    if self.start_for_iteration(iteration) is not False:\n        iteration.body.visit(self)\n        self.end_for_iteration(iteration)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_for_iteration","title":"start_for_iteration","text":"<pre><code>start_for_iteration(iteration: ForIteration) -&gt; bool | None\n</code></pre> <p>Called when a FOR loop iteration starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_for_iteration(self, iteration: 'ForIteration') -&gt; 'bool|None':\n    \"\"\"Called when a FOR loop iteration starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(iteration)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_for_iteration","title":"end_for_iteration","text":"<pre><code>end_for_iteration(iteration: ForIteration)\n</code></pre> <p>Called when a FOR loop iteration ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_for_iteration(self, iteration: 'ForIteration'):\n    \"\"\"Called when a FOR loop iteration ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(iteration)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_if","title":"visit_if","text":"<pre><code>visit_if(if_: If)\n</code></pre> <p>Implements traversing through IF/ELSE structures.</p> <p>Notice that <code>if_</code> does not have any data directly. Actual IF/ELSE branches are in its <code>body</code> and they are visited separately using :meth:<code>visit_if_branch</code>.</p> <p>Can be overridden to allow modifying the passed in <code>if_</code> without calling :meth:<code>start_if</code> or :meth:<code>end_if</code> nor visiting branches.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_if(self, if_: 'If'):\n    \"\"\"Implements traversing through IF/ELSE structures.\n\n    Notice that ``if_`` does not have any data directly. Actual IF/ELSE\n    branches are in its ``body`` and they are visited separately using\n    :meth:`visit_if_branch`.\n\n    Can be overridden to allow modifying the passed in ``if_`` without\n    calling :meth:`start_if` or :meth:`end_if` nor visiting branches.\n    \"\"\"\n    if self.start_if(if_) is not False:\n        if_.body.visit(self)\n        self.end_if(if_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_if","title":"start_if","text":"<pre><code>start_if(if_: If) -&gt; bool | None\n</code></pre> <p>Called when an IF/ELSE structure starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_if(self, if_: 'If') -&gt; 'bool|None':\n    \"\"\"Called when an IF/ELSE structure starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(if_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_if","title":"end_if","text":"<pre><code>end_if(if_: If)\n</code></pre> <p>Called when an IF/ELSE structure ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_if(self, if_: 'If'):\n    \"\"\"Called when an IF/ELSE structure ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(if_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_if_branch","title":"visit_if_branch","text":"<pre><code>visit_if_branch(branch: IfBranch)\n</code></pre> <p>Implements traversing through single IF/ELSE branch.</p> <p>Can be overridden to allow modifying the passed in <code>branch</code> without calling :meth:<code>start_if_branch</code> or :meth:<code>end_if_branch</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_if_branch(self, branch: 'IfBranch'):\n    \"\"\"Implements traversing through single IF/ELSE branch.\n\n    Can be overridden to allow modifying the passed in ``branch`` without\n    calling :meth:`start_if_branch` or :meth:`end_if_branch` nor visiting body.\n    \"\"\"\n    if self.start_if_branch(branch) is not False:\n        branch.body.visit(self)\n        self.end_if_branch(branch)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_if_branch","title":"start_if_branch","text":"<pre><code>start_if_branch(branch: IfBranch) -&gt; bool | None\n</code></pre> <p>Called when an IF/ELSE branch starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_if_branch(self, branch: 'IfBranch') -&gt; 'bool|None':\n    \"\"\"Called when an IF/ELSE branch starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(branch)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_if_branch","title":"end_if_branch","text":"<pre><code>end_if_branch(branch: IfBranch)\n</code></pre> <p>Called when an IF/ELSE branch ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_if_branch(self, branch: 'IfBranch'):\n    \"\"\"Called when an IF/ELSE branch ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(branch)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_try","title":"visit_try","text":"<pre><code>visit_try(try_: Try)\n</code></pre> <p>Implements traversing through TRY/EXCEPT structures.</p> <p>This method is used with the TRY/EXCEPT root element. Actual TRY, EXCEPT, ELSE and FINALLY branches are visited separately using :meth:<code>visit_try_branch</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_try(self, try_: 'Try'):\n    \"\"\"Implements traversing through TRY/EXCEPT structures.\n\n    This method is used with the TRY/EXCEPT root element. Actual TRY, EXCEPT, ELSE\n    and FINALLY branches are visited separately using :meth:`visit_try_branch`.\n    \"\"\"\n    if self.start_try(try_) is not False:\n        try_.body.visit(self)\n        self.end_try(try_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_try","title":"start_try","text":"<pre><code>start_try(try_: Try) -&gt; bool | None\n</code></pre> <p>Called when a TRY/EXCEPT structure starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_try(self, try_: 'Try') -&gt; 'bool|None':\n    \"\"\"Called when a TRY/EXCEPT structure starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(try_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_try","title":"end_try","text":"<pre><code>end_try(try_: Try)\n</code></pre> <p>Called when a TRY/EXCEPT structure ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_try(self, try_: 'Try'):\n    \"\"\"Called when a TRY/EXCEPT structure ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(try_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_try_branch","title":"visit_try_branch","text":"<pre><code>visit_try_branch(branch: TryBranch)\n</code></pre> <p>Visits individual TRY, EXCEPT, ELSE and FINALLY branches.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_try_branch(self, branch: 'TryBranch'):\n    \"\"\"Visits individual TRY, EXCEPT, ELSE and FINALLY branches.\"\"\"\n    if self.start_try_branch(branch) is not False:\n        branch.body.visit(self)\n        self.end_try_branch(branch)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_try_branch","title":"start_try_branch","text":"<pre><code>start_try_branch(branch: TryBranch) -&gt; bool | None\n</code></pre> <p>Called when TRY, EXCEPT, ELSE or FINALLY branches start.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_try_branch(self, branch: 'TryBranch') -&gt; 'bool|None':\n    \"\"\"Called when TRY, EXCEPT, ELSE or FINALLY branches start.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(branch)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_try_branch","title":"end_try_branch","text":"<pre><code>end_try_branch(branch: TryBranch)\n</code></pre> <p>Called when TRY, EXCEPT, ELSE and FINALLY branches end.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_try_branch(self, branch: 'TryBranch'):\n    \"\"\"Called when TRY, EXCEPT, ELSE and FINALLY branches end.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(branch)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_while","title":"visit_while","text":"<pre><code>visit_while(while_: While)\n</code></pre> <p>Implements traversing through WHILE loops.</p> <p>Can be overridden to allow modifying the passed in <code>while_</code> without calling :meth:<code>start_while</code> or :meth:<code>end_while</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_while(self, while_: 'While'):\n    \"\"\"Implements traversing through WHILE loops.\n\n    Can be overridden to allow modifying the passed in ``while_`` without\n    calling :meth:`start_while` or :meth:`end_while` nor visiting body.\n    \"\"\"\n    if self.start_while(while_) is not False:\n        while_.body.visit(self)\n        self.end_while(while_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_while","title":"start_while","text":"<pre><code>start_while(while_: While) -&gt; bool | None\n</code></pre> <p>Called when a WHILE loop starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_while(self, while_: 'While') -&gt; 'bool|None':\n    \"\"\"Called when a WHILE loop starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(while_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_while","title":"end_while","text":"<pre><code>end_while(while_: While)\n</code></pre> <p>Called when a WHILE loop ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_while(self, while_: 'While'):\n    \"\"\"Called when a WHILE loop ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(while_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_while_iteration","title":"visit_while_iteration","text":"<pre><code>visit_while_iteration(iteration: WhileIteration)\n</code></pre> <p>Implements traversing through single WHILE loop iteration.</p> <p>This is only used with the result side model because on the running side there are no iterations.</p> <p>Can be overridden to allow modifying the passed in <code>iteration</code> without calling :meth:<code>start_while_iteration</code> or :meth:<code>end_while_iteration</code> nor visiting body.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_while_iteration(self, iteration: 'WhileIteration'):\n    \"\"\"Implements traversing through single WHILE loop iteration.\n\n    This is only used with the result side model because on the running side\n    there are no iterations.\n\n    Can be overridden to allow modifying the passed in ``iteration`` without\n    calling :meth:`start_while_iteration` or :meth:`end_while_iteration` nor visiting\n    body.\n    \"\"\"\n    if self.start_while_iteration(iteration) is not False:\n        iteration.body.visit(self)\n        self.end_while_iteration(iteration)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_while_iteration","title":"start_while_iteration","text":"<pre><code>start_while_iteration(\n    iteration: WhileIteration,\n) -&gt; bool | None\n</code></pre> <p>Called when a WHILE loop iteration starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_while_iteration(self, iteration: 'WhileIteration') -&gt; 'bool|None':\n    \"\"\"Called when a WHILE loop iteration starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(iteration)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_while_iteration","title":"end_while_iteration","text":"<pre><code>end_while_iteration(iteration: WhileIteration)\n</code></pre> <p>Called when a WHILE loop iteration ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_while_iteration(self, iteration: 'WhileIteration'):\n    \"\"\"Called when a WHILE loop iteration ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(iteration)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_var","title":"visit_var","text":"<pre><code>visit_var(var: Var)\n</code></pre> <p>Visits a VAR elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_var(self, var: 'Var'):\n    \"\"\"Visits a VAR elements.\"\"\"\n    if self.start_var(var) is not False:\n        self._possible_body(var)\n        self.end_var(var)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_var","title":"start_var","text":"<pre><code>start_var(var: Var) -&gt; bool | None\n</code></pre> <p>Called when a VAR element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_var(self, var: 'Var') -&gt; 'bool|None':\n    \"\"\"Called when a VAR element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(var)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_var","title":"end_var","text":"<pre><code>end_var(var: Var)\n</code></pre> <p>Called when a VAR element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_var(self, var: 'Var'):\n    \"\"\"Called when a VAR element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(var)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_return","title":"visit_return","text":"<pre><code>visit_return(return_: Return)\n</code></pre> <p>Visits a RETURN elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_return(self, return_: 'Return'):\n    \"\"\"Visits a RETURN elements.\"\"\"\n    if self.start_return(return_) is not False:\n        self._possible_body(return_)\n        self.end_return(return_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_return","title":"start_return","text":"<pre><code>start_return(return_: Return) -&gt; bool | None\n</code></pre> <p>Called when a RETURN element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_return(self, return_: 'Return') -&gt; 'bool|None':\n    \"\"\"Called when a RETURN element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(return_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_return","title":"end_return","text":"<pre><code>end_return(return_: Return)\n</code></pre> <p>Called when a RETURN element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_return(self, return_: 'Return'):\n    \"\"\"Called when a RETURN element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(return_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_continue","title":"visit_continue","text":"<pre><code>visit_continue(continue_: Continue)\n</code></pre> <p>Visits CONTINUE elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_continue(self, continue_: 'Continue'):\n    \"\"\"Visits CONTINUE elements.\"\"\"\n    if self.start_continue(continue_) is not False:\n        self._possible_body(continue_)\n        self.end_continue(continue_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_continue","title":"start_continue","text":"<pre><code>start_continue(continue_: Continue) -&gt; bool | None\n</code></pre> <p>Called when a CONTINUE element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_continue(self, continue_: 'Continue') -&gt; 'bool|None':\n    \"\"\"Called when a CONTINUE element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(continue_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_continue","title":"end_continue","text":"<pre><code>end_continue(continue_: Continue)\n</code></pre> <p>Called when a CONTINUE element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_continue(self, continue_: 'Continue'):\n    \"\"\"Called when a CONTINUE element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(continue_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_break","title":"visit_break","text":"<pre><code>visit_break(break_: Break)\n</code></pre> <p>Visits BREAK elements.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_break(self, break_: 'Break'):\n    \"\"\"Visits BREAK elements.\"\"\"\n    if self.start_break(break_) is not False:\n        self._possible_body(break_)\n        self.end_break(break_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_break","title":"start_break","text":"<pre><code>start_break(break_: Break) -&gt; bool | None\n</code></pre> <p>Called when a BREAK element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_break(self, break_: 'Break') -&gt; 'bool|None':\n    \"\"\"Called when a BREAK element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(break_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_break","title":"end_break","text":"<pre><code>end_break(break_: Break)\n</code></pre> <p>Called when a BREAK element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_break(self, break_: 'Break'):\n    \"\"\"Called when a BREAK element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(break_)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_error","title":"visit_error","text":"<pre><code>visit_error(error: Error)\n</code></pre> <p>Visits body items resulting from invalid syntax.</p> <p>Examples include syntax like <code>END</code> or <code>ELSE</code> in wrong place and invalid setting like <code>[Invalid]</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_error(self, error: 'Error'):\n    \"\"\"Visits body items resulting from invalid syntax.\n\n    Examples include syntax like ``END`` or ``ELSE`` in wrong place and\n    invalid setting like ``[Invalid]``.\n    \"\"\"\n    if self.start_error(error) is not False:\n        self._possible_body(error)\n        self.end_error(error)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_error","title":"start_error","text":"<pre><code>start_error(error: Error) -&gt; bool | None\n</code></pre> <p>Called when a ERROR element starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_error(self, error: 'Error') -&gt; 'bool|None':\n    \"\"\"Called when a ERROR element starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(error)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_error","title":"end_error","text":"<pre><code>end_error(error: Error)\n</code></pre> <p>Called when a ERROR element ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_error(self, error: 'Error'):\n    \"\"\"Called when a ERROR element ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(error)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.visit_message","title":"visit_message","text":"<pre><code>visit_message(message: Message)\n</code></pre> <p>Implements visiting messages.</p> <p>Can be overridden to allow modifying the passed in <code>msg</code> without calling :meth:<code>start_message</code> or :meth:<code>end_message</code>.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def visit_message(self, message: 'Message'):\n    \"\"\"Implements visiting messages.\n\n    Can be overridden to allow modifying the passed in ``msg`` without\n    calling :meth:`start_message` or :meth:`end_message`.\n    \"\"\"\n    if self.start_message(message) is not False:\n        self.end_message(message)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_message","title":"start_message","text":"<pre><code>start_message(message: Message) -&gt; bool | None\n</code></pre> <p>Called when a message starts.</p> <p>By default, calls :meth:<code>start_body_item</code> which, by default, does nothing.</p> <p>Can return explicit <code>False</code> to stop visiting.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_message(self, message: 'Message') -&gt; 'bool|None':\n    \"\"\"Called when a message starts.\n\n    By default, calls :meth:`start_body_item` which, by default, does nothing.\n\n    Can return explicit ``False`` to stop visiting.\n    \"\"\"\n    return self.start_body_item(message)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_message","title":"end_message","text":"<pre><code>end_message(message: Message)\n</code></pre> <p>Called when a message ends.</p> <p>By default, calls :meth:<code>end_body_item</code> which, by default, does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_message(self, message: 'Message'):\n    \"\"\"Called when a message ends.\n\n    By default, calls :meth:`end_body_item` which, by default, does nothing.\n    \"\"\"\n    self.end_body_item(message)\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.start_body_item","title":"start_body_item","text":"<pre><code>start_body_item(item: BodyItem) -&gt; bool | None\n</code></pre> <p>Called, by default, when keywords, messages or control structures start.</p> <p>More specific :meth:<code>start_keyword</code>, :meth:<code>start_message</code>, <code>:meth:</code>start_for`, etc. can be implemented to visit only keywords, messages or specific control structures.</p> <p>Can return explicit <code>False</code> to stop visiting. Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def start_body_item(self, item: 'BodyItem') -&gt; 'bool|None':\n    \"\"\"Called, by default, when keywords, messages or control structures start.\n\n    More specific :meth:`start_keyword`, :meth:`start_message`, `:meth:`start_for`,\n    etc. can be implemented to visit only keywords, messages or specific control\n    structures.\n\n    Can return explicit ``False`` to stop visiting. Default implementation does\n    nothing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/visitor/#robot.result.visitor.ResultVisitor.end_body_item","title":"end_body_item","text":"<pre><code>end_body_item(item: BodyItem)\n</code></pre> <p>Called, by default, when keywords, messages or control structures end.</p> <p>More specific :meth:<code>end_keyword</code>, :meth:<code>end_message</code>, <code>:meth:</code>end_for`, etc. can be implemented to visit only keywords, messages or specific control structures.</p> <p>Default implementation does nothing.</p> Source code in <code>src/robot/model/visitor.py</code> <pre><code>def end_body_item(self, item: 'BodyItem'):\n    \"\"\"Called, by default, when keywords, messages or control structures end.\n\n    More specific :meth:`end_keyword`, :meth:`end_message`, `:meth:`end_for`,\n    etc. can be implemented to visit only keywords, messages or specific control\n    structures.\n\n    Default implementation does nothing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/result/xmlelementhandlers/","title":"robot.result.xmlelementhandlers","text":""},{"location":"api/robot/result/xmlelementhandlers/#robot.result.xmlelementhandlers","title":"robot.result.xmlelementhandlers","text":""},{"location":"api/robot/running/","title":"robot.running","text":""},{"location":"api/robot/running/#robot.running","title":"robot.running","text":"<p>Implements the core test execution logic.</p> <p>The public API of this module consists of the following objects:</p> <ul> <li> <p>:class:<code>~robot.running.model.TestSuite</code> for creating an executable   test suite structure programmatically.</p> </li> <li> <p>:class:<code>~robot.running.builder.builders.TestSuiteBuilder</code> for creating   executable test suites based on data on a file system.   Instead of using this class directly, it is possible to use the   :meth:<code>TestSuite.from_file_system &lt;robot.running.model.TestSuite.from_file_system&gt;</code>   classmethod that uses it internally.</p> </li> <li> <p>Classes used by :class:<code>~robot.running.model.TestSuite</code>, such as   :class:<code>~robot.running.model.TestCase</code>, :class:<code>~robot.running.model.Keyword</code>   and :class:<code>~robot.running.model.If</code> that are defined in the   :mod:<code>robot.running.model</code> module. These classes are typically only needed   in type hints.</p> </li> <li> <p>Keyword implementation related classes :class:<code>~robot.running.resourcemodel.UserKeyword</code>,   :class:<code>~robot.running.librarykeyword.LibraryKeyword</code>,   :class:<code>~robot.running.invalidkeyword.InvalidKeyword</code> and their common base class   :class:<code>~robot.running.keywordimplementation.KeywordImplementation</code>. Also these   classes are mainly needed in type hints.</p> </li> <li> <p>:class:<code>~robot.running.builder.settings.TestDefaults</code> that is part of the   <code>external parsing API</code>__ and also typically needed only in type hints.</p> </li> </ul> <p>__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#parser-interface</p> <p>:class:<code>~robot.running.model.TestSuite</code> and :class:<code>~robot.running.builder.builders.TestSuiteBuilder</code> can be imported also via the :mod:<code>robot.api</code> package.</p> <p>.. note:: Prior to Robot Framework 6.1, only some classes in           :mod:<code>robot.running.model</code> were exposed via :mod:<code>robot.running</code>.           Keyword implementation related classes are new in Robot Framework 7.0.</p>"},{"location":"api/robot/running/#robot.running--examples","title":"Examples","text":"<p>First, let's assume we have the following test suite in file <code>activate_skynet.robot</code>::</p> <pre><code>*** Settings ***\nLibrary    OperatingSystem\n\n*** Test Cases ***\nShould Activate Skynet\n    [Tags]    smoke\n    [Setup]    Set Environment Variable    SKYNET    activated\n    Environment Variable Should Be Set    SKYNET\n</code></pre> <p>We can easily create an executable test suite based on the above file::</p> <pre><code>from robot.api import TestSuite\n\nsuite = TestSuite.from_file_system('path/to/activate_skynet.robot')\n</code></pre> <p>That was easy. Let's next generate the same test suite from scratch::</p> <pre><code>from robot.api import TestSuite\n\nsuite = TestSuite('Activate Skynet')\nsuite.resource.imports.library('OperatingSystem')\ntest = suite.tests.create('Should Activate Skynet', tags=['smoke'])\ntest.setup.config(name='Set Environment Variable', args=['SKYNET', 'activated'])\ntest.body.create_keyword('Environment Variable Should Be Set', args=['SKYNET'])\n</code></pre> <p>Not that complicated either, especially considering the flexibility. Notice that the suite created based on the file could also be edited further using the same API.</p> <p>Now that we have a test suite ready, let's :meth:<code>execute it &lt;robot.running.model.TestSuite.run&gt;</code> and verify that the returned :class:<code>~robot.result.executionresult.Result</code> object contains correct information::</p> <pre><code>result = suite.run(output='skynet.xml')\n\nassert result.return_code == 0\nassert result.suite.name == 'Activate Skynet'\ntest = result.suite.tests[0]\nassert test.name == 'Should Activate Skynet'\nassert test.passed\nstats = result.suite.statistics\nassert stats.total == 1 and stats.passed == 1 and stats.failed == 0\n</code></pre> <p>Running the suite generates a normal output XML file, unless it is disabled by using <code>output=None</code>. Generating log, report, and xUnit files based on the results is possible using the :class:<code>~robot.reporting.resultwriter.ResultWriter</code> class::</p> <pre><code>from robot.api import ResultWriter\n\n# Report and xUnit files can be generated based on the result object.\nResultWriter(result).write_results(report='skynet.html', log=None)\n# Generating log files requires processing the earlier generated output XML.\nResultWriter('skynet.xml').write_results()\n</code></pre>"},{"location":"api/robot/running/bodyrunner/","title":"robot.running.bodyrunner","text":""},{"location":"api/robot/running/bodyrunner/#robot.running.bodyrunner","title":"robot.running.bodyrunner","text":""},{"location":"api/robot/running/context/","title":"robot.running.context","text":""},{"location":"api/robot/running/context/#robot.running.context","title":"robot.running.context","text":""},{"location":"api/robot/running/dynamicmethods/","title":"robot.running.dynamicmethods","text":""},{"location":"api/robot/running/dynamicmethods/#robot.running.dynamicmethods","title":"robot.running.dynamicmethods","text":""},{"location":"api/robot/running/importer/","title":"robot.running.importer","text":""},{"location":"api/robot/running/importer/#robot.running.importer","title":"robot.running.importer","text":""},{"location":"api/robot/running/importer/#robot.running.importer.ImportCache","title":"ImportCache","text":"<pre><code>ImportCache()\n</code></pre> <p>Keeps track on and optionally caches imported items.</p> <p>Handles paths in keys case-insensitively on case-insensitive OSes. Unlike dicts, this storage accepts mutable values in keys.</p> Source code in <code>src/robot/running/importer.py</code> <pre><code>def __init__(self):\n    self._keys = []\n    self._items = []\n</code></pre>"},{"location":"api/robot/running/invalidkeyword/","title":"robot.running.invalidkeyword","text":""},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword","title":"robot.running.invalidkeyword","text":""},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword.InvalidKeyword","title":"InvalidKeyword","text":"<pre><code>InvalidKeyword(\n    name: str = \"\",\n    args: ArgumentSpec | None = None,\n    doc: str = \"\",\n    tags: Tags | Sequence[str] = (),\n    lineno: int | None = None,\n    owner: ResourceFile | TestLibrary | None = None,\n    parent: BodyItemParent | None = None,\n    error: str | None = None,\n)\n</code></pre> <p>               Bases: <code>KeywordImplementation</code></p> <p>Represents an invalid keyword call.</p> <p>Keyword may not have been found, there could have been multiple matches, or the keyword call itself could have been invalid.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>def __init__(self, name: str = '',\n             args: 'ArgumentSpec|None' = None,\n             doc: str = '',\n             tags: 'Tags|Sequence[str]' = (),\n             lineno: 'int|None' = None,\n             owner: 'ResourceFile|TestLibrary|None' = None,\n             parent: 'BodyItemParent|None' = None,\n             error: 'str|None' = None):\n    self._name = name\n    self.embedded = self._get_embedded(name)\n    self.args = args\n    self._doc = doc\n    self.tags = tags\n    self._lineno = lineno\n    self.owner = owner\n    self.parent = parent\n    self.error = error\n</code></pre>"},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword.InvalidKeyword.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword.InvalidKeyword.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword.InvalidKeyword.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; DataDict\n</code></pre> <p>Serialize this object into a dictionary.</p> <p>The object can be later restored by using the :meth:<code>from_dict</code> method.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_dict(self) -&gt; DataDict:\n    \"\"\"Serialize this object into a dictionary.\n\n    The object can be later restored by using the :meth:`from_dict` method.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword.InvalidKeyword.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword.InvalidKeyword.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword.InvalidKeyword.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword.InvalidKeyword.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword.InvalidKeyword.args","title":"args","text":"<pre><code>args(spec: ArgumentSpec | None) -&gt; ArgumentSpec\n</code></pre> <p>Information about accepted arguments.</p> <p>It would be more correct to use term parameter instead of argument in this context, and this attribute may be renamed accordingly in the future. A forward compatible :attr:<code>params</code> attribute exists already now.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>@setter\ndef args(self, spec: 'ArgumentSpec|None') -&gt; ArgumentSpec:\n    \"\"\"Information about accepted arguments.\n\n    It would be more correct to use term *parameter* instead of\n    *argument* in this context, and this attribute may be renamed\n    accordingly in the future. A forward compatible :attr:`params`\n    attribute exists already now.\n    \"\"\"\n    if spec is None:\n        spec = ArgumentSpec()\n    spec.name = lambda: self.full_name\n    return spec\n</code></pre>"},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword.InvalidKeyword.params","title":"params  <code>property</code>","text":"<pre><code>params: ArgumentSpec\n</code></pre> <p>Keyword parameter information.</p> <p>This is a forward compatible alias for :attr:<code>args</code>.</p>"},{"location":"api/robot/running/invalidkeyword/#robot.running.invalidkeyword.InvalidKeyword.matches","title":"matches","text":"<pre><code>matches(name: str) -&gt; bool\n</code></pre> <p>Returns true if <code>name</code> matches the keyword name.</p> <p>With normal keywords matching is a case, space and underscore insensitive string comparison. With keywords accepting embedded arguments, matching is done against the name.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>def matches(self, name: str) -&gt; bool:\n    \"\"\"Returns true if ``name`` matches the keyword name.\n\n    With normal keywords matching is a case, space and underscore insensitive\n    string comparison. With keywords accepting embedded arguments, matching\n    is done against the name.\n    \"\"\"\n    if self.embedded:\n        return self.embedded.match(name) is not None\n    return eq(self.name, name, ignore='_')\n</code></pre>"},{"location":"api/robot/running/keywordfinder/","title":"robot.running.keywordfinder","text":""},{"location":"api/robot/running/keywordfinder/#robot.running.keywordfinder","title":"robot.running.keywordfinder","text":""},{"location":"api/robot/running/keywordfinder/#robot.running.keywordfinder.KeywordFinder","title":"KeywordFinder","text":"<pre><code>KeywordFinder(owner: TestLibrary | ResourceFile)\n</code></pre> <p>               Bases: <code>Generic[K]</code></p> Source code in <code>src/robot/running/keywordfinder.py</code> <pre><code>def __init__(self, owner: 'TestLibrary|ResourceFile'):\n    self.owner = owner\n    self.cache: KeywordCache|None = None\n</code></pre>"},{"location":"api/robot/running/keywordfinder/#robot.running.keywordfinder.KeywordFinder.find","title":"find","text":"<pre><code>find(name: str, count: Literal[1]) -&gt; K\n</code></pre><pre><code>find(name: str, count: int | None = None) -&gt; list[K]\n</code></pre> <pre><code>find(name: str, count: int | None = None) -&gt; list[K] | K\n</code></pre> <p>Find keywords based on the given <code>name</code>.</p> <p>With normal keywords matching is a case, space and underscore insensitive string comparison and there cannot be more than one match. With keywords accepting embedded arguments, matching is done against the name and there can be multiple matches.</p> <p>Returns matching keywords as a list, possibly as an empty list, without any validation by default. If the optional <code>count</code> is used, raises a <code>ValueError</code> if the number of found keywords does not match. If <code>count</code> is <code>1</code> and exactly one keyword is found, returns that keyword directly and not as a list.</p> Source code in <code>src/robot/running/keywordfinder.py</code> <pre><code>def find(self, name: str, count: 'int|None' = None) -&gt; 'list[K]|K':\n    \"\"\"Find keywords based on the given ``name``.\n\n    With normal keywords matching is a case, space and underscore insensitive\n    string comparison and there cannot be more than one match. With keywords\n    accepting embedded arguments, matching is done against the name and\n    there can be multiple matches.\n\n    Returns matching keywords as a list, possibly as an empty list, without\n    any validation by default. If the optional ``count`` is used, raises\n    a ``ValueError`` if the number of found keywords does not match. If\n    ``count`` is ``1`` and exactly one keyword is found, returns that keyword\n    directly and not as a list.\n    \"\"\"\n    if self.cache is None:\n        self.cache = KeywordCache[K](self.owner.keywords)\n    return self.cache.find(name, count)\n</code></pre>"},{"location":"api/robot/running/keywordimplementation/","title":"robot.running.keywordimplementation","text":""},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation","title":"robot.running.keywordimplementation","text":""},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation.KeywordImplementation","title":"KeywordImplementation","text":"<pre><code>KeywordImplementation(\n    name: str = \"\",\n    args: ArgumentSpec | None = None,\n    doc: str = \"\",\n    tags: Tags | Sequence[str] = (),\n    lineno: int | None = None,\n    owner: ResourceFile | TestLibrary | None = None,\n    parent: BodyItemParent | None = None,\n    error: str | None = None,\n)\n</code></pre> <p>               Bases: <code>ModelObject</code></p> <p>Base class for different keyword implementations.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>def __init__(self, name: str = '',\n             args: 'ArgumentSpec|None' = None,\n             doc: str = '',\n             tags: 'Tags|Sequence[str]' = (),\n             lineno: 'int|None' = None,\n             owner: 'ResourceFile|TestLibrary|None' = None,\n             parent: 'BodyItemParent|None' = None,\n             error: 'str|None' = None):\n    self._name = name\n    self.embedded = self._get_embedded(name)\n    self.args = args\n    self._doc = doc\n    self.tags = tags\n    self._lineno = lineno\n    self.owner = owner\n    self.parent = parent\n    self.error = error\n</code></pre>"},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation.KeywordImplementation.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation.KeywordImplementation.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation.KeywordImplementation.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; DataDict\n</code></pre> <p>Serialize this object into a dictionary.</p> <p>The object can be later restored by using the :meth:<code>from_dict</code> method.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_dict(self) -&gt; DataDict:\n    \"\"\"Serialize this object into a dictionary.\n\n    The object can be later restored by using the :meth:`from_dict` method.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation.KeywordImplementation.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation.KeywordImplementation.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation.KeywordImplementation.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation.KeywordImplementation.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation.KeywordImplementation.args","title":"args","text":"<pre><code>args(spec: ArgumentSpec | None) -&gt; ArgumentSpec\n</code></pre> <p>Information about accepted arguments.</p> <p>It would be more correct to use term parameter instead of argument in this context, and this attribute may be renamed accordingly in the future. A forward compatible :attr:<code>params</code> attribute exists already now.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>@setter\ndef args(self, spec: 'ArgumentSpec|None') -&gt; ArgumentSpec:\n    \"\"\"Information about accepted arguments.\n\n    It would be more correct to use term *parameter* instead of\n    *argument* in this context, and this attribute may be renamed\n    accordingly in the future. A forward compatible :attr:`params`\n    attribute exists already now.\n    \"\"\"\n    if spec is None:\n        spec = ArgumentSpec()\n    spec.name = lambda: self.full_name\n    return spec\n</code></pre>"},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation.KeywordImplementation.params","title":"params  <code>property</code>","text":"<pre><code>params: ArgumentSpec\n</code></pre> <p>Keyword parameter information.</p> <p>This is a forward compatible alias for :attr:<code>args</code>.</p>"},{"location":"api/robot/running/keywordimplementation/#robot.running.keywordimplementation.KeywordImplementation.matches","title":"matches","text":"<pre><code>matches(name: str) -&gt; bool\n</code></pre> <p>Returns true if <code>name</code> matches the keyword name.</p> <p>With normal keywords matching is a case, space and underscore insensitive string comparison. With keywords accepting embedded arguments, matching is done against the name.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>def matches(self, name: str) -&gt; bool:\n    \"\"\"Returns true if ``name`` matches the keyword name.\n\n    With normal keywords matching is a case, space and underscore insensitive\n    string comparison. With keywords accepting embedded arguments, matching\n    is done against the name.\n    \"\"\"\n    if self.embedded:\n        return self.embedded.match(name) is not None\n    return eq(self.name, name, ignore='_')\n</code></pre>"},{"location":"api/robot/running/librarykeyword/","title":"robot.running.librarykeyword","text":""},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword","title":"robot.running.librarykeyword","text":""},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryKeyword","title":"LibraryKeyword","text":"<pre><code>LibraryKeyword(\n    owner: TestLibrary,\n    name: str = \"\",\n    args: ArgumentSpec | None = None,\n    doc: str = \"\",\n    tags: Tags | Sequence[str] = (),\n    resolve_args_until: int | None = None,\n    parent: BodyItemParent | None = None,\n    error: str | None = None,\n)\n</code></pre> <p>               Bases: <code>KeywordImplementation</code></p> <p>Base class for different library keywords.</p> Source code in <code>src/robot/running/librarykeyword.py</code> <pre><code>def __init__(self, owner: 'TestLibrary',\n             name: str = '',\n             args: 'ArgumentSpec|None' = None,\n             doc: str = '',\n             tags: 'Tags|Sequence[str]' = (),\n             resolve_args_until: 'int|None' = None,\n             parent: 'BodyItemParent|None' = None,\n             error: 'str|None' = None):\n    super().__init__(name, args, doc, tags, owner=owner, parent=parent, error=error)\n    self._resolve_args_until = resolve_args_until\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryKeyword.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryKeyword.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryKeyword.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; DataDict\n</code></pre> <p>Serialize this object into a dictionary.</p> <p>The object can be later restored by using the :meth:<code>from_dict</code> method.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_dict(self) -&gt; DataDict:\n    \"\"\"Serialize this object into a dictionary.\n\n    The object can be later restored by using the :meth:`from_dict` method.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryKeyword.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryKeyword.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryKeyword.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryKeyword.args","title":"args","text":"<pre><code>args(spec: ArgumentSpec | None) -&gt; ArgumentSpec\n</code></pre> <p>Information about accepted arguments.</p> <p>It would be more correct to use term parameter instead of argument in this context, and this attribute may be renamed accordingly in the future. A forward compatible :attr:<code>params</code> attribute exists already now.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>@setter\ndef args(self, spec: 'ArgumentSpec|None') -&gt; ArgumentSpec:\n    \"\"\"Information about accepted arguments.\n\n    It would be more correct to use term *parameter* instead of\n    *argument* in this context, and this attribute may be renamed\n    accordingly in the future. A forward compatible :attr:`params`\n    attribute exists already now.\n    \"\"\"\n    if spec is None:\n        spec = ArgumentSpec()\n    spec.name = lambda: self.full_name\n    return spec\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryKeyword.params","title":"params  <code>property</code>","text":"<pre><code>params: ArgumentSpec\n</code></pre> <p>Keyword parameter information.</p> <p>This is a forward compatible alias for :attr:<code>args</code>.</p>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryKeyword.matches","title":"matches","text":"<pre><code>matches(name: str) -&gt; bool\n</code></pre> <p>Returns true if <code>name</code> matches the keyword name.</p> <p>With normal keywords matching is a case, space and underscore insensitive string comparison. With keywords accepting embedded arguments, matching is done against the name.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>def matches(self, name: str) -&gt; bool:\n    \"\"\"Returns true if ``name`` matches the keyword name.\n\n    With normal keywords matching is a case, space and underscore insensitive\n    string comparison. With keywords accepting embedded arguments, matching\n    is done against the name.\n    \"\"\"\n    if self.embedded:\n        return self.embedded.match(name) is not None\n    return eq(self.name, name, ignore='_')\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.StaticKeyword","title":"StaticKeyword","text":"<pre><code>StaticKeyword(\n    method_name: str,\n    owner: TestLibrary,\n    name: str = \"\",\n    args: ArgumentSpec | None = None,\n    doc: str = \"\",\n    tags: Tags | Sequence[str] = (),\n    resolve_args_until: int | None = None,\n    parent: BodyItemParent | None = None,\n    error: str | None = None,\n)\n</code></pre> <p>               Bases: <code>LibraryKeyword</code></p> <p>Represents a keyword in a static library.</p> Source code in <code>src/robot/running/librarykeyword.py</code> <pre><code>def __init__(self, method_name: str,\n             owner: 'TestLibrary',\n             name: str = '',\n             args: 'ArgumentSpec|None' = None,\n             doc: str = '',\n             tags: 'Tags|Sequence[str]' = (),\n             resolve_args_until: 'int|None' = None,\n             parent: 'BodyItemParent|None' = None,\n             error: 'str|None' = None):\n    super().__init__(owner, name, args, doc, tags, resolve_args_until, parent, error)\n    self.method_name = method_name\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.StaticKeyword.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.StaticKeyword.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.StaticKeyword.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; DataDict\n</code></pre> <p>Serialize this object into a dictionary.</p> <p>The object can be later restored by using the :meth:<code>from_dict</code> method.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_dict(self) -&gt; DataDict:\n    \"\"\"Serialize this object into a dictionary.\n\n    The object can be later restored by using the :meth:`from_dict` method.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.StaticKeyword.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.StaticKeyword.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.StaticKeyword.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.StaticKeyword.args","title":"args","text":"<pre><code>args(spec: ArgumentSpec | None) -&gt; ArgumentSpec\n</code></pre> <p>Information about accepted arguments.</p> <p>It would be more correct to use term parameter instead of argument in this context, and this attribute may be renamed accordingly in the future. A forward compatible :attr:<code>params</code> attribute exists already now.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>@setter\ndef args(self, spec: 'ArgumentSpec|None') -&gt; ArgumentSpec:\n    \"\"\"Information about accepted arguments.\n\n    It would be more correct to use term *parameter* instead of\n    *argument* in this context, and this attribute may be renamed\n    accordingly in the future. A forward compatible :attr:`params`\n    attribute exists already now.\n    \"\"\"\n    if spec is None:\n        spec = ArgumentSpec()\n    spec.name = lambda: self.full_name\n    return spec\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.StaticKeyword.params","title":"params  <code>property</code>","text":"<pre><code>params: ArgumentSpec\n</code></pre> <p>Keyword parameter information.</p> <p>This is a forward compatible alias for :attr:<code>args</code>.</p>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.StaticKeyword.matches","title":"matches","text":"<pre><code>matches(name: str) -&gt; bool\n</code></pre> <p>Returns true if <code>name</code> matches the keyword name.</p> <p>With normal keywords matching is a case, space and underscore insensitive string comparison. With keywords accepting embedded arguments, matching is done against the name.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>def matches(self, name: str) -&gt; bool:\n    \"\"\"Returns true if ``name`` matches the keyword name.\n\n    With normal keywords matching is a case, space and underscore insensitive\n    string comparison. With keywords accepting embedded arguments, matching\n    is done against the name.\n    \"\"\"\n    if self.embedded:\n        return self.embedded.match(name) is not None\n    return eq(self.name, name, ignore='_')\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.StaticKeyword.method","title":"method  <code>property</code>","text":"<pre><code>method: Callable[..., Any]\n</code></pre> <p>Keyword method.</p>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.DynamicKeyword","title":"DynamicKeyword","text":"<pre><code>DynamicKeyword(\n    owner: DynamicLibrary,\n    name: str = \"\",\n    args: ArgumentSpec | None = None,\n    doc: str = \"\",\n    tags: Tags | Sequence[str] = (),\n    resolve_args_until: int | None = None,\n    parent: BodyItemParent | None = None,\n    error: str | None = None,\n)\n</code></pre> <p>               Bases: <code>LibraryKeyword</code></p> <p>Represents a keyword in a dynamic library.</p> Source code in <code>src/robot/running/librarykeyword.py</code> <pre><code>def __init__(self, owner: 'DynamicLibrary',\n             name: str = '',\n             args: 'ArgumentSpec|None' = None,\n             doc: str = '',\n             tags: 'Tags|Sequence[str]' = (),\n             resolve_args_until: 'int|None' = None,\n             parent: 'BodyItemParent|None' = None,\n             error: 'str|None' = None):\n    # TODO: It would probably be better not to convert name we got from\n    # `get_keyword_names`. That would have some backwards incompatibility\n    # effects, but we can consider it in RF 8.0.\n    super().__init__(owner, printable_name(name, code_style=True), args, doc,\n                     tags, resolve_args_until, parent, error)\n    self._orig_name = name\n    self.__source_info = None\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.DynamicKeyword.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.DynamicKeyword.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.DynamicKeyword.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; DataDict\n</code></pre> <p>Serialize this object into a dictionary.</p> <p>The object can be later restored by using the :meth:<code>from_dict</code> method.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_dict(self) -&gt; DataDict:\n    \"\"\"Serialize this object into a dictionary.\n\n    The object can be later restored by using the :meth:`from_dict` method.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.DynamicKeyword.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.DynamicKeyword.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.DynamicKeyword.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.DynamicKeyword.args","title":"args","text":"<pre><code>args(spec: ArgumentSpec | None) -&gt; ArgumentSpec\n</code></pre> <p>Information about accepted arguments.</p> <p>It would be more correct to use term parameter instead of argument in this context, and this attribute may be renamed accordingly in the future. A forward compatible :attr:<code>params</code> attribute exists already now.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>@setter\ndef args(self, spec: 'ArgumentSpec|None') -&gt; ArgumentSpec:\n    \"\"\"Information about accepted arguments.\n\n    It would be more correct to use term *parameter* instead of\n    *argument* in this context, and this attribute may be renamed\n    accordingly in the future. A forward compatible :attr:`params`\n    attribute exists already now.\n    \"\"\"\n    if spec is None:\n        spec = ArgumentSpec()\n    spec.name = lambda: self.full_name\n    return spec\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.DynamicKeyword.params","title":"params  <code>property</code>","text":"<pre><code>params: ArgumentSpec\n</code></pre> <p>Keyword parameter information.</p> <p>This is a forward compatible alias for :attr:<code>args</code>.</p>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.DynamicKeyword.matches","title":"matches","text":"<pre><code>matches(name: str) -&gt; bool\n</code></pre> <p>Returns true if <code>name</code> matches the keyword name.</p> <p>With normal keywords matching is a case, space and underscore insensitive string comparison. With keywords accepting embedded arguments, matching is done against the name.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>def matches(self, name: str) -&gt; bool:\n    \"\"\"Returns true if ``name`` matches the keyword name.\n\n    With normal keywords matching is a case, space and underscore insensitive\n    string comparison. With keywords accepting embedded arguments, matching\n    is done against the name.\n    \"\"\"\n    if self.embedded:\n        return self.embedded.match(name) is not None\n    return eq(self.name, name, ignore='_')\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.DynamicKeyword.method","title":"method  <code>property</code>","text":"<pre><code>method: Callable[..., Any]\n</code></pre> <p>Dynamic <code>run_keyword</code> method.</p>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryInit","title":"LibraryInit","text":"<pre><code>LibraryInit(\n    owner: TestLibrary,\n    name: str = \"\",\n    args: ArgumentSpec | None = None,\n    doc: str = \"\",\n    tags: Tags | Sequence[str] = (),\n    positional: list | None = None,\n    named: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>LibraryKeyword</code></p> <p>Represents a library initializer.</p> <p>:attr:<code>positional</code> and :attr:<code>named</code> contain arguments used for initializing the library.</p> Source code in <code>src/robot/running/librarykeyword.py</code> <pre><code>def __init__(self, owner: 'TestLibrary',\n             name: str = '',\n             args: 'ArgumentSpec|None' = None,\n             doc: str = '',\n             tags: 'Tags|Sequence[str]' = (),\n             positional: 'list|None' = None,\n             named: 'dict|None' = None):\n    super().__init__(owner, name, args, doc, tags)\n    self.positional = positional or []\n    self.named = named or {}\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryInit.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryInit.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryInit.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; DataDict\n</code></pre> <p>Serialize this object into a dictionary.</p> <p>The object can be later restored by using the :meth:<code>from_dict</code> method.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_dict(self) -&gt; DataDict:\n    \"\"\"Serialize this object into a dictionary.\n\n    The object can be later restored by using the :meth:`from_dict` method.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryInit.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryInit.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryInit.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryInit.args","title":"args","text":"<pre><code>args(spec: ArgumentSpec | None) -&gt; ArgumentSpec\n</code></pre> <p>Information about accepted arguments.</p> <p>It would be more correct to use term parameter instead of argument in this context, and this attribute may be renamed accordingly in the future. A forward compatible :attr:<code>params</code> attribute exists already now.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>@setter\ndef args(self, spec: 'ArgumentSpec|None') -&gt; ArgumentSpec:\n    \"\"\"Information about accepted arguments.\n\n    It would be more correct to use term *parameter* instead of\n    *argument* in this context, and this attribute may be renamed\n    accordingly in the future. A forward compatible :attr:`params`\n    attribute exists already now.\n    \"\"\"\n    if spec is None:\n        spec = ArgumentSpec()\n    spec.name = lambda: self.full_name\n    return spec\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryInit.params","title":"params  <code>property</code>","text":"<pre><code>params: ArgumentSpec\n</code></pre> <p>Keyword parameter information.</p> <p>This is a forward compatible alias for :attr:<code>args</code>.</p>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryInit.matches","title":"matches","text":"<pre><code>matches(name: str) -&gt; bool\n</code></pre> <p>Returns true if <code>name</code> matches the keyword name.</p> <p>With normal keywords matching is a case, space and underscore insensitive string comparison. With keywords accepting embedded arguments, matching is done against the name.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>def matches(self, name: str) -&gt; bool:\n    \"\"\"Returns true if ``name`` matches the keyword name.\n\n    With normal keywords matching is a case, space and underscore insensitive\n    string comparison. With keywords accepting embedded arguments, matching\n    is done against the name.\n    \"\"\"\n    if self.embedded:\n        return self.embedded.match(name) is not None\n    return eq(self.name, name, ignore='_')\n</code></pre>"},{"location":"api/robot/running/librarykeyword/#robot.running.librarykeyword.LibraryInit.method","title":"method  <code>property</code>","text":"<pre><code>method: Callable[..., None] | None\n</code></pre> <p>Initializer method.</p> <p><code>None</code> with module based libraries and when class based libraries do not have <code>__init__</code>.</p>"},{"location":"api/robot/running/librarykeywordrunner/","title":"robot.running.librarykeywordrunner","text":""},{"location":"api/robot/running/librarykeywordrunner/#robot.running.librarykeywordrunner","title":"robot.running.librarykeywordrunner","text":""},{"location":"api/robot/running/libraryscopes/","title":"robot.running.libraryscopes","text":""},{"location":"api/robot/running/libraryscopes/#robot.running.libraryscopes","title":"robot.running.libraryscopes","text":""},{"location":"api/robot/running/model/","title":"robot.running.model","text":""},{"location":"api/robot/running/model/#robot.running.model","title":"robot.running.model","text":"<p>Module implementing test execution related model objects.</p> <p>When tests are executed by Robot Framework, a :class:<code>TestSuite</code> structure using classes defined in this module is created by :class:<code>~robot.running.builder.builders.TestSuiteBuilder</code> based on data on a file system. In addition to that, external tools can create executable suite structures programmatically.</p> <p>Regardless the approach to construct it, a :class:<code>TestSuite</code> object is executed by calling its :meth:<code>~TestSuite.run</code> method as shown in the example in the :mod:<code>robot.running</code> package level documentation. When a suite is run, test, keywords, and other objects it contains can be inspected and modified by using <code>pre-run modifiers</code> and <code>listeners</code>.</p> <p>The :class:<code>TestSuite</code> class is exposed via the :mod:<code>robot.api</code> package. If other classes are needed, they can be imported from :mod:<code>robot.running</code>.</p> <p>__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#programmatic-modification-of-results __ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-interface</p>"},{"location":"api/robot/running/model/#robot.running.model.Argument","title":"Argument","text":"<pre><code>Argument(name: str | None, value: Any)\n</code></pre> <p>A temporary API for creating named arguments with non-string values.</p> <p>This class was added in RF 7.0.1 (#5031) after a failed attempt to add a public API for this purpose in RF 7.0 (#5000). A better public API that allows passing named arguments separately was added in RF 7.1 (#5143).</p> <p>If you need to support also RF 7.0, you can pass named arguments as two-item tuples like <code>(name, value)</code> and positional arguments as one-item tuples like <code>(value,)</code>. That approach does not work anymore in RF 7.0.1, though, so the code needs to be conditional depending on Robot Framework version.</p> <p>The main limitation of this class is that it is not compatible with the JSON model. The current plan is to remove this in the future, possibly already in RF 8.0, but we can consider preserving it if it turns out to be useful.</p> <p>:param name: Argument name. If <code>None</code>, argument is considered positional. :param value: Argument value.</p> Source code in <code>src/robot/running/model.py</code> <pre><code>def __init__(self, name: 'str|None', value: Any):\n    \"\"\"\n    :param name: Argument name. If ``None``, argument is considered positional.\n    :param value: Argument value.\n    \"\"\"\n    self.name = name\n    self.value = value\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.Keyword","title":"Keyword","text":"<pre><code>Keyword(\n    name: str = \"\",\n    args: Sequence[str | Argument | Any] = (),\n    named_args: Mapping[str, Any] | None = None,\n    assign: Sequence[str] = (),\n    type: str = KEYWORD,\n    parent: BodyItemParent = None,\n    lineno: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Keyword</code>, <code>WithSource</code></p> <p>Represents an executable keyword call.</p> <p>A keyword call consists only of a keyword name, arguments and possible assignment in the data::</p> <pre><code>Keyword    arg\n${result} =    Another Keyword    arg1    arg2\n</code></pre> <p>The actual keyword that is executed depends on the context where this model is executed.</p> <p>Arguments originating from normal Robot Framework data are stored in the :attr:<code>args</code> attribute as a tuple of strings in the exact same format as in the data. This means that arguments can have variables and escape characters, and that named arguments are specified using the <code>name=value</code> syntax.</p> <p>When creating keywords programmatically, it is possible to set :attr:<code>named_args</code> separately and use :attr:<code>args</code> only for positional arguments. Argument values do not need to be strings, but also in this case strings can contain variables and normal Robot Framework escaping rules must be taken into account.</p> Source code in <code>src/robot/running/model.py</code> <pre><code>def __init__(self, name: str = '',\n             args: 'Sequence[str|Argument|Any]' = (),\n             named_args: 'Mapping[str, Any]|None' = None,\n             assign: Sequence[str] = (),\n             type: str = BodyItem.KEYWORD,\n             parent: BodyItemParent = None,\n             lineno: 'int|None' = None):\n    super().__init__(name, args, assign, type, parent)\n    self.named_args = named_args\n    self.lineno = lineno\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.Keyword.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.Keyword.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.Keyword.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.Keyword.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.Keyword.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.Keyword.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.Keyword.visit","title":"visit","text":"<pre><code>visit(visitor: SuiteVisitor)\n</code></pre> <p>:mod:<code>Visitor interface &lt;robot.model.visitor&gt;</code> entry-point.</p> Source code in <code>src/robot/model/keyword.py</code> <pre><code>def visit(self, visitor: 'SuiteVisitor'):\n    \"\"\":mod:`Visitor interface &lt;robot.model.visitor&gt;` entry-point.\"\"\"\n    if self:\n        visitor.visit_keyword(self)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestCase","title":"TestCase","text":"<pre><code>TestCase(\n    name: str = \"\",\n    doc: str = \"\",\n    tags: Sequence[str] = (),\n    timeout: str | None = None,\n    lineno: int | None = None,\n    parent: TestSuite | None = None,\n    template: str | None = None,\n    error: str | None = None,\n)\n</code></pre> <p>               Bases: <code>TestCase[Keyword]</code></p> <p>Represents a single executable test case.</p> <p>See the base class for documentation of attributes not documented here.</p> Source code in <code>src/robot/running/model.py</code> <pre><code>def __init__(self, name: str = '',\n             doc: str = '',\n             tags: Sequence[str] = (),\n             timeout: 'str|None' = None,\n             lineno: 'int|None' = None,\n             parent: 'TestSuite|None' = None,\n             template: 'str|None' = None,\n             error: 'str|None' = None):\n    super().__init__(name, doc, tags, timeout, lineno, parent)\n    #: Name of the keyword that has been used as a template when building the test.\n    # ``None`` if template is not used.\n    self.template = template\n    self.error = error\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.tags","title":"tags","text":"<pre><code>tags(tags: Tags | Sequence[str]) -&gt; Tags\n</code></pre> <p>Test tags as a :class:<code>~.model.tags.Tags</code> object.</p> Source code in <code>src/robot/model/testcase.py</code> <pre><code>@setter\ndef tags(self, tags: 'Tags|Sequence[str]') -&gt; Tags:\n    \"\"\"Test tags as a :class:`~.model.tags.Tags` object.\"\"\"\n    return Tags(tags)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.setup","title":"setup  <code>property</code> <code>writable</code>","text":"<pre><code>setup: KW\n</code></pre> <p>Test setup as a :class:<code>~.model.keyword.Keyword</code> object.</p> <p>This attribute is a <code>Keyword</code> object also when a test has no setup but in that case its truth value is <code>False</code>.</p> <p>Setup can be modified by setting attributes directly::</p> <pre><code>test.setup.name = 'Example'\ntest.setup.args = ('First', 'Second')\n</code></pre> <p>Alternatively the :meth:<code>config</code> method can be used to set multiple attributes in one call::</p> <pre><code>test.setup.config(name='Example', args=('First', 'Second'))\n</code></pre> <p>The easiest way to reset the whole setup is setting it to <code>None</code>. It will automatically recreate the underlying <code>Keyword</code> object::</p> <pre><code>test.setup = None\n</code></pre> <p>New in Robot Framework 4.0. Earlier setup was accessed like <code>test.keywords.setup</code>.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.has_setup","title":"has_setup  <code>property</code>","text":"<pre><code>has_setup: bool\n</code></pre> <p>Check does a suite have a setup without creating a setup object.</p> <p>A difference between using <code>if test.has_setup:</code> and <code>if test.setup:</code> is that accessing the :attr:<code>setup</code> attribute creates a :class:<code>Keyword</code> object representing the setup even when the test actually does not have one. This typically does not matter, but with bigger suite structures containing a huge about of tests it can have an effect on memory usage.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.teardown","title":"teardown  <code>property</code> <code>writable</code>","text":"<pre><code>teardown: KW\n</code></pre> <p>Test teardown as a :class:<code>~.model.keyword.Keyword</code> object.</p> <p>See :attr:<code>setup</code> for more information.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.has_teardown","title":"has_teardown  <code>property</code>","text":"<pre><code>has_teardown: bool\n</code></pre> <p>Check does a test have a teardown without creating a teardown object.</p> <p>See :attr:<code>has_setup</code> for more information.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre> <p>Test case id in format like <code>s1-t3</code>.</p> <p>See :attr:<code>TestSuite.id &lt;robot.model.testsuite.TestSuite.id&gt;</code> for more information.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Test name prefixed with the full name of the parent suite.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.longname","title":"longname  <code>property</code>","text":"<pre><code>longname: str\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>full_name</code> instead.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.visit","title":"visit","text":"<pre><code>visit(visitor: SuiteVisitor)\n</code></pre> <p>:mod:<code>Visitor interface &lt;robot.model.visitor&gt;</code> entry-point.</p> Source code in <code>src/robot/model/testcase.py</code> <pre><code>def visit(self, visitor: 'SuiteVisitor'):\n    \"\"\":mod:`Visitor interface &lt;robot.model.visitor&gt;` entry-point.\"\"\"\n    visitor.visit_test(self)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestCase.body","title":"body","text":"<pre><code>body(body: Sequence[BodyItem | DataDict]) -&gt; Body\n</code></pre> <p>Test body as a :class:<code>~robot.running.Body</code> object.</p> Source code in <code>src/robot/running/model.py</code> <pre><code>@setter\ndef body(self, body: 'Sequence[BodyItem|DataDict]') -&gt; Body:\n    \"\"\"Test body as a :class:`~robot.running.Body` object.\"\"\"\n    return self.body_class(self, body)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite","title":"TestSuite","text":"<pre><code>TestSuite(\n    name: str = \"\",\n    doc: str = \"\",\n    metadata: Mapping[str, str] | None = None,\n    source: Path | str | None = None,\n    rpa: bool | None = False,\n    parent: TestSuite | None = None,\n)\n</code></pre> <p>               Bases: <code>TestSuite[Keyword, TestCase]</code></p> <p>Represents a single executable test suite.</p> <p>See the base class for documentation of attributes not documented here.</p> Source code in <code>src/robot/running/model.py</code> <pre><code>def __init__(self, name: str = '',\n             doc: str = '',\n             metadata: 'Mapping[str, str]|None' = None,\n             source: 'Path|str|None' = None,\n             rpa: 'bool|None' = False,\n             parent: 'TestSuite|None' = None):\n    super().__init__(name, doc, metadata, source, rpa, parent)\n    #: :class:`ResourceFile` instance containing imports, variables and\n    #: keywords the suite owns. When data is parsed from the file system,\n    #: this data comes from the same test case file that creates the suite.\n    self.resource = None\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.metadata","title":"metadata","text":"<pre><code>metadata(metadata: Mapping[str, str] | None) -&gt; Metadata\n</code></pre> <p>Free suite metadata as a :class:<code>~.metadata.Metadata</code> object.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>@setter\ndef metadata(self, metadata: 'Mapping[str, str]|None') -&gt; Metadata:\n    \"\"\"Free suite metadata as a :class:`~.metadata.Metadata` object.\"\"\"\n    return Metadata(metadata)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.name_from_source","title":"name_from_source  <code>staticmethod</code>","text":"<pre><code>name_from_source(\n    source: Path | str | None, extension: Sequence[str] = ()\n) -&gt; str\n</code></pre> <p>Create suite name based on the given <code>source</code>.</p> <p>This method is used by Robot Framework itself when it builds suites. External parsers and other tools that want to produce suites with names matching names created by Robot Framework can use this method as well. This method is also used if :attr:<code>name</code> is not set and someone accesses it.</p> <p>The algorithm is as follows:</p> <ul> <li>If the source is <code>None</code> or empty, return an empty string.</li> <li>Get the base name of the source. Read more below.</li> <li>Remove possible prefix separated with <code>__</code>.</li> <li>Convert underscores to spaces.</li> <li>If the name is all lower case, title case it.</li> </ul> <p>The base name of files is got by calling <code>Path.stem</code>__ that drops the file extension. It typically works fine, but gives wrong result if the extension has multiple parts like in <code>tests.robot.zip</code>. That problem can be avoided by giving valid file extension or extensions as the optional <code>extension</code> argument.</p> <p>Examples::</p> <pre><code>TestSuite.name_from_source(source)\nTestSuite.name_from_source(source, extension='.robot.zip')\nTestSuite.name_from_source(source, ('.robot', '.robot.zip'))\n</code></pre> <p>__ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.stem</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>@staticmethod\ndef name_from_source(source: 'Path|str|None', extension: Sequence[str] = ()) -&gt; str:\n    \"\"\"Create suite name based on the given ``source``.\n\n    This method is used by Robot Framework itself when it builds suites.\n    External parsers and other tools that want to produce suites with\n    names matching names created by Robot Framework can use this method as\n    well. This method is also used if :attr:`name` is not set and someone\n    accesses it.\n\n    The algorithm is as follows:\n\n    - If the source is ``None`` or empty, return an empty string.\n    - Get the base name of the source. Read more below.\n    - Remove possible prefix separated with ``__``.\n    - Convert underscores to spaces.\n    - If the name is all lower case, title case it.\n\n    The base name of files is got by calling `Path.stem`__ that drops\n    the file extension. It typically works fine, but gives wrong result\n    if the extension has multiple parts like in ``tests.robot.zip``.\n    That problem can be avoided by giving valid file extension or extensions\n    as the optional ``extension`` argument.\n\n    Examples::\n\n        TestSuite.name_from_source(source)\n        TestSuite.name_from_source(source, extension='.robot.zip')\n        TestSuite.name_from_source(source, ('.robot', '.robot.zip'))\n\n    __ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.stem\n    \"\"\"\n    if not source:\n        return ''\n    if not isinstance(source, Path):\n        source = Path(source)\n    name = TestSuite._get_base_name(source, extension)\n    if '__' in name:\n        name = name.split('__', 1)[1] or name\n    name = name.replace('_', ' ').strip()\n    return name.title() if name.islower() else name\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Suite name.</p> <p>If name is not set, it is constructed from source. If source is not set, name is constructed from child suite names by concatenating them with <code>&amp;</code>. If there are no child suites, name is an empty string.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.adjust_source","title":"adjust_source","text":"<pre><code>adjust_source(\n    relative_to: Path | str | None = None,\n    root: Path | str | None = None,\n)\n</code></pre> <p>Adjust suite source and child suite sources, recursively.</p> <p>:param relative_to: Make suite source relative to the given path. Calls     <code>pathlib.Path.relative_to()</code>__ internally. Raises <code>ValueError</code>     if creating a relative path is not possible. :param root: Make given path a new root directory for the source. Raises     <code>ValueError</code> if suite source is absolute.</p> <p>Adjusting the source is especially useful when moving data around as JSON::</p> <pre><code>from robot.api import TestSuite\n\n# Create a suite, adjust source and convert to JSON.\nsuite = TestSuite.from_file_system('/path/to/data')\nsuite.adjust_source(relative_to='/path/to')\nsuite.to_json('data.rbt')\n\n# Recreate suite elsewhere and adjust source accordingly.\nsuite = TestSuite.from_json('data.rbt')\nsuite.adjust_source(root='/new/path/to')\n</code></pre> <p>New in Robot Framework 6.1.</p> <p>__ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.relative_to</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def adjust_source(self, relative_to: 'Path|str|None' = None,\n                  root: 'Path|str|None' = None):\n    \"\"\"Adjust suite source and child suite sources, recursively.\n\n    :param relative_to: Make suite source relative to the given path. Calls\n        `pathlib.Path.relative_to()`__ internally. Raises ``ValueError``\n        if creating a relative path is not possible.\n    :param root: Make given path a new root directory for the source. Raises\n        ``ValueError`` if suite source is absolute.\n\n    Adjusting the source is especially useful when moving data around as JSON::\n\n        from robot.api import TestSuite\n\n        # Create a suite, adjust source and convert to JSON.\n        suite = TestSuite.from_file_system('/path/to/data')\n        suite.adjust_source(relative_to='/path/to')\n        suite.to_json('data.rbt')\n\n        # Recreate suite elsewhere and adjust source accordingly.\n        suite = TestSuite.from_json('data.rbt')\n        suite.adjust_source(root='/new/path/to')\n\n    New in Robot Framework 6.1.\n\n    __ https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.relative_to\n    \"\"\"\n    if not self.source:\n        raise ValueError('Suite has no source.')\n    if relative_to:\n        self.source = self.source.relative_to(relative_to)\n    if root:\n        if self.source.is_absolute():\n            raise ValueError(f\"Cannot set root for absolute source '{self.source}'.\")\n        self.source = root / self.source\n    for suite in self.suites:\n        suite.adjust_source(relative_to, root)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Suite name prefixed with the full name of the possible parent suite.</p> <p>Just :attr:<code>name</code> of the suite if it has no :attr:<code>parent</code>.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.longname","title":"longname  <code>property</code>","text":"<pre><code>longname: str\n</code></pre> <p>Deprecated since Robot Framework 7.0. Use :attr:<code>full_name</code> instead.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.validate_execution_mode","title":"validate_execution_mode","text":"<pre><code>validate_execution_mode() -&gt; bool | None\n</code></pre> <p>Validate that suite execution mode is set consistently.</p> <p>Raise an exception if the execution mode is not set (i.e. the :attr:<code>rpa</code> attribute is <code>None</code>) and child suites have conflicting execution modes.</p> <p>The execution mode is returned. New in RF 6.1.1.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def validate_execution_mode(self) -&gt; 'bool|None':\n    \"\"\"Validate that suite execution mode is set consistently.\n\n    Raise an exception if the execution mode is not set (i.e. the :attr:`rpa`\n    attribute is ``None``) and child suites have conflicting execution modes.\n\n    The execution mode is returned. New in RF 6.1.1.\n    \"\"\"\n    if self.rpa is None:\n        rpa = name = None\n        for suite in self.suites:\n            suite.validate_execution_mode()\n            if rpa is None:\n                rpa = suite.rpa\n                name = suite.full_name\n            elif rpa is not suite.rpa:\n                mode1, mode2 = ('tasks', 'tests') if rpa else ('tests', 'tasks')\n                raise DataError(\n                    f\"Conflicting execution modes: Suite '{name}' has {mode1} but \"\n                    f\"suite '{suite.full_name}' has {mode2}. Resolve the conflict \"\n                    f\"or use '--rpa' or '--norpa' options to set the execution \"\n                    f\"mode explicitly.\"\n                )\n        self.rpa = rpa\n    return self.rpa\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.setup","title":"setup  <code>property</code> <code>writable</code>","text":"<pre><code>setup: KW\n</code></pre> <p>Suite setup.</p> <p>This attribute is a <code>Keyword</code> object also when a suite has no setup but in that case its truth value is <code>False</code>. The preferred way to check does a suite have a setup is using :attr:<code>has_setup</code>.</p> <p>Setup can be modified by setting attributes directly::</p> <pre><code>suite.setup.name = 'Example'\nsuite.setup.args = ('First', 'Second')\n</code></pre> <p>Alternatively the :meth:<code>config</code> method can be used to set multiple attributes in one call::</p> <pre><code>suite.setup.config(name='Example', args=('First', 'Second'))\n</code></pre> <p>The easiest way to reset the whole setup is setting it to <code>None</code>. It will automatically recreate the underlying <code>Keyword</code> object::</p> <pre><code>suite.setup = None\n</code></pre> <p>New in Robot Framework 4.0. Earlier setup was accessed like <code>suite.keywords.setup</code>.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.has_setup","title":"has_setup  <code>property</code>","text":"<pre><code>has_setup: bool\n</code></pre> <p>Check does a suite have a setup without creating a setup object.</p> <p>A difference between using <code>if suite.has_setup:</code> and <code>if suite.setup:</code> is that accessing the :attr:<code>setup</code> attribute creates a :class:<code>Keyword</code> object representing the setup even when the suite actually does not have one. This typically does not matter, but with bigger suite structures it can have some effect on memory usage.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.teardown","title":"teardown  <code>property</code> <code>writable</code>","text":"<pre><code>teardown: KW\n</code></pre> <p>Suite teardown.</p> <p>See :attr:<code>setup</code> for more information.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.has_teardown","title":"has_teardown  <code>property</code>","text":"<pre><code>has_teardown: bool\n</code></pre> <p>Check does a suite have a teardown without creating a teardown object.</p> <p>See :attr:<code>has_setup</code> for more information.</p> <p>New in Robot Framework 5.0.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre> <p>An automatically generated unique id.</p> <p>The root suite has id <code>s1</code>, its child suites have ids <code>s1-s1</code>, <code>s1-s2</code>, ..., their child suites get ids <code>s1-s1-s1</code>, <code>s1-s1-s2</code>, ..., <code>s1-s2-s1</code>, ..., and so on.</p> <p>The first test in a suite has an id like <code>s1-t1</code>, the second has an id <code>s1-t2</code>, and so on. Similarly, keywords in suites (setup/teardown) and in tests get ids like <code>s1-k1</code>, <code>s1-t1-k1</code>, and <code>s1-s4-t2-k5</code>.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.all_tests","title":"all_tests  <code>property</code>","text":"<pre><code>all_tests: Iterator[TestCase]\n</code></pre> <p>Yields all tests this suite and its child suites contain.</p> <p>New in Robot Framework 6.1.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.test_count","title":"test_count  <code>property</code>","text":"<pre><code>test_count: int\n</code></pre> <p>Total number of the tests in this suite and in its child suites.</p>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.set_tags","title":"set_tags","text":"<pre><code>set_tags(\n    add: Sequence[str] = (),\n    remove: Sequence[str] = (),\n    persist: bool = False,\n)\n</code></pre> <p>Add and/or remove specified tags to the tests in this suite.</p> <p>:param add: Tags to add as a list or, if adding only one,     as a single string. :param remove: Tags to remove as a list or as a single string.     Can be given as patterns where <code>*</code> and <code>?</code> work as wildcards. :param persist: Add/remove specified tags also to new tests added     to this suite in the future.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def set_tags(self, add: Sequence[str] = (), remove: Sequence[str] = (),\n             persist: bool = False):\n    \"\"\"Add and/or remove specified tags to the tests in this suite.\n\n    :param add: Tags to add as a list or, if adding only one,\n        as a single string.\n    :param remove: Tags to remove as a list or as a single string.\n        Can be given as patterns where ``*`` and ``?`` work as wildcards.\n    :param persist: Add/remove specified tags also to new tests added\n        to this suite in the future.\n    \"\"\"\n    setter = TagSetter(add, remove)\n    self.visit(setter)\n    if persist:\n        self._my_visitors.append(setter)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.filter","title":"filter","text":"<pre><code>filter(\n    included_suites: Sequence[str] | None = None,\n    included_tests: Sequence[str] | None = None,\n    included_tags: Sequence[str] | None = None,\n    excluded_tags: Sequence[str] | None = None,\n)\n</code></pre> <p>Select test cases and remove others from this suite.</p> <p>Parameters have the same semantics as <code>--suite</code>, <code>--test</code>, <code>--include</code>, and <code>--exclude</code> command line options. All of them can be given as a list of strings, or when selecting only one, as a single string.</p> <p>Child suites that contain no tests after filtering are automatically removed.</p> <p>Example::</p> <pre><code>suite.filter(included_tests=['Test 1', '* Example'],\n             included_tags='priority-1')\n</code></pre> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def filter(self, included_suites: 'Sequence[str]|None' = None,\n           included_tests: 'Sequence[str]|None' = None,\n           included_tags: 'Sequence[str]|None' = None,\n           excluded_tags: 'Sequence[str]|None' = None):\n    \"\"\"Select test cases and remove others from this suite.\n\n    Parameters have the same semantics as ``--suite``, ``--test``,\n    ``--include``, and ``--exclude`` command line options. All of them\n    can be given as a list of strings, or when selecting only one, as\n    a single string.\n\n    Child suites that contain no tests after filtering are automatically\n    removed.\n\n    Example::\n\n        suite.filter(included_tests=['Test 1', '* Example'],\n                     included_tags='priority-1')\n    \"\"\"\n    self.visit(Filter(included_suites, included_tests,\n                      included_tags, excluded_tags))\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.remove_empty_suites","title":"remove_empty_suites","text":"<pre><code>remove_empty_suites(preserve_direct_children: bool = False)\n</code></pre> <p>Removes all child suites not containing any tests, recursively.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def remove_empty_suites(self, preserve_direct_children: bool = False):\n    \"\"\"Removes all child suites not containing any tests, recursively.\"\"\"\n    self.visit(EmptySuiteRemover(preserve_direct_children))\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.visit","title":"visit","text":"<pre><code>visit(visitor: SuiteVisitor)\n</code></pre> <p>:mod:<code>Visitor interface &lt;robot.model.visitor&gt;</code> entry-point.</p> Source code in <code>src/robot/model/testsuite.py</code> <pre><code>def visit(self, visitor: SuiteVisitor):\n    \"\"\":mod:`Visitor interface &lt;robot.model.visitor&gt;` entry-point.\"\"\"\n    visitor.visit_suite(self)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.from_file_system","title":"from_file_system  <code>classmethod</code>","text":"<pre><code>from_file_system(*paths: Path | str, **config) -&gt; TestSuite\n</code></pre> <p>Create a :class:<code>TestSuite</code> object based on the given <code>paths</code>.</p> <p>:param paths: File or directory paths where to read the data from. :param config: Configuration parameters for :class:<code>~.builders.TestSuiteBuilder</code>     class that is used internally for building the suite.</p> <p>See also :meth:<code>from_model</code> and :meth:<code>from_string</code>.</p> Source code in <code>src/robot/running/model.py</code> <pre><code>@classmethod\ndef from_file_system(cls, *paths: 'Path|str', **config) -&gt; 'TestSuite':\n    \"\"\"Create a :class:`TestSuite` object based on the given ``paths``.\n\n    :param paths: File or directory paths where to read the data from.\n    :param config: Configuration parameters for :class:`~.builders.TestSuiteBuilder`\n        class that is used internally for building the suite.\n\n    See also :meth:`from_model` and :meth:`from_string`.\n    \"\"\"\n    from .builder import TestSuiteBuilder\n    return TestSuiteBuilder(**config).build(*paths)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.from_model","title":"from_model  <code>classmethod</code>","text":"<pre><code>from_model(\n    model: File,\n    name: str | None = None,\n    *,\n    defaults: TestDefaults | None = None\n) -&gt; TestSuite\n</code></pre> <p>Create a :class:<code>TestSuite</code> object based on the given <code>model</code>.</p> <p>:param model: Model to create the suite from. :param name: Deprecated since Robot Framework 6.1. :param defaults: Possible test specific defaults from suite     initialization files. New in Robot Framework 6.1.</p> <p>The model can be created by using the :func:<code>~robot.parsing.parser.parser.get_model</code> function and possibly modified by other tooling in the :mod:<code>robot.parsing</code> module.</p> <p>Giving suite name is deprecated and users should set it and possible other attributes to the returned suite separately. One easy way is using the :meth:<code>config</code> method like this::</p> <pre><code>suite = TestSuite.from_model(model).config(name='X', doc='Example')\n</code></pre> <p>See also :meth:<code>from_file_system</code> and :meth:<code>from_string</code>.</p> Source code in <code>src/robot/running/model.py</code> <pre><code>@classmethod\ndef from_model(cls, model: 'File', name: 'str|None' = None, *,\n               defaults: 'TestDefaults|None' = None) -&gt; 'TestSuite':\n    \"\"\"Create a :class:`TestSuite` object based on the given ``model``.\n\n    :param model: Model to create the suite from.\n    :param name: Deprecated since Robot Framework 6.1.\n    :param defaults: Possible test specific defaults from suite\n        initialization files. New in Robot Framework 6.1.\n\n    The model can be created by using the\n    :func:`~robot.parsing.parser.parser.get_model` function and possibly\n    modified by other tooling in the :mod:`robot.parsing` module.\n\n    Giving suite name is deprecated and users should set it and possible\n    other attributes to the returned suite separately. One easy way is using\n    the :meth:`config` method like this::\n\n        suite = TestSuite.from_model(model).config(name='X', doc='Example')\n\n    See also :meth:`from_file_system` and :meth:`from_string`.\n    \"\"\"\n    from .builder import RobotParser\n    suite = RobotParser().parse_model(model, defaults)\n    if name is not None:\n        # TODO: Remove 'name' in RF 7.\n        warnings.warn(\"'name' argument of 'TestSuite.from_model' is deprecated. \"\n                      \"Set the name to the returned suite separately.\")\n        suite.name = name\n    return suite\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(\n    string: str,\n    *,\n    defaults: TestDefaults | None = None,\n    **config\n) -&gt; TestSuite\n</code></pre> <p>Create a :class:<code>TestSuite</code> object based on the given <code>string</code>.</p> <p>:param string: String to create the suite from. :param defaults: Possible test specific defaults from suite     initialization files. :param config: Configuration parameters for      :func:<code>~robot.parsing.parser.parser.get_model</code> used internally.</p> <p>If suite name or other attributes need to be set, an easy way is using the :meth:<code>config</code> method like this::</p> <pre><code>suite = TestSuite.from_string(string).config(name='X', doc='Example')\n</code></pre> <p>New in Robot Framework 6.1. See also :meth:<code>from_model</code> and :meth:<code>from_file_system</code>.</p> Source code in <code>src/robot/running/model.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str, *, defaults: 'TestDefaults|None' = None,\n                **config) -&gt; 'TestSuite':\n    \"\"\"Create a :class:`TestSuite` object based on the given ``string``.\n\n    :param string: String to create the suite from.\n    :param defaults: Possible test specific defaults from suite\n        initialization files.\n    :param config: Configuration parameters for\n         :func:`~robot.parsing.parser.parser.get_model` used internally.\n\n    If suite name or other attributes need to be set, an easy way is using\n    the :meth:`config` method like this::\n\n        suite = TestSuite.from_string(string).config(name='X', doc='Example')\n\n    New in Robot Framework 6.1. See also :meth:`from_model` and\n    :meth:`from_file_system`.\n    \"\"\"\n    from robot.parsing import get_model\n    model = get_model(string, data_only=True, **config)\n    return cls.from_model(model, defaults=defaults)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.configure","title":"configure","text":"<pre><code>configure(\n    randomize_suites: bool = False,\n    randomize_tests: bool = False,\n    randomize_seed: int | None = None,\n    **options\n)\n</code></pre> <p>A shortcut to configure a suite using one method call.</p> <p>Can only be used with the root test suite.</p> <p>:param randomize_xxx: Passed to :meth:<code>randomize</code>. :param options: Passed to     :class:<code>~robot.model.configurer.SuiteConfigurer</code> that will then     set suite attributes, call :meth:<code>filter</code>, etc. as needed.</p> <p>Example::</p> <pre><code>suite.configure(include_tags=['smoke'],\n                doc='Smoke test results.')\n</code></pre> <p>Not to be confused with :meth:<code>config</code> method that suites, tests, and keywords have to make it possible to set multiple attributes in one call.</p> Source code in <code>src/robot/running/model.py</code> <pre><code>def configure(self, randomize_suites: bool = False, randomize_tests: bool = False,\n              randomize_seed: 'int|None' = None, **options):\n    \"\"\"A shortcut to configure a suite using one method call.\n\n    Can only be used with the root test suite.\n\n    :param randomize_xxx: Passed to :meth:`randomize`.\n    :param options: Passed to\n        :class:`~robot.model.configurer.SuiteConfigurer` that will then\n        set suite attributes, call :meth:`filter`, etc. as needed.\n\n    Example::\n\n        suite.configure(include_tags=['smoke'],\n                        doc='Smoke test results.')\n\n    Not to be confused with :meth:`config` method that suites, tests,\n    and keywords have to make it possible to set multiple attributes in\n    one call.\n    \"\"\"\n    super().configure(**options)\n    self.randomize(randomize_suites, randomize_tests, randomize_seed)\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.randomize","title":"randomize","text":"<pre><code>randomize(\n    suites: bool = True,\n    tests: bool = True,\n    seed: int | None = None,\n)\n</code></pre> <p>Randomizes the order of suites and/or tests, recursively.</p> <p>:param suites: Boolean controlling should suites be randomized. :param tests: Boolean controlling should tests be randomized. :param seed: Random seed. Can be given if previous random order needs     to be re-created. Seed value is always shown in logs and reports.</p> Source code in <code>src/robot/running/model.py</code> <pre><code>def randomize(self, suites: bool = True, tests: bool = True,\n              seed: 'int|None' = None):\n    \"\"\"Randomizes the order of suites and/or tests, recursively.\n\n    :param suites: Boolean controlling should suites be randomized.\n    :param tests: Boolean controlling should tests be randomized.\n    :param seed: Random seed. Can be given if previous random order needs\n        to be re-created. Seed value is always shown in logs and reports.\n    \"\"\"\n    self.visit(Randomizer(suites, tests, seed))\n</code></pre>"},{"location":"api/robot/running/model/#robot.running.model.TestSuite.run","title":"run","text":"<pre><code>run(settings=None, **options)\n</code></pre> <p>Executes the suite based on the given <code>settings</code> or <code>options</code>.</p> <p>:param settings: :class:<code>~robot.conf.settings.RobotSettings</code> object     to configure test execution. :param options: Used to construct new     :class:<code>~robot.conf.settings.RobotSettings</code> object if <code>settings</code>     are not given. :return: :class:<code>~robot.result.executionresult.Result</code> object with     information about executed suites and tests.</p> <p>If <code>options</code> are used, their names are the same as long command line options except without hyphens. Some options are ignored (see below), but otherwise they have the same semantics as on the command line. Options that can be given on the command line multiple times can be passed as lists like <code>variable=['VAR1:value1', 'VAR2:value2']</code>. If such an option is used only once, it can be given also as a single string like <code>variable='VAR:value'</code>.</p> <p>Additionally, listener option allows passing object directly instead of listener name, e.g. <code>run('tests.robot', listener=Listener())</code>.</p> <p>To capture stdout and/or stderr streams, pass open file objects in as special keyword arguments <code>stdout</code> and <code>stderr</code>, respectively.</p> <p>Only options related to the actual test execution have an effect. For example, options related to selecting or modifying test cases or suites (e.g. <code>--include</code>, <code>--name</code>, <code>--prerunmodifier</code>) or creating logs and reports are silently ignored. The output XML generated as part of the execution can be configured, though. This includes disabling it with <code>output=None</code>.</p> <p>Example::</p> <pre><code>stdout = StringIO()\nresult = suite.run(variable='EXAMPLE:value',\n                   output='example.xml',\n                   exitonfailure=True,\n                   stdout=stdout)\nprint(result.return_code)\n</code></pre> <p>To save memory, the returned :class:<code>~robot.result.executionresult.Result</code> object does not have any information about the executed keywords. If that information is needed, the created output XML file needs to be read  using the :class:<code>~robot.result.resultbuilder.ExecutionResult</code> factory method.</p> <p>See the :mod:<code>package level &lt;robot.running&gt;</code> documentation for more examples, including how to construct executable test suites and how to create logs and reports based on the execution results.</p> <p>See the :func:<code>robot.run &lt;robot.run.run&gt;</code> function for a higher-level API for executing tests in files or directories.</p> Source code in <code>src/robot/running/model.py</code> <pre><code>def run(self, settings=None, **options):\n    \"\"\"Executes the suite based on the given ``settings`` or ``options``.\n\n    :param settings: :class:`~robot.conf.settings.RobotSettings` object\n        to configure test execution.\n    :param options: Used to construct new\n        :class:`~robot.conf.settings.RobotSettings` object if ``settings``\n        are not given.\n    :return: :class:`~robot.result.executionresult.Result` object with\n        information about executed suites and tests.\n\n    If ``options`` are used, their names are the same as long command line\n    options except without hyphens. Some options are ignored (see below),\n    but otherwise they have the same semantics as on the command line.\n    Options that can be given on the command line multiple times can be\n    passed as lists like ``variable=['VAR1:value1', 'VAR2:value2']``.\n    If such an option is used only once, it can be given also as a single\n    string like ``variable='VAR:value'``.\n\n    Additionally, listener option allows passing object directly instead of\n    listener name, e.g. ``run('tests.robot', listener=Listener())``.\n\n    To capture stdout and/or stderr streams, pass open file objects in as\n    special keyword arguments ``stdout`` and ``stderr``, respectively.\n\n    Only options related to the actual test execution have an effect.\n    For example, options related to selecting or modifying test cases or\n    suites (e.g. ``--include``, ``--name``, ``--prerunmodifier``) or\n    creating logs and reports are silently ignored. The output XML\n    generated as part of the execution can be configured, though. This\n    includes disabling it with ``output=None``.\n\n    Example::\n\n        stdout = StringIO()\n        result = suite.run(variable='EXAMPLE:value',\n                           output='example.xml',\n                           exitonfailure=True,\n                           stdout=stdout)\n        print(result.return_code)\n\n    To save memory, the returned\n    :class:`~robot.result.executionresult.Result` object does not\n    have any information about the executed keywords. If that information\n    is needed, the created output XML file needs to be read  using the\n    :class:`~robot.result.resultbuilder.ExecutionResult` factory method.\n\n    See the :mod:`package level &lt;robot.running&gt;` documentation for\n    more examples, including how to construct executable test suites and\n    how to create logs and reports based on the execution results.\n\n    See the :func:`robot.run &lt;robot.run.run&gt;` function for a higher-level\n    API for executing tests in files or directories.\n    \"\"\"\n    from .namespace import IMPORTER\n    from .signalhandler import STOP_SIGNAL_MONITOR\n    from .suiterunner import SuiteRunner\n\n    with LOGGER:\n        if not settings:\n            settings = RobotSettings(options)\n            LOGGER.register_console_logger(**settings.console_output_config)\n        with pyloggingconf.robot_handler_enabled(settings.log_level):\n            with STOP_SIGNAL_MONITOR:\n                IMPORTER.reset()\n                output = Output(settings)\n                runner = SuiteRunner(output, settings)\n                self.visit(runner)\n            output.close(runner.result)\n    return runner.result\n</code></pre>"},{"location":"api/robot/running/namespace/","title":"robot.running.namespace","text":""},{"location":"api/robot/running/namespace/#robot.running.namespace","title":"robot.running.namespace","text":""},{"location":"api/robot/running/namespace/#robot.running.namespace.KeywordRecommendationFinder","title":"KeywordRecommendationFinder","text":"<pre><code>KeywordRecommendationFinder(*owners)\n</code></pre> Source code in <code>src/robot/running/namespace.py</code> <pre><code>def __init__(self, *owners):\n    self.owners = owners\n</code></pre>"},{"location":"api/robot/running/namespace/#robot.running.namespace.KeywordRecommendationFinder.recommend_similar_keywords","title":"recommend_similar_keywords","text":"<pre><code>recommend_similar_keywords(name, message)\n</code></pre> <p>Return keyword names similar to <code>name</code>.</p> Source code in <code>src/robot/running/namespace.py</code> <pre><code>def recommend_similar_keywords(self, name, message):\n    \"\"\"Return keyword names similar to `name`.\"\"\"\n    candidates = self._get_candidates(use_full_name='.' in name)\n    finder = RecommendationFinder(\n        lambda name: normalize(candidates.get(name, name), ignore='_')\n    )\n    return finder.find_and_format(name, candidates, message,\n                                  check_missing_argument_separator=True)\n</code></pre>"},{"location":"api/robot/running/outputcapture/","title":"robot.running.outputcapture","text":""},{"location":"api/robot/running/outputcapture/#robot.running.outputcapture","title":"robot.running.outputcapture","text":""},{"location":"api/robot/running/randomizer/","title":"robot.running.randomizer","text":""},{"location":"api/robot/running/randomizer/#robot.running.randomizer","title":"robot.running.randomizer","text":""},{"location":"api/robot/running/resourcemodel/","title":"robot.running.resourcemodel","text":""},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel","title":"robot.running.resourcemodel","text":""},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.ResourceFile","title":"ResourceFile","text":"<pre><code>ResourceFile(\n    source: Path | str | None = None,\n    owner: TestSuite | None = None,\n    doc: str = \"\",\n)\n</code></pre> <p>               Bases: <code>ModelObject</code></p> <p>Represents a resource file.</p> Source code in <code>src/robot/running/resourcemodel.py</code> <pre><code>def __init__(self, source: 'Path|str|None' = None,\n             owner: 'TestSuite|None' = None,\n             doc: str = ''):\n    self.source = source\n    self.owner = owner\n    self.doc = doc\n    self.keyword_finder = KeywordFinder['UserKeyword'](self)\n    self.imports = []\n    self.variables = []\n    self.keywords = []\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.ResourceFile.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.ResourceFile.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.ResourceFile.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.ResourceFile.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.ResourceFile.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.ResourceFile.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.ResourceFile.name","title":"name  <code>property</code>","text":"<pre><code>name: str | None\n</code></pre> <p>Resource file name.</p> <p><code>None</code> if resource file is part of a suite or if it does not have :attr:<code>source</code>, name of the source file without the extension otherwise.</p>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.ResourceFile.from_file_system","title":"from_file_system  <code>classmethod</code>","text":"<pre><code>from_file_system(\n    path: Path | str, **config\n) -&gt; ResourceFile\n</code></pre> <p>Create a :class:<code>ResourceFile</code> object based on the give <code>path</code>.</p> <p>:param path: File path where to read the data from. :param config: Configuration parameters for :class:<code>~.builders.ResourceFileBuilder</code>     class that is used internally for building the suite.</p> <p>New in Robot Framework 6.1. See also :meth:<code>from_string</code> and :meth:<code>from_model</code>.</p> Source code in <code>src/robot/running/resourcemodel.py</code> <pre><code>@classmethod\ndef from_file_system(cls, path: 'Path|str', **config) -&gt; 'ResourceFile':\n    \"\"\"Create a :class:`ResourceFile` object based on the give ``path``.\n\n    :param path: File path where to read the data from.\n    :param config: Configuration parameters for :class:`~.builders.ResourceFileBuilder`\n        class that is used internally for building the suite.\n\n    New in Robot Framework 6.1. See also :meth:`from_string` and :meth:`from_model`.\n    \"\"\"\n    from .builder import ResourceFileBuilder\n    return ResourceFileBuilder(**config).build(path)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.ResourceFile.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str, **config) -&gt; ResourceFile\n</code></pre> <p>Create a :class:<code>ResourceFile</code> object based on the given <code>string</code>.</p> <p>:param string: String to create the resource file from. :param config: Configuration parameters for      :func:<code>~robot.parsing.parser.parser.get_resource_model</code> used internally.</p> <p>New in Robot Framework 6.1. See also :meth:<code>from_file_system</code> and :meth:<code>from_model</code>.</p> Source code in <code>src/robot/running/resourcemodel.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str, **config) -&gt; 'ResourceFile':\n    \"\"\"Create a :class:`ResourceFile` object based on the given ``string``.\n\n    :param string: String to create the resource file from.\n    :param config: Configuration parameters for\n         :func:`~robot.parsing.parser.parser.get_resource_model` used internally.\n\n    New in Robot Framework 6.1. See also :meth:`from_file_system` and\n    :meth:`from_model`.\n    \"\"\"\n    from robot.parsing import get_resource_model\n    model = get_resource_model(string, data_only=True, **config)\n    return cls.from_model(model)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.ResourceFile.from_model","title":"from_model  <code>classmethod</code>","text":"<pre><code>from_model(model: File) -&gt; ResourceFile\n</code></pre> <p>Create a :class:<code>ResourceFile</code> object based on the given <code>model</code>.</p> <p>:param model: Model to create the suite from.</p> <p>The model can be created by using the :func:<code>~robot.parsing.parser.parser.get_resource_model</code> function and possibly modified by other tooling in the :mod:<code>robot.parsing</code> module.</p> <p>New in Robot Framework 6.1. See also :meth:<code>from_file_system</code> and :meth:<code>from_string</code>.</p> Source code in <code>src/robot/running/resourcemodel.py</code> <pre><code>@classmethod\ndef from_model(cls, model: 'File') -&gt; 'ResourceFile':\n    \"\"\"Create a :class:`ResourceFile` object based on the given ``model``.\n\n    :param model: Model to create the suite from.\n\n    The model can be created by using the\n    :func:`~robot.parsing.parser.parser.get_resource_model` function and possibly\n    modified by other tooling in the :mod:`robot.parsing` module.\n\n    New in Robot Framework 6.1. See also :meth:`from_file_system` and\n    :meth:`from_string`.\n    \"\"\"\n    from .builder import RobotParser\n    return RobotParser().parse_resource_model(model)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword","title":"UserKeyword","text":"<pre><code>UserKeyword(\n    name: str = \"\",\n    args: ArgumentSpec | Sequence[str] | None = (),\n    doc: str = \"\",\n    tags: Tags | Sequence[str] = (),\n    timeout: str | None = None,\n    lineno: int | None = None,\n    owner: ResourceFile | None = None,\n    parent: BodyItemParent | None = None,\n    error: str | None = None,\n)\n</code></pre> <p>               Bases: <code>KeywordImplementation</code></p> <p>Represents a user keyword.</p> Source code in <code>src/robot/running/resourcemodel.py</code> <pre><code>def __init__(self, name: str = '',\n             args: 'ArgumentSpec|Sequence[str]|None' = (),\n             doc: str = '',\n             tags: 'Tags|Sequence[str]' = (),\n             timeout: 'str|None' = None,\n             lineno: 'int|None' = None,\n             owner: 'ResourceFile|None' = None,\n             parent: 'BodyItemParent|None' = None,\n             error: 'str|None' = None):\n    super().__init__(name, args, doc, tags, lineno, owner, parent, error)\n    self.timeout = timeout\n    self._setup = None\n    self._teardown = None\n    self.body = []\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: DataDict) -&gt; T\n</code></pre> <p>Create this object based on data in a dictionary.</p> <p>Data can be got from the :meth:<code>to_dict</code> method or created externally.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[T], data: DataDict) -&gt; T:\n    \"\"\"Create this object based on data in a dictionary.\n\n    Data can be got from the :meth:`to_dict` method or created externally.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        return cls().config(**data)\n    except (AttributeError, TypeError) as err:\n        raise DataError(f\"Creating '{full_name(cls)}' object from dictionary \"\n                        f\"failed: {err}\")\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.params","title":"params  <code>property</code>","text":"<pre><code>params: ArgumentSpec\n</code></pre> <p>Keyword parameter information.</p> <p>This is a forward compatible alias for :attr:<code>args</code>.</p>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.matches","title":"matches","text":"<pre><code>matches(name: str) -&gt; bool\n</code></pre> <p>Returns true if <code>name</code> matches the keyword name.</p> <p>With normal keywords matching is a case, space and underscore insensitive string comparison. With keywords accepting embedded arguments, matching is done against the name.</p> Source code in <code>src/robot/running/keywordimplementation.py</code> <pre><code>def matches(self, name: str) -&gt; bool:\n    \"\"\"Returns true if ``name`` matches the keyword name.\n\n    With normal keywords matching is a case, space and underscore insensitive\n    string comparison. With keywords accepting embedded arguments, matching\n    is done against the name.\n    \"\"\"\n    if self.embedded:\n        return self.embedded.match(name) is not None\n    return eq(self.name, name, ignore='_')\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.setup","title":"setup  <code>property</code> <code>writable</code>","text":"<pre><code>setup: Keyword\n</code></pre> <p>User keyword setup as a :class:<code>Keyword</code> object.</p> <p>New in Robot Framework 7.0.</p>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.has_setup","title":"has_setup  <code>property</code>","text":"<pre><code>has_setup: bool\n</code></pre> <p>Check does a keyword have a setup without creating a setup object.</p> <p>See :attr:<code>has_teardown</code> for more information. New in Robot Framework 7.0.</p>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.teardown","title":"teardown  <code>property</code> <code>writable</code>","text":"<pre><code>teardown: Keyword\n</code></pre> <p>User keyword teardown as a :class:<code>Keyword</code> object.</p>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.UserKeyword.has_teardown","title":"has_teardown  <code>property</code>","text":"<pre><code>has_teardown: bool\n</code></pre> <p>Check does a keyword have a teardown without creating a teardown object.</p> <p>A difference between using <code>if kw.has_teardown:</code> and <code>if kw.teardown:</code> is that accessing the :attr:<code>teardown</code> attribute creates a :class:<code>Keyword</code> object representing the teardown even when the user keyword actually does not have one. This can have an effect on memory usage.</p> <p>New in Robot Framework 6.1.</p>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Import","title":"Import","text":"<pre><code>Import(\n    type: Literal[\"LIBRARY\", \"RESOURCE\", \"VARIABLES\"],\n    name: str,\n    args: Sequence[str] = (),\n    alias: str | None = None,\n    owner: ResourceFile | None = None,\n    lineno: int | None = None,\n)\n</code></pre> <p>               Bases: <code>ModelObject</code></p> <p>Represents library, resource file or variable file import.</p> Source code in <code>src/robot/running/resourcemodel.py</code> <pre><code>def __init__(self, type: Literal['LIBRARY', 'RESOURCE', 'VARIABLES'],\n             name: str,\n             args: Sequence[str] = (),\n             alias: 'str|None' = None,\n             owner: 'ResourceFile|None' = None,\n             lineno: 'int|None' = None):\n    if type not in (self.LIBRARY, self.RESOURCE, self.VARIABLES):\n        raise ValueError(f\"Invalid import type: Expected '{self.LIBRARY}', \"\n                         f\"'{self.RESOURCE}' or '{self.VARIABLES}', got '{type}'.\")\n    self.type = type\n    self.name = name\n    self.args = tuple(args)\n    self.alias = alias\n    self.owner = owner\n    self.lineno = lineno\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Import.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(source: str | bytes | TextIO | Path) -&gt; T\n</code></pre> <p>Create this object based on JSON data.</p> <p>The data is given as the <code>source</code> parameter. It can be:</p> <ul> <li>a string (or bytes) containing the data directly,</li> <li>an open file object where to read the data from, or</li> <li>a path (<code>pathlib.Path</code> or string) to a UTF-8 encoded file to read.</li> </ul> <p>The JSON data is first converted to a Python dictionary and the object created using the :meth:<code>from_dict</code> method.</p> <p>Notice that the <code>source</code> is considered to be JSON data if it is a string and contains <code>{</code>. If you need to use <code>{</code> in a file system path, pass it in as a <code>pathlib.Path</code> instance.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>@classmethod\ndef from_json(cls: Type[T], source: 'str|bytes|TextIO|Path') -&gt; T:\n    \"\"\"Create this object based on JSON data.\n\n    The data is given as the ``source`` parameter. It can be:\n\n    - a string (or bytes) containing the data directly,\n    - an open file object where to read the data from, or\n    - a path (``pathlib.Path`` or string) to a UTF-8 encoded file to read.\n\n    The JSON data is first converted to a Python dictionary and the object\n    created using the :meth:`from_dict` method.\n\n    Notice that the ``source`` is considered to be JSON data if it is\n    a string and contains ``{``. If you need to use ``{`` in a file system\n    path, pass it in as a ``pathlib.Path`` instance.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n    \"\"\"\n    try:\n        data = JsonLoader().load(source)\n    except (TypeError, ValueError) as err:\n        raise DataError(f'Loading JSON data failed: {err}')\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Import.to_json","title":"to_json","text":"<pre><code>to_json(\n    file: None = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str\n</code></pre><pre><code>to_json(\n    file: TextIO | Path | str,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; None\n</code></pre> <pre><code>to_json(\n    file: None | TextIO | Path | str = None,\n    *,\n    ensure_ascii: bool = False,\n    indent: int = 0,\n    separators: tuple[str, str] = (\",\", \":\")\n) -&gt; str | None\n</code></pre> <p>Serialize this object into JSON.</p> <p>The object is first converted to a Python dictionary using the :meth:<code>to_dict</code> method and then the dictionary is converted to JSON.</p> <p>The <code>file</code> parameter controls what to do with the resulting JSON data. It can be:</p> <ul> <li><code>None</code> (default) to return the data as a string,</li> <li>an open file object where to write the data to, or</li> <li>a path (<code>pathlib.Path</code> or string) to a file where to write   the data using UTF-8 encoding.</li> </ul> <p>JSON formatting can be configured using optional parameters that are passed directly to the underlying json__ module. Notice that the defaults differ from what <code>json</code> uses.</p> <p>With <code>robot.running</code> model objects new in Robot Framework 6.1, with <code>robot.result</code> new in Robot Framework 7.0.</p> <p>__ https://docs.python.org/3/library/json.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def to_json(self, file: 'None|TextIO|Path|str' = None, *,\n            ensure_ascii: bool = False, indent: int = 0,\n            separators: 'tuple[str, str]' = (',', ':')) -&gt; 'str|None':\n    \"\"\"Serialize this object into JSON.\n\n    The object is first converted to a Python dictionary using the\n    :meth:`to_dict` method and then the dictionary is converted to JSON.\n\n    The ``file`` parameter controls what to do with the resulting JSON data.\n    It can be:\n\n    - ``None`` (default) to return the data as a string,\n    - an open file object where to write the data to, or\n    - a path (``pathlib.Path`` or string) to a file where to write\n      the data using UTF-8 encoding.\n\n    JSON formatting can be configured using optional parameters that\n    are passed directly to the underlying json__ module. Notice that\n    the defaults differ from what ``json`` uses.\n\n    With ``robot.running`` model objects new in Robot Framework 6.1,\n    with ``robot.result`` new in Robot Framework 7.0.\n\n    __ https://docs.python.org/3/library/json.html\n    \"\"\"\n    return JsonDumper(ensure_ascii=ensure_ascii, indent=indent,\n                      separators=separators).dump(self.to_dict(), file)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Import.config","title":"config","text":"<pre><code>config(**attributes) -&gt; T\n</code></pre> <p>Configure model object with given attributes.</p> <p><code>obj.config(name='Example', doc='Something')</code> is equivalent to setting <code>obj.name = 'Example'</code> and <code>obj.doc = 'Something'</code>.</p> <p>New in Robot Framework 4.0.</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def config(self: T, **attributes) -&gt; T:\n    \"\"\"Configure model object with given attributes.\n\n    ``obj.config(name='Example', doc='Something')`` is equivalent to setting\n    ``obj.name = 'Example'`` and ``obj.doc = 'Something'``.\n\n    New in Robot Framework 4.0.\n    \"\"\"\n    for name, value in attributes.items():\n        try:\n            orig = getattr(self, name)\n        except AttributeError:\n            raise AttributeError(f\"'{full_name(self)}' object does not have \"\n                                 f\"attribute '{name}'\")\n        # Preserve tuples. Main motivation is converting lists with `from_json`.\n        if isinstance(orig, tuple) and not isinstance(value, tuple):\n            try:\n                value = tuple(value)\n            except TypeError:\n                raise TypeError(f\"'{full_name(self)}' object attribute '{name}' \"\n                                f\"is 'tuple', got '{type_name(value)}'.\")\n        try:\n            setattr(self, name, value)\n        except AttributeError as err:\n            # Ignore error setting attribute if the object already has it.\n            # Avoids problems with `from_dict` with body items having\n            # un-settable `type` attribute that is needed in dict data.\n            if value != orig:\n                raise AttributeError(f\"Setting attribute '{name}' failed: {err}\")\n    return self\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Import.copy","title":"copy","text":"<pre><code>copy(**attributes) -&gt; T\n</code></pre> <p>Return a shallow copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.copy(name='New name')</code>.</p> <p>See also :meth:<code>deepcopy</code>. The difference between <code>copy</code> and <code>deepcopy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def copy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a shallow copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.copy(name='New name')``.\n\n    See also :meth:`deepcopy`. The difference between ``copy`` and\n    ``deepcopy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.copy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Import.deepcopy","title":"deepcopy","text":"<pre><code>deepcopy(**attributes) -&gt; T\n</code></pre> <p>Return a deep copy of this object.</p> <p>:param attributes: Attributes to be set to the returned copy.     For example, <code>obj.deepcopy(name='New name')</code>.</p> <p>See also :meth:<code>copy</code>. The difference between <code>deepcopy</code> and <code>copy</code> is the same as with the methods having same names in the copy__ module.</p> <p>__ https://docs.python.org/3/library/copy.html</p> Source code in <code>src/robot/model/modelobject.py</code> <pre><code>def deepcopy(self: T, **attributes) -&gt; T:\n    \"\"\"Return a deep copy of this object.\n\n    :param attributes: Attributes to be set to the returned copy.\n        For example, ``obj.deepcopy(name='New name')``.\n\n    See also :meth:`copy`. The difference between ``deepcopy`` and\n    ``copy`` is the same as with the methods having same names in\n    the copy__ module.\n\n    __ https://docs.python.org/3/library/copy.html\n    \"\"\"\n    return copy.deepcopy(self).config(**attributes)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Imports","title":"Imports","text":"<pre><code>Imports(\n    owner: ResourceFile, imports: Sequence[Import] = ()\n)\n</code></pre> <p>               Bases: <code>ItemList</code></p> Source code in <code>src/robot/running/resourcemodel.py</code> <pre><code>def __init__(self, owner: ResourceFile, imports: Sequence[Import] = ()):\n    super().__init__(Import, {'owner': owner}, items=imports)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Imports.to_dicts","title":"to_dicts","text":"<pre><code>to_dicts() -&gt; list[DataDict]\n</code></pre> <p>Return list of items converted to dictionaries.</p> <p>Items are converted to dictionaries using the <code>to_dict</code> method, if they have it, or the built-in <code>vars()</code>.</p> <p>New in Robot Framework 6.1.</p> Source code in <code>src/robot/model/itemlist.py</code> <pre><code>def to_dicts(self) -&gt; 'list[DataDict]':\n    \"\"\"Return list of items converted to dictionaries.\n\n    Items are converted to dictionaries using the ``to_dict`` method, if\n    they have it, or the built-in ``vars()``.\n\n    New in Robot Framework 6.1.\n    \"\"\"\n    if not hasattr(self._item_class, 'to_dict'):\n        return [vars(item) for item in self]\n    return [item.to_dict() for item in self]    # type: ignore\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Imports.library","title":"library","text":"<pre><code>library(\n    name: str,\n    args: Sequence[str] = (),\n    alias: str | None = None,\n    lineno: int | None = None,\n) -&gt; Import\n</code></pre> <p>Create library import.</p> Source code in <code>src/robot/running/resourcemodel.py</code> <pre><code>def library(self, name: str, args: Sequence[str] = (), alias: 'str|None' = None,\n            lineno: 'int|None' = None) -&gt; Import:\n    \"\"\"Create library import.\"\"\"\n    return self.create(Import.LIBRARY, name, args, alias, lineno=lineno)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Imports.resource","title":"resource","text":"<pre><code>resource(name: str, lineno: int | None = None) -&gt; Import\n</code></pre> <p>Create resource import.</p> Source code in <code>src/robot/running/resourcemodel.py</code> <pre><code>def resource(self, name: str, lineno: 'int|None' = None) -&gt; Import:\n    \"\"\"Create resource import.\"\"\"\n    return self.create(Import.RESOURCE, name, lineno=lineno)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Imports.variables","title":"variables","text":"<pre><code>variables(\n    name: str,\n    args: Sequence[str] = (),\n    lineno: int | None = None,\n) -&gt; Import\n</code></pre> <p>Create variables import.</p> Source code in <code>src/robot/running/resourcemodel.py</code> <pre><code>def variables(self, name: str, args: Sequence[str] = (),\n              lineno: 'int|None' = None) -&gt; Import:\n    \"\"\"Create variables import.\"\"\"\n    return self.create(Import.VARIABLES, name, args, lineno=lineno)\n</code></pre>"},{"location":"api/robot/running/resourcemodel/#robot.running.resourcemodel.Imports.create","title":"create","text":"<pre><code>create(*args, **kwargs) -&gt; Import\n</code></pre> <p>Generic method for creating imports.</p> <p>Import type specific methods :meth:<code>library</code>, :meth:<code>resource</code> and :meth:<code>variables</code> are recommended over this method.</p> Source code in <code>src/robot/running/resourcemodel.py</code> <pre><code>def create(self, *args, **kwargs) -&gt; Import:\n    \"\"\"Generic method for creating imports.\n\n    Import type specific methods :meth:`library`, :meth:`resource` and\n    :meth:`variables` are recommended over this method.\n    \"\"\"\n    # RF 6.1 changed types to upper case. Code below adds backwards compatibility.\n    if args:\n        args = (args[0].upper(),) + args[1:]\n    elif 'type' in kwargs:\n        kwargs['type'] = kwargs['type'].upper()\n    return super().create(*args, **kwargs)\n</code></pre>"},{"location":"api/robot/running/runkwregister/","title":"robot.running.runkwregister","text":""},{"location":"api/robot/running/runkwregister/#robot.running.runkwregister","title":"robot.running.runkwregister","text":""},{"location":"api/robot/running/signalhandler/","title":"robot.running.signalhandler","text":""},{"location":"api/robot/running/signalhandler/#robot.running.signalhandler","title":"robot.running.signalhandler","text":""},{"location":"api/robot/running/status/","title":"robot.running.status","text":""},{"location":"api/robot/running/status/#robot.running.status","title":"robot.running.status","text":""},{"location":"api/robot/running/statusreporter/","title":"robot.running.statusreporter","text":""},{"location":"api/robot/running/statusreporter/#robot.running.statusreporter","title":"robot.running.statusreporter","text":""},{"location":"api/robot/running/suiterunner/","title":"robot.running.suiterunner","text":""},{"location":"api/robot/running/suiterunner/#robot.running.suiterunner","title":"robot.running.suiterunner","text":""},{"location":"api/robot/running/testlibraries/","title":"robot.running.testlibraries","text":""},{"location":"api/robot/running/testlibraries/#robot.running.testlibraries","title":"robot.running.testlibraries","text":""},{"location":"api/robot/running/testlibraries/#robot.running.testlibraries.TestLibrary","title":"TestLibrary","text":"<pre><code>TestLibrary(\n    code: type | ModuleType,\n    init: LibraryInit,\n    name: str | None = None,\n    real_name: str | None = None,\n    source: Path | None = None,\n    logger=LOGGER,\n)\n</code></pre> <p>Represents imported test library.</p> Source code in <code>src/robot/running/testlibraries.py</code> <pre><code>def __init__(self, code: 'type|ModuleType',\n             init: LibraryInit,\n             name: 'str|None' = None,\n             real_name: 'str|None' = None,\n             source: 'Path|None' = None,\n             logger=LOGGER):\n    self.code = code\n    self.init = init\n    self.init.owner = self\n    self.instance = None\n    self.name = name or code.__name__\n    self.real_name = real_name or self.name\n    self.source = source\n    self._logger = logger\n    self.keywords: list[LibraryKeyword] = []\n    self._has_listeners = None\n    self.scope_manager = ScopeManager.for_library(self)\n    self.keyword_finder = KeywordFinder[LibraryKeyword](self)\n</code></pre>"},{"location":"api/robot/running/testlibraries/#robot.running.testlibraries.TestLibrary.instance","title":"instance  <code>property</code> <code>writable</code>","text":"<pre><code>instance: Any\n</code></pre> <p>Current library instance.</p> <p>With module based libraries this is the module itself.</p> <p>With class based libraries this is an instance of the class. Instances are cleared automatically during execution based on their scope. Accessing this property creates a new instance if needed.</p> <p>:attr:<code>code\u00b4 contains the original library code. With module based libraries it is the same as :attr:</code>instance`. With class based libraries it is the library class.</p>"},{"location":"api/robot/running/userkeywordrunner/","title":"robot.running.userkeywordrunner","text":""},{"location":"api/robot/running/userkeywordrunner/#robot.running.userkeywordrunner","title":"robot.running.userkeywordrunner","text":""},{"location":"api/robot/running/arguments/","title":"robot.running.arguments","text":""},{"location":"api/robot/running/arguments/#robot.running.arguments","title":"robot.running.arguments","text":""},{"location":"api/robot/running/arguments/argumentconverter/","title":"robot.running.arguments.argumentconverter","text":""},{"location":"api/robot/running/arguments/argumentconverter/#robot.running.arguments.argumentconverter","title":"robot.running.arguments.argumentconverter","text":""},{"location":"api/robot/running/arguments/argumentmapper/","title":"robot.running.arguments.argumentmapper","text":""},{"location":"api/robot/running/arguments/argumentmapper/#robot.running.arguments.argumentmapper","title":"robot.running.arguments.argumentmapper","text":""},{"location":"api/robot/running/arguments/argumentparser/","title":"robot.running.arguments.argumentparser","text":""},{"location":"api/robot/running/arguments/argumentparser/#robot.running.arguments.argumentparser","title":"robot.running.arguments.argumentparser","text":""},{"location":"api/robot/running/arguments/argumentresolver/","title":"robot.running.arguments.argumentresolver","text":""},{"location":"api/robot/running/arguments/argumentresolver/#robot.running.arguments.argumentresolver","title":"robot.running.arguments.argumentresolver","text":""},{"location":"api/robot/running/arguments/argumentspec/","title":"robot.running.arguments.argumentspec","text":""},{"location":"api/robot/running/arguments/argumentspec/#robot.running.arguments.argumentspec","title":"robot.running.arguments.argumentspec","text":""},{"location":"api/robot/running/arguments/argumentspec/#robot.running.arguments.argumentspec.ArgInfo","title":"ArgInfo","text":"<pre><code>ArgInfo(\n    kind: str,\n    name: str = \"\",\n    type: TypeInfo | None = None,\n    default: Any = NOT_SET,\n)\n</code></pre> <p>Contains argument information. Only used by Libdoc.</p> Source code in <code>src/robot/running/arguments/argumentspec.py</code> <pre><code>def __init__(self, kind: str,\n             name: str = '',\n             type: 'TypeInfo|None' = None,\n             default: Any = NOT_SET):\n    self.kind = kind\n    self.name = name\n    self.type = type or TypeInfo()\n    self.default = default\n</code></pre>"},{"location":"api/robot/running/arguments/argumentvalidator/","title":"robot.running.arguments.argumentvalidator","text":""},{"location":"api/robot/running/arguments/argumentvalidator/#robot.running.arguments.argumentvalidator","title":"robot.running.arguments.argumentvalidator","text":""},{"location":"api/robot/running/arguments/customconverters/","title":"robot.running.arguments.customconverters","text":""},{"location":"api/robot/running/arguments/customconverters/#robot.running.arguments.customconverters","title":"robot.running.arguments.customconverters","text":""},{"location":"api/robot/running/arguments/embedded/","title":"robot.running.arguments.embedded","text":""},{"location":"api/robot/running/arguments/embedded/#robot.running.arguments.embedded","title":"robot.running.arguments.embedded","text":""},{"location":"api/robot/running/arguments/embedded/#robot.running.arguments.embedded.EmbeddedArguments","title":"EmbeddedArguments","text":"<pre><code>EmbeddedArguments(\n    name: Pattern,\n    args: Sequence[str] = (),\n    custom_patterns: Mapping[str, str] | None = None,\n)\n</code></pre> Source code in <code>src/robot/running/arguments/embedded.py</code> <pre><code>def __init__(self, name: re.Pattern,\n             args: Sequence[str] = (),\n             custom_patterns: 'Mapping[str, str]|None' = None):\n    self.name = name\n    self.args = tuple(args)\n    self.custom_patterns = custom_patterns or None\n</code></pre>"},{"location":"api/robot/running/arguments/embedded/#robot.running.arguments.embedded.EmbeddedArguments.validate","title":"validate","text":"<pre><code>validate(args: Sequence[Any])\n</code></pre> <p>Validate that embedded args match custom regexps.</p> <p>Initial validation is done already when matching keywords, but this validation makes sure arguments match also if they are given as variables.</p> <p>Currently, argument not matching only causes a deprecation warning, but that will be changed to <code>ValueError</code> in RF 8.0: #4069</p> Source code in <code>src/robot/running/arguments/embedded.py</code> <pre><code>def validate(self, args: Sequence[Any]):\n    \"\"\"Validate that embedded args match custom regexps.\n\n    Initial validation is done already when matching keywords, but this\n    validation makes sure arguments match also if they are given as variables.\n\n    Currently, argument not matching only causes a deprecation warning, but\n    that will be changed to ``ValueError`` in RF 8.0:\n    https://github.com/robotframework/robotframework/issues/4069\n    \"\"\"\n    if not self.custom_patterns:\n        return\n    for name, value in zip(self.args, args):\n        if name in self.custom_patterns and isinstance(value, str):\n            pattern = self.custom_patterns[name]\n            if not re.fullmatch(pattern, value):\n                # TODO: Change to `raise ValueError(...)` in RF 8.0.\n                context = EXECUTION_CONTEXTS.current\n                context.warn(f\"Embedded argument '{name}' got value {value!r} \"\n                             f\"that does not match custom pattern {pattern!r}. \"\n                             f\"The argument is still accepted, but this behavior \"\n                             f\"will change in Robot Framework 8.0.\")\n</code></pre>"},{"location":"api/robot/running/arguments/typeconverters/","title":"robot.running.arguments.typeconverters","text":""},{"location":"api/robot/running/arguments/typeconverters/#robot.running.arguments.typeconverters","title":"robot.running.arguments.typeconverters","text":""},{"location":"api/robot/running/arguments/typeinfo/","title":"robot.running.arguments.typeinfo","text":""},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo","title":"robot.running.arguments.typeinfo","text":""},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypeInfo","title":"TypeInfo","text":"<pre><code>TypeInfo(\n    name: str | None = None,\n    type: Any = NOT_SET,\n    nested: Sequence[TypeInfo] | None = None,\n)\n</code></pre> <p>Represents an argument type.</p> <p>Normally created using the :meth:<code>from_type_hint</code> classmethod. With unions and parametrized types, :attr:<code>nested</code> contains nested types.</p> <p>Values can be converted according to this type info by using the :meth:<code>convert</code> method.</p> <p>Part of the public API starting from Robot Framework 7.0. In such usage should be imported via the :mod:<code>robot.api</code> package.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>def __init__(self, name: 'str|None' = None,\n             type: Any = NOT_SET,\n             nested: 'Sequence[TypeInfo]|None' = None):\n    if type is NOT_SET:\n        type = TYPE_NAMES.get(name.lower()) if name else None\n    self.name = name\n    self.type = type\n    self.nested = nested\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypeInfo.nested","title":"nested","text":"<pre><code>nested(\n    nested: Sequence[TypeInfo],\n) -&gt; tuple[TypeInfo, ...] | None\n</code></pre> <p>Nested types as a tuple of <code>TypeInfo</code> objects.</p> <p>Used with parameterized types and unions.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>@setter\ndef nested(self, nested: 'Sequence[TypeInfo]') -&gt; 'tuple[TypeInfo, ...]|None':\n    \"\"\"Nested types as a tuple of ``TypeInfo`` objects.\n\n    Used with parameterized types and unions.\n    \"\"\"\n    typ = self.type\n    if self.is_union:\n        self._validate_union(nested)\n    elif nested is None:\n        return None\n    elif typ is None:\n        return tuple(nested)\n    elif typ is Literal:\n        self._validate_literal(nested)\n    elif not isinstance(typ, type):\n        self._report_nested_error(nested)\n    elif issubclass(typ, tuple):\n        if nested[-1].type is Ellipsis:\n            self._validate_nested_count(nested, 2, 'Homogenous tuple', offset=-1)\n    elif issubclass(typ, Sequence) and not issubclass(typ, (str, bytes, bytearray)):\n        self._validate_nested_count(nested, 1)\n    elif issubclass(typ, Set):\n        self._validate_nested_count(nested, 1)\n    elif issubclass(typ, Mapping):\n        self._validate_nested_count(nested, 2)\n    elif typ in TYPE_NAMES.values():\n        self._report_nested_error(nested)\n    return tuple(nested)\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypeInfo.from_type_hint","title":"from_type_hint  <code>classmethod</code>","text":"<pre><code>from_type_hint(hint: Any) -&gt; TypeInfo\n</code></pre> <p>Construct a <code>TypeInfo</code> based on a type hint.</p> <p>The type hint can be in various different formats:</p> <ul> <li>an actual type such as <code>int</code></li> <li>a parameterized type such as <code>list[int]</code></li> <li>a union such as <code>int | float</code></li> <li>a string such as <code>'int'</code>, <code>'list[int]'</code> or <code>'int | float'</code></li> <li>a <code>TypedDict</code> (represented as a :class:<code>TypedDictInfo</code>)</li> <li>a sequence of supported type hints to create a union from such as   <code>[int, float]</code> or <code>('int', 'list[int]')</code></li> </ul> <p>In special cases using a more specialized method like :meth:<code>from_sequence</code> may be more appropriate than using this generic method.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>@classmethod\ndef from_type_hint(cls, hint: Any) -&gt; 'TypeInfo':\n    \"\"\"Construct a ``TypeInfo`` based on a type hint.\n\n    The type hint can be in various different formats:\n\n    - an actual type such as ``int``\n    - a parameterized type such as ``list[int]``\n    - a union such as ``int | float``\n    - a string such as ``'int'``, ``'list[int]'`` or ``'int | float'``\n    - a ``TypedDict`` (represented as a :class:`TypedDictInfo`)\n    - a sequence of supported type hints to create a union from such as\n      ``[int, float]`` or ``('int', 'list[int]')``\n\n    In special cases using a more specialized method like :meth:`from_sequence`\n    may be more appropriate than using this generic method.\n    \"\"\"\n    if hint is NOT_SET:\n        return cls()\n    if isinstance(hint, ForwardRef):\n        hint = hint.__forward_arg__\n    if isinstance(hint, typeddict_types):\n        return TypedDictInfo(hint.__name__, hint)\n    if is_union(hint):\n        nested = [cls.from_type_hint(a) for a in hint.__args__]\n        return cls('Union', nested=nested)\n    if hasattr(hint, '__origin__'):\n        if hint.__origin__ is Literal:\n            nested = [cls(repr(a) if not isinstance(a, Enum) else a.name, a)\n                      for a in hint.__args__]\n        elif has_args(hint):\n            nested = [cls.from_type_hint(a) for a in hint.__args__]\n        else:\n            nested = None\n        return cls(type_repr(hint, nested=False), hint.__origin__, nested)\n    if isinstance(hint, str):\n        return cls.from_string(hint)\n    if isinstance(hint, (tuple, list)):\n        return cls.from_sequence(hint)\n    if isinstance(hint, type):\n        return cls(type_repr(hint), hint)\n    if hint is None:\n        return cls('None', type(None))\n    if hint is Union:    # Plain `Union` without params.\n        return cls('Union')\n    if hint is Any:\n        return cls('Any', hint)\n    if hint is Ellipsis:\n        return cls('...', hint)\n    return cls(str(hint))\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypeInfo.from_type","title":"from_type  <code>classmethod</code>","text":"<pre><code>from_type(hint: type) -&gt; TypeInfo\n</code></pre> <p>Construct a <code>TypeInfo</code> based on an actual type.</p> <p>Use :meth:<code>from_type_hint</code> if the type hint can also be something else than a concrete type such as a string.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>@classmethod\ndef from_type(cls, hint: type) -&gt; 'TypeInfo':\n    \"\"\"Construct a ``TypeInfo`` based on an actual type.\n\n    Use :meth:`from_type_hint` if the type hint can also be something else\n    than a concrete type such as a string.\n    \"\"\"\n    return cls(type_repr(hint), hint)\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypeInfo.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(hint: str) -&gt; TypeInfo\n</code></pre> <p>Construct a <code>TypeInfo</code> based on a string.</p> <p>In addition to just types names or their aliases like <code>int</code> or <code>integer</code>, supports also parameterized types like <code>list[int]</code> as well as unions like <code>int | float</code>.</p> <p>Use :meth:<code>from_type_hint</code> if the type hint can also be something else than a string such as an actual type.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>@classmethod\ndef from_string(cls, hint: str) -&gt; 'TypeInfo':\n    \"\"\"Construct a ``TypeInfo`` based on a string.\n\n    In addition to just types names or their aliases like ``int`` or ``integer``,\n    supports also parameterized types like ``list[int]`` as well as unions like\n    ``int | float``.\n\n    Use :meth:`from_type_hint` if the type hint can also be something else\n    than a string such as an actual type.\n    \"\"\"\n    # Needs to be imported here due to cyclic dependency.\n    from .typeinfoparser import TypeInfoParser\n    try:\n        return TypeInfoParser(hint).parse()\n    except ValueError as err:\n        raise DataError(str(err))\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypeInfo.from_sequence","title":"from_sequence  <code>classmethod</code>","text":"<pre><code>from_sequence(sequence: tuple | list) -&gt; TypeInfo\n</code></pre> <p>Construct a <code>TypeInfo</code> based on a sequence of types.</p> <p>Types can be actual types, strings, or anything else accepted by :meth:<code>from_type_hint</code>. If the sequence contains just one type, a <code>TypeInfo</code> created based on it is returned. If there are more types, the returned <code>TypeInfo</code> represents a union. Using an empty sequence is an error.</p> <p>Use :meth:<code>from_type_hint</code> if other types than sequences need to supported.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>@classmethod\ndef from_sequence(cls, sequence: 'tuple|list') -&gt; 'TypeInfo':\n    \"\"\"Construct a ``TypeInfo`` based on a sequence of types.\n\n    Types can be actual types, strings, or anything else accepted by\n    :meth:`from_type_hint`. If the sequence contains just one type,\n    a ``TypeInfo`` created based on it is returned. If there are more\n    types, the returned ``TypeInfo`` represents a union. Using an empty\n    sequence is an error.\n\n    Use :meth:`from_type_hint` if other types than sequences need to\n    supported.\n    \"\"\"\n    infos = []\n    for typ in sequence:\n        info = cls.from_type_hint(typ)\n        if info.is_union:\n            infos.extend(info.nested)\n        else:\n            infos.append(info)\n    if len(infos) == 1:\n        return infos[0]\n    return cls('Union', nested=infos)\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypeInfo.convert","title":"convert","text":"<pre><code>convert(\n    value: Any,\n    name: str | None = None,\n    custom_converters: (\n        CustomArgumentConverters | dict | None\n    ) = None,\n    languages: LanguagesLike = None,\n    kind: str = \"Argument\",\n)\n</code></pre> <p>Convert <code>value</code> based on type information this <code>TypeInfo</code> contains.</p> <p>:param value: Value to convert. :param name: Name of the argument or other thing to convert.     Used only for error reporting. :param custom_converters: Custom argument converters. :param languages: Language configuration. During execution, uses the     current language configuration by default. :param kind: Type of the thing to be converted.     Used only for error reporting. :raises: <code>TypeError</code> if there is no converter for this type or     <code>ValueError</code> is conversion fails. :return: Converted value.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>def convert(self, value: Any,\n            name: 'str|None' = None,\n            custom_converters: 'CustomArgumentConverters|dict|None' = None,\n            languages: 'LanguagesLike' = None,\n            kind: str = 'Argument'):\n    \"\"\"Convert ``value`` based on type information this ``TypeInfo`` contains.\n\n    :param value: Value to convert.\n    :param name: Name of the argument or other thing to convert.\n        Used only for error reporting.\n    :param custom_converters: Custom argument converters.\n    :param languages: Language configuration. During execution, uses the\n        current language configuration by default.\n    :param kind: Type of the thing to be converted.\n        Used only for error reporting.\n    :raises: ``TypeError`` if there is no converter for this type or\n        ``ValueError`` is conversion fails.\n    :return: Converted value.\n    \"\"\"\n    if isinstance(custom_converters, dict):\n        custom_converters = CustomArgumentConverters.from_dict(custom_converters)\n    if not languages and EXECUTION_CONTEXTS.current:\n        languages = EXECUTION_CONTEXTS.current.languages\n    elif not isinstance(languages, Languages):\n        languages = Languages(languages)\n    converter = TypeConverter.converter_for(self, custom_converters, languages)\n    if not converter:\n        raise TypeError(f\"No converter found for '{self}'.\")\n    return converter.convert(value, name, kind)\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypedDictInfo","title":"TypedDictInfo","text":"<pre><code>TypedDictInfo(name: str, type: type)\n</code></pre> <p>               Bases: <code>TypeInfo</code></p> <p>Represents <code>TypedDict</code> used as an argument.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>def __init__(self, name: str, type: type):\n    super().__init__(name, type)\n    type_hints = self._get_type_hints(type)\n    # __required_keys__ is new in Python 3.9.\n    self.required = getattr(type, '__required_keys__', frozenset())\n    if sys.version_info &lt; (3, 11):\n        self._handle_typing_extensions_required_and_not_required(type_hints)\n    self.annotations = {name: TypeInfo.from_type_hint(hint)\n                        for name, hint in type_hints.items()}\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypedDictInfo.nested","title":"nested","text":"<pre><code>nested(\n    nested: Sequence[TypeInfo],\n) -&gt; tuple[TypeInfo, ...] | None\n</code></pre> <p>Nested types as a tuple of <code>TypeInfo</code> objects.</p> <p>Used with parameterized types and unions.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>@setter\ndef nested(self, nested: 'Sequence[TypeInfo]') -&gt; 'tuple[TypeInfo, ...]|None':\n    \"\"\"Nested types as a tuple of ``TypeInfo`` objects.\n\n    Used with parameterized types and unions.\n    \"\"\"\n    typ = self.type\n    if self.is_union:\n        self._validate_union(nested)\n    elif nested is None:\n        return None\n    elif typ is None:\n        return tuple(nested)\n    elif typ is Literal:\n        self._validate_literal(nested)\n    elif not isinstance(typ, type):\n        self._report_nested_error(nested)\n    elif issubclass(typ, tuple):\n        if nested[-1].type is Ellipsis:\n            self._validate_nested_count(nested, 2, 'Homogenous tuple', offset=-1)\n    elif issubclass(typ, Sequence) and not issubclass(typ, (str, bytes, bytearray)):\n        self._validate_nested_count(nested, 1)\n    elif issubclass(typ, Set):\n        self._validate_nested_count(nested, 1)\n    elif issubclass(typ, Mapping):\n        self._validate_nested_count(nested, 2)\n    elif typ in TYPE_NAMES.values():\n        self._report_nested_error(nested)\n    return tuple(nested)\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypedDictInfo.from_type_hint","title":"from_type_hint  <code>classmethod</code>","text":"<pre><code>from_type_hint(hint: Any) -&gt; TypeInfo\n</code></pre> <p>Construct a <code>TypeInfo</code> based on a type hint.</p> <p>The type hint can be in various different formats:</p> <ul> <li>an actual type such as <code>int</code></li> <li>a parameterized type such as <code>list[int]</code></li> <li>a union such as <code>int | float</code></li> <li>a string such as <code>'int'</code>, <code>'list[int]'</code> or <code>'int | float'</code></li> <li>a <code>TypedDict</code> (represented as a :class:<code>TypedDictInfo</code>)</li> <li>a sequence of supported type hints to create a union from such as   <code>[int, float]</code> or <code>('int', 'list[int]')</code></li> </ul> <p>In special cases using a more specialized method like :meth:<code>from_sequence</code> may be more appropriate than using this generic method.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>@classmethod\ndef from_type_hint(cls, hint: Any) -&gt; 'TypeInfo':\n    \"\"\"Construct a ``TypeInfo`` based on a type hint.\n\n    The type hint can be in various different formats:\n\n    - an actual type such as ``int``\n    - a parameterized type such as ``list[int]``\n    - a union such as ``int | float``\n    - a string such as ``'int'``, ``'list[int]'`` or ``'int | float'``\n    - a ``TypedDict`` (represented as a :class:`TypedDictInfo`)\n    - a sequence of supported type hints to create a union from such as\n      ``[int, float]`` or ``('int', 'list[int]')``\n\n    In special cases using a more specialized method like :meth:`from_sequence`\n    may be more appropriate than using this generic method.\n    \"\"\"\n    if hint is NOT_SET:\n        return cls()\n    if isinstance(hint, ForwardRef):\n        hint = hint.__forward_arg__\n    if isinstance(hint, typeddict_types):\n        return TypedDictInfo(hint.__name__, hint)\n    if is_union(hint):\n        nested = [cls.from_type_hint(a) for a in hint.__args__]\n        return cls('Union', nested=nested)\n    if hasattr(hint, '__origin__'):\n        if hint.__origin__ is Literal:\n            nested = [cls(repr(a) if not isinstance(a, Enum) else a.name, a)\n                      for a in hint.__args__]\n        elif has_args(hint):\n            nested = [cls.from_type_hint(a) for a in hint.__args__]\n        else:\n            nested = None\n        return cls(type_repr(hint, nested=False), hint.__origin__, nested)\n    if isinstance(hint, str):\n        return cls.from_string(hint)\n    if isinstance(hint, (tuple, list)):\n        return cls.from_sequence(hint)\n    if isinstance(hint, type):\n        return cls(type_repr(hint), hint)\n    if hint is None:\n        return cls('None', type(None))\n    if hint is Union:    # Plain `Union` without params.\n        return cls('Union')\n    if hint is Any:\n        return cls('Any', hint)\n    if hint is Ellipsis:\n        return cls('...', hint)\n    return cls(str(hint))\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypedDictInfo.from_type","title":"from_type  <code>classmethod</code>","text":"<pre><code>from_type(hint: type) -&gt; TypeInfo\n</code></pre> <p>Construct a <code>TypeInfo</code> based on an actual type.</p> <p>Use :meth:<code>from_type_hint</code> if the type hint can also be something else than a concrete type such as a string.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>@classmethod\ndef from_type(cls, hint: type) -&gt; 'TypeInfo':\n    \"\"\"Construct a ``TypeInfo`` based on an actual type.\n\n    Use :meth:`from_type_hint` if the type hint can also be something else\n    than a concrete type such as a string.\n    \"\"\"\n    return cls(type_repr(hint), hint)\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypedDictInfo.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(hint: str) -&gt; TypeInfo\n</code></pre> <p>Construct a <code>TypeInfo</code> based on a string.</p> <p>In addition to just types names or their aliases like <code>int</code> or <code>integer</code>, supports also parameterized types like <code>list[int]</code> as well as unions like <code>int | float</code>.</p> <p>Use :meth:<code>from_type_hint</code> if the type hint can also be something else than a string such as an actual type.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>@classmethod\ndef from_string(cls, hint: str) -&gt; 'TypeInfo':\n    \"\"\"Construct a ``TypeInfo`` based on a string.\n\n    In addition to just types names or their aliases like ``int`` or ``integer``,\n    supports also parameterized types like ``list[int]`` as well as unions like\n    ``int | float``.\n\n    Use :meth:`from_type_hint` if the type hint can also be something else\n    than a string such as an actual type.\n    \"\"\"\n    # Needs to be imported here due to cyclic dependency.\n    from .typeinfoparser import TypeInfoParser\n    try:\n        return TypeInfoParser(hint).parse()\n    except ValueError as err:\n        raise DataError(str(err))\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypedDictInfo.from_sequence","title":"from_sequence  <code>classmethod</code>","text":"<pre><code>from_sequence(sequence: tuple | list) -&gt; TypeInfo\n</code></pre> <p>Construct a <code>TypeInfo</code> based on a sequence of types.</p> <p>Types can be actual types, strings, or anything else accepted by :meth:<code>from_type_hint</code>. If the sequence contains just one type, a <code>TypeInfo</code> created based on it is returned. If there are more types, the returned <code>TypeInfo</code> represents a union. Using an empty sequence is an error.</p> <p>Use :meth:<code>from_type_hint</code> if other types than sequences need to supported.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>@classmethod\ndef from_sequence(cls, sequence: 'tuple|list') -&gt; 'TypeInfo':\n    \"\"\"Construct a ``TypeInfo`` based on a sequence of types.\n\n    Types can be actual types, strings, or anything else accepted by\n    :meth:`from_type_hint`. If the sequence contains just one type,\n    a ``TypeInfo`` created based on it is returned. If there are more\n    types, the returned ``TypeInfo`` represents a union. Using an empty\n    sequence is an error.\n\n    Use :meth:`from_type_hint` if other types than sequences need to\n    supported.\n    \"\"\"\n    infos = []\n    for typ in sequence:\n        info = cls.from_type_hint(typ)\n        if info.is_union:\n            infos.extend(info.nested)\n        else:\n            infos.append(info)\n    if len(infos) == 1:\n        return infos[0]\n    return cls('Union', nested=infos)\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfo/#robot.running.arguments.typeinfo.TypedDictInfo.convert","title":"convert","text":"<pre><code>convert(\n    value: Any,\n    name: str | None = None,\n    custom_converters: (\n        CustomArgumentConverters | dict | None\n    ) = None,\n    languages: LanguagesLike = None,\n    kind: str = \"Argument\",\n)\n</code></pre> <p>Convert <code>value</code> based on type information this <code>TypeInfo</code> contains.</p> <p>:param value: Value to convert. :param name: Name of the argument or other thing to convert.     Used only for error reporting. :param custom_converters: Custom argument converters. :param languages: Language configuration. During execution, uses the     current language configuration by default. :param kind: Type of the thing to be converted.     Used only for error reporting. :raises: <code>TypeError</code> if there is no converter for this type or     <code>ValueError</code> is conversion fails. :return: Converted value.</p> Source code in <code>src/robot/running/arguments/typeinfo.py</code> <pre><code>def convert(self, value: Any,\n            name: 'str|None' = None,\n            custom_converters: 'CustomArgumentConverters|dict|None' = None,\n            languages: 'LanguagesLike' = None,\n            kind: str = 'Argument'):\n    \"\"\"Convert ``value`` based on type information this ``TypeInfo`` contains.\n\n    :param value: Value to convert.\n    :param name: Name of the argument or other thing to convert.\n        Used only for error reporting.\n    :param custom_converters: Custom argument converters.\n    :param languages: Language configuration. During execution, uses the\n        current language configuration by default.\n    :param kind: Type of the thing to be converted.\n        Used only for error reporting.\n    :raises: ``TypeError`` if there is no converter for this type or\n        ``ValueError`` is conversion fails.\n    :return: Converted value.\n    \"\"\"\n    if isinstance(custom_converters, dict):\n        custom_converters = CustomArgumentConverters.from_dict(custom_converters)\n    if not languages and EXECUTION_CONTEXTS.current:\n        languages = EXECUTION_CONTEXTS.current.languages\n    elif not isinstance(languages, Languages):\n        languages = Languages(languages)\n    converter = TypeConverter.converter_for(self, custom_converters, languages)\n    if not converter:\n        raise TypeError(f\"No converter found for '{self}'.\")\n    return converter.convert(value, name, kind)\n</code></pre>"},{"location":"api/robot/running/arguments/typeinfoparser/","title":"robot.running.arguments.typeinfoparser","text":""},{"location":"api/robot/running/arguments/typeinfoparser/#robot.running.arguments.typeinfoparser","title":"robot.running.arguments.typeinfoparser","text":""},{"location":"api/robot/running/arguments/typevalidator/","title":"robot.running.arguments.typevalidator","text":""},{"location":"api/robot/running/arguments/typevalidator/#robot.running.arguments.typevalidator","title":"robot.running.arguments.typevalidator","text":""},{"location":"api/robot/running/builder/","title":"robot.running.builder","text":""},{"location":"api/robot/running/builder/#robot.running.builder","title":"robot.running.builder","text":""},{"location":"api/robot/running/builder/builders/","title":"robot.running.builder.builders","text":""},{"location":"api/robot/running/builder/builders/#robot.running.builder.builders","title":"robot.running.builder.builders","text":""},{"location":"api/robot/running/builder/builders/#robot.running.builder.builders.TestSuiteBuilder","title":"TestSuiteBuilder","text":"<pre><code>TestSuiteBuilder(\n    included_suites: str = \"DEPRECATED\",\n    included_extensions: Sequence[str] = (\n        \".robot\",\n        \".rbt\",\n        \".robot.rst\",\n    ),\n    included_files: Sequence[str] = (),\n    custom_parsers: Sequence[str] = (),\n    defaults: TestDefaults | None = None,\n    rpa: bool | None = None,\n    lang: LanguagesLike = None,\n    allow_empty_suite: bool = False,\n    process_curdir: bool = True,\n)\n</code></pre> <p>Builder to construct <code>TestSuite</code> objects based on data on the disk.</p> <p>The :meth:<code>build</code> method constructs executable :class:<code>~robot.running.model.TestSuite</code> objects based on test data files or directories. There are two main use cases for this API:</p> <ul> <li> <p>Execute the created suite by using its   :meth:<code>~robot.running.model.TestSuite.run</code> method. The suite can be   modified before execution if needed.</p> </li> <li> <p>Inspect the suite to see, for example, what tests it has or what tags   tests have. This can be more convenient than using the lower level   :mod:<code>~robot.parsing</code> APIs.</p> </li> </ul> <p>Both modifying the suite and inspecting what data it contains are easiest done by using the :mod:<code>~robot.model.visitor</code> interface.</p> <p>This class is part of the public API and should be imported via the :mod:<code>robot.api</code> package. An alternative is using the :meth:<code>TestSuite.from_file_system &lt;robot.running.model.TestSuite.from_file_system&gt;</code> classmethod that uses this class internally.</p> <p>:param included_suites:     This argument used to be used for limiting what suite file to parse.     It is deprecated and has no effect starting from RF 6.1. Use the     new <code>included_files</code> argument or filter the created suite after     parsing instead. :param included_extensions:     List of extensions of files to parse. Same as <code>--extension</code>. :param included_files:     List of names, paths or directory paths of files to parse. All files     are parsed by default. Same as <code>--parse-include</code>. New in RF 6.1. :param custom_parsers:     Custom parsers as names or paths (same as <code>--parser</code>) or as     parser objects. New in RF 6.1. :param defaults:     Possible test specific defaults from suite initialization files.     New in RF 6.1. :param rpa:     Explicit execution mode. <code>True</code> for RPA and <code>False</code> for test     automation. By default, mode is got from data file headers.     Same as <code>--rpa</code> or <code>--norpa</code>. :param lang:     Additional languages to be supported during parsing.     Can be a string matching any of the supported language codes or names,     an initialized :class:<code>~robot.conf.languages.Language</code> subclass,     a list containing such strings or instances, or a     :class:<code>~robot.conf.languages.Languages</code> instance. :param allow_empty_suite:     Specify is it an error if the built suite contains no tests.     Same as <code>--runemptysuite</code>. :param process_curdir:     Control processing the special <code>${CURDIR}</code> variable. It is     resolved already at parsing time by default, but that can be     changed by giving this argument <code>False</code> value.</p> Source code in <code>src/robot/running/builder/builders.py</code> <pre><code>def __init__(self, included_suites: str = 'DEPRECATED',\n             included_extensions: Sequence[str] = ('.robot', '.rbt', '.robot.rst'),\n             included_files: Sequence[str] = (),\n             custom_parsers: Sequence[str] = (),\n             defaults: 'TestDefaults|None' = None,\n             rpa: 'bool|None' = None,\n             lang: LanguagesLike = None,\n             allow_empty_suite: bool = False,\n             process_curdir: bool = True):\n    \"\"\"\n    :param included_suites:\n        This argument used to be used for limiting what suite file to parse.\n        It is deprecated and has no effect starting from RF 6.1. Use the\n        new ``included_files`` argument or filter the created suite after\n        parsing instead.\n    :param included_extensions:\n        List of extensions of files to parse. Same as ``--extension``.\n    :param included_files:\n        List of names, paths or directory paths of files to parse. All files\n        are parsed by default. Same as `--parse-include`. New in RF 6.1.\n    :param custom_parsers:\n        Custom parsers as names or paths (same as ``--parser``) or as\n        parser objects. New in RF 6.1.\n    :param defaults:\n        Possible test specific defaults from suite initialization files.\n        New in RF 6.1.\n    :param rpa:\n        Explicit execution mode. ``True`` for RPA and ``False`` for test\n        automation. By default, mode is got from data file headers.\n        Same as ``--rpa`` or ``--norpa``.\n    :param lang:\n        Additional languages to be supported during parsing.\n        Can be a string matching any of the supported language codes or names,\n        an initialized :class:`~robot.conf.languages.Language` subclass,\n        a list containing such strings or instances, or a\n        :class:`~robot.conf.languages.Languages` instance.\n    :param allow_empty_suite:\n        Specify is it an error if the built suite contains no tests.\n        Same as ``--runemptysuite``.\n    :param process_curdir:\n        Control processing the special ``${CURDIR}`` variable. It is\n        resolved already at parsing time by default, but that can be\n        changed by giving this argument ``False`` value.\n    \"\"\"\n    self.standard_parsers = self._get_standard_parsers(lang, process_curdir)\n    self.custom_parsers = self._get_custom_parsers(custom_parsers)\n    self.defaults = defaults\n    self.included_extensions = tuple(included_extensions or ())\n    self.included_files = tuple(included_files or ())\n    self.rpa = rpa\n    self.allow_empty_suite = allow_empty_suite\n    # TODO: Remove in RF 7.\n    if included_suites != 'DEPRECATED':\n        warnings.warn(\"'TestSuiteBuilder' argument 'included_suites' is deprecated \"\n                      \"and has no effect. Use the new 'included_files' argument \"\n                      \"or filter the created suite instead.\")\n</code></pre>"},{"location":"api/robot/running/builder/builders/#robot.running.builder.builders.TestSuiteBuilder.build","title":"build","text":"<pre><code>build(*paths: Path | str) -&gt; TestSuite\n</code></pre> <p>:param paths: Paths to test data files or directories. :return: :class:<code>~robot.running.model.TestSuite</code> instance.</p> Source code in <code>src/robot/running/builder/builders.py</code> <pre><code>def build(self, *paths: 'Path|str') -&gt; TestSuite:\n    \"\"\"\n    :param paths: Paths to test data files or directories.\n    :return: :class:`~robot.running.model.TestSuite` instance.\n    \"\"\"\n    paths = self._normalize_paths(paths)\n    extensions = self.included_extensions + tuple(self.custom_parsers)\n    structure = SuiteStructureBuilder(extensions,\n                                      self.included_files).build(*paths)\n    suite = SuiteStructureParser(self._get_parsers(paths), self.defaults,\n                                 self.rpa).parse(structure)\n    if not self.allow_empty_suite:\n        self._validate_not_empty(suite, multi_source=len(paths) &gt; 1)\n    suite.remove_empty_suites(preserve_direct_children=len(paths) &gt; 1)\n    return suite\n</code></pre>"},{"location":"api/robot/running/builder/parsers/","title":"robot.running.builder.parsers","text":""},{"location":"api/robot/running/builder/parsers/#robot.running.builder.parsers","title":"robot.running.builder.parsers","text":""},{"location":"api/robot/running/builder/settings/","title":"robot.running.builder.settings","text":""},{"location":"api/robot/running/builder/settings/#robot.running.builder.settings","title":"robot.running.builder.settings","text":""},{"location":"api/robot/running/builder/settings/#robot.running.builder.settings.FixtureDict","title":"FixtureDict","text":"<p>               Bases: <code>OptionalItems</code></p> <p>Dictionary containing setup or teardown info.</p> <p>:attr:<code>args</code> and :attr:<code>lineno</code> are optional.</p>"},{"location":"api/robot/running/builder/settings/#robot.running.builder.settings.TestDefaults","title":"TestDefaults","text":"<pre><code>TestDefaults(\n    parent: TestDefaults | None = None,\n    setup: FixtureDict | None = None,\n    teardown: FixtureDict | None = None,\n    tags: Sequence[str] = (),\n    timeout: str | None = None,\n)\n</code></pre> <p>Represents default values for test related settings set in init files.</p> <p>Parsers parsing suite files can read defaults and parsers parsing init files can set them. The easiest way to set defaults to a test is using the :meth:<code>set_to</code> method.</p> <p>This class is part of the <code>public parser API</code>__. When implementing <code>parse</code> or <code>parse_init</code> method so that they accept two arguments, the second is an instance of this class. If the class is needed as a type hint, it can be imported via :mod:<code>robot.running</code> or :mod:<code>robot.api.interfaces</code>.</p> <p>__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#parser-interface</p> Source code in <code>src/robot/running/builder/settings.py</code> <pre><code>def __init__(self, parent: 'TestDefaults|None' = None,\n             setup: 'FixtureDict|None' = None,\n             teardown: 'FixtureDict|None' = None,\n             tags: 'Sequence[str]' = (), timeout: 'str|None' = None):\n    self.parent = parent\n    self.setup = setup\n    self.teardown = teardown\n    self.tags = tags\n    self.timeout = timeout\n</code></pre>"},{"location":"api/robot/running/builder/settings/#robot.running.builder.settings.TestDefaults.setup","title":"setup  <code>property</code> <code>writable</code>","text":"<pre><code>setup: FixtureDict | None\n</code></pre> <p>Default setup as a <code>Keyword</code> object or <code>None</code> when not set.</p> <p>Can be set also using a dictionary.</p>"},{"location":"api/robot/running/builder/settings/#robot.running.builder.settings.TestDefaults.teardown","title":"teardown  <code>property</code> <code>writable</code>","text":"<pre><code>teardown: FixtureDict | None\n</code></pre> <p>Default teardown as a <code>Keyword</code> object or <code>None</code> when not set.</p> <p>Can be set also using a dictionary.</p>"},{"location":"api/robot/running/builder/settings/#robot.running.builder.settings.TestDefaults.tags","title":"tags  <code>property</code> <code>writable</code>","text":"<pre><code>tags: tuple[str, ...]\n</code></pre> <p>Default tags. Can be set also as a sequence.</p>"},{"location":"api/robot/running/builder/settings/#robot.running.builder.settings.TestDefaults.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: str | None\n</code></pre> <p>Default timeout.</p>"},{"location":"api/robot/running/builder/settings/#robot.running.builder.settings.TestDefaults.set_to","title":"set_to","text":"<pre><code>set_to(test: TestCase)\n</code></pre> <p>Sets defaults to the given test.</p> <p>Tags are always added to the test. Setup, teardown and timeout are set only if the test does not have them set initially.</p> Source code in <code>src/robot/running/builder/settings.py</code> <pre><code>def set_to(self, test: TestCase):\n    \"\"\"Sets defaults to the given test.\n\n    Tags are always added to the test. Setup, teardown and timeout are\n    set only if the test does not have them set initially.\n    \"\"\"\n    if self.tags:\n        test.tags += self.tags\n    if self.setup and not test.has_setup:\n        test.setup.config(**self.setup)\n    if self.teardown and not test.has_teardown:\n        test.teardown.config(**self.teardown)\n    if self.timeout and not test.timeout:\n        test.timeout = self.timeout\n</code></pre>"},{"location":"api/robot/running/builder/transformers/","title":"robot.running.builder.transformers","text":""},{"location":"api/robot/running/builder/transformers/#robot.running.builder.transformers","title":"robot.running.builder.transformers","text":""},{"location":"api/robot/running/timeouts/","title":"robot.running.timeouts","text":""},{"location":"api/robot/running/timeouts/#robot.running.timeouts","title":"robot.running.timeouts","text":""},{"location":"api/robot/running/timeouts/nosupport/","title":"robot.running.timeouts.nosupport","text":""},{"location":"api/robot/running/timeouts/nosupport/#robot.running.timeouts.nosupport","title":"robot.running.timeouts.nosupport","text":""},{"location":"api/robot/running/timeouts/posix/","title":"robot.running.timeouts.posix","text":""},{"location":"api/robot/running/timeouts/posix/#robot.running.timeouts.posix","title":"robot.running.timeouts.posix","text":""},{"location":"api/robot/running/timeouts/windows/","title":"robot.running.timeouts.windows","text":""},{"location":"api/robot/running/timeouts/windows/#robot.running.timeouts.windows","title":"robot.running.timeouts.windows","text":""},{"location":"api/robot/utils/","title":"robot.utils","text":""},{"location":"api/robot/utils/#robot.utils","title":"robot.utils","text":"<p>Various generic utility functions and classes.</p> <p>Utilities are mainly for internal usage, but external libraries and tools may find some of them useful. Utilities are generally stable, but absolute backwards compatibility between major versions is not guaranteed.</p> <p>All utilities are exposed via the :mod:<code>robot.utils</code> package, and should be used either like::</p> <pre><code>from robot import utils\n\nassert utils.Matcher('H?llo').match('Hillo')\n</code></pre> <p>or::</p> <pre><code>from robot.utils import Matcher\n\nassert Matcher('H?llo').match('Hillo')\n</code></pre>"},{"location":"api/robot/utils/application/","title":"robot.utils.application","text":""},{"location":"api/robot/utils/application/#robot.utils.application","title":"robot.utils.application","text":""},{"location":"api/robot/utils/application/#robot.utils.application.Application","title":"Application","text":"<pre><code>Application(\n    usage,\n    name=None,\n    version=None,\n    arg_limits=None,\n    env_options=None,\n    logger=None,\n    **auto_options\n)\n</code></pre> Source code in <code>src/robot/utils/application.py</code> <pre><code>def __init__(self, usage, name=None, version=None, arg_limits=None,\n             env_options=None, logger=None, **auto_options):\n    self._ap = ArgumentParser(usage, name, version, arg_limits,\n                              self.validate, env_options, **auto_options)\n    self._logger = logger or DefaultLogger()\n</code></pre>"},{"location":"api/robot/utils/application/#robot.utils.application.Application.parse_arguments","title":"parse_arguments","text":"<pre><code>parse_arguments(cli_args)\n</code></pre> <p>Public interface for parsing command line arguments.</p> <p>:param    cli_args: Command line arguments as a list :returns: options (dict), arguments (list) :raises:  :class:<code>~robot.errors.Information</code> when --help or --version used :raises:  :class:<code>~robot.errors.DataError</code> when parsing fails</p> Source code in <code>src/robot/utils/application.py</code> <pre><code>def parse_arguments(self, cli_args):\n    \"\"\"Public interface for parsing command line arguments.\n\n    :param    cli_args: Command line arguments as a list\n    :returns: options (dict), arguments (list)\n    :raises:  :class:`~robot.errors.Information` when --help or --version used\n    :raises:  :class:`~robot.errors.DataError` when parsing fails\n    \"\"\"\n    return self._ap.parse_args(cli_args)\n</code></pre>"},{"location":"api/robot/utils/argumentparser/","title":"robot.utils.argumentparser","text":""},{"location":"api/robot/utils/argumentparser/#robot.utils.argumentparser","title":"robot.utils.argumentparser","text":""},{"location":"api/robot/utils/argumentparser/#robot.utils.argumentparser.ArgumentParser","title":"ArgumentParser","text":"<pre><code>ArgumentParser(\n    usage,\n    name=None,\n    version=None,\n    arg_limits=None,\n    validator=None,\n    env_options=None,\n    auto_help=True,\n    auto_version=True,\n    auto_pythonpath=\"DEPRECATED\",\n    auto_argumentfile=True,\n)\n</code></pre> <p>Available options and tool name are read from the usage.</p> <p>Tool name is got from the first row of the usage. It is either the whole row or anything before first ' -- '.</p> Source code in <code>src/robot/utils/argumentparser.py</code> <pre><code>def __init__(self, usage, name=None, version=None, arg_limits=None,\n             validator=None, env_options=None, auto_help=True,\n             auto_version=True, auto_pythonpath='DEPRECATED',\n             auto_argumentfile=True):\n    \"\"\"Available options and tool name are read from the usage.\n\n    Tool name is got from the first row of the usage. It is either the\n    whole row or anything before first ' -- '.\n    \"\"\"\n    if not usage:\n        raise FrameworkError('Usage cannot be empty')\n    self.name = name or usage.splitlines()[0].split(' -- ')[0].strip()\n    self.version = version or get_full_version()\n    self._usage = usage\n    self._arg_limit_validator = ArgLimitValidator(arg_limits)\n    self._validator = validator\n    self._auto_help = auto_help\n    self._auto_version = auto_version\n    if auto_pythonpath == 'DEPRECATED':\n        auto_pythonpath = False\n    else:\n        warnings.warn(\"ArgumentParser option 'auto_pythonpath' is deprecated \"\n                      \"since Robot Framework 5.0.\")\n    self._auto_pythonpath = auto_pythonpath\n    self._auto_argumentfile = auto_argumentfile\n    self._env_options = env_options\n    self._short_opts = ''\n    self._long_opts = []\n    self._multi_opts = []\n    self._flag_opts = []\n    self._short_to_long = {}\n    self._expected_args = ()\n    self._create_options(usage)\n</code></pre>"},{"location":"api/robot/utils/argumentparser/#robot.utils.argumentparser.ArgumentParser.parse_args","title":"parse_args","text":"<pre><code>parse_args(args)\n</code></pre> <p>Parse given arguments and return options and positional arguments.</p> <p>Arguments must be given as a list and are typically sys.argv[1:].</p> <p>Options are returned as a dictionary where long options are keys. Value is a string for those options that can be given only one time (if they are given multiple times the last value is used) or None if the option is not used at all. Value for options that can be given multiple times (denoted with '*' in the usage) is a list which contains all the given values and is empty if options are not used. Options not taken arguments have value False when they are not set and True otherwise.</p> <p>Positional arguments are returned as a list in the order they are given.</p> <p>If 'check_args' is True, this method will automatically check that correct number of arguments, as parsed from the usage line, are given. If the last argument in the usage line ends with the character 's', the maximum number of arguments is infinite.</p> <p>Possible errors in processing arguments are reported using DataError.</p> <p>Some options have a special meaning and are handled automatically if defined in the usage and given from the command line:</p> <p>--argumentfile can be used to automatically read arguments from a specified file. When --argumentfile is used, the parser always allows using it multiple times. Adding '*' to denote that is thus recommend. A special value 'stdin' can be used to read arguments from stdin instead of a file.</p> <p>--pythonpath can be used to add extra path(s) to sys.path. This functionality was deprecated in Robot Framework 5.0.</p> <p>--help and --version automatically generate help and version messages. Version is generated based on the tool name and version -- see init for information how to set them. Help contains the whole usage given to init. Possible  text in the usage is replaced with the given version. Both help and version are wrapped to Information exception. Source code in <code>src/robot/utils/argumentparser.py</code> <pre><code>def parse_args(self, args):\n    \"\"\"Parse given arguments and return options and positional arguments.\n\n    Arguments must be given as a list and are typically sys.argv[1:].\n\n    Options are returned as a dictionary where long options are keys. Value\n    is a string for those options that can be given only one time (if they\n    are given multiple times the last value is used) or None if the option\n    is not used at all. Value for options that can be given multiple times\n    (denoted with '*' in the usage) is a list which contains all the given\n    values and is empty if options are not used. Options not taken\n    arguments have value False when they are not set and True otherwise.\n\n    Positional arguments are returned as a list in the order they are given.\n\n    If 'check_args' is True, this method will automatically check that\n    correct number of arguments, as parsed from the usage line, are given.\n    If the last argument in the usage line ends with the character 's',\n    the maximum number of arguments is infinite.\n\n    Possible errors in processing arguments are reported using DataError.\n\n    Some options have a special meaning and are handled automatically\n    if defined in the usage and given from the command line:\n\n    --argumentfile can be used to automatically read arguments from\n    a specified file. When --argumentfile is used, the parser always\n    allows using it multiple times. Adding '*' to denote that is thus\n    recommend. A special value 'stdin' can be used to read arguments from\n    stdin instead of a file.\n\n    --pythonpath can be used to add extra path(s) to sys.path.\n    This functionality was deprecated in Robot Framework 5.0.\n\n    --help and --version automatically generate help and version messages.\n    Version is generated based on the tool name and version -- see __init__\n    for information how to set them. Help contains the whole usage given to\n    __init__. Possible &lt;VERSION&gt; text in the usage is replaced with the\n    given version. Both help and version are wrapped to Information\n    exception.\n    \"\"\"\n    args = self._get_env_options() + list(args)\n    args = [system_decode(a) for a in args]\n    if self._auto_argumentfile:\n        args = self._process_possible_argfile(args)\n    opts, args = self._parse_args(args)\n    if self._auto_argumentfile and opts.get('argumentfile'):\n        raise DataError(\"Using '--argumentfile' option in shortened format \"\n                        \"like '--argumentf' is not supported.\")\n    opts, args = self._handle_special_options(opts, args)\n    self._arg_limit_validator(args)\n    if self._validator:\n        opts, args = self._validator(opts, args)\n    return opts, args\n</code></pre>"},{"location":"api/robot/utils/asserts/","title":"robot.utils.asserts","text":""},{"location":"api/robot/utils/asserts/#robot.utils.asserts","title":"robot.utils.asserts","text":"<p>Convenience functions for testing both in unit and higher levels.</p> Benefits <ul> <li>Integrates 100% with unittest (see example below)</li> <li>Can be easily used without unittest (using unittest.TestCase when you   only need convenient asserts is not so nice)</li> <li>Saved typing and shorter lines because no need to have 'self.' before   asserts. These are static functions after all so that is OK.</li> <li>All 'equals' methods (by default) report given values even if optional   message given. This behavior can be controlled with the optional values   argument.</li> </ul> Drawbacks <ul> <li>unittest is not able to filter as much non-interesting traceback away   as with its own methods because AssertionErrors occur outside.</li> </ul> <p>Most of the functions are copied more or less directly from unittest.TestCase which comes with the following license. Further information about unittest in general can be found from http://pyunit.sourceforge.net/. This module can be used freely in same terms as unittest.</p> <p>unittest license::</p> <pre><code>Copyright (c) 1999-2003 Steve Purcell\nThis module is free software, and you may redistribute it and/or modify\nit under the same terms as Python itself, so long as this copyright message\nand disclaimer are retained in their original form.\n\nIN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,\nSPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF\nTHIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nTHE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN \"AS IS\" BASIS,\nAND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,\nSUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n</code></pre> <p>Examples::</p> <pre><code>import unittest\nfrom robot.utils.asserts import assert_equal\n\nclass MyTests(unittest.TestCase):\n\n    def test_old_style(self):\n        self.assertEqual(1, 2, 'my msg')\n\n    def test_new_style(self):\n        assert_equal(1, 2, 'my msg')\n</code></pre> <p>Example output::</p> <pre><code>FF\n======================================================================\nFAIL: test_old_style (example.MyTests)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"example.py\", line 7, in test_old_style\n    self.assertEqual(1, 2, 'my msg')\nAssertionError: my msg\n\n======================================================================\nFAIL: test_new_style (example.MyTests)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"example.py\", line 10, in test_new_style\n    assert_equal(1, 2, 'my msg')\n  File \"/path/to/robot/utils/asserts.py\", line 181, in assert_equal\n    _report_inequality_failure(first, second, msg, values, '!=')\n  File \"/path/to/robot/utils/asserts.py\", line 229, in _report_inequality_failure\n    raise AssertionError(msg)\nAssertionError: my msg: 1 != 2\n\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nFAILED (failures=2)\n</code></pre>"},{"location":"api/robot/utils/asserts/#robot.utils.asserts.fail","title":"fail","text":"<pre><code>fail(msg=None)\n</code></pre> <p>Fail test immediately with the given message.</p> Source code in <code>src/robot/utils/asserts.py</code> <pre><code>def fail(msg=None):\n    \"\"\"Fail test immediately with the given message.\"\"\"\n    _report_failure(msg)\n</code></pre>"},{"location":"api/robot/utils/asserts/#robot.utils.asserts.assert_false","title":"assert_false","text":"<pre><code>assert_false(expr, msg=None)\n</code></pre> <p>Fail the test if the expression is True.</p> Source code in <code>src/robot/utils/asserts.py</code> <pre><code>def assert_false(expr, msg=None):\n    \"\"\"Fail the test if the expression is True.\"\"\"\n    if expr:\n        _report_failure(msg)\n</code></pre>"},{"location":"api/robot/utils/asserts/#robot.utils.asserts.assert_true","title":"assert_true","text":"<pre><code>assert_true(expr, msg=None)\n</code></pre> <p>Fail the test unless the expression is True.</p> Source code in <code>src/robot/utils/asserts.py</code> <pre><code>def assert_true(expr, msg=None):\n    \"\"\"Fail the test unless the expression is True.\"\"\"\n    if not expr:\n        _report_failure(msg)\n</code></pre>"},{"location":"api/robot/utils/asserts/#robot.utils.asserts.assert_not_none","title":"assert_not_none","text":"<pre><code>assert_not_none(obj, msg=None, values=True)\n</code></pre> <p>Fail the test if given object is None.</p> Source code in <code>src/robot/utils/asserts.py</code> <pre><code>def assert_not_none(obj, msg=None, values=True):\n    \"\"\"Fail the test if given object is None.\"\"\"\n    _msg = 'is None'\n    if obj is None:\n        if msg is None:\n            msg = _msg\n        elif values is True:\n            msg = '%s: %s' % (msg, _msg)\n        _report_failure(msg)\n</code></pre>"},{"location":"api/robot/utils/asserts/#robot.utils.asserts.assert_none","title":"assert_none","text":"<pre><code>assert_none(obj, msg=None, values=True)\n</code></pre> <p>Fail the test if given object is not None.</p> Source code in <code>src/robot/utils/asserts.py</code> <pre><code>def assert_none(obj, msg=None, values=True):\n    \"\"\"Fail the test if given object is not None.\"\"\"\n    _msg = '%r is not None' % obj\n    if obj is not None:\n        if msg is None:\n            msg = _msg\n        elif values is True:\n            msg = '%s: %s' % (msg, _msg)\n        _report_failure(msg)\n</code></pre>"},{"location":"api/robot/utils/asserts/#robot.utils.asserts.assert_raises","title":"assert_raises","text":"<pre><code>assert_raises(exc_class, callable_obj, *args, **kwargs)\n</code></pre> <p>Fail unless an exception of class exc_class is thrown by callable_obj.</p> <p>callable_obj is invoked with arguments args and keyword arguments kwargs. If a different type of exception is thrown, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.</p> <p>If a correct exception is raised, the exception instance is returned by this method.</p> Source code in <code>src/robot/utils/asserts.py</code> <pre><code>def assert_raises(exc_class, callable_obj, *args, **kwargs):\n    \"\"\"Fail unless an exception of class exc_class is thrown by callable_obj.\n\n    callable_obj is invoked with arguments args and keyword arguments\n    kwargs. If a different type of exception is thrown, it will not be\n    caught, and the test case will be deemed to have suffered an\n    error, exactly as for an unexpected exception.\n\n    If a correct exception is raised, the exception instance is returned\n    by this method.\n    \"\"\"\n    try:\n        callable_obj(*args, **kwargs)\n    except exc_class as err:\n        return err\n    else:\n        if hasattr(exc_class,'__name__'):\n            exc_name = exc_class.__name__\n        else:\n            exc_name = str(exc_class)\n        _report_failure('%s not raised' % exc_name)\n</code></pre>"},{"location":"api/robot/utils/asserts/#robot.utils.asserts.assert_raises_with_msg","title":"assert_raises_with_msg","text":"<pre><code>assert_raises_with_msg(\n    exc_class, expected_msg, callable_obj, *args, **kwargs\n)\n</code></pre> <p>Similar to fail_unless_raises but also checks the exception message.</p> Source code in <code>src/robot/utils/asserts.py</code> <pre><code>def assert_raises_with_msg(exc_class, expected_msg, callable_obj, *args,\n                           **kwargs):\n    \"\"\"Similar to fail_unless_raises but also checks the exception message.\"\"\"\n    try:\n        callable_obj(*args, **kwargs)\n    except exc_class as err:\n        assert_equal(expected_msg, str(err), 'Correct exception but wrong message')\n    else:\n        if hasattr(exc_class,'__name__'):\n            exc_name = exc_class.__name__\n        else:\n            exc_name = str(exc_class)\n        _report_failure('%s not raised' % exc_name)\n</code></pre>"},{"location":"api/robot/utils/asserts/#robot.utils.asserts.assert_equal","title":"assert_equal","text":"<pre><code>assert_equal(\n    first, second, msg=None, values=True, formatter=safe_str\n)\n</code></pre> <p>Fail if given objects are unequal as determined by the '==' operator.</p> Source code in <code>src/robot/utils/asserts.py</code> <pre><code>def assert_equal(first, second, msg=None, values=True, formatter=safe_str):\n    \"\"\"Fail if given objects are unequal as determined by the '==' operator.\"\"\"\n    if not first == second:\n        _report_inequality(first, second, '!=', msg, values, formatter)\n</code></pre>"},{"location":"api/robot/utils/asserts/#robot.utils.asserts.assert_not_equal","title":"assert_not_equal","text":"<pre><code>assert_not_equal(\n    first, second, msg=None, values=True, formatter=safe_str\n)\n</code></pre> <p>Fail if given objects are equal as determined by the '==' operator.</p> Source code in <code>src/robot/utils/asserts.py</code> <pre><code>def assert_not_equal(first, second, msg=None, values=True, formatter=safe_str):\n    \"\"\"Fail if given objects are equal as determined by the '==' operator.\"\"\"\n    if first == second:\n        _report_inequality(first, second, '==', msg, values, formatter)\n</code></pre>"},{"location":"api/robot/utils/asserts/#robot.utils.asserts.assert_almost_equal","title":"assert_almost_equal","text":"<pre><code>assert_almost_equal(\n    first, second, places=7, msg=None, values=True\n)\n</code></pre> <p>Fail if the two objects are unequal after rounded to given places.</p> <p>inequality is determined by object's difference rounded to the given number of decimal places (default 7) and comparing to zero. Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit).</p> Source code in <code>src/robot/utils/asserts.py</code> <pre><code>def assert_almost_equal(first, second, places=7, msg=None, values=True):\n    \"\"\"Fail if the two objects are unequal after rounded to given places.\n\n    inequality is determined by object's difference rounded to the\n    given number of decimal places (default 7) and comparing to zero.\n    Note that decimal places (from zero) are usually not the same as\n    significant digits (measured from the most significant digit).\n    \"\"\"\n    if round(second - first, places) != 0:\n        extra = 'within %r places' % places\n        _report_inequality(first, second, '!=', msg, values, extra=extra)\n</code></pre>"},{"location":"api/robot/utils/asserts/#robot.utils.asserts.assert_not_almost_equal","title":"assert_not_almost_equal","text":"<pre><code>assert_not_almost_equal(\n    first, second, places=7, msg=None, values=True\n)\n</code></pre> <p>Fail if the two objects are unequal after rounded to given places.</p> <p>Equality is determined by object's difference rounded to to the given number of decimal places (default 7) and comparing to zero. Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit).</p> Source code in <code>src/robot/utils/asserts.py</code> <pre><code>def assert_not_almost_equal(first, second, places=7, msg=None, values=True):\n    \"\"\"Fail if the two objects are unequal after rounded to given places.\n\n    Equality is determined by object's difference rounded to to the\n    given number of decimal places (default 7) and comparing to zero.\n    Note that decimal places (from zero) are usually not the same as\n    significant digits (measured from the most significant digit).\n    \"\"\"\n    if round(second-first, places) == 0:\n        extra = 'within %r places' % places\n        _report_inequality(first, second, '==', msg, values, extra=extra)\n</code></pre>"},{"location":"api/robot/utils/charwidth/","title":"robot.utils.charwidth","text":""},{"location":"api/robot/utils/charwidth/#robot.utils.charwidth","title":"robot.utils.charwidth","text":"<p>A module to handle different character widths on the console.</p> <p>Some East Asian characters have width of two on console, and combining characters themselves take no extra space.</p> <p>See issue 604 [1] for more details about East Asian characters. The issue also contains <code>generate_wild_chars.py</code> script that was originally used to create <code>_EAST_ASIAN_WILD_CHARS</code> mapping. An updated version of the script is attached to issue 1096. Big thanks for xieyanbo for the script and the original patch.</p> <p>Python's <code>unicodedata</code> module was not used here because importing it took several seconds on Jython. That could possibly be changed now.</p> <p>[1] #604 [2] #1096</p>"},{"location":"api/robot/utils/compress/","title":"robot.utils.compress","text":""},{"location":"api/robot/utils/compress/#robot.utils.compress","title":"robot.utils.compress","text":""},{"location":"api/robot/utils/connectioncache/","title":"robot.utils.connectioncache","text":""},{"location":"api/robot/utils/connectioncache/#robot.utils.connectioncache","title":"robot.utils.connectioncache","text":""},{"location":"api/robot/utils/connectioncache/#robot.utils.connectioncache.ConnectionCache","title":"ConnectionCache","text":"<pre><code>ConnectionCache(no_current_msg='No open connection.')\n</code></pre> <p>Cache for libraries to use with concurrent connections, processes, etc.</p> <p>The cache stores the registered connections (or other objects) and allows switching between them using generated indices, user given aliases or connection objects themselves. This is useful with any library having a need for multiple concurrent connections, processes, etc.</p> <p>This class is used also outside the core framework by SeleniumLibrary, SSHLibrary, etc. Backwards compatibility is thus important when doing changes.</p> Source code in <code>src/robot/utils/connectioncache.py</code> <pre><code>def __init__(self, no_current_msg='No open connection.'):\n    self._no_current = NoConnection(no_current_msg)\n    self.current = self._no_current  #: Current active connection.\n    self._connections = []\n    self._aliases = NormalizedDict[int]()\n</code></pre>"},{"location":"api/robot/utils/connectioncache/#robot.utils.connectioncache.ConnectionCache.register","title":"register","text":"<pre><code>register(connection: Connection, alias: str | None = None)\n</code></pre> <p>Registers given connection with optional alias and returns its index.</p> <p>Given connection is set to be the :attr:<code>current</code> connection.</p> <p>If alias is given, it must be a string. Aliases are case and space insensitive.</p> <p>The index of the first connection after initialization, and after :meth:<code>close_all</code> or :meth:<code>empty_cache</code>, is 1, second is 2, etc.</p> Source code in <code>src/robot/utils/connectioncache.py</code> <pre><code>def register(self, connection: Connection, alias: 'str|None' = None):\n    \"\"\"Registers given connection with optional alias and returns its index.\n\n    Given connection is set to be the :attr:`current` connection.\n\n    If alias is given, it must be a string. Aliases are case and space\n    insensitive.\n\n    The index of the first connection after initialization, and after\n    :meth:`close_all` or :meth:`empty_cache`, is 1, second is 2, etc.\n    \"\"\"\n    self.current = connection\n    self._connections.append(connection)\n    index = len(self._connections)\n    if alias:\n        self._aliases[alias] = index\n    return index\n</code></pre>"},{"location":"api/robot/utils/connectioncache/#robot.utils.connectioncache.ConnectionCache.switch","title":"switch","text":"<pre><code>switch(identifier: int | str | Connection) -&gt; Connection\n</code></pre> <p>Switches to the connection specified using the <code>identifier</code>.</p> <p>Identifier can be an index, an alias, or a registered connection. Raises an error if no matching connection is found.</p> <p>Updates :attr:<code>current</code> and also returns its new value.</p> Source code in <code>src/robot/utils/connectioncache.py</code> <pre><code>def switch(self, identifier: 'int|str|Connection') -&gt; Connection:\n    \"\"\"Switches to the connection specified using the ``identifier``.\n\n    Identifier can be an index, an alias, or a registered connection.\n    Raises an error if no matching connection is found.\n\n    Updates :attr:`current` and also returns its new value.\n    \"\"\"\n    self.current = self.get_connection(identifier)\n    return self.current\n</code></pre>"},{"location":"api/robot/utils/connectioncache/#robot.utils.connectioncache.ConnectionCache.get_connection","title":"get_connection","text":"<pre><code>get_connection(\n    identifier: int | str | Connection | None = None,\n) -&gt; Connection\n</code></pre> <p>Returns the connection specified using the <code>identifier</code>.</p> <p>Identifier can be an index (integer or string), an alias, a registered connection or <code>None</code>. If the identifier is <code>None</code>, returns the current connection if it is active and raises an error if it is not. Raises an error also if no matching connection is found.</p> Source code in <code>src/robot/utils/connectioncache.py</code> <pre><code>def get_connection(self, identifier: 'int|str|Connection|None' = None) -&gt; Connection:\n    \"\"\"Returns the connection specified using the ``identifier``.\n\n    Identifier can be an index (integer or string), an alias, a registered\n    connection or ``None``. If the identifier is ``None``, returns the\n    current connection if it is active and raises an error if it is not.\n    Raises an error also if no matching connection is found.\n    \"\"\"\n    if identifier is None:\n        if not self:\n            self.current.raise_error()\n        return self.current\n    try:\n        index = self.get_connection_index(identifier)\n    except ValueError as err:\n        raise RuntimeError(err.args[0])\n    return self._connections[index-1]\n</code></pre>"},{"location":"api/robot/utils/connectioncache/#robot.utils.connectioncache.ConnectionCache.get_connection_index","title":"get_connection_index","text":"<pre><code>get_connection_index(\n    identifier: int | str | Connection,\n) -&gt; int\n</code></pre> <p>Returns the index of the connection specified using the <code>identifier</code>.</p> <p>Identifier can be an index (integer or string), an alias, or a registered connection.</p> <p>New in Robot Framework 7.0. :meth:<code>resolve_alias_or_index</code> can be used with earlier versions.</p> Source code in <code>src/robot/utils/connectioncache.py</code> <pre><code>def get_connection_index(self, identifier: 'int|str|Connection') -&gt; int:\n    \"\"\"Returns the index of the connection specified using the ``identifier``.\n\n    Identifier can be an index (integer or string), an alias, or a registered\n    connection.\n\n    New in Robot Framework 7.0. :meth:`resolve_alias_or_index` can be used\n    with earlier versions.\n    \"\"\"\n    if isinstance(identifier, str) and identifier in self._aliases:\n        return self._aliases[identifier]\n    if identifier in self._connections:\n        return self._connections.index(identifier) + 1\n    try:\n        index = int(identifier)\n    except (ValueError, TypeError):\n        index = -1\n    if 0 &lt; index &lt;= len(self._connections):\n        return index\n    raise ValueError(f\"Non-existing index or alias '{identifier}'.\")\n</code></pre>"},{"location":"api/robot/utils/connectioncache/#robot.utils.connectioncache.ConnectionCache.resolve_alias_or_index","title":"resolve_alias_or_index","text":"<pre><code>resolve_alias_or_index(alias_or_index)\n</code></pre> <p>Deprecated in RF 7.0. Use :meth:<code>get_connection_index</code> instead.</p> Source code in <code>src/robot/utils/connectioncache.py</code> <pre><code>def resolve_alias_or_index(self, alias_or_index):\n    \"\"\"Deprecated in RF 7.0. Use :meth:`get_connection_index` instead.\"\"\"\n    # This was initially added for SeleniumLibrary in RF 3.1.2.\n    # https://github.com/robotframework/robotframework/issues/3125\n    # The new method was added in RF 7.0. We can loudly deprecate this\n    # earliest in RF 8.0.\n    return self.get_connection_index(alias_or_index)\n</code></pre>"},{"location":"api/robot/utils/connectioncache/#robot.utils.connectioncache.ConnectionCache.close_all","title":"close_all","text":"<pre><code>close_all(closer_method: str = 'close')\n</code></pre> <p>Closes connections using the specified closer method and empties cache.</p> <p>If simply calling the closer method is not adequate for closing connections, clients should close connections themselves and use :meth:<code>empty_cache</code> afterward.</p> Source code in <code>src/robot/utils/connectioncache.py</code> <pre><code>def close_all(self, closer_method: str = 'close'):\n    \"\"\"Closes connections using the specified closer method and empties cache.\n\n    If simply calling the closer method is not adequate for closing\n    connections, clients should close connections themselves and use\n    :meth:`empty_cache` afterward.\n    \"\"\"\n    for conn in self._connections:\n        getattr(conn, closer_method)()\n    self.empty_cache()\n    return self.current\n</code></pre>"},{"location":"api/robot/utils/connectioncache/#robot.utils.connectioncache.ConnectionCache.empty_cache","title":"empty_cache","text":"<pre><code>empty_cache()\n</code></pre> <p>Empties the connection cache.</p> <p>Indexes of the new connections starts from 1 after this.</p> Source code in <code>src/robot/utils/connectioncache.py</code> <pre><code>def empty_cache(self):\n    \"\"\"Empties the connection cache.\n\n    Indexes of the new connections starts from 1 after this.\n    \"\"\"\n    self.current = self._no_current\n    self._connections = []\n    self._aliases = NormalizedDict()\n</code></pre>"},{"location":"api/robot/utils/dotdict/","title":"robot.utils.dotdict","text":""},{"location":"api/robot/utils/dotdict/#robot.utils.dotdict","title":"robot.utils.dotdict","text":""},{"location":"api/robot/utils/encoding/","title":"robot.utils.encoding","text":""},{"location":"api/robot/utils/encoding/#robot.utils.encoding","title":"robot.utils.encoding","text":""},{"location":"api/robot/utils/encoding/#robot.utils.encoding.console_decode","title":"console_decode","text":"<pre><code>console_decode(string, encoding=CONSOLE_ENCODING)\n</code></pre> <p>Decodes bytes from console encoding to Unicode.</p> <p>Uses the system console encoding by default, but that can be configured using the <code>encoding</code> argument. In addition to the normal encodings, it is possible to use case-insensitive values <code>CONSOLE</code> and <code>SYSTEM</code> to use the system console and system encoding, respectively.</p> <p>If <code>string</code> is already Unicode, it is returned as-is.</p> Source code in <code>src/robot/utils/encoding.py</code> <pre><code>def console_decode(string, encoding=CONSOLE_ENCODING):\n    \"\"\"Decodes bytes from console encoding to Unicode.\n\n    Uses the system console encoding by default, but that can be configured\n    using the `encoding` argument. In addition to the normal encodings,\n    it is possible to use case-insensitive values `CONSOLE` and `SYSTEM` to\n    use the system console and system encoding, respectively.\n\n    If `string` is already Unicode, it is returned as-is.\n    \"\"\"\n    if is_string(string):\n        return string\n    encoding = {'CONSOLE': CONSOLE_ENCODING,\n                'SYSTEM': SYSTEM_ENCODING}.get(encoding.upper(), encoding)\n    try:\n        return string.decode(encoding)\n    except UnicodeError:\n        return safe_str(string)\n</code></pre>"},{"location":"api/robot/utils/encoding/#robot.utils.encoding.console_encode","title":"console_encode","text":"<pre><code>console_encode(\n    string,\n    encoding=None,\n    errors=\"replace\",\n    stream=__stdout__,\n    force=False,\n)\n</code></pre> <p>Encodes the given string so that it can be used in the console.</p> <p>If encoding is not given, determines it based on the given stream and system configuration. In addition to the normal encodings, it is possible to use case-insensitive values <code>CONSOLE</code> and <code>SYSTEM</code> to use the system console and system encoding, respectively.</p> <p>Decodes bytes back to Unicode by default, because Python 3 APIs in general work with strings. Use <code>force=True</code> if that is not desired.</p> Source code in <code>src/robot/utils/encoding.py</code> <pre><code>def console_encode(string, encoding=None, errors='replace', stream=sys.__stdout__,\n                   force=False):\n    \"\"\"Encodes the given string so that it can be used in the console.\n\n    If encoding is not given, determines it based on the given stream and system\n    configuration. In addition to the normal encodings, it is possible to use\n    case-insensitive values `CONSOLE` and `SYSTEM` to use the system console\n    and system encoding, respectively.\n\n    Decodes bytes back to Unicode by default, because Python 3 APIs in general\n    work with strings. Use `force=True` if that is not desired.\n    \"\"\"\n    if not is_string(string):\n        string = safe_str(string)\n    if encoding:\n        encoding = {'CONSOLE': CONSOLE_ENCODING,\n                    'SYSTEM': SYSTEM_ENCODING}.get(encoding.upper(), encoding)\n    else:\n        encoding = _get_console_encoding(stream)\n    if encoding.upper() != 'UTF-8':\n        encoded = string.encode(encoding, errors)\n        return encoded if force else encoded.decode(encoding)\n    return string.encode(encoding, errors) if force else string\n</code></pre>"},{"location":"api/robot/utils/encodingsniffer/","title":"robot.utils.encodingsniffer","text":""},{"location":"api/robot/utils/encodingsniffer/#robot.utils.encodingsniffer","title":"robot.utils.encodingsniffer","text":""},{"location":"api/robot/utils/error/","title":"robot.utils.error","text":""},{"location":"api/robot/utils/error/#robot.utils.error","title":"robot.utils.error","text":""},{"location":"api/robot/utils/error/#robot.utils.error.get_error_message","title":"get_error_message","text":"<pre><code>get_error_message()\n</code></pre> <p>Returns error message of the last occurred exception.</p> <p>This method handles also exceptions containing unicode messages. Thus it MUST be used to get messages from all exceptions originating outside the framework.</p> Source code in <code>src/robot/utils/error.py</code> <pre><code>def get_error_message():\n    \"\"\"Returns error message of the last occurred exception.\n\n    This method handles also exceptions containing unicode messages. Thus it\n    MUST be used to get messages from all exceptions originating outside the\n    framework.\n    \"\"\"\n    return ErrorDetails().message\n</code></pre>"},{"location":"api/robot/utils/error/#robot.utils.error.get_error_details","title":"get_error_details","text":"<pre><code>get_error_details(\n    full_traceback=True,\n    exclude_robot_traces=EXCLUDE_ROBOT_TRACES,\n)\n</code></pre> <p>Returns error message and details of the last occurred exception.</p> Source code in <code>src/robot/utils/error.py</code> <pre><code>def get_error_details(full_traceback=True, exclude_robot_traces=EXCLUDE_ROBOT_TRACES):\n    \"\"\"Returns error message and details of the last occurred exception.\"\"\"\n    details = ErrorDetails(full_traceback=full_traceback,\n                           exclude_robot_traces=exclude_robot_traces)\n    return details.message, details.traceback\n</code></pre>"},{"location":"api/robot/utils/error/#robot.utils.error.ErrorDetails","title":"ErrorDetails","text":"<pre><code>ErrorDetails(\n    error=None,\n    full_traceback=True,\n    exclude_robot_traces=EXCLUDE_ROBOT_TRACES,\n)\n</code></pre> <p>Object wrapping the last occurred exception.</p> <p>It has attributes <code>message</code>, <code>traceback</code>, and <code>error</code>, where <code>message</code> contains the message with possible generic exception name removed, <code>traceback</code> contains the traceback and <code>error</code> contains the original error instance.</p> Source code in <code>src/robot/utils/error.py</code> <pre><code>def __init__(self, error=None, full_traceback=True,\n             exclude_robot_traces=EXCLUDE_ROBOT_TRACES):\n    if not error:\n        error = sys.exc_info()[1]\n    if isinstance(error, RERAISED_EXCEPTIONS):\n        raise error\n    self.error = error\n    self._full_traceback = full_traceback\n    self._exclude_robot_traces = exclude_robot_traces\n    self._message = None\n    self._traceback = None\n</code></pre>"},{"location":"api/robot/utils/escaping/","title":"robot.utils.escaping","text":""},{"location":"api/robot/utils/escaping/#robot.utils.escaping","title":"robot.utils.escaping","text":""},{"location":"api/robot/utils/etreewrapper/","title":"robot.utils.etreewrapper","text":""},{"location":"api/robot/utils/etreewrapper/#robot.utils.etreewrapper","title":"robot.utils.etreewrapper","text":""},{"location":"api/robot/utils/filereader/","title":"robot.utils.filereader","text":""},{"location":"api/robot/utils/filereader/#robot.utils.filereader","title":"robot.utils.filereader","text":""},{"location":"api/robot/utils/filereader/#robot.utils.filereader.FileReader","title":"FileReader","text":"<pre><code>FileReader(source: Source, accept_text: bool = False)\n</code></pre> <p>Utility to ease reading different kind of source files.</p> <p>Supports different sources where to read the data:</p> <ul> <li> <p>The source can be a path to a file, either as a string or as a   <code>pathlib.Path</code> instance. The file itself must be UTF-8 encoded.</p> </li> <li> <p>Alternatively the source can be an already opened file object,   including a StringIO or BytesIO object. The file can contain either   Unicode text or UTF-8 encoded bytes.</p> </li> <li> <p>The third options is giving the source as Unicode text directly.   This requires setting <code>accept_text=True</code> when creating the reader.</p> </li> </ul> <p>In all cases bytes are automatically decoded to Unicode and possible BOM removed.</p> Source code in <code>src/robot/utils/filereader.py</code> <pre><code>def __init__(self, source: Source, accept_text: bool = False):\n    self.file, self._opened = self._get_file(source, accept_text)\n</code></pre>"},{"location":"api/robot/utils/frange/","title":"robot.utils.frange","text":""},{"location":"api/robot/utils/frange/#robot.utils.frange","title":"robot.utils.frange","text":""},{"location":"api/robot/utils/frange/#robot.utils.frange.frange","title":"frange","text":"<pre><code>frange(*args)\n</code></pre> <p>Like <code>range()</code> but accepts float arguments.</p> Source code in <code>src/robot/utils/frange.py</code> <pre><code>def frange(*args):\n    \"\"\"Like ``range()`` but accepts float arguments.\"\"\"\n    if all(is_integer(arg) for arg in args):\n        return list(range(*args))\n    start, stop, step = _get_start_stop_step(args)\n    digits = max(_digits(start), _digits(stop), _digits(step))\n    factor = pow(10, digits)\n    return [x / factor\n            for x in range(round(start*factor), round(stop*factor), round(step*factor))]\n</code></pre>"},{"location":"api/robot/utils/htmlformatters/","title":"robot.utils.htmlformatters","text":""},{"location":"api/robot/utils/htmlformatters/#robot.utils.htmlformatters","title":"robot.utils.htmlformatters","text":""},{"location":"api/robot/utils/importer/","title":"robot.utils.importer","text":""},{"location":"api/robot/utils/importer/#robot.utils.importer","title":"robot.utils.importer","text":""},{"location":"api/robot/utils/importer/#robot.utils.importer.Importer","title":"Importer","text":"<pre><code>Importer(type=None, logger=None)\n</code></pre> <p>Utility that can import modules and classes based on names and paths.</p> <p>Imported classes can optionally be instantiated automatically.</p> <p>:param type:     Type of the thing being imported. Used in error and log messages. :param logger:     Logger to be notified about successful imports and other events.     Currently only needs the <code>info</code> method, but other level specific     methods may be needed in the future. If not given, logging is disabled.</p> Source code in <code>src/robot/utils/importer.py</code> <pre><code>def __init__(self, type=None, logger=None):\n    \"\"\"\n    :param type:\n        Type of the thing being imported. Used in error and log messages.\n    :param logger:\n        Logger to be notified about successful imports and other events.\n        Currently only needs the ``info`` method, but other level specific\n        methods may be needed in the future. If not given, logging is disabled.\n    \"\"\"\n    self._type = type or ''\n    self._logger = logger or NoLogger()\n    library_import = type and type.upper() == 'LIBRARY'\n    self._importers = (ByPathImporter(logger, library_import),\n                       NonDottedImporter(logger, library_import),\n                       DottedImporter(logger, library_import))\n    self._by_path_importer = self._importers[0]\n</code></pre>"},{"location":"api/robot/utils/importer/#robot.utils.importer.Importer.import_class_or_module","title":"import_class_or_module","text":"<pre><code>import_class_or_module(\n    name_or_path,\n    instantiate_with_args=None,\n    return_source=False,\n)\n</code></pre> <p>Imports Python class or module based on the given name or path.</p> <p>:param name_or_path:     Name or path of the module or class to import. :param instantiate_with_args:     When arguments are given, imported classes are automatically initialized     using them. :param return_source:     When true, returns a tuple containing the imported module or class     and a path to it. By default, returns only the imported module or class.</p> <p>The class or module to import can be specified either as a name, in which case it must be in the module search path, or as a path to the file or directory implementing the module. See :meth:<code>import_class_or_module_by_path</code> for more information about importing classes and modules by path.</p> <p>Classes can be imported from the module search path using name like <code>modulename.ClassName</code>. If the class name and module name are same, using just <code>CommonName</code> is enough. When importing a class by a path, the class name and the module name must match.</p> <p>Optional arguments to use when creating an instance are given as a list. Starting from Robot Framework 4.0, both positional and named arguments are supported (e.g. <code>['positional', 'name=value']</code>) and arguments are converted automatically based on type hints and default values.</p> <p>If arguments needed when creating an instance are initially embedded into the name or path like <code>Example:arg1:arg2</code>, separate :func:<code>~robot.utils.text.split_args_from_name_or_path</code> function can be used to split them before calling this method.</p> <p>Use :meth:<code>import_module</code> if only a module needs to be imported.</p> Source code in <code>src/robot/utils/importer.py</code> <pre><code>def import_class_or_module(self, name_or_path, instantiate_with_args=None,\n                           return_source=False):\n    \"\"\"Imports Python class or module based on the given name or path.\n\n    :param name_or_path:\n        Name or path of the module or class to import.\n    :param instantiate_with_args:\n        When arguments are given, imported classes are automatically initialized\n        using them.\n    :param return_source:\n        When true, returns a tuple containing the imported module or class\n        and a path to it. By default, returns only the imported module or class.\n\n    The class or module to import can be specified either as a name, in which\n    case it must be in the module search path, or as a path to the file or\n    directory implementing the module. See :meth:`import_class_or_module_by_path`\n    for more information about importing classes and modules by path.\n\n    Classes can be imported from the module search path using name like\n    ``modulename.ClassName``. If the class name and module name are same, using\n    just ``CommonName`` is enough. When importing a class by a path, the class\n    name and the module name must match.\n\n    Optional arguments to use when creating an instance are given as a list.\n    Starting from Robot Framework 4.0, both positional and named arguments are\n    supported (e.g. ``['positional', 'name=value']``) and arguments are converted\n    automatically based on type hints and default values.\n\n    If arguments needed when creating an instance are initially embedded into\n    the name or path like ``Example:arg1:arg2``, separate\n    :func:`~robot.utils.text.split_args_from_name_or_path` function can be\n    used to split them before calling this method.\n\n    Use :meth:`import_module` if only a module needs to be imported.\n    \"\"\"\n    try:\n        imported, source = self._import(name_or_path)\n        self._log_import_succeeded(imported, name_or_path, source)\n        imported = self._instantiate_if_needed(imported, instantiate_with_args)\n    except DataError as err:\n        self._raise_import_failed(name_or_path, err)\n    else:\n        return self._handle_return_values(imported, source, return_source)\n</code></pre>"},{"location":"api/robot/utils/importer/#robot.utils.importer.Importer.import_module","title":"import_module","text":"<pre><code>import_module(name_or_path)\n</code></pre> <p>Imports Python module based on the given name or path.</p> <p>:param name_or_path:     Name or path of the module to import.</p> <p>The module to import can be specified either as a name, in which case it must be in the module search path, or as a path to the file or directory implementing the module. See :meth:<code>import_class_or_module_by_path</code> for more information about importing modules by path.</p> <p>Use :meth:<code>import_class_or_module</code> if it is desired to get a class from the imported module automatically.</p> <p>New in Robot Framework 6.0.</p> Source code in <code>src/robot/utils/importer.py</code> <pre><code>def import_module(self, name_or_path):\n    \"\"\"Imports Python module based on the given name or path.\n\n    :param name_or_path:\n        Name or path of the module to import.\n\n    The module to import can be specified either as a name, in which\n    case it must be in the module search path, or as a path to the file or\n    directory implementing the module. See :meth:`import_class_or_module_by_path`\n    for more information about importing modules by path.\n\n    Use :meth:`import_class_or_module` if it is desired to get a class\n    from the imported module automatically.\n\n    New in Robot Framework 6.0.\n    \"\"\"\n    try:\n        imported, source = self._import(name_or_path, get_class=False)\n        self._log_import_succeeded(imported, name_or_path, source)\n    except DataError as err:\n        self._raise_import_failed(name_or_path, err)\n    else:\n        return imported\n</code></pre>"},{"location":"api/robot/utils/importer/#robot.utils.importer.Importer.import_class_or_module_by_path","title":"import_class_or_module_by_path","text":"<pre><code>import_class_or_module_by_path(\n    path, instantiate_with_args=None\n)\n</code></pre> <p>Import a Python module or class using a file system path.</p> <p>:param path:     Path to the module or class to import. :param instantiate_with_args:     When arguments are given, imported classes are automatically initialized     using them.</p> <p>When importing a Python file, the path must end with :file:<code>.py</code> and the actual file must also exist.</p> <p>Use :meth:<code>import_class_or_module</code> to support importing also using name, not only path. See the documentation of that function for more information about creating instances automatically.</p> Source code in <code>src/robot/utils/importer.py</code> <pre><code>def import_class_or_module_by_path(self, path, instantiate_with_args=None):\n    \"\"\"Import a Python module or class using a file system path.\n\n    :param path:\n        Path to the module or class to import.\n    :param instantiate_with_args:\n        When arguments are given, imported classes are automatically initialized\n        using them.\n\n    When importing a Python file, the path must end with :file:`.py` and the\n    actual file must also exist.\n\n    Use :meth:`import_class_or_module` to support importing also using name,\n    not only path. See the documentation of that function for more information\n    about creating instances automatically.\n    \"\"\"\n    try:\n        imported, source = self._by_path_importer.import_(path)\n        self._log_import_succeeded(imported, imported.__name__, source)\n        return self._instantiate_if_needed(imported, instantiate_with_args)\n    except DataError as err:\n        self._raise_import_failed(path, err)\n</code></pre>"},{"location":"api/robot/utils/markuputils/","title":"robot.utils.markuputils","text":""},{"location":"api/robot/utils/markuputils/#robot.utils.markuputils","title":"robot.utils.markuputils","text":""},{"location":"api/robot/utils/markupwriters/","title":"robot.utils.markupwriters","text":""},{"location":"api/robot/utils/markupwriters/#robot.utils.markupwriters","title":"robot.utils.markupwriters","text":""},{"location":"api/robot/utils/markupwriters/#robot.utils.markupwriters.NullMarkupWriter","title":"NullMarkupWriter","text":"<pre><code>NullMarkupWriter()\n</code></pre> <p>Null implementation of the _MarkupWriter interface.</p> Source code in <code>src/robot/utils/markupwriters.py</code> <pre><code>__init__ = start = content = element = end = close = lambda *args, **kwargs: None\n</code></pre>"},{"location":"api/robot/utils/match/","title":"robot.utils.match","text":""},{"location":"api/robot/utils/match/#robot.utils.match","title":"robot.utils.match","text":""},{"location":"api/robot/utils/misc/","title":"robot.utils.misc","text":""},{"location":"api/robot/utils/misc/#robot.utils.misc","title":"robot.utils.misc","text":""},{"location":"api/robot/utils/misc/#robot.utils.misc.printable_name","title":"printable_name","text":"<pre><code>printable_name(string, code_style=False)\n</code></pre> <p>Generates and returns printable name from the given string.</p> <p>Examples: 'simple'           -&gt; 'Simple' 'name with spaces' -&gt; 'Name With Spaces' 'more   spaces'    -&gt; 'More Spaces' 'Cases AND spaces' -&gt; 'Cases AND Spaces' ''                 -&gt; ''</p> <p>If 'code_style' is True:</p> <p>'mixedCAPSCamel'   -&gt; 'Mixed CAPS Camel' 'camelCaseName'    -&gt; 'Camel Case Name' 'under_score_name' -&gt; 'Under Score Name' 'under_and space'  -&gt; 'Under And Space' 'miXed_CAPS_nAMe'  -&gt; 'MiXed CAPS NAMe' ''                 -&gt; ''</p> Source code in <code>src/robot/utils/misc.py</code> <pre><code>def printable_name(string, code_style=False):\n    \"\"\"Generates and returns printable name from the given string.\n\n    Examples:\n    'simple'           -&gt; 'Simple'\n    'name with spaces' -&gt; 'Name With Spaces'\n    'more   spaces'    -&gt; 'More Spaces'\n    'Cases AND spaces' -&gt; 'Cases AND Spaces'\n    ''                 -&gt; ''\n\n    If 'code_style' is True:\n\n    'mixedCAPSCamel'   -&gt; 'Mixed CAPS Camel'\n    'camelCaseName'    -&gt; 'Camel Case Name'\n    'under_score_name' -&gt; 'Under Score Name'\n    'under_and space'  -&gt; 'Under And Space'\n    'miXed_CAPS_nAMe'  -&gt; 'MiXed CAPS NAMe'\n    ''                 -&gt; ''\n    \"\"\"\n    if code_style and '_' in string:\n        string = string.replace('_', ' ')\n    parts = string.split()\n    if code_style and len(parts) == 1 \\\n            and not (string.isalpha() and string.islower()):\n        parts = _split_camel_case(parts[0])\n    return ' '.join(part[0].upper() + part[1:] for part in parts)\n</code></pre>"},{"location":"api/robot/utils/misc/#robot.utils.misc.seq2str","title":"seq2str","text":"<pre><code>seq2str(sequence, quote=\"'\", sep=', ', lastsep=' and ')\n</code></pre> <p>Returns sequence in format <code>'item 1', 'item 2' and 'item 3'</code>.</p> Source code in <code>src/robot/utils/misc.py</code> <pre><code>def seq2str(sequence, quote=\"'\", sep=', ', lastsep=' and '):\n    \"\"\"Returns sequence in format `'item 1', 'item 2' and 'item 3'`.\"\"\"\n    sequence = [f'{quote}{safe_str(item)}{quote}' for item in sequence]\n    if not sequence:\n        return ''\n    if len(sequence) == 1:\n        return sequence[0]\n    last_two = lastsep.join(sequence[-2:])\n    return sep.join(sequence[:-2] + [last_two])\n</code></pre>"},{"location":"api/robot/utils/misc/#robot.utils.misc.seq2str2","title":"seq2str2","text":"<pre><code>seq2str2(sequence)\n</code></pre> <p>Returns sequence in format <code>[ item 1 | item 2 | ... ]</code>.</p> Source code in <code>src/robot/utils/misc.py</code> <pre><code>def seq2str2(sequence):\n    \"\"\"Returns sequence in format `[ item 1 | item 2 | ... ]`.\"\"\"\n    if not sequence:\n        return '[ ]'\n    return '[ %s ]' % ' | '.join(safe_str(item) for item in sequence)\n</code></pre>"},{"location":"api/robot/utils/misc/#robot.utils.misc.test_or_task","title":"test_or_task","text":"<pre><code>test_or_task(text: str, rpa: bool)\n</code></pre> <p>Replace 'test' with 'task' in the given <code>text</code> depending on <code>rpa</code>.</p> <p>If given text is <code>test</code>, <code>test</code> or <code>task</code> is returned directly. Otherwise, pattern <code>{test}</code> is searched from the text and occurrences replaced with <code>test</code> or <code>task</code>.</p> <p>In both cases matching the word <code>test</code> is case-insensitive and the returned <code>test</code> or <code>task</code> has exactly same case as the original.</p> Source code in <code>src/robot/utils/misc.py</code> <pre><code>def test_or_task(text: str, rpa: bool):\n    \"\"\"Replace 'test' with 'task' in the given `text` depending on `rpa`.\n\n     If given text is `test`, `test` or `task` is returned directly. Otherwise,\n     pattern `{test}` is searched from the text and occurrences replaced with\n     `test` or `task`.\n\n     In both cases matching the word `test` is case-insensitive and the returned\n     `test` or `task` has exactly same case as the original.\n     \"\"\"\n    def replace(test):\n        if not rpa:\n            return test\n        upper = [c.isupper() for c in test]\n        return ''.join(c.upper() if up else c for c, up in zip('task', upper))\n    if text.upper() == 'TEST':\n        return replace(text)\n    return re.sub('{(test)}', lambda m: replace(m.group(1)), text, flags=re.IGNORECASE)\n</code></pre>"},{"location":"api/robot/utils/misc/#robot.utils.misc.classproperty","title":"classproperty","text":"<pre><code>classproperty(fget, fset=None, fdel=None, doc=None)\n</code></pre> <p>               Bases: <code>property</code></p> <p>Property that works with classes in addition to instances.</p> <p>Only supports getters. Setters and deleters cannot work with classes due to how the descriptor protocol works, and they are thus explicitly disabled. Metaclasses must be used if they are needed.</p> Source code in <code>src/robot/utils/misc.py</code> <pre><code>def __init__(self, fget, fset=None, fdel=None, doc=None):\n    if fset:\n        self.setter(fset)\n    if fdel:\n        self.deleter(fset)\n    super().__init__(fget)\n    if doc:\n        self.__doc__ = doc\n</code></pre>"},{"location":"api/robot/utils/normalizing/","title":"robot.utils.normalizing","text":""},{"location":"api/robot/utils/normalizing/#robot.utils.normalizing","title":"robot.utils.normalizing","text":""},{"location":"api/robot/utils/normalizing/#robot.utils.normalizing.normalize","title":"normalize","text":"<pre><code>normalize(\n    string: str,\n    ignore: Sequence[str] = (),\n    caseless: bool = True,\n    spaceless: bool = True,\n) -&gt; str\n</code></pre> <p>Normalize the <code>string</code> according to the given spec.</p> <p>By default, string is turned to lower case (actually case-folded) and all whitespace is removed. Additional characters can be removed by giving them in <code>ignore</code> list.</p> Source code in <code>src/robot/utils/normalizing.py</code> <pre><code>def normalize(string: str, ignore: 'Sequence[str]' = (), caseless: bool = True,\n              spaceless: bool = True) -&gt; str:\n    \"\"\"Normalize the ``string`` according to the given spec.\n\n    By default, string is turned to lower case (actually case-folded) and all\n    whitespace is removed. Additional characters can be removed by giving them\n    in ``ignore`` list.\n    \"\"\"\n    if spaceless:\n        string = ''.join(string.split())\n    if caseless:\n        string = string.casefold()\n        ignore = [i.casefold() for i in ignore]\n    # both if statements below enhance performance a little\n    if ignore:\n        for ign in ignore:\n            if ign in string:\n                string = string.replace(ign, '')\n    return string\n</code></pre>"},{"location":"api/robot/utils/normalizing/#robot.utils.normalizing.NormalizedDict","title":"NormalizedDict","text":"<pre><code>NormalizedDict(\n    initial: (\n        Mapping[str, V] | Iterable[tuple[str, V]] | None\n    ) = None,\n    ignore: Sequence[str] = (),\n    caseless: bool = True,\n    spaceless: bool = True,\n)\n</code></pre> <p>               Bases: <code>MutableMapping[str, V]</code></p> <p>Custom dictionary implementation automatically normalizing keys.</p> <p>Initialized with possible initial value and normalizing spec.</p> <p>Initial values can be either a dictionary or an iterable of name/value pairs.</p> <p>Normalizing spec has exact same semantics as with the :func:<code>normalize</code> function.</p> Source code in <code>src/robot/utils/normalizing.py</code> <pre><code>def __init__(self, initial: 'Mapping[str, V]|Iterable[tuple[str, V]]|None' = None,\n             ignore: 'Sequence[str]' = (), caseless: bool = True,\n             spaceless: bool = True):\n    \"\"\"Initialized with possible initial value and normalizing spec.\n\n    Initial values can be either a dictionary or an iterable of name/value\n    pairs.\n\n    Normalizing spec has exact same semantics as with the :func:`normalize`\n    function.\n    \"\"\"\n    self._data: 'dict[str, V]' = {}\n    self._keys: 'dict[str, str]' = {}\n    self._normalize = lambda s: normalize(s, ignore, caseless, spaceless)\n    if initial:\n        self.update(initial)\n</code></pre>"},{"location":"api/robot/utils/notset/","title":"robot.utils.notset","text":""},{"location":"api/robot/utils/notset/#robot.utils.notset","title":"robot.utils.notset","text":""},{"location":"api/robot/utils/notset/#robot.utils.notset.NotSet","title":"NotSet","text":"<p>Represents value that is not set.</p> <p>Can be used instead of the standard <code>None</code> in cases where <code>None</code> itself is a valid value.</p> <p><code>robot.utils.NOT_SET</code> is an instance of this class, but it in same cases it is better to create a separate instance.</p> <p>New in Robot Framework 7.0.</p>"},{"location":"api/robot/utils/platform/","title":"robot.utils.platform","text":""},{"location":"api/robot/utils/platform/#robot.utils.platform","title":"robot.utils.platform","text":""},{"location":"api/robot/utils/recommendations/","title":"robot.utils.recommendations","text":""},{"location":"api/robot/utils/recommendations/#robot.utils.recommendations","title":"robot.utils.recommendations","text":""},{"location":"api/robot/utils/recommendations/#robot.utils.recommendations.RecommendationFinder","title":"RecommendationFinder","text":"<pre><code>RecommendationFinder(normalizer=None)\n</code></pre> Source code in <code>src/robot/utils/recommendations.py</code> <pre><code>def __init__(self, normalizer=None):\n    self.normalizer = normalizer or (lambda x: x)\n</code></pre>"},{"location":"api/robot/utils/recommendations/#robot.utils.recommendations.RecommendationFinder.find","title":"find","text":"<pre><code>find(name, candidates, max_matches=10)\n</code></pre> <p>Return a list of close matches to <code>name</code> from <code>candidates</code>.</p> Source code in <code>src/robot/utils/recommendations.py</code> <pre><code>def find(self, name, candidates, max_matches=10):\n    \"\"\"Return a list of close matches to `name` from `candidates`.\"\"\"\n    if not name or not candidates:\n        return []\n    norm_name = self.normalizer(name)\n    norm_candidates = self._get_normalized_candidates(candidates)\n    cutoff = self._calculate_cutoff(norm_name)\n    norm_matches = difflib.get_close_matches(\n        norm_name, norm_candidates, n=max_matches, cutoff=cutoff\n    )\n    return self._get_original_candidates(norm_matches, norm_candidates)\n</code></pre>"},{"location":"api/robot/utils/recommendations/#robot.utils.recommendations.RecommendationFinder.format","title":"format","text":"<pre><code>format(message, recommendations)\n</code></pre> <p>Add recommendations to the given message.</p> <p>The recommendation string looks like::</p> <pre><code>&lt;message&gt; Did you mean:\n    &lt;recommendations[0]&gt;\n    &lt;recommendations[1]&gt;\n    &lt;recommendations[2]&gt;\n</code></pre> Source code in <code>src/robot/utils/recommendations.py</code> <pre><code>def format(self, message, recommendations):\n    \"\"\"Add recommendations to the given message.\n\n    The recommendation string looks like::\n\n        &lt;message&gt; Did you mean:\n            &lt;recommendations[0]&gt;\n            &lt;recommendations[1]&gt;\n            &lt;recommendations[2]&gt;\n    \"\"\"\n    if recommendations:\n        message += \" Did you mean:\"\n        for rec in recommendations:\n            message += \"\\n    %s\" % rec\n    return message\n</code></pre>"},{"location":"api/robot/utils/restreader/","title":"robot.utils.restreader","text":""},{"location":"api/robot/utils/restreader/#robot.utils.restreader","title":"robot.utils.restreader","text":""},{"location":"api/robot/utils/robotenv/","title":"robot.utils.robotenv","text":""},{"location":"api/robot/utils/robotenv/#robot.utils.robotenv","title":"robot.utils.robotenv","text":""},{"location":"api/robot/utils/robotinspect/","title":"robot.utils.robotinspect","text":""},{"location":"api/robot/utils/robotinspect/#robot.utils.robotinspect","title":"robot.utils.robotinspect","text":""},{"location":"api/robot/utils/robotio/","title":"robot.utils.robotio","text":""},{"location":"api/robot/utils/robotio/#robot.utils.robotio","title":"robot.utils.robotio","text":""},{"location":"api/robot/utils/robotpath/","title":"robot.utils.robotpath","text":""},{"location":"api/robot/utils/robotpath/#robot.utils.robotpath","title":"robot.utils.robotpath","text":""},{"location":"api/robot/utils/robotpath/#robot.utils.robotpath.normpath","title":"normpath","text":"<pre><code>normpath(path, case_normalize=False)\n</code></pre> <p>Replacement for os.path.normpath with some enhancements.</p> <ol> <li>Convert non-Unicode paths to Unicode using the file system encoding.</li> <li>NFC normalize Unicode paths (affects mainly OSX).</li> <li>Optionally lower-case paths on case-insensitive file systems.    That includes Windows and also OSX in default configuration.</li> <li>Turn <code>c:</code> into <code>c:\\</code> on Windows instead of keeping it as <code>c:</code>.</li> </ol> Source code in <code>src/robot/utils/robotpath.py</code> <pre><code>def normpath(path, case_normalize=False):\n    \"\"\"Replacement for os.path.normpath with some enhancements.\n\n    1. Convert non-Unicode paths to Unicode using the file system encoding.\n    2. NFC normalize Unicode paths (affects mainly OSX).\n    3. Optionally lower-case paths on case-insensitive file systems.\n       That includes Windows and also OSX in default configuration.\n    4. Turn ``c:`` into ``c:\\\\`` on Windows instead of keeping it as ``c:``.\n    \"\"\"\n    # FIXME: Support pathlib.Path\n    if not is_string(path):\n        path = system_decode(path)\n    path = safe_str(path)  # Handles NFC normalization on OSX\n    path = os.path.normpath(path)\n    if case_normalize and CASE_INSENSITIVE_FILESYSTEM:\n        path = path.lower()\n    if WINDOWS and len(path) == 2 and path[1] == ':':\n        return path + '\\\\'\n    return path\n</code></pre>"},{"location":"api/robot/utils/robotpath/#robot.utils.robotpath.abspath","title":"abspath","text":"<pre><code>abspath(path, case_normalize=False)\n</code></pre> <p>Replacement for os.path.abspath with some enhancements and bug fixes.</p> <ol> <li>Non-Unicode paths are converted to Unicode using file system encoding.</li> <li>Optionally lower-case paths on case-insensitive file systems.    That includes Windows and also OSX in default configuration.</li> <li>Turn <code>c:</code> into <code>c:\\</code> on Windows instead of <code>c:\\current\\path</code>.</li> </ol> Source code in <code>src/robot/utils/robotpath.py</code> <pre><code>def abspath(path, case_normalize=False):\n    \"\"\"Replacement for os.path.abspath with some enhancements and bug fixes.\n\n    1. Non-Unicode paths are converted to Unicode using file system encoding.\n    2. Optionally lower-case paths on case-insensitive file systems.\n       That includes Windows and also OSX in default configuration.\n    3. Turn ``c:`` into ``c:\\\\`` on Windows instead of ``c:\\\\current\\\\path``.\n    \"\"\"\n    path = normpath(path, case_normalize)\n    return normpath(os.path.abspath(path), case_normalize)\n</code></pre>"},{"location":"api/robot/utils/robotpath/#robot.utils.robotpath.get_link_path","title":"get_link_path","text":"<pre><code>get_link_path(target, base)\n</code></pre> <p>Returns a relative path to <code>target</code> from <code>base</code>.</p> <p>If <code>base</code> is an existing file, then its parent directory is considered to be the base. Otherwise <code>base</code> is assumed to be a directory.</p> <p>The returned path is URL encoded. On Windows returns an absolute path with <code>file:</code> prefix if the target is on a different drive.</p> Source code in <code>src/robot/utils/robotpath.py</code> <pre><code>def get_link_path(target, base):\n    \"\"\"Returns a relative path to ``target`` from ``base``.\n\n    If ``base`` is an existing file, then its parent directory is considered to\n    be the base. Otherwise ``base`` is assumed to be a directory.\n\n    The returned path is URL encoded. On Windows returns an absolute path with\n    ``file:`` prefix if the target is on a different drive.\n    \"\"\"\n    path = _get_link_path(target, base)\n    url = path_to_url(path)\n    if os.path.isabs(path):\n        url = 'file:' + url\n    return url\n</code></pre>"},{"location":"api/robot/utils/robottime/","title":"robot.utils.robottime","text":""},{"location":"api/robot/utils/robottime/#robot.utils.robottime","title":"robot.utils.robottime","text":""},{"location":"api/robot/utils/robottime/#robot.utils.robottime.timestr_to_secs","title":"timestr_to_secs","text":"<pre><code>timestr_to_secs(timestr, round_to=3)\n</code></pre> <p>Parses time strings like '1h 10s', '01:00:10' and '42' and returns seconds.</p> <p>Time can also be given as an integer or float or, starting from RF 6.0.1, as a <code>timedelta</code> instance.</p> <p>The result is rounded according to the <code>round_to</code> argument. Use <code>round_to=None</code> to disable rounding altogether.</p> Source code in <code>src/robot/utils/robottime.py</code> <pre><code>def timestr_to_secs(timestr, round_to=3):\n    \"\"\"Parses time strings like '1h 10s', '01:00:10' and '42' and returns seconds.\n\n    Time can also be given as an integer or float or, starting from RF 6.0.1,\n    as a `timedelta` instance.\n\n    The result is rounded according to the `round_to` argument.\n    Use `round_to=None` to disable rounding altogether.\n    \"\"\"\n    if is_string(timestr) or is_number(timestr):\n        converters = [_number_to_secs, _timer_to_secs, _time_string_to_secs]\n        for converter in converters:\n            secs = converter(timestr)\n            if secs is not None:\n                return secs if round_to is None else round(secs, round_to)\n    if isinstance(timestr, timedelta):\n        return timestr.total_seconds()\n    raise ValueError(f\"Invalid time string '{timestr}'.\")\n</code></pre>"},{"location":"api/robot/utils/robottime/#robot.utils.robottime.secs_to_timestr","title":"secs_to_timestr","text":"<pre><code>secs_to_timestr(\n    secs: int | float | timedelta, compact=False\n) -&gt; str\n</code></pre> <p>Converts time in seconds to a string representation.</p> <p>Returned string is in format like '1 day 2 hours 3 minutes 4 seconds 5 milliseconds' with following rules:</p> <ul> <li>Time parts having zero value are not included (e.g. '3 minutes 4 seconds'   instead of '0 days 0 hours 3 minutes 4 seconds')</li> <li>Hour part has a maximum of 23 and minutes and seconds both have 59   (e.g. '1 minute 40 seconds' instead of '100 seconds')</li> </ul> <p>If compact has value 'True', short suffixes are used. (e.g. 1d 2h 3min 4s 5ms)</p> Source code in <code>src/robot/utils/robottime.py</code> <pre><code>def secs_to_timestr(secs: 'int|float|timedelta', compact=False) -&gt; str:\n    \"\"\"Converts time in seconds to a string representation.\n\n    Returned string is in format like\n    '1 day 2 hours 3 minutes 4 seconds 5 milliseconds' with following rules:\n\n    - Time parts having zero value are not included (e.g. '3 minutes 4 seconds'\n      instead of '0 days 0 hours 3 minutes 4 seconds')\n    - Hour part has a maximum of 23 and minutes and seconds both have 59\n      (e.g. '1 minute 40 seconds' instead of '100 seconds')\n\n    If compact has value 'True', short suffixes are used.\n    (e.g. 1d 2h 3min 4s 5ms)\n    \"\"\"\n    if isinstance(secs, timedelta):\n        secs = secs.total_seconds()\n    return _SecsToTimestrHelper(secs, compact).get_value()\n</code></pre>"},{"location":"api/robot/utils/robottime/#robot.utils.robottime.format_time","title":"format_time","text":"<pre><code>format_time(\n    timetuple_or_epochsecs,\n    daysep=\"\",\n    daytimesep=\" \",\n    timesep=\":\",\n    millissep=None,\n)\n</code></pre> <p>Deprecated in Robot Framework 7.0. Will be removed in Robot Framework 8.0.</p> Source code in <code>src/robot/utils/robottime.py</code> <pre><code>def format_time(timetuple_or_epochsecs, daysep='', daytimesep=' ', timesep=':',\n                millissep=None):\n    \"\"\"Deprecated in Robot Framework 7.0. Will be removed in Robot Framework 8.0.\"\"\"\n    warnings.warn(\"'robot.utils.format_time' is deprecated and will be \"\n                  \"removed in Robot Framework 8.0.\")\n    if is_number(timetuple_or_epochsecs):\n        timetuple = _get_timetuple(timetuple_or_epochsecs)\n    else:\n        timetuple = timetuple_or_epochsecs\n    daytimeparts = ['%02d' % t for t in timetuple[:6]]\n    day = daysep.join(daytimeparts[:3])\n    time_ = timesep.join(daytimeparts[3:6])\n    millis = millissep and '%s%03d' % (millissep, timetuple[6]) or ''\n    return day + daytimesep + time_ + millis\n</code></pre>"},{"location":"api/robot/utils/robottime/#robot.utils.robottime.get_time","title":"get_time","text":"<pre><code>get_time(format='timestamp', time_=None)\n</code></pre> <p>Return the given or current time in requested format.</p> <p>If time is not given, current time is used. How time is returned is determined based on the given 'format' string as follows. Note that all checks are case-insensitive.</p> <ul> <li>If 'format' contains word 'epoch' the time is returned in seconds after   the unix epoch.</li> <li>If 'format' contains any of the words 'year', 'month', 'day', 'hour',   'min' or 'sec' only selected parts are returned. The order of the returned   parts is always the one in previous sentence and order of words in   'format' is not significant. Parts are returned as zero padded strings   (e.g. May -&gt; '05').</li> <li>Otherwise (and by default) the time is returned as a timestamp string in   format '2006-02-24 15:08:31'</li> </ul> Source code in <code>src/robot/utils/robottime.py</code> <pre><code>def get_time(format='timestamp', time_=None):\n    \"\"\"Return the given or current time in requested format.\n\n    If time is not given, current time is used. How time is returned is\n    determined based on the given 'format' string as follows. Note that all\n    checks are case-insensitive.\n\n    - If 'format' contains word 'epoch' the time is returned in seconds after\n      the unix epoch.\n    - If 'format' contains any of the words 'year', 'month', 'day', 'hour',\n      'min' or 'sec' only selected parts are returned. The order of the returned\n      parts is always the one in previous sentence and order of words in\n      'format' is not significant. Parts are returned as zero padded strings\n      (e.g. May -&gt; '05').\n    - Otherwise (and by default) the time is returned as a timestamp string in\n      format '2006-02-24 15:08:31'\n    \"\"\"\n    time_ = int(time.time() if time_ is None else time_)\n    format = format.lower()\n    # 1) Return time in seconds since epoc\n    if 'epoch' in format:\n        return time_\n    dt = datetime.fromtimestamp(time_)\n    parts = []\n    for part, name in [(dt.year, 'year'), (dt.month, 'month'), (dt.day, 'day'),\n                       (dt.hour, 'hour'), (dt.minute, 'min'), (dt.second, 'sec')]:\n        if name in format:\n            parts.append(f'{part:02}')\n    # 2) Return time as timestamp\n    if not parts:\n        return dt.isoformat(' ', timespec='seconds')\n    # Return requested parts of the time\n    elif len(parts) == 1:\n        return parts[0]\n    else:\n        return parts\n</code></pre>"},{"location":"api/robot/utils/robottime/#robot.utils.robottime.parse_timestamp","title":"parse_timestamp","text":"<pre><code>parse_timestamp(timestamp: str | datetime) -&gt; datetime\n</code></pre> <p>Parse timestamp in ISO 8601-like formats into a <code>datetime</code>.</p> <p>Months, days, hours, minutes and seconds must use two digits and year must use four. Microseconds can use up to six digits. All time parts can be omitted.</p> <p>Separators '-', '_', ' ', 'T', ':' and '.' between date and time components. Separators can also be omitted altogether.</p> <p>Examples::</p> <pre><code>2023-09-08T14:34:42.123456\n2023-09-08 14:34:42.123\n20230908 143442\n2023_09_08\n</code></pre> <p>This is similar to <code>datetime.fromisoformat</code>, but a little less strict. The standard function is recommended if the input format is known to be accepted.</p> <p>If the input is a <code>datetime</code>, it is returned as-is.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/utils/robottime.py</code> <pre><code>def parse_timestamp(timestamp: 'str|datetime') -&gt; datetime:\n    \"\"\"Parse timestamp in ISO 8601-like formats into a ``datetime``.\n\n    Months, days, hours, minutes and seconds must use two digits and\n    year must use four. Microseconds can use up to six digits. All time\n    parts can be omitted.\n\n    Separators '-', '_', ' ', 'T', ':' and '.' between date and time components.\n    Separators can also be omitted altogether.\n\n    Examples::\n\n        2023-09-08T14:34:42.123456\n        2023-09-08 14:34:42.123\n        20230908 143442\n        2023_09_08\n\n    This is similar to ``datetime.fromisoformat``, but a little less strict.\n    The standard function is recommended if the input format is known to be\n    accepted.\n\n    If the input is a ``datetime``, it is returned as-is.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    if isinstance(timestamp, datetime):\n        return timestamp\n    try:\n        return datetime.fromisoformat(timestamp)\n    except ValueError:\n        pass\n    orig = timestamp\n    for sep in ('-', '_', ' ', 'T', ':', '.'):\n        if sep in timestamp:\n            timestamp = timestamp.replace(sep, '')\n    timestamp = timestamp.ljust(20, '0')\n    try:\n        return datetime(int(timestamp[0:4]), int(timestamp[4:6]), int(timestamp[6:8]),\n                        int(timestamp[8:10]), int(timestamp[10:12]), int(timestamp[12:14]),\n                        int(timestamp[14:20]))\n    except ValueError:\n        raise ValueError(f\"Invalid timestamp '{orig}'.\")\n</code></pre>"},{"location":"api/robot/utils/robottime/#robot.utils.robottime.parse_time","title":"parse_time","text":"<pre><code>parse_time(timestr)\n</code></pre> <p>Parses the time string and returns its value as seconds since epoch.</p> <p>Time can be given in five different formats:</p> <p>1) Numbers are interpreted as time since epoch directly. It is possible to    use also ints and floats, not only strings containing numbers. 2) Valid timestamp ('YYYY-MM-DD hhss' and 'YYYYMMDD hhmmss'). 3) 'NOW' (case-insensitive) is the current local time. 4) 'UTC' (case-insensitive) is the current time in UTC. 5) Format 'NOW - 1 day' or 'UTC + 1 hour 30 min' is the current local/UTC    time plus/minus the time specified with the time string.</p> <p>Seconds are rounded down to avoid getting times in the future.</p> Source code in <code>src/robot/utils/robottime.py</code> <pre><code>def parse_time(timestr):\n    \"\"\"Parses the time string and returns its value as seconds since epoch.\n\n    Time can be given in five different formats:\n\n    1) Numbers are interpreted as time since epoch directly. It is possible to\n       use also ints and floats, not only strings containing numbers.\n    2) Valid timestamp ('YYYY-MM-DD hh:mm:ss' and 'YYYYMMDD hhmmss').\n    3) 'NOW' (case-insensitive) is the current local time.\n    4) 'UTC' (case-insensitive) is the current time in UTC.\n    5) Format 'NOW - 1 day' or 'UTC + 1 hour 30 min' is the current local/UTC\n       time plus/minus the time specified with the time string.\n\n    Seconds are rounded down to avoid getting times in the future.\n    \"\"\"\n    for method in [_parse_time_epoch,\n                   _parse_time_timestamp,\n                   _parse_time_now_and_utc]:\n        seconds = method(timestr)\n        if seconds is not None:\n            return int(seconds)\n    raise ValueError(\"Invalid time format '%s'.\" % timestr)\n</code></pre>"},{"location":"api/robot/utils/robottime/#robot.utils.robottime.get_timestamp","title":"get_timestamp","text":"<pre><code>get_timestamp(\n    daysep=\"\", daytimesep=\" \", timesep=\":\", millissep=\".\"\n)\n</code></pre> <p>Deprecated in Robot Framework 7.0. Will be removed in Robot Framework 8.0.</p> Source code in <code>src/robot/utils/robottime.py</code> <pre><code>def get_timestamp(daysep='', daytimesep=' ', timesep=':', millissep='.'):\n    \"\"\"Deprecated in Robot Framework 7.0. Will be removed in Robot Framework 8.0.\"\"\"\n    warnings.warn(\"'robot.utils.get_timestamp' is deprecated and will be \"\n                  \"removed in Robot Framework 8.0.\")\n    dt = datetime.now()\n    parts = [str(dt.year), daysep, f'{dt.month:02}', daysep, f'{dt.day:02}', daytimesep,\n             f'{dt.hour:02}', timesep, f'{dt.minute:02}', timesep, f'{dt.second:02}']\n    if millissep:\n        # Make sure milliseconds is &lt; 1000. Good enough for a deprecated function.\n        millis = min(round(dt.microsecond, -3) // 1000, 999)\n        parts.extend([millissep, f'{millis:03}'])\n    return ''.join(parts)\n</code></pre>"},{"location":"api/robot/utils/robottime/#robot.utils.robottime.timestamp_to_secs","title":"timestamp_to_secs","text":"<pre><code>timestamp_to_secs(timestamp, seps=None)\n</code></pre> <p>Deprecated in Robot Framework 7.0. Will be removed in Robot Framework 8.0.</p> Source code in <code>src/robot/utils/robottime.py</code> <pre><code>def timestamp_to_secs(timestamp, seps=None):\n    \"\"\"Deprecated in Robot Framework 7.0. Will be removed in Robot Framework 8.0.\"\"\"\n    warnings.warn(\"'robot.utils.timestamp_to_secs' is deprecated and will be \"\n                  \"removed in Robot Framework 8.0. User 'parse_timestamp' instead.\")\n    try:\n        secs = _timestamp_to_millis(timestamp, seps) / 1000.0\n    except (ValueError, OverflowError):\n        raise ValueError(\"Invalid timestamp '%s'.\" % timestamp)\n    else:\n        return round(secs, 3)\n</code></pre>"},{"location":"api/robot/utils/robottime/#robot.utils.robottime.secs_to_timestamp","title":"secs_to_timestamp","text":"<pre><code>secs_to_timestamp(secs, seps=None, millis=False)\n</code></pre> <p>Deprecated in Robot Framework 7.0. Will be removed in Robot Framework 8.0.</p> Source code in <code>src/robot/utils/robottime.py</code> <pre><code>def secs_to_timestamp(secs, seps=None, millis=False):\n    \"\"\"Deprecated in Robot Framework 7.0. Will be removed in Robot Framework 8.0.\"\"\"\n    warnings.warn(\"'robot.utils.secs_to_timestamp' is deprecated and will be \"\n                  \"removed in Robot Framework 8.0.\")\n    if not seps:\n        seps = ('', ' ', ':', '.' if millis else None)\n    ttuple = time.localtime(secs)[:6]\n    if millis:\n        millis = (secs - int(secs)) * 1000\n        ttuple = ttuple + (round(millis),)\n    return format_time(ttuple, *seps)\n</code></pre>"},{"location":"api/robot/utils/robottime/#robot.utils.robottime.get_elapsed_time","title":"get_elapsed_time","text":"<pre><code>get_elapsed_time(start_time, end_time)\n</code></pre> <p>Deprecated in Robot Framework 7.0. Will be removed in Robot Framework 8.0.</p> Source code in <code>src/robot/utils/robottime.py</code> <pre><code>def get_elapsed_time(start_time, end_time):\n    \"\"\"Deprecated in Robot Framework 7.0. Will be removed in Robot Framework 8.0.\"\"\"\n    warnings.warn(\"'robot.utils.get_elapsed_time' is deprecated and will be \"\n                  \"removed in Robot Framework 8.0.\")\n    if start_time == end_time or not (start_time and end_time):\n        return 0\n    if start_time[:-4] == end_time[:-4]:\n        return int(end_time[-3:]) - int(start_time[-3:])\n    start_millis = _timestamp_to_millis(start_time)\n    end_millis = _timestamp_to_millis(end_time)\n    return end_millis - start_millis\n</code></pre>"},{"location":"api/robot/utils/robottime/#robot.utils.robottime.elapsed_time_to_string","title":"elapsed_time_to_string","text":"<pre><code>elapsed_time_to_string(\n    elapsed: int | float | timedelta,\n    include_millis: bool = True,\n    seconds: bool = False,\n)\n</code></pre> <p>Converts elapsed time to format 'hhss.mil'.</p> <p>Elapsed time as an integer or as a float is currently considered to be milliseconds, but that will be changed to seconds in Robot Framework 8.0. Use <code>seconds=True</code> to change the behavior already now and to avoid the deprecation warning. An alternative is giving the elapsed time as a <code>timedelta</code>.</p> <p>If <code>include_millis</code> is True, '.mil' part is omitted.</p> <p>Support for giving the elapsed time as a <code>timedelta</code> and the <code>seconds</code> argument are new in Robot Framework 7.0.</p> Source code in <code>src/robot/utils/robottime.py</code> <pre><code>def elapsed_time_to_string(elapsed: 'int|float|timedelta',\n                           include_millis: bool = True,\n                           seconds: bool = False):\n    \"\"\"Converts elapsed time to format 'hh:mm:ss.mil'.\n\n    Elapsed time as an integer or as a float is currently considered to be\n    milliseconds, but that will be changed to seconds in Robot Framework 8.0.\n    Use ``seconds=True`` to change the behavior already now and to avoid the\n    deprecation warning. An alternative is giving the elapsed time as\n    a ``timedelta``.\n\n    If `include_millis` is True, '.mil' part is omitted.\n\n    Support for giving the elapsed time as a ``timedelta`` and the ``seconds``\n    argument are new in Robot Framework 7.0.\n    \"\"\"\n    # TODO: Change the default input to seconds in RF 8.0.\n    if isinstance(elapsed, timedelta):\n        elapsed = elapsed.total_seconds()\n    elif not seconds:\n        elapsed /= 1000\n        warnings.warn(\"'robot.utils.elapsed_time_to_string' currently accepts \"\n                      \"input as milliseconds, but that will be changed to seconds \"\n                      \"in Robot Framework 8.0. Use 'seconds=True' to change the \"\n                      \"behavior already now and to avoid this warning. Alternatively \"\n                      \"pass the elapsed time as a 'timedelta'.\")\n    prefix = ''\n    if elapsed &lt; 0:\n        prefix = '-'\n        elapsed = abs(elapsed)\n    if include_millis:\n        return prefix + _elapsed_time_to_string_with_millis(elapsed)\n    return prefix + _elapsed_time_to_string_without_millis(elapsed)\n</code></pre>"},{"location":"api/robot/utils/robottypes/","title":"robot.utils.robottypes","text":""},{"location":"api/robot/utils/robottypes/#robot.utils.robottypes","title":"robot.utils.robottypes","text":""},{"location":"api/robot/utils/robottypes/#robot.utils.robottypes.type_name","title":"type_name","text":"<pre><code>type_name(item, capitalize=False)\n</code></pre> <p>Return \"non-technical\" type name for objects and types.</p> <p>For example, 'integer' instead of 'int' and 'file' instead of 'TextIOWrapper'.</p> Source code in <code>src/robot/utils/robottypes.py</code> <pre><code>def type_name(item, capitalize=False):\n    \"\"\"Return \"non-technical\" type name for objects and types.\n\n    For example, 'integer' instead of 'int' and 'file' instead of 'TextIOWrapper'.\n    \"\"\"\n    if getattr(item, '__origin__', None):\n        item = item.__origin__\n    if hasattr(item, '_name') and item._name:\n        # Prior to Python 3.10 Union, Any, etc. from typing didn't have `__name__`.\n        # but instead had `_name`. Python 3.10 has both and newer only `__name__`.\n        # Also, pandas.Series has `_name` but it's None.\n        name = item._name\n    elif is_union(item):\n        name = 'Union'\n    elif isinstance(item, IOBase):\n        name = 'file'\n    else:\n        typ = type(item) if not isinstance(item, type) else item\n        named_types = {str: 'string', bool: 'boolean', int: 'integer',\n                       type(None): 'None', dict: 'dictionary'}\n        name = named_types.get(typ, typ.__name__.strip('_'))\n    return name.capitalize() if capitalize and name.islower() else name\n</code></pre>"},{"location":"api/robot/utils/robottypes/#robot.utils.robottypes.type_repr","title":"type_repr","text":"<pre><code>type_repr(typ, nested=True)\n</code></pre> <p>Return string representation for types.</p> <p>Aims to look as much as the source code as possible. For example, 'List[Any]' instead of 'typing.List[typing.Any]'.</p> Source code in <code>src/robot/utils/robottypes.py</code> <pre><code>def type_repr(typ, nested=True):\n    \"\"\"Return string representation for types.\n\n    Aims to look as much as the source code as possible. For example, 'List[Any]'\n    instead of 'typing.List[typing.Any]'.\n    \"\"\"\n    if typ is type(None):\n        return 'None'\n    if typ is Ellipsis:\n        return '...'\n    if is_union(typ):\n        return ' | '.join(type_repr(a) for a in typ.__args__) if nested else 'Union'\n    if getattr(typ, '__origin__', None) is Literal:\n        if nested:\n            args = ', '.join(repr(a) for a in typ.__args__)\n            return f'Literal[{args}]'\n        return 'Literal'\n    name = _get_type_name(typ)\n    if nested and has_args(typ):\n        args = ', '.join(type_repr(a) for a in typ.__args__)\n        return f'{name}[{args}]'\n    return name\n</code></pre>"},{"location":"api/robot/utils/robottypes/#robot.utils.robottypes.has_args","title":"has_args","text":"<pre><code>has_args(type)\n</code></pre> <p>Helper to check has type valid <code>__args__</code>.</p> <p><code>__args__</code> contains TypeVars when accessed directly from <code>typing.List</code> and other such types with Python 3.8. Python 3.9+ don't have <code>__args__</code> at all. Parameterize usages like <code>List[int].__args__</code> always work the same way.</p> <p>This helper can be removed in favor of using <code>hasattr(type, '__args__')</code>  when we support only Python 3.9 and newer.</p> Source code in <code>src/robot/utils/robottypes.py</code> <pre><code>def has_args(type):\n    \"\"\"Helper to check has type valid ``__args__``.\n\n   ``__args__`` contains TypeVars when accessed directly from ``typing.List`` and\n   other such types with Python 3.8. Python 3.9+ don't have ``__args__`` at all.\n   Parameterize usages like ``List[int].__args__`` always work the same way.\n\n    This helper can be removed in favor of using ``hasattr(type, '__args__')``\n    when we support only Python 3.9 and newer.\n    \"\"\"\n    args = getattr(type, '__args__', None)\n    return bool(args and not all(isinstance(a, TypeVar) for a in args))\n</code></pre>"},{"location":"api/robot/utils/robottypes/#robot.utils.robottypes.is_truthy","title":"is_truthy","text":"<pre><code>is_truthy(item)\n</code></pre> <p>Returns <code>True</code> or <code>False</code> depending on is the item considered true or not.</p> <p>Validation rules:</p> <ul> <li>If the value is a string, it is considered false if it is <code>'FALSE'</code>,   <code>'NO'</code>, <code>'OFF'</code>, <code>'0'</code>, <code>'NONE'</code> or <code>''</code>, case-insensitively.</li> <li>Other strings are considered true.</li> <li>Other values are handled by using the standard <code>bool()</code> function.</li> </ul> <p>Designed to be used also by external test libraries that want to handle Boolean values similarly as Robot Framework itself. See also :func:<code>is_falsy</code>.</p> Source code in <code>src/robot/utils/robottypes.py</code> <pre><code>def is_truthy(item):\n    \"\"\"Returns `True` or `False` depending on is the item considered true or not.\n\n    Validation rules:\n\n    - If the value is a string, it is considered false if it is `'FALSE'`,\n      `'NO'`, `'OFF'`, `'0'`, `'NONE'` or `''`, case-insensitively.\n    - Other strings are considered true.\n    - Other values are handled by using the standard `bool()` function.\n\n    Designed to be used also by external test libraries that want to handle\n    Boolean values similarly as Robot Framework itself. See also\n    :func:`is_falsy`.\n    \"\"\"\n    if is_string(item):\n        return item.upper() not in FALSE_STRINGS\n    return bool(item)\n</code></pre>"},{"location":"api/robot/utils/robottypes/#robot.utils.robottypes.is_falsy","title":"is_falsy","text":"<pre><code>is_falsy(item)\n</code></pre> <p>Opposite of :func:<code>is_truthy</code>.</p> Source code in <code>src/robot/utils/robottypes.py</code> <pre><code>def is_falsy(item):\n    \"\"\"Opposite of :func:`is_truthy`.\"\"\"\n    return not is_truthy(item)\n</code></pre>"},{"location":"api/robot/utils/setter/","title":"robot.utils.setter","text":""},{"location":"api/robot/utils/setter/#robot.utils.setter","title":"robot.utils.setter","text":""},{"location":"api/robot/utils/setter/#robot.utils.setter.setter","title":"setter","text":"<pre><code>setter(method: Callable[[T, V], A])\n</code></pre> <p>               Bases: <code>Generic[T, V, A]</code></p> <p>Modify instance attributes only when they are set, not when they are get.</p> <p>Usage::</p> <pre><code>@setter\ndef source(self, source: str|Path) -&gt; Path:\n    return source if isinstance(source, Path) else Path(source)\n</code></pre> <p>The setter method is called when the attribute is assigned like::</p> <pre><code>instance.source = 'example.txt'\n</code></pre> <p>and the returned value is stored in the instance in an attribute like <code>_setter__source</code>. When the attribute is accessed, the stored value is returned.</p> <p>The above example is equivalent to using the standard <code>property</code> as follows. The main benefit of using <code>setter</code> is that it avoids a dummy getter method::</p> <pre><code>@property\ndef source(self) -&gt; Path:\n    return self._source\n\n@source.setter\ndef source(self, source: src|Path):\n    self._source = source if isinstance(source, Path) else Path(source)\n</code></pre> <p>When using <code>setter</code> with <code>__slots__</code>, the special <code>_setter__xxx</code> attributes needs to be added to <code>__slots__</code> as well. The provided :class:<code>SetterAwareType</code> metaclass can take care of that automatically.</p> Source code in <code>src/robot/utils/setter.py</code> <pre><code>def __init__(self, method: Callable[[T, V], A]):\n    self.method = method\n    self.attr_name = '_setter__' + method.__name__\n    self.__doc__ = method.__doc__\n</code></pre>"},{"location":"api/robot/utils/setter/#robot.utils.setter.SetterAwareType","title":"SetterAwareType","text":"<p>               Bases: <code>type</code></p> <p>Metaclass for adding attributes used by :class:<code>setter</code> to <code>__slots__</code>.</p>"},{"location":"api/robot/utils/sortable/","title":"robot.utils.sortable","text":""},{"location":"api/robot/utils/sortable/#robot.utils.sortable","title":"robot.utils.sortable","text":""},{"location":"api/robot/utils/sortable/#robot.utils.sortable.Sortable","title":"Sortable","text":"<p>Base class for sorting based self._sort_key</p>"},{"location":"api/robot/utils/text/","title":"robot.utils.text","text":""},{"location":"api/robot/utils/text/#robot.utils.text","title":"robot.utils.text","text":""},{"location":"api/robot/utils/text/#robot.utils.text.split_args_from_name_or_path","title":"split_args_from_name_or_path","text":"<pre><code>split_args_from_name_or_path(name)\n</code></pre> <p>Split arguments embedded to name or path like <code>Example:arg1:arg2</code>.</p> <p>The separator can be either colon <code>:</code> or semicolon <code>;</code>. If both are used, the first one is considered to be the separator.</p> Source code in <code>src/robot/utils/text.py</code> <pre><code>def split_args_from_name_or_path(name):\n    \"\"\"Split arguments embedded to name or path like ``Example:arg1:arg2``.\n\n    The separator can be either colon ``:`` or semicolon ``;``. If both are used,\n    the first one is considered to be the separator.\n    \"\"\"\n    if os.path.exists(name):\n        return os.path.abspath(name), []\n    if isinstance(name, Path):\n        name = str(name)\n    index = _get_arg_separator_index_from_name_or_path(name)\n    if index == -1:\n        return name, []\n    args = name[index+1:].split(name[index])\n    name = name[:index]\n    if os.path.exists(name):\n        name = os.path.abspath(name)\n    return name, args\n</code></pre>"},{"location":"api/robot/utils/typehints/","title":"robot.utils.typehints","text":""},{"location":"api/robot/utils/typehints/#robot.utils.typehints","title":"robot.utils.typehints","text":""},{"location":"api/robot/utils/typehints/#robot.utils.typehints.copy_signature","title":"copy_signature","text":"<pre><code>copy_signature(target: T) -&gt; Callable[..., T]\n</code></pre> <p>A decorator that applies the signature of <code>T</code> to any function that it decorates see https://github.com/python/typing/issues/270#issuecomment-555966301 for source and discussion.</p> Source code in <code>src/robot/utils/typehints.py</code> <pre><code>def copy_signature(target: T) -&gt; Callable[..., T]:\n    \"\"\"A decorator that applies the signature of `T` to any function that it decorates\n    see https://github.com/python/typing/issues/270#issuecomment-555966301 for source\n    and discussion.\n    \"\"\"\n    def decorator(func):\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/robot/utils/unic/","title":"robot.utils.unic","text":""},{"location":"api/robot/utils/unic/#robot.utils.unic","title":"robot.utils.unic","text":""},{"location":"api/robot/variables/","title":"robot.variables","text":""},{"location":"api/robot/variables/#robot.variables","title":"robot.variables","text":"<p>Implements storing and resolving variables.</p> <p>This package is mainly for internal usage, but utilities for finding variables can be used externally as well.</p>"},{"location":"api/robot/variables/assigner/","title":"robot.variables.assigner","text":""},{"location":"api/robot/variables/assigner/#robot.variables.assigner","title":"robot.variables.assigner","text":""},{"location":"api/robot/variables/evaluation/","title":"robot.variables.evaluation","text":""},{"location":"api/robot/variables/evaluation/#robot.variables.evaluation","title":"robot.variables.evaluation","text":""},{"location":"api/robot/variables/filesetter/","title":"robot.variables.filesetter","text":""},{"location":"api/robot/variables/filesetter/#robot.variables.filesetter","title":"robot.variables.filesetter","text":""},{"location":"api/robot/variables/finders/","title":"robot.variables.finders","text":""},{"location":"api/robot/variables/finders/#robot.variables.finders","title":"robot.variables.finders","text":""},{"location":"api/robot/variables/notfound/","title":"robot.variables.notfound","text":""},{"location":"api/robot/variables/notfound/#robot.variables.notfound","title":"robot.variables.notfound","text":""},{"location":"api/robot/variables/notfound/#robot.variables.notfound.variable_not_found","title":"variable_not_found","text":"<pre><code>variable_not_found(\n    name, candidates, message=None, deco_braces=True\n)\n</code></pre> <p>Raise DataError for missing variable name.</p> <p>Return recommendations for similar variable names if any are found.</p> Source code in <code>src/robot/variables/notfound.py</code> <pre><code>def variable_not_found(name, candidates, message=None, deco_braces=True):\n    \"\"\"Raise DataError for missing variable name.\n\n    Return recommendations for similar variable names if any are found.\n    \"\"\"\n    candidates = _decorate_candidates(name[0], candidates, deco_braces)\n    normalizer = partial(normalize, ignore='$@&amp;%{}_')\n    message = RecommendationFinder(normalizer).find_and_format(\n        name, candidates,\n        message=message or \"Variable '%s' not found.\" % name\n    )\n    raise VariableError(message)\n</code></pre>"},{"location":"api/robot/variables/replacer/","title":"robot.variables.replacer","text":""},{"location":"api/robot/variables/replacer/#robot.variables.replacer","title":"robot.variables.replacer","text":""},{"location":"api/robot/variables/replacer/#robot.variables.replacer.VariableReplacer","title":"VariableReplacer","text":"<pre><code>VariableReplacer(variables)\n</code></pre> Source code in <code>src/robot/variables/replacer.py</code> <pre><code>def __init__(self, variables):\n    self._finder = VariableFinder(variables)\n</code></pre>"},{"location":"api/robot/variables/replacer/#robot.variables.replacer.VariableReplacer.replace_list","title":"replace_list","text":"<pre><code>replace_list(\n    items, replace_until=None, ignore_errors=False\n)\n</code></pre> <p>Replaces variables from a list of items.</p> <p>If an item in a list is a @{list} variable its value is returned. Possible variables from other items are replaced using 'replace_scalar'. Result is always a list.</p> <p>'replace_until' can be used to limit replacing arguments to certain index from the beginning. Used with Run Keyword variants that only want to resolve some arguments in the beginning and pass others to called keywords unmodified.</p> Source code in <code>src/robot/variables/replacer.py</code> <pre><code>def replace_list(self, items, replace_until=None, ignore_errors=False):\n    \"\"\"Replaces variables from a list of items.\n\n    If an item in a list is a @{list} variable its value is returned.\n    Possible variables from other items are replaced using 'replace_scalar'.\n    Result is always a list.\n\n    'replace_until' can be used to limit replacing arguments to certain\n    index from the beginning. Used with Run Keyword variants that only\n    want to resolve some arguments in the beginning and pass others\n    to called keywords unmodified.\n    \"\"\"\n    items = list(items or [])\n    if replace_until is not None:\n        return self._replace_list_until(items, replace_until, ignore_errors)\n    return self._replace_list(items, ignore_errors)\n</code></pre>"},{"location":"api/robot/variables/replacer/#robot.variables.replacer.VariableReplacer.replace_scalar","title":"replace_scalar","text":"<pre><code>replace_scalar(item, ignore_errors=False)\n</code></pre> <p>Replaces variables from a scalar item.</p> <p>If the item is not a string it is returned as is. If it is a variable, its value is returned. Otherwise, possible variables are replaced with 'replace_string'. Result may be any object.</p> Source code in <code>src/robot/variables/replacer.py</code> <pre><code>def replace_scalar(self, item, ignore_errors=False):\n    \"\"\"Replaces variables from a scalar item.\n\n    If the item is not a string it is returned as is. If it is a variable,\n    its value is returned. Otherwise, possible variables are replaced with\n    'replace_string'. Result may be any object.\n    \"\"\"\n    if isinstance(item, VariableMatch):\n        match = item\n    else:\n        match = search_variable(item, ignore_errors=ignore_errors)\n    if not match:\n        return unescape(match.string)\n    return self._replace_scalar(match, ignore_errors)\n</code></pre>"},{"location":"api/robot/variables/replacer/#robot.variables.replacer.VariableReplacer.replace_string","title":"replace_string","text":"<pre><code>replace_string(\n    item, custom_unescaper=None, ignore_errors=False\n)\n</code></pre> <p>Replaces variables from a string. Result is always a string.</p> <p>Input can also be an already found VariableMatch.</p> Source code in <code>src/robot/variables/replacer.py</code> <pre><code>def replace_string(self, item, custom_unescaper=None, ignore_errors=False):\n    \"\"\"Replaces variables from a string. Result is always a string.\n\n    Input can also be an already found VariableMatch.\n    \"\"\"\n    unescaper = custom_unescaper or unescape\n    if isinstance(item, VariableMatch):\n        match = item\n    else:\n        match = search_variable(item, ignore_errors=ignore_errors)\n    if not match:\n        return safe_str(unescaper(match.string))\n    return self._replace_string(match, unescaper, ignore_errors)\n</code></pre>"},{"location":"api/robot/variables/resolvable/","title":"robot.variables.resolvable","text":""},{"location":"api/robot/variables/resolvable/#robot.variables.resolvable","title":"robot.variables.resolvable","text":""},{"location":"api/robot/variables/scopes/","title":"robot.variables.scopes","text":""},{"location":"api/robot/variables/scopes/#robot.variables.scopes","title":"robot.variables.scopes","text":""},{"location":"api/robot/variables/search/","title":"robot.variables.search","text":""},{"location":"api/robot/variables/search/#robot.variables.search","title":"robot.variables.search","text":""},{"location":"api/robot/variables/store/","title":"robot.variables.store","text":""},{"location":"api/robot/variables/store/#robot.variables.store","title":"robot.variables.store","text":""},{"location":"api/robot/variables/tablesetter/","title":"robot.variables.tablesetter","text":""},{"location":"api/robot/variables/tablesetter/#robot.variables.tablesetter","title":"robot.variables.tablesetter","text":""},{"location":"api/robot/variables/variables/","title":"robot.variables.variables","text":""},{"location":"api/robot/variables/variables/#robot.variables.variables","title":"robot.variables.variables","text":""},{"location":"api/robot/variables/variables/#robot.variables.variables.Variables","title":"Variables","text":"<pre><code>Variables()\n</code></pre> <p>Represents a set of variables.</p> <p>Contains methods for replacing variables from list, scalars, and strings. On top of ${scalar}, @{list} and &amp;{dict} variables, these methods handle also %{environment} variables.</p> Source code in <code>src/robot/variables/variables.py</code> <pre><code>def __init__(self):\n    self.store = VariableStore(self)\n    self._replacer = VariableReplacer(self)\n</code></pre>"},{"location":"data/","title":"Data","text":"<p>This section will cover data syntax, how to create tests and tasks, how to use keywords, etc.</p> <p></p>"},{"location":"data/syntax/","title":"Syntax","text":"<p>At them moment this page is just a placeholder for testing navigation. It also mentions the 6251a85a-47d0-11ee-be56-0242ac120002:_:keyword:&lt;__None__&gt;:b040672770abe23f8ac87db1b8b318f5 term to get one usage to the glossary.</p>"},{"location":"execution/","title":"Execution","text":"<p>This section will cover both execution and results.</p> <p></p>"},{"location":"extend/","title":"Extending Robot Framework","text":"<p>The content of this section is still missing. The idea is that this page would contain a quick introduction to this section and actual content would be on separate pages.</p>"},{"location":"extend/libraries/","title":"Creating libraries","text":"<p>This is just a placeholder at the moment.</p>"},{"location":"install/","title":"Robot Framework installation","text":"<p>These instructions cover installing Robot Framework and its preconditions on different operating systems. If you already have Python installed, you can install Robot Framework using the standard package manager pip:</p> <pre><code>pip install robotframework\n</code></pre>"},{"location":"install/#python-installation","title":"Python installation","text":"<p>Robot Framework is implemented using Python, and a precondition to install it  is having Python or its alternative implementation PyPy installed. Another recommended precondition is having the pip package manager available.</p> <p>Robot Framework requires Python 3.8 or newer. The latest version that supports Python 3.6 and 3.7 is Robot Framework 6.1.1. If you need to use Python 2, Jython or IronPython, you can use Robot Framework 4.1.3.</p>"},{"location":"install/#installing-python-on-linux","title":"Installing Python on Linux","text":"<p>On Linux you should have suitable Python installation with pip available by default. If not, you need to consult your distributions documentation to learn how to install them. This is also true if you want to use some other Python version than the one provided by your distribution by default.</p> <p>To check what Python version you have installed, you can run <code>python --version</code> command in a terminal:</p> <pre><code>$ python --version\nPython 3.12.7\n</code></pre> <p>Notice that if your distribution provides also older Python 2, running <code>python</code> may use that. To use Python 3, you can use <code>python3</code> command or even more version specific command like <code>python3.12</code>. You need to use these version specific variants also if you have multiple Python 3 versions installed and need to pinpoint which one to use:</p> <pre><code>$ python3.11 --version\nPython 3.11.10\n$ python3.12 --version\nPython 3.12.7\n</code></pre> <p>Installing Robot Framework directly under the system provided Python has a risk that possible problems can affect the whole Python installation used also by the operating system itself. Nowadays, Linux distributions typically use user installs by default to avoid such problems, but users can also themselves decide to use virtual environments.</p>"},{"location":"install/#installing-python-on-windows","title":"Installing Python on Windows","text":"<p>On Windows Python is not available by default, but it is easy to install. The recommended way to install it is using the official Windows installers available at http://python.org. For other alternatives, such as installing from the Microsoft Store, see the official Python documentation.</p> <p>When installing Python on Windows, it is recommended to add Python to PATH to make Python itself and also tools like pip and Robot Framework easier to execute from the command line. When using the official installer, you just need to select the <code>Add Python 3.x to PATH</code> checkbox on the first dialog.</p> <p>To make sure Python installation has been successful and Python has been added to <code>PATH</code>, you can open the command prompt and execute <code>python --version</code>:</p> <pre><code>C:\\&gt;python --version\nPython 3.11.9\n</code></pre> <p>If you install multiple Python versions on Windows, the version that is used when you execute <code>python</code> is the one first in <code>PATH</code>. If you need to use others, the easiest way is using the official py launcher:</p> <pre><code>C:\\&gt;py --version\nPython 3.11.9\nC:\\&gt;py -3.12 --version\nPython 3.12.3\n</code></pre>"},{"location":"install/#installing-python-on-macos","title":"Installing Python on macOS","text":"<p>MacOS does not provide Python 3 compatible Python version by default, so it needs to be installed separately. The recommended  approach is using the official macOS installers available at http://python.org. If you are using a package manager like Homebrew, installing Python via it is possible as well.</p> <p>You can validate Python installation on macOS using <code>python --version</code> like on other operating systems.</p>"},{"location":"install/#pypy-installation","title":"PyPy installation","text":"<p>PyPy is an alternative Python implementation. Its main advantage over the standard Python implementation is that it can be faster and use less memory, but this depends on the context where and how it is used. If execution speed is important, at least testing PyPy is probably a good idea.</p> <p>Installing PyPy is a straightforward procedure, and you can find both installers and installation instructions at http://pypy.org. To validate that PyPy installation was successful, run <code>pypy --version</code> or <code>pypy3 --version</code>.</p> <p>Note that using Robot Framework with PyPy is officially supported only on Linux.</p>"},{"location":"install/#configuring-path","title":"Configuring <code>PATH</code>","text":"<p>The PATH environment variable lists directories where commands executed in a system are searched from. To make using Python, pip_ and Robot Framework easier  from the command line, it is recommended to add the Python installation directory as well as the directory where commands like <code>pip</code> and <code>robot</code> are installed into <code>PATH</code>.</p> <p>When using Python on Linux or macOS, Python and tools installed with it should be automatically in <code>PATH</code>. If you nevertheless need to update <code>PATH</code>, you typically need to edit some system-wide or user specific configuration file. Which file to edit and how depends on your operating system, and you need to consult its documentation for more details.</p> <p>On Windows the easiest way to make sure <code>PATH</code> is configured correctly is setting the <code>Add Python 3.x to PATH</code> checkbox when running the installer. To manually modify <code>PATH</code> on Windows, follow these steps:</p> <ol> <li> <p>Find <code>Environment Variables</code> under <code>Settings</code>. There are variables affecting    the whole system and variables affecting only the current user. Modifying    the former will require admin rights, but modifying the latter is typically    enough.</p> </li> <li> <p>Select <code>PATH</code> (often written like <code>Path</code>) and click <code>Edit</code>. If you are    editing user variables and <code>PATH</code> does not exist, click <code>New</code> instead.</p> </li> <li> <p>Add both the Python installation directory and the <code>Scripts</code> directory    under the installation directory into <code>PATH</code>.</p> </li> <li> <p>Exit the dialog with <code>Ok</code> to save the changes.</p> </li> <li> <p>Start a new command prompt for the changes to take effect.</p> </li> </ol>"},{"location":"install/#installation-using-pip","title":"Installation using pip","text":"<p>These instructions cover installing Robot Framework using pip, the standard Python package manager. If you are using some other package manager like Poetry or Conda, you need to study its documentation for installation instructions.</p> <p>When installing Python, you typically get pip installed automatically. If that is not the case, you need to check the documentation of that Python installation for instructions how to install it separately.</p>"},{"location":"install/#running-pip-command","title":"Running <code>pip</code> command","text":"<p>Typically, you use pip by running the <code>pip</code> command, but on Linux you may need to use <code>pip3</code> or even more Python version specific variant like <code>pip3.8</code> instead. When running <code>pip</code> or any of its variants, the pip version that is found first in PATH will be used. If you have multiple Python versions installed, you may need to pinpoint which exact version you want to use. This is typically easiest done by running <code>python -m pip</code> and substituting <code>python</code> with the Python version you want to use.</p> <p>To make sure you have pip available, you can run <code>pip --version</code> or equivalent.</p> <p>Examples on Linux:</p> <pre><code>$ pip --version\npip 23.2.1 from ... (python 3.11)\n$ python3.12 -m pip --version\npip 24.2 from ... (python 3.12)\n</code></pre> <p>Examples on Windows:</p> <pre><code>C:\\&gt; pip --version\npip 23.2.2 from ... (python 3.11)\nC:\\&gt; py -m 3.12 -m pip --version\npip 24.1.1 from ... (python 3.12)\n</code></pre> <p>In the subsequent sections pip is always run using the <code>pip</code> command. You may need to use some of the other approaches explained above in your environment.</p>"},{"location":"install/#installing-and-uninstalling-robot-framework","title":"Installing and uninstalling Robot Framework","text":"<p>The easiest way to use pip is by letting it find and download packages it installs from the Python Package Index (PyPI), but it can also install packages downloaded from the PyPI separately. The most common usages are shown below and pip documentation has more information and examples.</p> <pre><code># Install the latest version (does not upgrade).\npip install robotframework\n\n# Upgrade to the latest stable version.\npip install --upgrade robotframework\n\n# Upgrade to the latest version even if it is a pre-release.\npip install --upgrade --pre robotframework\n\n# Install a specific version.\npip install robotframework==7.0.1\n\n# Install separately downloaded package (no network connection needed).\npip install robotframework-7.1-py3-none-any.whl\n\n# Install latest (possibly unreleased) code directly from GitHub.\npip install https://github.com/robotframework/robotframework/archive/master.zip\n\n# Uninstall.\npip uninstall robotframework\n</code></pre>"},{"location":"install/#installing-from-source","title":"Installing from source","text":"<p>Another installation alternative is getting Robot Framework source code and installing it using the provided <code>setup.py</code> script. This approach is recommended only if you do not have pip available for some reason.</p> <p>You can get the source code by downloading a source distribution as a zip package from PyPI and extracting it. An alternative is cloning the GitHub repository and checking out the appropriate release tag.</p> <p>Once you have the source code, you can install it with the following command:</p> <pre><code>python setup.py install\n</code></pre> <p>The <code>setup.py</code> script accepts several arguments allowing, for example, installation into a non-default location that does not require administrative rights. It is also used for creating different distribution packages. Run <code>python setup.py --help</code> for more details.</p>"},{"location":"install/#verifying-installation","title":"Verifying installation","text":"<p>To make sure that the correct Robot Framework version has been installed, run the following command:</p> <pre><code>$ robot --version\nRobot Framework 7.1 (Python 3.12.7 on linux)\n</code></pre> <p>If running the command fails with a message saying that the command is not found or recognized, a good first step is double-checking the PATH configuration.</p> <p>If you have installed Robot Framework under multiple Python versions, running <code>robot</code> will execute the one first in PATH. To select explicitly, you can run <code>python -m robot</code> and substitute <code>python</code> with the right Python version.</p> <pre><code>$ python3.12 -m robot --version\nRobot Framework 7.1 (Python 3.12.7 on linux)\n\nC:\\&gt;py -3.11 -m robot --version\nRobot Framework 7.0.1 (Python 3.11.10 on win32)\n</code></pre>"},{"location":"install/#virtual-environments","title":"Virtual environments","text":"<p>Python virtual environments allow Python packages to be installed in an isolated location for a particular system or application, rather than installing all packages into the same global location. They have two main use cases:</p> <ul> <li> <p>Install packages needed by different projects into their own environments.   This avoids conflicts if projects need different versions of same packages.</p> </li> <li> <p>Avoid installing everything under the global Python installation. This is   especially important on Linux where the global Python installation may be   used by the distribution itself and messing it up can cause severe problems.</p> </li> </ul>"},{"location":"libraries/","title":"Libraries","text":"<p>Robot Framework cannot do anything without libraries. Some generally useful libraries are distributed with it as standard libraries, but the real strength of the framework is the huge amount of external libraries provided by the community. If they are not enough, you can also easily create your own custom libraries.</p>"},{"location":"libraries/#standard-libraries","title":"Standard libraries","text":"<p>Standard libraries are distributed with Robot Framework as part of a normal installation.</p> Library Description BuiltIn Contains generic often needed keywords. Imported automatically and thus always available. Collections Contains keywords for handling lists and dictionaries. DateTime Supports creating and verifying date and time values as well as calculations between them. Dialogs Supports pausing the test execution and getting input from users. OperatingSystem Enables performing various operating system related tasks. Process Supports executing processes in the system. Remote Part of the remote library interface. Does not have any keywords of its own. Screenshot Provides keywords to capture and store screenshots of the desktop. String Library for manipulating strings and verifying their contents. Telnet Supports connecting to Telnet servers and executing commands on the opened connections. XML Library for verifying and modifying XML documents. <p>Note</p> <p>Standard libraries in general work out-of-the-box, but some of them have external dependencies that need to be installed before they can be used. See library documentations themselves for more details about possible dependencies.</p>"},{"location":"libraries/#spec-files","title":"Spec files","text":"<p>Standard library spec files are hosted here as well. They contain library information in JSON format and can be used by external tools such as editors.</p> <p>BuiltIn \u00b7 Collections \u00b7 DateTime \u00b7 Dialogs \u00b7 OperatingSystem \u00b7 Process \u00b7 Screenshot \u00b7 String \u00b7 Telnet \u00b7 XML</p>"},{"location":"libraries/#external-libraries","title":"External libraries","text":"<p>Robot Framework community has provided a huge amount of libraries for different usages such as web automation, REST APIs, databases, various GUI technologies and even mainframes. The best place to start looking for different libraries is https://robotframework.org.</p>"},{"location":"libraries/#custom-libraries","title":"Custom libraries","text":"<p>You can also easily create your own libraries for your specific needs. See the creating libraries section for more information.</p>"}]}